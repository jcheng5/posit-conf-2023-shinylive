{
  "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 are generally accurate but we do\n# not guarantee their correctness.\n\n__future__: 2.7-\n__main__: 2.7-\n_ast: 2.7-\n_bisect: 2.7-\n_bootlocale: 3.4-3.9\n_codecs: 2.7-\n_collections_abc: 3.3-\n_compat_pickle: 3.1-\n_compression: 3.5-\n_csv: 2.7-\n_ctypes: 2.7-\n_curses: 2.7-\n_decimal: 3.3-\n_dummy_thread: 3.0-3.8\n_dummy_threading: 2.7-3.8\n_heapq: 2.7-\n_imp: 3.0-\n_json: 2.7-\n_markupbase: 2.7-\n_msi: 2.7-\n_operator: 3.4-\n_osx_support: 2.7-\n_posixsubprocess: 3.2-\n_py_abc: 3.7-\n_pydecimal: 3.5-\n_random: 2.7-\n_sitebuiltins: 3.4-\n_socket: 3.0-  # present in 2.7 at runtime, but not in typeshed\n_stat: 3.4-\n_thread: 2.7-\n_threading_local: 2.7-\n_tkinter: 2.7-\n_tracemalloc: 3.4-\n_typeshed: 2.7-  # not present at runtime, only for type checking\n_warnings: 2.7-\n_weakref: 2.7-\n_weakrefset: 2.7-\n_winapi: 3.3-\nabc: 2.7-\naifc: 2.7-\nantigravity: 2.7-\nargparse: 2.7-\narray: 2.7-\nast: 2.7-\nasynchat: 2.7-\nasyncio: 3.4-\nasyncio.mixins: 3.10-\nasyncio.exceptions: 3.8-\nasyncio.format_helpers: 3.7-\nasyncio.runners: 3.7-\nasyncio.staggered: 3.8-\nasyncio.taskgroups: 3.11-\nasyncio.threads: 3.9-\nasyncio.timeouts: 3.11-\nasyncio.trsock: 3.8-\nasyncore: 2.7-\natexit: 2.7-\naudioop: 2.7-\nbase64: 2.7-\nbdb: 2.7-\nbinascii: 2.7-\nbinhex: 2.7-3.10\nbisect: 2.7-\nbuiltins: 3.0-\nbz2: 2.7-\ncProfile: 2.7-\ncalendar: 2.7-\ncgi: 2.7-\ncgitb: 2.7-\nchunk: 2.7-\ncmath: 2.7-\ncmd: 2.7-\ncode: 2.7-\ncodecs: 2.7-\ncodeop: 2.7-\ncollections: 2.7-\ncollections.abc: 3.3-\ncolorsys: 2.7-\ncompileall: 2.7-\nconcurrent: 3.2-\nconfigparser: 3.0-\ncontextlib: 2.7-\ncontextvars: 3.7-\ncopy: 2.7-\ncopyreg: 2.7-\ncrypt: 2.7-\ncsv: 2.7-\nctypes: 2.7-\ncurses: 2.7-\ndataclasses: 3.7-\ndatetime: 2.7-\ndbm: 2.7-\ndecimal: 2.7-\ndifflib: 2.7-\ndis: 2.7-\ndistutils: 2.7-\ndistutils.command.bdist_msi: 2.7-3.10\ndistutils.command.bdist_wininst: 2.7-3.9\ndoctest: 2.7-\ndummy_threading: 2.7-3.8\nemail: 2.7-\nencodings: 2.7-\nensurepip: 2.7-\nenum: 3.4-\nerrno: 2.7-\nfaulthandler: 3.3-\nfcntl: 2.7-\nfilecmp: 2.7-\nfileinput: 2.7-\nfnmatch: 2.7-\nformatter: 2.7-3.9\nfractions: 2.7-\nftplib: 2.7-\nfunctools: 2.7-\ngc: 2.7-\ngenericpath: 2.7-\ngetopt: 2.7-\ngetpass: 2.7-\ngettext: 2.7-\nglob: 2.7-\ngraphlib: 3.9-\ngrp: 2.7-\ngzip: 2.7-\nhashlib: 2.7-\nheapq: 2.7-\nhmac: 2.7-\nhtml: 3.0-\nhttp: 3.0-\nimaplib: 2.7-\nimghdr: 2.7-\nimp: 2.7-\nimportlib: 2.7-\nimportlib.metadata: 3.8-\nimportlib.metadata._meta: 3.10-\nimportlib.resources: 3.7-\nimportlib.resources.abc: 3.11-\ninspect: 2.7-\nio: 2.7-\nipaddress: 3.3-\nitertools: 2.7-\njson: 2.7-\nkeyword: 2.7-\nlib2to3: 2.7-\nlinecache: 2.7-\nlocale: 2.7-\nlogging: 2.7-\nlzma: 3.3-\nmacpath: 2.7-3.7\nmailbox: 2.7-\nmailcap: 2.7-\nmarshal: 2.7-\nmath: 2.7-\nmimetypes: 2.7-\nmmap: 2.7-\nmodulefinder: 2.7-\nmsilib: 2.7-\nmsvcrt: 2.7-\nmultiprocessing: 2.7-\nmultiprocessing.resource_tracker: 3.8-\nmultiprocessing.shared_memory: 3.8-\nnetrc: 2.7-\nnis: 2.7-\nnntplib: 2.7-\nntpath: 2.7-\nnturl2path: 2.7-\nnumbers: 2.7-\nopcode: 2.7-\noperator: 2.7-\noptparse: 2.7-\nos: 2.7-\nossaudiodev: 2.7-\nparser: 2.7-3.9\npathlib: 3.4-\npdb: 2.7-\npickle: 2.7-\npickletools: 2.7-\npipes: 2.7-\npkgutil: 2.7-\nplatform: 2.7-\nplistlib: 2.7-\npoplib: 2.7-\nposix: 2.7-\nposixpath: 2.7-\npprint: 2.7-\nprofile: 2.7-\npstats: 2.7-\npty: 2.7-\npwd: 2.7-\npy_compile: 2.7-\npyclbr: 2.7-\npydoc: 2.7-\npydoc_data: 2.7-\npyexpat: 2.7-\nqueue: 3.0-\nquopri: 2.7-\nrandom: 2.7-\nre: 2.7-\nreadline: 2.7-\nreprlib: 3.0-\nresource: 2.7-\nrlcompleter: 2.7-\nrunpy: 2.7-\nsched: 2.7-\nsecrets: 3.6-\nselect: 2.7-\nselectors: 3.4-\nshelve: 2.7-\nshlex: 2.7-\nshutil: 2.7-\nsignal: 2.7-\nsite: 2.7-\nsmtpd: 2.7-\nsmtplib: 2.7-\nsndhdr: 2.7-\nsocket: 2.7-\nsocketserver: 3.0-\nspwd: 2.7-\nsqlite3: 2.7-\nsre_compile: 2.7-\nsre_constants: 2.7-\nsre_parse: 2.7-\nssl: 2.7-\nstat: 2.7-\nstatistics: 3.4-\nstring: 2.7-\nstringprep: 2.7-\nstruct: 2.7-\nsubprocess: 2.7-\nsunau: 2.7-\nsymbol: 2.7-3.9\nsymtable: 2.7-\nsys: 2.7-\nsysconfig: 2.7-\nsyslog: 2.7-\ntabnanny: 2.7-\ntarfile: 2.7-\ntelnetlib: 2.7-\ntempfile: 2.7-\ntermios: 2.7-\ntextwrap: 2.7-\nthis: 2.7-\nthreading: 2.7-\ntime: 2.7-\ntimeit: 2.7-\ntkinter: 3.0-\ntoken: 2.7-\ntokenize: 2.7-\ntomllib: 3.11-\ntrace: 2.7-\ntraceback: 2.7-\ntracemalloc: 3.4-\ntty: 2.7-\nturtle: 2.7-\ntypes: 2.7-\ntyping: 3.5-\ntyping_extensions: 2.7-\nunicodedata: 2.7-\nunittest: 2.7-\nunittest._log: 3.9-\nunittest.async_case: 3.8-\nurllib: 2.7-\nuu: 2.7-\nuuid: 2.7-\nvenv: 3.3-\nwarnings: 2.7-\nwave: 2.7-\nweakref: 2.7-\nwebbrowser: 2.7-\nwinreg: 3.0-\nwinsound: 2.7-\nwsgiref: 2.7-\nwsgiref.types: 3.11-\nxdrlib: 2.7-\nxml: 2.7-\nxmlrpc: 3.0-\nxxlimited: 3.2-\nzipapp: 3.5-\nzipfile: 2.7-\nzipimport: 2.7-\nzlib: 2.7-\nzoneinfo: 3.9-\n",
  "/typeshed/stdlib/__future__.pyi": "from typing_extensions import TypeAlias\n\n_VersionInfo: TypeAlias = tuple[int, int, int, str, int]\n\nclass _Feature:\n    def __init__(self, optionalRelease: _VersionInfo, mandatoryRelease: _VersionInfo | None, compiler_flag: int) -> None: ...\n    def getOptionalRelease(self) -> _VersionInfo: ...\n    def getMandatoryRelease(self) -> _VersionInfo | None: ...\n    compiler_flag: int\n\nabsolute_import: _Feature\ndivision: _Feature\ngenerators: _Feature\nnested_scopes: _Feature\nprint_function: _Feature\nunicode_literals: _Feature\nwith_statement: _Feature\nbarry_as_FLUFL: _Feature\ngenerator_stop: _Feature\nannotations: _Feature\n\nall_feature_names: list[str]  # undocumented\n\n__all__ = [\n    \"all_feature_names\",\n    \"absolute_import\",\n    \"division\",\n    \"generators\",\n    \"nested_scopes\",\n    \"print_function\",\n    \"unicode_literals\",\n    \"with_statement\",\n    \"barry_as_FLUFL\",\n    \"generator_stop\",\n    \"annotations\",\n]\n",
  "/typeshed/stdlib/__main__.pyi": "from typing import Any\n\ndef __getattr__(name: str) -> Any: ...\n",
  "/typeshed/stdlib/_ast.pyi": "import sys\nfrom typing import Any, ClassVar\nfrom typing_extensions import Literal, TypeAlias\n\nPyCF_ONLY_AST: Literal[1024]\nif sys.version_info >= (3, 8):\n    PyCF_TYPE_COMMENTS: Literal[4096]\n    PyCF_ALLOW_TOP_LEVEL_AWAIT: Literal[8192]\n\n_Identifier: TypeAlias = str\n\nclass AST:\n    if sys.version_info >= (3, 10):\n        __match_args__ = ()\n    _attributes: ClassVar[tuple[str, ...]]\n    _fields: ClassVar[tuple[str, ...]]\n    def __init__(self, *args: Any, **kwargs: Any) -> None: ...\n    # TODO: Not all nodes have all of the following attributes\n    lineno: int\n    col_offset: int\n    if sys.version_info >= (3, 8):\n        end_lineno: int | None\n        end_col_offset: int | None\n        type_comment: str | None\n\nclass mod(AST): ...\n\nif sys.version_info >= (3, 8):\n    class type_ignore(AST): ...\n\n    class TypeIgnore(type_ignore):\n        if sys.version_info >= (3, 10):\n            __match_args__ = (\"lineno\", \"tag\")\n        tag: str\n\n    class FunctionType(mod):\n        if sys.version_info >= (3, 10):\n            __match_args__ = (\"argtypes\", \"returns\")\n        argtypes: list[expr]\n        returns: expr\n\nclass Module(mod):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"body\", \"type_ignores\")\n    body: list[stmt]\n    if sys.version_info >= (3, 8):\n        type_ignores: list[TypeIgnore]\n\nclass Interactive(mod):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"body\",)\n    body: list[stmt]\n\nclass Expression(mod):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"body\",)\n    body: expr\n\nclass stmt(AST): ...\n\nclass FunctionDef(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"name\", \"args\", \"body\", \"decorator_list\", \"returns\", \"type_comment\")\n    name: _Identifier\n    args: arguments\n    body: list[stmt]\n    decorator_list: list[expr]\n    returns: expr | None\n\nclass AsyncFunctionDef(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"name\", \"args\", \"body\", \"decorator_list\", \"returns\", \"type_comment\")\n    name: _Identifier\n    args: arguments\n    body: list[stmt]\n    decorator_list: list[expr]\n    returns: expr | None\n\nclass ClassDef(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"name\", \"bases\", \"keywords\", \"body\", \"decorator_list\")\n    name: _Identifier\n    bases: list[expr]\n    keywords: list[keyword]\n    body: list[stmt]\n    decorator_list: list[expr]\n\nclass Return(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\",)\n    value: expr | None\n\nclass Delete(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"targets\",)\n    targets: list[expr]\n\nclass Assign(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"targets\", \"value\", \"type_comment\")\n    targets: list[expr]\n    value: expr\n\nclass AugAssign(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"target\", \"op\", \"value\")\n    target: Name | Attribute | Subscript\n    op: operator\n    value: expr\n\nclass AnnAssign(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"target\", \"annotation\", \"value\", \"simple\")\n    target: Name | Attribute | Subscript\n    annotation: expr\n    value: expr | None\n    simple: int\n\nclass For(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"target\", \"iter\", \"body\", \"orelse\", \"type_comment\")\n    target: expr\n    iter: expr\n    body: list[stmt]\n    orelse: list[stmt]\n\nclass AsyncFor(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"target\", \"iter\", \"body\", \"orelse\", \"type_comment\")\n    target: expr\n    iter: expr\n    body: list[stmt]\n    orelse: list[stmt]\n\nclass While(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"test\", \"body\", \"orelse\")\n    test: expr\n    body: list[stmt]\n    orelse: list[stmt]\n\nclass If(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"test\", \"body\", \"orelse\")\n    test: expr\n    body: list[stmt]\n    orelse: list[stmt]\n\nclass With(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"items\", \"body\", \"type_comment\")\n    items: list[withitem]\n    body: list[stmt]\n\nclass AsyncWith(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"items\", \"body\", \"type_comment\")\n    items: list[withitem]\n    body: list[stmt]\n\nclass Raise(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"exc\", \"cause\")\n    exc: expr | None\n    cause: expr | None\n\nclass Try(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n    body: list[stmt]\n    handlers: list[ExceptHandler]\n    orelse: list[stmt]\n    finalbody: list[stmt]\n\nif sys.version_info >= (3, 11):\n    class TryStar(stmt):\n        __match_args__ = (\"body\", \"handlers\", \"orelse\", \"finalbody\")\n        body: list[stmt]\n        handlers: list[ExceptHandler]\n        orelse: list[stmt]\n        finalbody: list[stmt]\n\nclass Assert(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"test\", \"msg\")\n    test: expr\n    msg: expr | None\n\nclass Import(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"names\",)\n    names: list[alias]\n\nclass ImportFrom(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"module\", \"names\", \"level\")\n    module: str | None\n    names: list[alias]\n    level: int\n\nclass Global(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"names\",)\n    names: list[_Identifier]\n\nclass Nonlocal(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"names\",)\n    names: list[_Identifier]\n\nclass Expr(stmt):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\",)\n    value: expr\n\nclass Pass(stmt): ...\nclass Break(stmt): ...\nclass Continue(stmt): ...\nclass expr(AST): ...\n\nclass BoolOp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"op\", \"values\")\n    op: boolop\n    values: list[expr]\n\nclass BinOp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"left\", \"op\", \"right\")\n    left: expr\n    op: operator\n    right: expr\n\nclass UnaryOp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"op\", \"operand\")\n    op: unaryop\n    operand: expr\n\nclass Lambda(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"args\", \"body\")\n    args: arguments\n    body: expr\n\nclass IfExp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"test\", \"body\", \"orelse\")\n    test: expr\n    body: expr\n    orelse: expr\n\nclass Dict(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"keys\", \"values\")\n    keys: list[expr | None]\n    values: list[expr]\n\nclass Set(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elts\",)\n    elts: list[expr]\n\nclass ListComp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elt\", \"generators\")\n    elt: expr\n    generators: list[comprehension]\n\nclass SetComp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elt\", \"generators\")\n    elt: expr\n    generators: list[comprehension]\n\nclass DictComp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"key\", \"value\", \"generators\")\n    key: expr\n    value: expr\n    generators: list[comprehension]\n\nclass GeneratorExp(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elt\", \"generators\")\n    elt: expr\n    generators: list[comprehension]\n\nclass Await(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\",)\n    value: expr\n\nclass Yield(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\",)\n    value: expr | None\n\nclass YieldFrom(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\",)\n    value: expr\n\nclass Compare(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"left\", \"ops\", \"comparators\")\n    left: expr\n    ops: list[cmpop]\n    comparators: list[expr]\n\nclass Call(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"func\", \"args\", \"keywords\")\n    func: expr\n    args: list[expr]\n    keywords: list[keyword]\n\nclass FormattedValue(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\", \"conversion\", \"format_spec\")\n    value: expr\n    conversion: int\n    format_spec: expr | None\n\nclass JoinedStr(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"values\",)\n    values: list[expr]\n\nif sys.version_info < (3, 8):\n    class Num(expr):  # Deprecated in 3.8; use Constant\n        n: int | float | complex\n\n    class Str(expr):  # Deprecated in 3.8; use Constant\n        s: str\n\n    class Bytes(expr):  # Deprecated in 3.8; use Constant\n        s: bytes\n\n    class NameConstant(expr):  # Deprecated in 3.8; use Constant\n        value: Any\n\n    class Ellipsis(expr): ...  # Deprecated in 3.8; use Constant\n\nclass Constant(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\", \"kind\")\n    value: Any  # None, str, bytes, bool, int, float, complex, Ellipsis\n    kind: str | None\n    # Aliases for value, for backwards compatibility\n    s: Any\n    n: int | float | complex\n\nif sys.version_info >= (3, 8):\n    class NamedExpr(expr):\n        if sys.version_info >= (3, 10):\n            __match_args__ = (\"target\", \"value\")\n        target: Name\n        value: expr\n\nclass Attribute(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\", \"attr\", \"ctx\")\n    value: expr\n    attr: _Identifier\n    ctx: expr_context\n\nif sys.version_info >= (3, 9):\n    _Slice: TypeAlias = expr\nelse:\n    class slice(AST): ...\n    _Slice: TypeAlias = slice\n\nclass Slice(_Slice):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"lower\", \"upper\", \"step\")\n    lower: expr | None\n    upper: expr | None\n    step: expr | None\n\nif sys.version_info < (3, 9):\n    class ExtSlice(slice):\n        dims: list[slice]\n\n    class Index(slice):\n        value: expr\n\nclass Subscript(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\", \"slice\", \"ctx\")\n    value: expr\n    slice: _Slice\n    ctx: expr_context\n\nclass Starred(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"value\", \"ctx\")\n    value: expr\n    ctx: expr_context\n\nclass Name(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"id\", \"ctx\")\n    id: _Identifier\n    ctx: expr_context\n\nclass List(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elts\", \"ctx\")\n    elts: list[expr]\n    ctx: expr_context\n\nclass Tuple(expr):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"elts\", \"ctx\")\n    elts: list[expr]\n    ctx: expr_context\n    if sys.version_info >= (3, 9):\n        dims: list[expr]\n\nclass expr_context(AST): ...\n\nif sys.version_info < (3, 9):\n    class AugLoad(expr_context): ...\n    class AugStore(expr_context): ...\n    class Param(expr_context): ...\n\n    class Suite(mod):\n        body: list[stmt]\n\nclass Del(expr_context): ...\nclass Load(expr_context): ...\nclass Store(expr_context): ...\nclass boolop(AST): ...\nclass And(boolop): ...\nclass Or(boolop): ...\nclass operator(AST): ...\nclass Add(operator): ...\nclass BitAnd(operator): ...\nclass BitOr(operator): ...\nclass BitXor(operator): ...\nclass Div(operator): ...\nclass FloorDiv(operator): ...\nclass LShift(operator): ...\nclass Mod(operator): ...\nclass Mult(operator): ...\nclass MatMult(operator): ...\nclass Pow(operator): ...\nclass RShift(operator): ...\nclass Sub(operator): ...\nclass unaryop(AST): ...\nclass Invert(unaryop): ...\nclass Not(unaryop): ...\nclass UAdd(unaryop): ...\nclass USub(unaryop): ...\nclass cmpop(AST): ...\nclass Eq(cmpop): ...\nclass Gt(cmpop): ...\nclass GtE(cmpop): ...\nclass In(cmpop): ...\nclass Is(cmpop): ...\nclass IsNot(cmpop): ...\nclass Lt(cmpop): ...\nclass LtE(cmpop): ...\nclass NotEq(cmpop): ...\nclass NotIn(cmpop): ...\n\nclass comprehension(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"target\", \"iter\", \"ifs\", \"is_async\")\n    target: expr\n    iter: expr\n    ifs: list[expr]\n    is_async: int\n\nclass excepthandler(AST): ...\n\nclass ExceptHandler(excepthandler):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"type\", \"name\", \"body\")\n    type: expr | None\n    name: _Identifier | None\n    body: list[stmt]\n\nclass arguments(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"posonlyargs\", \"args\", \"vararg\", \"kwonlyargs\", \"kw_defaults\", \"kwarg\", \"defaults\")\n    if sys.version_info >= (3, 8):\n        posonlyargs: list[arg]\n    args: list[arg]\n    vararg: arg | None\n    kwonlyargs: list[arg]\n    kw_defaults: list[expr | None]\n    kwarg: arg | None\n    defaults: list[expr]\n\nclass arg(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"arg\", \"annotation\", \"type_comment\")\n    arg: _Identifier\n    annotation: expr | None\n\nclass keyword(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"arg\", \"value\")\n    arg: _Identifier | None\n    value: expr\n\nclass alias(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"name\", \"asname\")\n    name: _Identifier\n    asname: _Identifier | None\n\nclass withitem(AST):\n    if sys.version_info >= (3, 10):\n        __match_args__ = (\"context_expr\", \"optional_vars\")\n    context_expr: expr\n    optional_vars: expr | None\n\nif sys.version_info >= (3, 10):\n    class Match(stmt):\n        __match_args__ = (\"subject\", \"cases\")\n        subject: expr\n        cases: list[match_case]\n\n    class pattern(AST): ...\n    # Without the alias, Pyright complains variables named pattern are recursively defined\n    _Pattern: TypeAlias = pattern\n\n    class match_case(AST):\n        __match_args__ = (\"pattern\", \"guard\", \"body\")\n        pattern: _Pattern\n        guard: expr | None\n        body: list[stmt]\n\n    class MatchValue(pattern):\n        __match_args__ = (\"value\",)\n        value: expr\n\n    class MatchSingleton(pattern):\n        __match_args__ = (\"value\",)\n        value: Literal[True, False, None]\n\n    class MatchSequence(pattern):\n        __match_args__ = (\"patterns\",)\n        patterns: list[pattern]\n\n    class MatchStar(pattern):\n        __match_args__ = (\"name\",)\n        name: _Identifier | None\n\n    class MatchMapping(pattern):\n        __match_args__ = (\"keys\", \"patterns\", \"rest\")\n        keys: list[expr]\n        patterns: list[pattern]\n        rest: _Identifier | None\n\n    class MatchClass(pattern):\n        __match_args__ = (\"cls\", \"patterns\", \"kwd_attrs\", \"kwd_patterns\")\n        cls: expr\n        patterns: list[pattern]\n        kwd_attrs: list[_Identifier]\n        kwd_patterns: list[pattern]\n\n    class MatchAs(pattern):\n        __match_args__ = (\"pattern\", \"name\")\n        pattern: _Pattern | None\n        name: _Identifier | None\n\n    class MatchOr(pattern):\n        __match_args__ = (\"patterns\",)\n        patterns: list[pattern]\n",
  "/typeshed/stdlib/_bisect.pyi": "import sys\nfrom _typeshed import SupportsLenAndGetItem, SupportsRichComparisonT\nfrom collections.abc import Callable, MutableSequence\nfrom typing import TypeVar, overload\n\n_T = TypeVar(\"_T\")\n\nif sys.version_info >= (3, 10):\n    @overload\n    def bisect_left(\n        a: SupportsLenAndGetItem[SupportsRichComparisonT],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: None = None,\n    ) -> int: ...\n    @overload\n    def bisect_left(\n        a: SupportsLenAndGetItem[_T],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: Callable[[_T], SupportsRichComparisonT],\n    ) -> int: ...\n    @overload\n    def bisect_right(\n        a: SupportsLenAndGetItem[SupportsRichComparisonT],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: None = None,\n    ) -> int: ...\n    @overload\n    def bisect_right(\n        a: SupportsLenAndGetItem[_T],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: Callable[[_T], SupportsRichComparisonT],\n    ) -> int: ...\n    @overload\n    def insort_left(\n        a: MutableSequence[SupportsRichComparisonT],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: None = None,\n    ) -> None: ...\n    @overload\n    def insort_left(\n        a: MutableSequence[_T], x: _T, lo: int = 0, hi: int | None = None, *, key: Callable[[_T], SupportsRichComparisonT]\n    ) -> None: ...\n    @overload\n    def insort_right(\n        a: MutableSequence[SupportsRichComparisonT],\n        x: SupportsRichComparisonT,\n        lo: int = 0,\n        hi: int | None = None,\n        *,\n        key: None = None,\n    ) -> None: ...\n    @overload\n    def insort_right(\n        a: MutableSequence[_T], x: _T, lo: int = 0, hi: int | None = None, *, key: Callable[[_T], SupportsRichComparisonT]\n    ) -> None: ...\n\nelse:\n    def bisect_left(\n        a: SupportsLenAndGetItem[SupportsRichComparisonT], x: SupportsRichComparisonT, lo: int = 0, hi: int | None = None\n    ) -> int: ...\n    def bisect_right(\n        a: SupportsLenAndGetItem[SupportsRichComparisonT], x: SupportsRichComparisonT, lo: int = 0, hi: int | None = None\n    ) -> int: ...\n    def insort_left(\n        a: MutableSequence[SupportsRichComparisonT], x: SupportsRichComparisonT, lo: int = 0, hi: int | None = None\n    ) -> None: ...\n    def insort_right(\n        a: MutableSequence[SupportsRichComparisonT], x: SupportsRichComparisonT, lo: int = 0, hi: int | None = None\n    ) -> None: ...\n",
  "/typeshed/stdlib/_bootlocale.pyi": "def getpreferredencoding(do_setlocale: bool = True) -> str: ...\n",
  "/typeshed/stdlib/_codecs.pyi": "import codecs\nimport sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable\nfrom typing import overload\nfrom typing_extensions import Literal, TypeAlias\n\n# This type is not exposed; it is defined in unicodeobject.c\nclass _EncodingMap:\n    def size(self) -> int: ...\n\n_CharMap: TypeAlias = dict[int, int] | _EncodingMap\n_Handler: TypeAlias = Callable[[UnicodeError], tuple[str | bytes, int]]\n_SearchFunction: TypeAlias = Callable[[str], codecs.CodecInfo | None]\n\ndef register(__search_function: _SearchFunction) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def unregister(__search_function: _SearchFunction) -> None: ...\n\ndef register_error(__errors: str, __handler: _Handler) -> None: ...\ndef lookup_error(__name: str) -> _Handler: ...\n\n# The type ignore on `encode` and `decode` is to avoid issues with overlapping overloads, for more details, see #300\n# https://docs.python.org/3/library/codecs.html#binary-transforms\n_BytesToBytesEncoding: TypeAlias = Literal[\n    \"base64\",\n    \"base_64\",\n    \"base64_codec\",\n    \"bz2\",\n    \"bz2_codec\",\n    \"hex\",\n    \"hex_codec\",\n    \"quopri\",\n    \"quotedprintable\",\n    \"quoted_printable\",\n    \"quopri_codec\",\n    \"uu\",\n    \"uu_codec\",\n    \"zip\",\n    \"zlib\",\n    \"zlib_codec\",\n]\n# https://docs.python.org/3/library/codecs.html#text-transforms\n_StrToStrEncoding: TypeAlias = Literal[\"rot13\", \"rot_13\"]\n\n@overload\ndef encode(obj: ReadableBuffer, encoding: _BytesToBytesEncoding, errors: str = \"strict\") -> bytes: ...\n@overload\ndef encode(obj: str, encoding: _StrToStrEncoding, errors: str = \"strict\") -> str: ...  # type: ignore[misc]\n@overload\ndef encode(obj: str, encoding: str = \"utf-8\", errors: str = \"strict\") -> bytes: ...\n@overload\ndef decode(obj: ReadableBuffer, encoding: _BytesToBytesEncoding, errors: str = \"strict\") -> bytes: ...  # type: ignore[misc]\n@overload\ndef decode(obj: str, encoding: _StrToStrEncoding, errors: str = \"strict\") -> str: ...\n\n# these are documented as text encodings but in practice they also accept str as input\n@overload\ndef decode(\n    obj: str,\n    encoding: Literal[\"unicode_escape\", \"unicode-escape\", \"raw_unicode_escape\", \"raw-unicode-escape\"],\n    errors: str = \"strict\",\n) -> str: ...\n\n# hex is officially documented as a bytes to bytes encoding, but it appears to also work with str\n@overload\ndef decode(obj: str, encoding: Literal[\"hex\", \"hex_codec\"], errors: str = \"strict\") -> bytes: ...\n@overload\ndef decode(obj: ReadableBuffer, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\ndef lookup(__encoding: str) -> codecs.CodecInfo: ...\ndef charmap_build(__map: str) -> _CharMap: ...\ndef ascii_decode(__data: ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\ndef ascii_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef charmap_decode(__data: ReadableBuffer, __errors: str | None = None, __mapping: _CharMap | None = None) -> tuple[str, int]: ...\ndef charmap_encode(__str: str, __errors: str | None = None, __mapping: _CharMap | None = None) -> tuple[bytes, int]: ...\ndef escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\ndef escape_encode(__data: bytes, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef latin_1_decode(__data: ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\ndef latin_1_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n\nif sys.version_info >= (3, 9):\n    def raw_unicode_escape_decode(\n        __data: str | ReadableBuffer, __errors: str | None = None, __final: bool = True\n    ) -> tuple[str, int]: ...\n\nelse:\n    def raw_unicode_escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\n\ndef raw_unicode_escape_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef readbuffer_encode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[bytes, int]: ...\n\nif sys.version_info >= (3, 9):\n    def unicode_escape_decode(\n        __data: str | ReadableBuffer, __errors: str | None = None, __final: bool = True\n    ) -> tuple[str, int]: ...\n\nelse:\n    def unicode_escape_decode(__data: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\n\ndef unicode_escape_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n\nif sys.version_info < (3, 8):\n    def unicode_internal_decode(__obj: str | ReadableBuffer, __errors: str | None = None) -> tuple[str, int]: ...\n    def unicode_internal_encode(__obj: str | ReadableBuffer, __errors: str | None = None) -> tuple[bytes, int]: ...\n\ndef utf_16_be_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_16_be_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef utf_16_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_16_encode(__str: str, __errors: str | None = None, __byteorder: int = 0) -> tuple[bytes, int]: ...\ndef utf_16_ex_decode(\n    __data: ReadableBuffer, __errors: str | None = None, __byteorder: int = 0, __final: bool = False\n) -> tuple[str, int, int]: ...\ndef utf_16_le_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_16_le_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef utf_32_be_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_32_be_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef utf_32_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_32_encode(__str: str, __errors: str | None = None, __byteorder: int = 0) -> tuple[bytes, int]: ...\ndef utf_32_ex_decode(\n    __data: ReadableBuffer, __errors: str | None = None, __byteorder: int = 0, __final: bool = False\n) -> tuple[str, int, int]: ...\ndef utf_32_le_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_32_le_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef utf_7_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_7_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef utf_8_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\ndef utf_8_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n\nif sys.platform == \"win32\":\n    def mbcs_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\n    def mbcs_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n    def code_page_decode(\n        __codepage: int, __data: ReadableBuffer, __errors: str | None = None, __final: bool = False\n    ) -> tuple[str, int]: ...\n    def code_page_encode(__code_page: int, __str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n    def oem_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\n    def oem_encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n",
  "/typeshed/stdlib/_collections_abc.pyi": "import sys\nfrom types import MappingProxyType\nfrom typing import (  # noqa: Y022,Y038\n    AbstractSet as Set,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    ByteString as ByteString,\n    Callable as Callable,\n    Collection as Collection,\n    Container as Container,\n    Coroutine as Coroutine,\n    Generator as Generator,\n    Generic,\n    Hashable as Hashable,\n    ItemsView as ItemsView,\n    Iterable as Iterable,\n    Iterator as Iterator,\n    KeysView as KeysView,\n    Mapping as Mapping,\n    MappingView as MappingView,\n    MutableMapping as MutableMapping,\n    MutableSequence as MutableSequence,\n    MutableSet as MutableSet,\n    Reversible as Reversible,\n    Sequence as Sequence,\n    Sized as Sized,\n    TypeVar,\n    ValuesView as ValuesView,\n)\nfrom typing_extensions import final\n\n__all__ = [\n    \"Awaitable\",\n    \"Coroutine\",\n    \"AsyncIterable\",\n    \"AsyncIterator\",\n    \"AsyncGenerator\",\n    \"Hashable\",\n    \"Iterable\",\n    \"Iterator\",\n    \"Generator\",\n    \"Reversible\",\n    \"Sized\",\n    \"Container\",\n    \"Callable\",\n    \"Collection\",\n    \"Set\",\n    \"MutableSet\",\n    \"Mapping\",\n    \"MutableMapping\",\n    \"MappingView\",\n    \"KeysView\",\n    \"ItemsView\",\n    \"ValuesView\",\n    \"Sequence\",\n    \"MutableSequence\",\n    \"ByteString\",\n]\n\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n\n@final\nclass dict_keys(KeysView[_KT_co], Generic[_KT_co, _VT_co]):  # undocumented\n    if sys.version_info >= (3, 10):\n        @property\n        def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...\n\n@final\nclass dict_values(ValuesView[_VT_co], Generic[_KT_co, _VT_co]):  # undocumented\n    if sys.version_info >= (3, 10):\n        @property\n        def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...\n\n@final\nclass dict_items(ItemsView[_KT_co, _VT_co], Generic[_KT_co, _VT_co]):  # undocumented\n    if sys.version_info >= (3, 10):\n        @property\n        def mapping(self) -> MappingProxyType[_KT_co, _VT_co]: ...\n",
  "/typeshed/stdlib/_compat_pickle.pyi": "IMPORT_MAPPING: dict[str, str]\nNAME_MAPPING: dict[tuple[str, str], tuple[str, str]]\nPYTHON2_EXCEPTIONS: tuple[str, ...]\nMULTIPROCESSING_EXCEPTIONS: tuple[str, ...]\nREVERSE_IMPORT_MAPPING: dict[str, str]\nREVERSE_NAME_MAPPING: dict[tuple[str, str], tuple[str, str]]\nPYTHON3_OSERROR_EXCEPTIONS: tuple[str, ...]\nPYTHON3_IMPORTERROR_EXCEPTIONS: tuple[str, ...]\n",
  "/typeshed/stdlib/_compression.pyi": "from _typeshed import WriteableBuffer\nfrom collections.abc import Callable\nfrom io import DEFAULT_BUFFER_SIZE, BufferedIOBase, RawIOBase\nfrom typing import Any, Protocol\n\nBUFFER_SIZE = DEFAULT_BUFFER_SIZE\n\nclass _Reader(Protocol):\n    def read(self, __n: int) -> bytes: ...\n    def seekable(self) -> bool: ...\n    def seek(self, __n: int) -> Any: ...\n\nclass BaseStream(BufferedIOBase): ...\n\nclass DecompressReader(RawIOBase):\n    def __init__(\n        self,\n        fp: _Reader,\n        decomp_factory: Callable[..., object],\n        trailing_error: type[Exception] | tuple[type[Exception], ...] = (),\n        **decomp_args: Any,\n    ) -> None: ...\n    def readinto(self, b: WriteableBuffer) -> int: ...\n    def read(self, size: int = -1) -> bytes: ...\n    def seek(self, offset: int, whence: int = 0) -> int: ...\n",
  "/typeshed/stdlib/_csv.pyi": "from _typeshed import SupportsWrite\nfrom collections.abc import Iterable, Iterator\nfrom typing import Any\nfrom typing_extensions import Final, Literal, TypeAlias\n\n__version__: Final[str]\n\nQUOTE_ALL: Literal[1]\nQUOTE_MINIMAL: Literal[0]\nQUOTE_NONE: Literal[3]\nQUOTE_NONNUMERIC: Literal[2]\n\n# Ideally this would be `QUOTE_ALL | QUOTE_MINIMAL | QUOTE_NONE | QUOTE_NONNUMERIC`\n# However, using literals in situations like these can cause false-positives (see #7258)\n_QuotingType: TypeAlias = int\n\nclass Error(Exception): ...\n\nclass Dialect:\n    delimiter: str\n    quotechar: str | None\n    escapechar: str | None\n    doublequote: bool\n    skipinitialspace: bool\n    lineterminator: str\n    quoting: _QuotingType\n    strict: bool\n    def __init__(self) -> None: ...\n\n_DialectLike: TypeAlias = str | Dialect | type[Dialect]\n\nclass _reader(Iterator[list[str]]):\n    @property\n    def dialect(self) -> Dialect: ...\n    line_num: int\n    def __next__(self) -> list[str]: ...\n\nclass _writer:\n    @property\n    def dialect(self) -> Dialect: ...\n    def writerow(self, row: Iterable[Any]) -> Any: ...\n    def writerows(self, rows: Iterable[Iterable[Any]]) -> None: ...\n\ndef writer(\n    csvfile: SupportsWrite[str],\n    dialect: _DialectLike = \"excel\",\n    *,\n    delimiter: str = \",\",\n    quotechar: str | None = '\"',\n    escapechar: str | None = None,\n    doublequote: bool = True,\n    skipinitialspace: bool = False,\n    lineterminator: str = \"\\r\\n\",\n    quoting: _QuotingType = 0,\n    strict: bool = False,\n) -> _writer: ...\ndef reader(\n    csvfile: Iterable[str],\n    dialect: _DialectLike = \"excel\",\n    *,\n    delimiter: str = \",\",\n    quotechar: str | None = '\"',\n    escapechar: str | None = None,\n    doublequote: bool = True,\n    skipinitialspace: bool = False,\n    lineterminator: str = \"\\r\\n\",\n    quoting: _QuotingType = 0,\n    strict: bool = False,\n) -> _reader: ...\ndef register_dialect(\n    name: str,\n    dialect: type[Dialect] = ...,\n    *,\n    delimiter: str = \",\",\n    quotechar: str | None = '\"',\n    escapechar: str | None = None,\n    doublequote: bool = True,\n    skipinitialspace: bool = False,\n    lineterminator: str = \"\\r\\n\",\n    quoting: _QuotingType = 0,\n    strict: bool = False,\n) -> None: ...\ndef unregister_dialect(name: str) -> None: ...\ndef get_dialect(name: str) -> Dialect: ...\ndef list_dialects() -> list[str]: ...\ndef field_size_limit(new_limit: int = ...) -> int: ...\n",
  "/typeshed/stdlib/_ctypes.pyi": "import sys\nfrom ctypes import _CArgObject, _PointerLike\nfrom typing_extensions import TypeAlias\n\nFUNCFLAG_CDECL: int\nFUNCFLAG_PYTHONAPI: int\nFUNCFLAG_USE_ERRNO: int\nFUNCFLAG_USE_LASTERROR: int\nRTLD_GLOBAL: int\nRTLD_LOCAL: int\n\nif sys.version_info >= (3, 11):\n    CTYPES_MAX_ARGCOUNT: int\n\nif sys.platform == \"win32\":\n    # Description, Source, HelpFile, HelpContext, scode\n    _COMError_Details: TypeAlias = tuple[str | None, str | None, str | None, int | None, int | None]\n\n    class COMError(Exception):\n        hresult: int\n        text: str | None\n        details: _COMError_Details\n\n        def __init__(self, hresult: int, text: str | None, details: _COMError_Details) -> None: ...\n\n    def CopyComPointer(src: _PointerLike, dst: _PointerLike | _CArgObject) -> int: ...\n\n    FUNCFLAG_HRESULT: int\n    FUNCFLAG_STDCALL: int\n",
  "/typeshed/stdlib/_curses.pyi": "import sys\nfrom _typeshed import ReadOnlyBuffer, SupportsRead\nfrom typing import IO, Any, NamedTuple, overload\nfrom typing_extensions import TypeAlias, final\n\nif sys.platform != \"win32\":\n    # Handled by PyCurses_ConvertToChtype in _cursesmodule.c.\n    _ChType: TypeAlias = str | bytes | int\n\n    # ACS codes are only initialized after initscr is called\n    ACS_BBSS: int\n    ACS_BLOCK: int\n    ACS_BOARD: int\n    ACS_BSBS: int\n    ACS_BSSB: int\n    ACS_BSSS: int\n    ACS_BTEE: int\n    ACS_BULLET: int\n    ACS_CKBOARD: int\n    ACS_DARROW: int\n    ACS_DEGREE: int\n    ACS_DIAMOND: int\n    ACS_GEQUAL: int\n    ACS_HLINE: int\n    ACS_LANTERN: int\n    ACS_LARROW: int\n    ACS_LEQUAL: int\n    ACS_LLCORNER: int\n    ACS_LRCORNER: int\n    ACS_LTEE: int\n    ACS_NEQUAL: int\n    ACS_PI: int\n    ACS_PLMINUS: int\n    ACS_PLUS: int\n    ACS_RARROW: int\n    ACS_RTEE: int\n    ACS_S1: int\n    ACS_S3: int\n    ACS_S7: int\n    ACS_S9: int\n    ACS_SBBS: int\n    ACS_SBSB: int\n    ACS_SBSS: int\n    ACS_SSBB: int\n    ACS_SSBS: int\n    ACS_SSSB: int\n    ACS_SSSS: int\n    ACS_STERLING: int\n    ACS_TTEE: int\n    ACS_UARROW: int\n    ACS_ULCORNER: int\n    ACS_URCORNER: int\n    ACS_VLINE: int\n    ALL_MOUSE_EVENTS: int\n    A_ALTCHARSET: int\n    A_ATTRIBUTES: int\n    A_BLINK: int\n    A_BOLD: int\n    A_CHARTEXT: int\n    A_COLOR: int\n    A_DIM: int\n    A_HORIZONTAL: int\n    A_INVIS: int\n    A_ITALIC: int\n    A_LEFT: int\n    A_LOW: int\n    A_NORMAL: int\n    A_PROTECT: int\n    A_REVERSE: int\n    A_RIGHT: int\n    A_STANDOUT: int\n    A_TOP: int\n    A_UNDERLINE: int\n    A_VERTICAL: int\n    BUTTON1_CLICKED: int\n    BUTTON1_DOUBLE_CLICKED: int\n    BUTTON1_PRESSED: int\n    BUTTON1_RELEASED: int\n    BUTTON1_TRIPLE_CLICKED: int\n    BUTTON2_CLICKED: int\n    BUTTON2_DOUBLE_CLICKED: int\n    BUTTON2_PRESSED: int\n    BUTTON2_RELEASED: int\n    BUTTON2_TRIPLE_CLICKED: int\n    BUTTON3_CLICKED: int\n    BUTTON3_DOUBLE_CLICKED: int\n    BUTTON3_PRESSED: int\n    BUTTON3_RELEASED: int\n    BUTTON3_TRIPLE_CLICKED: int\n    BUTTON4_CLICKED: int\n    BUTTON4_DOUBLE_CLICKED: int\n    BUTTON4_PRESSED: int\n    BUTTON4_RELEASED: int\n    BUTTON4_TRIPLE_CLICKED: int\n    # Darwin ncurses doesn't provide BUTTON5_* constants\n    if sys.version_info >= (3, 10) and sys.platform != \"darwin\":\n        BUTTON5_PRESSED: int\n        BUTTON5_RELEASED: int\n        BUTTON5_CLICKED: int\n        BUTTON5_DOUBLE_CLICKED: int\n        BUTTON5_TRIPLE_CLICKED: int\n    BUTTON_ALT: int\n    BUTTON_CTRL: int\n    BUTTON_SHIFT: int\n    COLOR_BLACK: int\n    COLOR_BLUE: int\n    COLOR_CYAN: int\n    COLOR_GREEN: int\n    COLOR_MAGENTA: int\n    COLOR_RED: int\n    COLOR_WHITE: int\n    COLOR_YELLOW: int\n    ERR: int\n    KEY_A1: int\n    KEY_A3: int\n    KEY_B2: int\n    KEY_BACKSPACE: int\n    KEY_BEG: int\n    KEY_BREAK: int\n    KEY_BTAB: int\n    KEY_C1: int\n    KEY_C3: int\n    KEY_CANCEL: int\n    KEY_CATAB: int\n    KEY_CLEAR: int\n    KEY_CLOSE: int\n    KEY_COMMAND: int\n    KEY_COPY: int\n    KEY_CREATE: int\n    KEY_CTAB: int\n    KEY_DC: int\n    KEY_DL: int\n    KEY_DOWN: int\n    KEY_EIC: int\n    KEY_END: int\n    KEY_ENTER: int\n    KEY_EOL: int\n    KEY_EOS: int\n    KEY_EXIT: int\n    KEY_F0: int\n    KEY_F1: int\n    KEY_F10: int\n    KEY_F11: int\n    KEY_F12: int\n    KEY_F13: int\n    KEY_F14: int\n    KEY_F15: int\n    KEY_F16: int\n    KEY_F17: int\n    KEY_F18: int\n    KEY_F19: int\n    KEY_F2: int\n    KEY_F20: int\n    KEY_F21: int\n    KEY_F22: int\n    KEY_F23: int\n    KEY_F24: int\n    KEY_F25: int\n    KEY_F26: int\n    KEY_F27: int\n    KEY_F28: int\n    KEY_F29: int\n    KEY_F3: int\n    KEY_F30: int\n    KEY_F31: int\n    KEY_F32: int\n    KEY_F33: int\n    KEY_F34: int\n    KEY_F35: int\n    KEY_F36: int\n    KEY_F37: int\n    KEY_F38: int\n    KEY_F39: int\n    KEY_F4: int\n    KEY_F40: int\n    KEY_F41: int\n    KEY_F42: int\n    KEY_F43: int\n    KEY_F44: int\n    KEY_F45: int\n    KEY_F46: int\n    KEY_F47: int\n    KEY_F48: int\n    KEY_F49: int\n    KEY_F5: int\n    KEY_F50: int\n    KEY_F51: int\n    KEY_F52: int\n    KEY_F53: int\n    KEY_F54: int\n    KEY_F55: int\n    KEY_F56: int\n    KEY_F57: int\n    KEY_F58: int\n    KEY_F59: int\n    KEY_F6: int\n    KEY_F60: int\n    KEY_F61: int\n    KEY_F62: int\n    KEY_F63: int\n    KEY_F7: int\n    KEY_F8: int\n    KEY_F9: int\n    KEY_FIND: int\n    KEY_HELP: int\n    KEY_HOME: int\n    KEY_IC: int\n    KEY_IL: int\n    KEY_LEFT: int\n    KEY_LL: int\n    KEY_MARK: int\n    KEY_MAX: int\n    KEY_MESSAGE: int\n    KEY_MIN: int\n    KEY_MOUSE: int\n    KEY_MOVE: int\n    KEY_NEXT: int\n    KEY_NPAGE: int\n    KEY_OPEN: int\n    KEY_OPTIONS: int\n    KEY_PPAGE: int\n    KEY_PREVIOUS: int\n    KEY_PRINT: int\n    KEY_REDO: int\n    KEY_REFERENCE: int\n    KEY_REFRESH: int\n    KEY_REPLACE: int\n    KEY_RESET: int\n    KEY_RESIZE: int\n    KEY_RESTART: int\n    KEY_RESUME: int\n    KEY_RIGHT: int\n    KEY_SAVE: int\n    KEY_SBEG: int\n    KEY_SCANCEL: int\n    KEY_SCOMMAND: int\n    KEY_SCOPY: int\n    KEY_SCREATE: int\n    KEY_SDC: int\n    KEY_SDL: int\n    KEY_SELECT: int\n    KEY_SEND: int\n    KEY_SEOL: int\n    KEY_SEXIT: int\n    KEY_SF: int\n    KEY_SFIND: int\n    KEY_SHELP: int\n    KEY_SHOME: int\n    KEY_SIC: int\n    KEY_SLEFT: int\n    KEY_SMESSAGE: int\n    KEY_SMOVE: int\n    KEY_SNEXT: int\n    KEY_SOPTIONS: int\n    KEY_SPREVIOUS: int\n    KEY_SPRINT: int\n    KEY_SR: int\n    KEY_SREDO: int\n    KEY_SREPLACE: int\n    KEY_SRESET: int\n    KEY_SRIGHT: int\n    KEY_SRSUME: int\n    KEY_SSAVE: int\n    KEY_SSUSPEND: int\n    KEY_STAB: int\n    KEY_SUNDO: int\n    KEY_SUSPEND: int\n    KEY_UNDO: int\n    KEY_UP: int\n    OK: int\n    REPORT_MOUSE_POSITION: int\n    _C_API: Any\n    version: bytes\n    def baudrate() -> int: ...\n    def beep() -> None: ...\n    def can_change_color() -> bool: ...\n    def cbreak(__flag: bool = True) -> None: ...\n    def color_content(__color_number: int) -> tuple[int, int, int]: ...\n    # Changed in Python 3.8.8 and 3.9.2\n    if sys.version_info >= (3, 8):\n        def color_pair(pair_number: int) -> int: ...\n    else:\n        def color_pair(__color_number: int) -> int: ...\n\n    def curs_set(__visibility: int) -> int: ...\n    def def_prog_mode() -> None: ...\n    def def_shell_mode() -> None: ...\n    def delay_output(__ms: int) -> None: ...\n    def doupdate() -> None: ...\n    def echo(__flag: bool = True) -> None: ...\n    def endwin() -> None: ...\n    def erasechar() -> bytes: ...\n    def filter() -> None: ...\n    def flash() -> None: ...\n    def flushinp() -> None: ...\n    if sys.version_info >= (3, 9):\n        def get_escdelay() -> int: ...\n        def get_tabsize() -> int: ...\n\n    def getmouse() -> tuple[int, int, int, int, int]: ...\n    def getsyx() -> tuple[int, int]: ...\n    def getwin(__file: SupportsRead[bytes]) -> _CursesWindow: ...\n    def halfdelay(__tenths: int) -> None: ...\n    def has_colors() -> bool: ...\n    if sys.version_info >= (3, 10):\n        def has_extended_color_support() -> bool: ...\n\n    def has_ic() -> bool: ...\n    def has_il() -> bool: ...\n    def has_key(__key: int) -> bool: ...\n    def init_color(__color_number: int, __r: int, __g: int, __b: int) -> None: ...\n    def init_pair(__pair_number: int, __fg: int, __bg: int) -> None: ...\n    def initscr() -> _CursesWindow: ...\n    def intrflush(__flag: bool) -> None: ...\n    def is_term_resized(__nlines: int, __ncols: int) -> bool: ...\n    def isendwin() -> bool: ...\n    def keyname(__key: int) -> bytes: ...\n    def killchar() -> bytes: ...\n    def longname() -> bytes: ...\n    def meta(__yes: bool) -> None: ...\n    def mouseinterval(__interval: int) -> None: ...\n    def mousemask(__newmask: int) -> tuple[int, int]: ...\n    def napms(__ms: int) -> int: ...\n    def newpad(__nlines: int, __ncols: int) -> _CursesWindow: ...\n    def newwin(__nlines: int, __ncols: int, __begin_y: int = ..., __begin_x: int = ...) -> _CursesWindow: ...\n    def nl(__flag: bool = True) -> None: ...\n    def nocbreak() -> None: ...\n    def noecho() -> None: ...\n    def nonl() -> None: ...\n    def noqiflush() -> None: ...\n    def noraw() -> None: ...\n    def pair_content(__pair_number: int) -> tuple[int, int]: ...\n    def pair_number(__attr: int) -> int: ...\n    def putp(__string: ReadOnlyBuffer) -> None: ...\n    def qiflush(__flag: bool = True) -> None: ...\n    def raw(__flag: bool = True) -> None: ...\n    def reset_prog_mode() -> None: ...\n    def reset_shell_mode() -> None: ...\n    def resetty() -> None: ...\n    def resize_term(__nlines: int, __ncols: int) -> None: ...\n    def resizeterm(__nlines: int, __ncols: int) -> None: ...\n    def savetty() -> None: ...\n    if sys.version_info >= (3, 9):\n        def set_escdelay(__ms: int) -> None: ...\n        def set_tabsize(__size: int) -> None: ...\n\n    def setsyx(__y: int, __x: int) -> None: ...\n    def setupterm(term: str | None = None, fd: int = -1) -> None: ...\n    def start_color() -> None: ...\n    def termattrs() -> int: ...\n    def termname() -> bytes: ...\n    def tigetflag(__capname: str) -> int: ...\n    def tigetnum(__capname: str) -> int: ...\n    def tigetstr(__capname: str) -> bytes | None: ...\n    def tparm(\n        __str: ReadOnlyBuffer,\n        __i1: int = 0,\n        __i2: int = 0,\n        __i3: int = 0,\n        __i4: int = 0,\n        __i5: int = 0,\n        __i6: int = 0,\n        __i7: int = 0,\n        __i8: int = 0,\n        __i9: int = 0,\n    ) -> bytes: ...\n    def typeahead(__fd: int) -> None: ...\n    def unctrl(__ch: _ChType) -> bytes: ...\n    def unget_wch(__ch: int | str) -> None: ...\n    def ungetch(__ch: _ChType) -> None: ...\n    def ungetmouse(__id: int, __x: int, __y: int, __z: int, __bstate: int) -> None: ...\n    def update_lines_cols() -> None: ...\n    def use_default_colors() -> None: ...\n    def use_env(__flag: bool) -> None: ...\n\n    class error(Exception): ...\n\n    @final\n    class _CursesWindow:\n        encoding: str\n        @overload\n        def addch(self, ch: _ChType, attr: int = ...) -> None: ...\n        @overload\n        def addch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...\n        @overload\n        def addnstr(self, str: str, n: int, attr: int = ...) -> None: ...\n        @overload\n        def addnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...\n        @overload\n        def addstr(self, str: str, attr: int = ...) -> None: ...\n        @overload\n        def addstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...\n        def attroff(self, __attr: int) -> None: ...\n        def attron(self, __attr: int) -> None: ...\n        def attrset(self, __attr: int) -> None: ...\n        def bkgd(self, __ch: _ChType, __attr: int = ...) -> None: ...\n        def bkgdset(self, __ch: _ChType, __attr: int = ...) -> None: ...\n        def border(\n            self,\n            ls: _ChType = ...,\n            rs: _ChType = ...,\n            ts: _ChType = ...,\n            bs: _ChType = ...,\n            tl: _ChType = ...,\n            tr: _ChType = ...,\n            bl: _ChType = ...,\n            br: _ChType = ...,\n        ) -> None: ...\n        @overload\n        def box(self) -> None: ...\n        @overload\n        def box(self, vertch: _ChType = ..., horch: _ChType = ...) -> None: ...\n        @overload\n        def chgat(self, attr: int) -> None: ...\n        @overload\n        def chgat(self, num: int, attr: int) -> None: ...\n        @overload\n        def chgat(self, y: int, x: int, attr: int) -> None: ...\n        @overload\n        def chgat(self, y: int, x: int, num: int, attr: int) -> None: ...\n        def clear(self) -> None: ...\n        def clearok(self, yes: int) -> None: ...\n        def clrtobot(self) -> None: ...\n        def clrtoeol(self) -> None: ...\n        def cursyncup(self) -> None: ...\n        @overload\n        def delch(self) -> None: ...\n        @overload\n        def delch(self, y: int, x: int) -> None: ...\n        def deleteln(self) -> None: ...\n        @overload\n        def derwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        @overload\n        def derwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        def echochar(self, __ch: _ChType, __attr: int = ...) -> None: ...\n        def enclose(self, __y: int, __x: int) -> bool: ...\n        def erase(self) -> None: ...\n        def getbegyx(self) -> tuple[int, int]: ...\n        def getbkgd(self) -> tuple[int, int]: ...\n        @overload\n        def getch(self) -> int: ...\n        @overload\n        def getch(self, y: int, x: int) -> int: ...\n        @overload\n        def get_wch(self) -> int | str: ...\n        @overload\n        def get_wch(self, y: int, x: int) -> int | str: ...\n        @overload\n        def getkey(self) -> str: ...\n        @overload\n        def getkey(self, y: int, x: int) -> str: ...\n        def getmaxyx(self) -> tuple[int, int]: ...\n        def getparyx(self) -> tuple[int, int]: ...\n        @overload\n        def getstr(self) -> bytes: ...\n        @overload\n        def getstr(self, n: int) -> bytes: ...\n        @overload\n        def getstr(self, y: int, x: int) -> bytes: ...\n        @overload\n        def getstr(self, y: int, x: int, n: int) -> bytes: ...\n        def getyx(self) -> tuple[int, int]: ...\n        @overload\n        def hline(self, ch: _ChType, n: int) -> None: ...\n        @overload\n        def hline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...\n        def idcok(self, flag: bool) -> None: ...\n        def idlok(self, yes: bool) -> None: ...\n        def immedok(self, flag: bool) -> None: ...\n        @overload\n        def inch(self) -> int: ...\n        @overload\n        def inch(self, y: int, x: int) -> int: ...\n        @overload\n        def insch(self, ch: _ChType, attr: int = ...) -> None: ...\n        @overload\n        def insch(self, y: int, x: int, ch: _ChType, attr: int = ...) -> None: ...\n        def insdelln(self, nlines: int) -> None: ...\n        def insertln(self) -> None: ...\n        @overload\n        def insnstr(self, str: str, n: int, attr: int = ...) -> None: ...\n        @overload\n        def insnstr(self, y: int, x: int, str: str, n: int, attr: int = ...) -> None: ...\n        @overload\n        def insstr(self, str: str, attr: int = ...) -> None: ...\n        @overload\n        def insstr(self, y: int, x: int, str: str, attr: int = ...) -> None: ...\n        @overload\n        def instr(self, n: int = ...) -> bytes: ...\n        @overload\n        def instr(self, y: int, x: int, n: int = ...) -> bytes: ...\n        def is_linetouched(self, __line: int) -> bool: ...\n        def is_wintouched(self) -> bool: ...\n        def keypad(self, yes: bool) -> None: ...\n        def leaveok(self, yes: bool) -> None: ...\n        def move(self, new_y: int, new_x: int) -> None: ...\n        def mvderwin(self, y: int, x: int) -> None: ...\n        def mvwin(self, new_y: int, new_x: int) -> None: ...\n        def nodelay(self, yes: bool) -> None: ...\n        def notimeout(self, yes: bool) -> None: ...\n        @overload\n        def noutrefresh(self) -> None: ...\n        @overload\n        def noutrefresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...\n        @overload\n        def overlay(self, destwin: _CursesWindow) -> None: ...\n        @overload\n        def overlay(\n            self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int\n        ) -> None: ...\n        @overload\n        def overwrite(self, destwin: _CursesWindow) -> None: ...\n        @overload\n        def overwrite(\n            self, destwin: _CursesWindow, sminrow: int, smincol: int, dminrow: int, dmincol: int, dmaxrow: int, dmaxcol: int\n        ) -> None: ...\n        def putwin(self, __file: IO[Any]) -> None: ...\n        def redrawln(self, __beg: int, __num: int) -> None: ...\n        def redrawwin(self) -> None: ...\n        @overload\n        def refresh(self) -> None: ...\n        @overload\n        def refresh(self, pminrow: int, pmincol: int, sminrow: int, smincol: int, smaxrow: int, smaxcol: int) -> None: ...\n        def resize(self, nlines: int, ncols: int) -> None: ...\n        def scroll(self, lines: int = ...) -> None: ...\n        def scrollok(self, flag: bool) -> None: ...\n        def setscrreg(self, __top: int, __bottom: int) -> None: ...\n        def standend(self) -> None: ...\n        def standout(self) -> None: ...\n        @overload\n        def subpad(self, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        @overload\n        def subpad(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        @overload\n        def subwin(self, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        @overload\n        def subwin(self, nlines: int, ncols: int, begin_y: int, begin_x: int) -> _CursesWindow: ...\n        def syncdown(self) -> None: ...\n        def syncok(self, flag: bool) -> None: ...\n        def syncup(self) -> None: ...\n        def timeout(self, delay: int) -> None: ...\n        def touchline(self, start: int, count: int, changed: bool = ...) -> None: ...\n        def touchwin(self) -> None: ...\n        def untouchwin(self) -> None: ...\n        @overload\n        def vline(self, ch: _ChType, n: int) -> None: ...\n        @overload\n        def vline(self, y: int, x: int, ch: _ChType, n: int) -> None: ...\n    if sys.version_info >= (3, 8):\n        class _ncurses_version(NamedTuple):\n            major: int\n            minor: int\n            patch: int\n        ncurses_version: _ncurses_version\n        window = _CursesWindow  # undocumented\n",
  "/typeshed/stdlib/_decimal.pyi": "import numbers\nimport sys\nfrom collections.abc import Container, Sequence\nfrom types import TracebackType\nfrom typing import Any, ClassVar, NamedTuple, overload\nfrom typing_extensions import Final, Literal, Self, TypeAlias\n\n_Decimal: TypeAlias = Decimal | int\n_DecimalNew: TypeAlias = Decimal | float | str | tuple[int, Sequence[int], int]\n_ComparableNum: TypeAlias = Decimal | float | numbers.Rational\n\n__version__: Final[str]\n__libmpdec_version__: Final[str]\n\nclass DecimalTuple(NamedTuple):\n    sign: int\n    digits: tuple[int, ...]\n    exponent: int | Literal[\"n\", \"N\", \"F\"]\n\nROUND_DOWN: str\nROUND_HALF_UP: str\nROUND_HALF_EVEN: str\nROUND_CEILING: str\nROUND_FLOOR: str\nROUND_UP: str\nROUND_HALF_DOWN: str\nROUND_05UP: str\nHAVE_CONTEXTVAR: bool\nHAVE_THREADS: bool\nMAX_EMAX: int\nMAX_PREC: int\nMIN_EMIN: int\nMIN_ETINY: int\n\nclass DecimalException(ArithmeticError): ...\nclass Clamped(DecimalException): ...\nclass InvalidOperation(DecimalException): ...\nclass ConversionSyntax(InvalidOperation): ...\nclass DivisionByZero(DecimalException, ZeroDivisionError): ...\nclass DivisionImpossible(InvalidOperation): ...\nclass DivisionUndefined(InvalidOperation, ZeroDivisionError): ...\nclass Inexact(DecimalException): ...\nclass InvalidContext(InvalidOperation): ...\nclass Rounded(DecimalException): ...\nclass Subnormal(DecimalException): ...\nclass Overflow(Inexact, Rounded): ...\nclass Underflow(Inexact, Rounded, Subnormal): ...\nclass FloatOperation(DecimalException, TypeError): ...\n\ndef setcontext(__context: Context) -> None: ...\ndef getcontext() -> Context: ...\n\nif sys.version_info >= (3, 11):\n    def localcontext(\n        ctx: Context | None = None,\n        *,\n        prec: int | None = ...,\n        rounding: str | None = ...,\n        Emin: int | None = ...,\n        Emax: int | None = ...,\n        capitals: int | None = ...,\n        clamp: int | None = ...,\n        traps: dict[_TrapType, bool] | None = ...,\n        flags: dict[_TrapType, bool] | None = ...,\n    ) -> _ContextManager: ...\n\nelse:\n    def localcontext(ctx: Context | None = None) -> _ContextManager: ...\n\nclass Decimal:\n    def __new__(cls, value: _DecimalNew = ..., context: Context | None = ...) -> Self: ...\n    @classmethod\n    def from_float(cls, __f: float) -> Self: ...\n    def __bool__(self) -> bool: ...\n    def compare(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def as_tuple(self) -> DecimalTuple: ...\n    def as_integer_ratio(self) -> tuple[int, int]: ...\n    def to_eng_string(self, context: Context | None = None) -> str: ...\n    def __abs__(self) -> Decimal: ...\n    def __add__(self, __value: _Decimal) -> Decimal: ...\n    def __divmod__(self, __value: _Decimal) -> tuple[Decimal, Decimal]: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __floordiv__(self, __value: _Decimal) -> Decimal: ...\n    def __ge__(self, __value: _ComparableNum) -> bool: ...\n    def __gt__(self, __value: _ComparableNum) -> bool: ...\n    def __le__(self, __value: _ComparableNum) -> bool: ...\n    def __lt__(self, __value: _ComparableNum) -> bool: ...\n    def __mod__(self, __value: _Decimal) -> Decimal: ...\n    def __mul__(self, __value: _Decimal) -> Decimal: ...\n    def __neg__(self) -> Decimal: ...\n    def __pos__(self) -> Decimal: ...\n    def __pow__(self, __value: _Decimal, __mod: _Decimal | None = None) -> Decimal: ...\n    def __radd__(self, __value: _Decimal) -> Decimal: ...\n    def __rdivmod__(self, __value: _Decimal) -> tuple[Decimal, Decimal]: ...\n    def __rfloordiv__(self, __value: _Decimal) -> Decimal: ...\n    def __rmod__(self, __value: _Decimal) -> Decimal: ...\n    def __rmul__(self, __value: _Decimal) -> Decimal: ...\n    def __rsub__(self, __value: _Decimal) -> Decimal: ...\n    def __rtruediv__(self, __value: _Decimal) -> Decimal: ...\n    def __sub__(self, __value: _Decimal) -> Decimal: ...\n    def __truediv__(self, __value: _Decimal) -> Decimal: ...\n    def remainder_near(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    @property\n    def real(self) -> Decimal: ...\n    @property\n    def imag(self) -> Decimal: ...\n    def conjugate(self) -> Decimal: ...\n    def __complex__(self) -> complex: ...\n    @overload\n    def __round__(self) -> int: ...\n    @overload\n    def __round__(self, __ndigits: int) -> Decimal: ...\n    def __floor__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def fma(self, other: _Decimal, third: _Decimal, context: Context | None = None) -> Decimal: ...\n    def __rpow__(self, __value: _Decimal, __mod: Context | None = None) -> Decimal: ...\n    def normalize(self, context: Context | None = None) -> Decimal: ...\n    def quantize(self, exp: _Decimal, rounding: str | None = None, context: Context | None = None) -> Decimal: ...\n    def same_quantum(self, other: _Decimal, context: Context | None = None) -> bool: ...\n    def to_integral_exact(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...\n    def to_integral_value(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...\n    def to_integral(self, rounding: str | None = None, context: Context | None = None) -> Decimal: ...\n    def sqrt(self, context: Context | None = None) -> Decimal: ...\n    def max(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def min(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def adjusted(self) -> int: ...\n    def canonical(self) -> Decimal: ...\n    def compare_signal(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def compare_total(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def compare_total_mag(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def copy_abs(self) -> Decimal: ...\n    def copy_negate(self) -> Decimal: ...\n    def copy_sign(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def exp(self, context: Context | None = None) -> Decimal: ...\n    def is_canonical(self) -> bool: ...\n    def is_finite(self) -> bool: ...\n    def is_infinite(self) -> bool: ...\n    def is_nan(self) -> bool: ...\n    def is_normal(self, context: Context | None = None) -> bool: ...\n    def is_qnan(self) -> bool: ...\n    def is_signed(self) -> bool: ...\n    def is_snan(self) -> bool: ...\n    def is_subnormal(self, context: Context | None = None) -> bool: ...\n    def is_zero(self) -> bool: ...\n    def ln(self, context: Context | None = None) -> Decimal: ...\n    def log10(self, context: Context | None = None) -> Decimal: ...\n    def logb(self, context: Context | None = None) -> Decimal: ...\n    def logical_and(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def logical_invert(self, context: Context | None = None) -> Decimal: ...\n    def logical_or(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def logical_xor(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def max_mag(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def min_mag(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def next_minus(self, context: Context | None = None) -> Decimal: ...\n    def next_plus(self, context: Context | None = None) -> Decimal: ...\n    def next_toward(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def number_class(self, context: Context | None = None) -> str: ...\n    def radix(self) -> Decimal: ...\n    def rotate(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def scaleb(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def shift(self, other: _Decimal, context: Context | None = None) -> Decimal: ...\n    def __reduce__(self) -> tuple[type[Self], tuple[str]]: ...\n    def __copy__(self) -> Self: ...\n    def __deepcopy__(self, __memo: Any) -> Self: ...\n    def __format__(self, __specifier: str, __context: Context | None = ...) -> str: ...\n\nclass _ContextManager:\n    new_context: Context\n    saved_context: Context\n    def __init__(self, new_context: Context) -> None: ...\n    def __enter__(self) -> Context: ...\n    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n\n_TrapType: TypeAlias = type[DecimalException]\n\nclass Context:\n    # TODO: Context doesn't allow you to delete *any* attributes from instances of the class at runtime,\n    # even settable attributes like `prec` and `rounding`,\n    # but that's inexpressable in the stub.\n    # Type checkers either ignore it or misinterpret it\n    # if you add a `def __delattr__(self, __name: str) -> NoReturn` method to the stub\n    prec: int\n    rounding: str\n    Emin: int\n    Emax: int\n    capitals: int\n    clamp: int\n    traps: dict[_TrapType, bool]\n    flags: dict[_TrapType, bool]\n    def __init__(\n        self,\n        prec: int | None = ...,\n        rounding: str | None = ...,\n        Emin: int | None = ...,\n        Emax: int | None = ...,\n        capitals: int | None = ...,\n        clamp: int | None = ...,\n        flags: None | dict[_TrapType, bool] | Container[_TrapType] = ...,\n        traps: None | dict[_TrapType, bool] | Container[_TrapType] = ...,\n        _ignored_flags: list[_TrapType] | None = ...,\n    ) -> None: ...\n    def __reduce__(self) -> tuple[type[Self], tuple[Any, ...]]: ...\n    def clear_flags(self) -> None: ...\n    def clear_traps(self) -> None: ...\n    def copy(self) -> Context: ...\n    def __copy__(self) -> Context: ...\n    # see https://github.com/python/cpython/issues/94107\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def Etiny(self) -> int: ...\n    def Etop(self) -> int: ...\n    def create_decimal(self, __num: _DecimalNew = \"0\") -> Decimal: ...\n    def create_decimal_from_float(self, __f: float) -> Decimal: ...\n    def abs(self, __x: _Decimal) -> Decimal: ...\n    def add(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def canonical(self, __x: Decimal) -> Decimal: ...\n    def compare(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def compare_signal(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def compare_total(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def compare_total_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def copy_abs(self, __x: _Decimal) -> Decimal: ...\n    def copy_decimal(self, __x: _Decimal) -> Decimal: ...\n    def copy_negate(self, __x: _Decimal) -> Decimal: ...\n    def copy_sign(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def divide(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def divide_int(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def divmod(self, __x: _Decimal, __y: _Decimal) -> tuple[Decimal, Decimal]: ...\n    def exp(self, __x: _Decimal) -> Decimal: ...\n    def fma(self, __x: _Decimal, __y: _Decimal, __z: _Decimal) -> Decimal: ...\n    def is_canonical(self, __x: _Decimal) -> bool: ...\n    def is_finite(self, __x: _Decimal) -> bool: ...\n    def is_infinite(self, __x: _Decimal) -> bool: ...\n    def is_nan(self, __x: _Decimal) -> bool: ...\n    def is_normal(self, __x: _Decimal) -> bool: ...\n    def is_qnan(self, __x: _Decimal) -> bool: ...\n    def is_signed(self, __x: _Decimal) -> bool: ...\n    def is_snan(self, __x: _Decimal) -> bool: ...\n    def is_subnormal(self, __x: _Decimal) -> bool: ...\n    def is_zero(self, __x: _Decimal) -> bool: ...\n    def ln(self, __x: _Decimal) -> Decimal: ...\n    def log10(self, __x: _Decimal) -> Decimal: ...\n    def logb(self, __x: _Decimal) -> Decimal: ...\n    def logical_and(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def logical_invert(self, __x: _Decimal) -> Decimal: ...\n    def logical_or(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def logical_xor(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def max(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def max_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def min(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def min_mag(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def minus(self, __x: _Decimal) -> Decimal: ...\n    def multiply(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def next_minus(self, __x: _Decimal) -> Decimal: ...\n    def next_plus(self, __x: _Decimal) -> Decimal: ...\n    def next_toward(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def normalize(self, __x: _Decimal) -> Decimal: ...\n    def number_class(self, __x: _Decimal) -> str: ...\n    def plus(self, __x: _Decimal) -> Decimal: ...\n    def power(self, a: _Decimal, b: _Decimal, modulo: _Decimal | None = None) -> Decimal: ...\n    def quantize(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def radix(self) -> Decimal: ...\n    def remainder(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def remainder_near(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def rotate(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def same_quantum(self, __x: _Decimal, __y: _Decimal) -> bool: ...\n    def scaleb(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def shift(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def sqrt(self, __x: _Decimal) -> Decimal: ...\n    def subtract(self, __x: _Decimal, __y: _Decimal) -> Decimal: ...\n    def to_eng_string(self, __x: _Decimal) -> str: ...\n    def to_sci_string(self, __x: _Decimal) -> str: ...\n    def to_integral_exact(self, __x: _Decimal) -> Decimal: ...\n    def to_integral_value(self, __x: _Decimal) -> Decimal: ...\n    def to_integral(self, __x: _Decimal) -> Decimal: ...\n\nDefaultContext: Context\nBasicContext: Context\nExtendedContext: Context\n",
  "/typeshed/stdlib/_dummy_thread.pyi": "from collections.abc import Callable\nfrom types import TracebackType\nfrom typing import Any, NoReturn\n\n__all__ = [\"error\", \"start_new_thread\", \"exit\", \"get_ident\", \"allocate_lock\", \"interrupt_main\", \"LockType\", \"RLock\"]\n\nTIMEOUT_MAX: int\nerror = RuntimeError\n\ndef start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any] = {}) -> None: ...\ndef exit() -> NoReturn: ...\ndef get_ident() -> int: ...\ndef allocate_lock() -> LockType: ...\ndef stack_size(size: int | None = None) -> int: ...\n\nclass LockType:\n    locked_status: bool\n    def acquire(self, waitflag: bool | None = None, timeout: int = -1) -> bool: ...\n    def __enter__(self, waitflag: bool | None = None, timeout: int = -1) -> bool: ...\n    def __exit__(self, typ: type[BaseException] | None, val: BaseException | None, tb: TracebackType | None) -> None: ...\n    def release(self) -> bool: ...\n    def locked(self) -> bool: ...\n\nclass RLock(LockType):\n    def release(self) -> None: ...  # type: ignore[override]\n\ndef interrupt_main() -> None: ...\n",
  "/typeshed/stdlib/_dummy_threading.pyi": "import sys\nfrom _typeshed import ProfileFunction, TraceFunction\nfrom collections.abc import Callable, Iterable, Mapping\nfrom types import TracebackType\nfrom typing import Any, TypeVar\n\n_T = TypeVar(\"_T\")\n\n__all__ = [\n    \"get_ident\",\n    \"active_count\",\n    \"Condition\",\n    \"current_thread\",\n    \"enumerate\",\n    \"main_thread\",\n    \"TIMEOUT_MAX\",\n    \"Event\",\n    \"Lock\",\n    \"RLock\",\n    \"Semaphore\",\n    \"BoundedSemaphore\",\n    \"Thread\",\n    \"Barrier\",\n    \"BrokenBarrierError\",\n    \"Timer\",\n    \"ThreadError\",\n    \"setprofile\",\n    \"settrace\",\n    \"local\",\n    \"stack_size\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"ExceptHookArgs\", \"excepthook\"]\n\ndef active_count() -> int: ...\ndef current_thread() -> Thread: ...\ndef currentThread() -> Thread: ...\ndef get_ident() -> int: ...\ndef enumerate() -> list[Thread]: ...\ndef main_thread() -> Thread: ...\ndef settrace(func: TraceFunction) -> None: ...\ndef setprofile(func: ProfileFunction | None) -> None: ...\ndef stack_size(size: int | None = None) -> int: ...\n\nTIMEOUT_MAX: float\n\nclass ThreadError(Exception): ...\n\nclass local:\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass Thread:\n    name: str\n    daemon: bool\n    @property\n    def ident(self) -> int | None: ...\n    def __init__(\n        self,\n        group: None = None,\n        target: Callable[..., object] | None = None,\n        name: str | None = None,\n        args: Iterable[Any] = (),\n        kwargs: Mapping[str, Any] | None = None,\n        *,\n        daemon: bool | None = None,\n    ) -> None: ...\n    def start(self) -> None: ...\n    def run(self) -> None: ...\n    def join(self, timeout: float | None = None) -> None: ...\n    def getName(self) -> str: ...\n    def setName(self, name: str) -> None: ...\n    if sys.version_info >= (3, 8):\n        @property\n        def native_id(self) -> int | None: ...  # only available on some platforms\n\n    def is_alive(self) -> bool: ...\n    if sys.version_info < (3, 9):\n        def isAlive(self) -> bool: ...\n\n    def isDaemon(self) -> bool: ...\n    def setDaemon(self, daemonic: bool) -> None: ...\n\nclass _DummyThread(Thread): ...\n\nclass Lock:\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> bool | None: ...\n    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...\n    def release(self) -> None: ...\n    def locked(self) -> bool: ...\n\nclass _RLock:\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> bool | None: ...\n    def acquire(self, blocking: bool = True, timeout: float = -1) -> bool: ...\n    def release(self) -> None: ...\n\nRLock = _RLock\n\nclass Condition:\n    def __init__(self, lock: Lock | _RLock | None = None) -> None: ...\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> bool | None: ...\n    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...\n    def release(self) -> None: ...\n    def wait(self, timeout: float | None = None) -> bool: ...\n    def wait_for(self, predicate: Callable[[], _T], timeout: float | None = None) -> _T: ...\n    def notify(self, n: int = 1) -> None: ...\n    def notify_all(self) -> None: ...\n    def notifyAll(self) -> None: ...\n\nclass Semaphore:\n    def __init__(self, value: int = 1) -> None: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> bool | None: ...\n    def acquire(self, blocking: bool = True, timeout: float | None = None) -> bool: ...\n    def __enter__(self, blocking: bool = True, timeout: float | None = None) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def release(self, n: int = ...) -> None: ...\n    else:\n        def release(self) -> None: ...\n\nclass BoundedSemaphore(Semaphore): ...\n\nclass Event:\n    def is_set(self) -> bool: ...\n    def set(self) -> None: ...\n    def clear(self) -> None: ...\n    def wait(self, timeout: float | None = None) -> bool: ...\n\nif sys.version_info >= (3, 8):\n    from _thread import _excepthook, _ExceptHookArgs\n\n    excepthook = _excepthook\n    ExceptHookArgs = _ExceptHookArgs\n\nclass Timer(Thread):\n    def __init__(\n        self,\n        interval: float,\n        function: Callable[..., object],\n        args: Iterable[Any] | None = None,\n        kwargs: Mapping[str, Any] | None = None,\n    ) -> None: ...\n    def cancel(self) -> None: ...\n\nclass Barrier:\n    @property\n    def parties(self) -> int: ...\n    @property\n    def n_waiting(self) -> int: ...\n    @property\n    def broken(self) -> bool: ...\n    def __init__(self, parties: int, action: Callable[[], None] | None = None, timeout: float | None = None) -> None: ...\n    def wait(self, timeout: float | None = None) -> int: ...\n    def reset(self) -> None: ...\n    def abort(self) -> None: ...\n\nclass BrokenBarrierError(RuntimeError): ...\n",
  "/typeshed/stdlib/_heapq.pyi": "from typing import Any, TypeVar\nfrom typing_extensions import Final\n\n_T = TypeVar(\"_T\")\n\n__about__: Final[str]\n\ndef heapify(__heap: list[Any]) -> None: ...\ndef heappop(__heap: list[_T]) -> _T: ...\ndef heappush(__heap: list[_T], __item: _T) -> None: ...\ndef heappushpop(__heap: list[_T], __item: _T) -> _T: ...\ndef heapreplace(__heap: list[_T], __item: _T) -> _T: ...\n",
  "/typeshed/stdlib/_imp.pyi": "import sys\nimport types\nfrom _typeshed import ReadableBuffer\nfrom importlib.machinery import ModuleSpec\nfrom typing import Any\n\ncheck_hash_based_pycs: str\n\ndef source_hash(key: int, source: ReadableBuffer) -> bytes: ...\ndef create_builtin(__spec: ModuleSpec) -> types.ModuleType: ...\ndef create_dynamic(__spec: ModuleSpec, __file: Any = None) -> types.ModuleType: ...\ndef acquire_lock() -> None: ...\ndef exec_builtin(__mod: types.ModuleType) -> int: ...\ndef exec_dynamic(__mod: types.ModuleType) -> int: ...\ndef extension_suffixes() -> list[str]: ...\ndef init_frozen(__name: str) -> types.ModuleType: ...\ndef is_builtin(__name: str) -> int: ...\ndef is_frozen(__name: str) -> bool: ...\ndef is_frozen_package(__name: str) -> bool: ...\ndef lock_held() -> bool: ...\ndef release_lock() -> None: ...\n\nif sys.version_info >= (3, 11):\n    def find_frozen(__name: str, *, withdata: bool = False) -> tuple[memoryview | None, bool, str | None] | None: ...\n    def get_frozen_object(__name: str, __data: ReadableBuffer | None = None) -> types.CodeType: ...\n\nelse:\n    def get_frozen_object(__name: str) -> types.CodeType: ...\n",
  "/typeshed/stdlib/_json.pyi": "from collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import final\n\n@final\nclass make_encoder:\n    @property\n    def sort_keys(self) -> bool: ...\n    @property\n    def skipkeys(self) -> bool: ...\n    @property\n    def key_separator(self) -> str: ...\n    @property\n    def indent(self) -> int | None: ...\n    @property\n    def markers(self) -> dict[int, Any] | None: ...\n    @property\n    def default(self) -> Callable[[Any], Any]: ...\n    @property\n    def encoder(self) -> Callable[[str], str]: ...\n    @property\n    def item_separator(self) -> str: ...\n    def __init__(\n        self,\n        markers: dict[int, Any] | None,\n        default: Callable[[Any], Any],\n        encoder: Callable[[str], str],\n        indent: int | None,\n        key_separator: str,\n        item_separator: str,\n        sort_keys: bool,\n        skipkeys: bool,\n        allow_nan: bool,\n    ) -> None: ...\n    def __call__(self, obj: object, _current_indent_level: int) -> Any: ...\n\n@final\nclass make_scanner:\n    object_hook: Any\n    object_pairs_hook: Any\n    parse_int: Any\n    parse_constant: Any\n    parse_float: Any\n    strict: bool\n    # TODO: 'context' needs the attrs above (ducktype), but not __call__.\n    def __init__(self, context: make_scanner) -> None: ...\n    def __call__(self, string: str, index: int) -> tuple[Any, int]: ...\n\ndef encode_basestring_ascii(s: str) -> str: ...\ndef scanstring(string: str, end: int, strict: bool = ...) -> tuple[str, int]: ...\n",
  "/typeshed/stdlib/_markupbase.pyi": "import sys\nfrom typing import Any\n\nclass ParserBase:\n    def reset(self) -> None: ...\n    def getpos(self) -> tuple[int, int]: ...\n    def unknown_decl(self, data: str) -> None: ...\n    def parse_comment(self, i: int, report: int = 1) -> int: ...  # undocumented\n    def parse_declaration(self, i: int) -> int: ...  # undocumented\n    def parse_marked_section(self, i: int, report: int = 1) -> int: ...  # undocumented\n    def updatepos(self, i: int, j: int) -> int: ...  # undocumented\n    if sys.version_info < (3, 10):\n        # Removed from ParserBase: https://bugs.python.org/issue31844\n        def error(self, message: str) -> Any: ...  # undocumented\n    lineno: int  # undocumented\n    offset: int  # undocumented\n",
  "/typeshed/stdlib/_msi.pyi": "import sys\n\nif sys.platform == \"win32\":\n    # Actual typename View, not exposed by the implementation\n    class _View:\n        def Execute(self, params: _Record | None = ...) -> None: ...\n        def GetColumnInfo(self, kind: int) -> _Record: ...\n        def Fetch(self) -> _Record: ...\n        def Modify(self, mode: int, record: _Record) -> None: ...\n        def Close(self) -> None: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n\n    # Actual typename SummaryInformation, not exposed by the implementation\n    class _SummaryInformation:\n        def GetProperty(self, field: int) -> int | bytes | None: ...\n        def GetPropertyCount(self) -> int: ...\n        def SetProperty(self, field: int, value: int | str) -> None: ...\n        def Persist(self) -> None: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n\n    # Actual typename Database, not exposed by the implementation\n    class _Database:\n        def OpenView(self, sql: str) -> _View: ...\n        def Commit(self) -> None: ...\n        def GetSummaryInformation(self, updateCount: int) -> _SummaryInformation: ...\n        def Close(self) -> None: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n\n    # Actual typename Record, not exposed by the implementation\n    class _Record:\n        def GetFieldCount(self) -> int: ...\n        def GetInteger(self, field: int) -> int: ...\n        def GetString(self, field: int) -> str: ...\n        def SetString(self, field: int, str: str) -> None: ...\n        def SetStream(self, field: int, stream: str) -> None: ...\n        def SetInteger(self, field: int, int: int) -> None: ...\n        def ClearData(self) -> None: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n    def UuidCreate() -> str: ...\n    def FCICreate(__cabname: str, __files: list[str]) -> None: ...\n    def OpenDatabase(__path: str, __persist: int) -> _Database: ...\n    def CreateRecord(__count: int) -> _Record: ...\n\n    MSICOLINFO_NAMES: int\n    MSICOLINFO_TYPES: int\n    MSIDBOPEN_CREATE: int\n    MSIDBOPEN_CREATEDIRECT: int\n    MSIDBOPEN_DIRECT: int\n    MSIDBOPEN_PATCHFILE: int\n    MSIDBOPEN_READONLY: int\n    MSIDBOPEN_TRANSACT: int\n    MSIMODIFY_ASSIGN: int\n    MSIMODIFY_DELETE: int\n    MSIMODIFY_INSERT: int\n    MSIMODIFY_INSERT_TEMPORARY: int\n    MSIMODIFY_MERGE: int\n    MSIMODIFY_REFRESH: int\n    MSIMODIFY_REPLACE: int\n    MSIMODIFY_SEEK: int\n    MSIMODIFY_UPDATE: int\n    MSIMODIFY_VALIDATE: int\n    MSIMODIFY_VALIDATE_DELETE: int\n    MSIMODIFY_VALIDATE_FIELD: int\n    MSIMODIFY_VALIDATE_NEW: int\n\n    PID_APPNAME: int\n    PID_AUTHOR: int\n    PID_CHARCOUNT: int\n    PID_CODEPAGE: int\n    PID_COMMENTS: int\n    PID_CREATE_DTM: int\n    PID_KEYWORDS: int\n    PID_LASTAUTHOR: int\n    PID_LASTPRINTED: int\n    PID_LASTSAVE_DTM: int\n    PID_PAGECOUNT: int\n    PID_REVNUMBER: int\n    PID_SECURITY: int\n    PID_SUBJECT: int\n    PID_TEMPLATE: int\n    PID_TITLE: int\n    PID_WORDCOUNT: int\n",
  "/typeshed/stdlib/_operator.pyi": "import sys\nfrom _typeshed import SupportsGetItem\nfrom collections.abc import Callable, Container, Iterable, MutableMapping, MutableSequence, Sequence\nfrom typing import Any, AnyStr, Generic, Protocol, SupportsAbs, TypeVar, overload\nfrom typing_extensions import ParamSpec, SupportsIndex, TypeAlias, final\n\n_R = TypeVar(\"_R\")\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_K = TypeVar(\"_K\")\n_V = TypeVar(\"_V\")\n_P = ParamSpec(\"_P\")\n\n# The following protocols return \"Any\" instead of bool, since the comparison\n# operators can be overloaded to return an arbitrary object. For example,\n# the numpy.array comparison dunders return another numpy.array.\n\nclass _SupportsDunderLT(Protocol):\n    def __lt__(self, __other: Any) -> Any: ...\n\nclass _SupportsDunderGT(Protocol):\n    def __gt__(self, __other: Any) -> Any: ...\n\nclass _SupportsDunderLE(Protocol):\n    def __le__(self, __other: Any) -> Any: ...\n\nclass _SupportsDunderGE(Protocol):\n    def __ge__(self, __other: Any) -> Any: ...\n\n_SupportsComparison: TypeAlias = _SupportsDunderLE | _SupportsDunderGE | _SupportsDunderGT | _SupportsDunderLT\n\nclass _SupportsInversion(Protocol[_T_co]):\n    def __invert__(self) -> _T_co: ...\n\nclass _SupportsNeg(Protocol[_T_co]):\n    def __neg__(self) -> _T_co: ...\n\nclass _SupportsPos(Protocol[_T_co]):\n    def __pos__(self) -> _T_co: ...\n\n# All four comparison functions must have the same signature, or we get false-positive errors\ndef lt(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...\ndef le(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...\ndef eq(__a: object, __b: object) -> Any: ...\ndef ne(__a: object, __b: object) -> Any: ...\ndef ge(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...\ndef gt(__a: _SupportsComparison, __b: _SupportsComparison) -> Any: ...\ndef not_(__a: object) -> bool: ...\ndef truth(__a: object) -> bool: ...\ndef is_(__a: object, __b: object) -> bool: ...\ndef is_not(__a: object, __b: object) -> bool: ...\ndef abs(__a: SupportsAbs[_T]) -> _T: ...\ndef add(__a: Any, __b: Any) -> Any: ...\ndef and_(__a: Any, __b: Any) -> Any: ...\ndef floordiv(__a: Any, __b: Any) -> Any: ...\ndef index(__a: SupportsIndex) -> int: ...\ndef inv(__a: _SupportsInversion[_T_co]) -> _T_co: ...\ndef invert(__a: _SupportsInversion[_T_co]) -> _T_co: ...\ndef lshift(__a: Any, __b: Any) -> Any: ...\ndef mod(__a: Any, __b: Any) -> Any: ...\ndef mul(__a: Any, __b: Any) -> Any: ...\ndef matmul(__a: Any, __b: Any) -> Any: ...\ndef neg(__a: _SupportsNeg[_T_co]) -> _T_co: ...\ndef or_(__a: Any, __b: Any) -> Any: ...\ndef pos(__a: _SupportsPos[_T_co]) -> _T_co: ...\ndef pow(__a: Any, __b: Any) -> Any: ...\ndef rshift(__a: Any, __b: Any) -> Any: ...\ndef sub(__a: Any, __b: Any) -> Any: ...\ndef truediv(__a: Any, __b: Any) -> Any: ...\ndef xor(__a: Any, __b: Any) -> Any: ...\ndef concat(__a: Sequence[_T], __b: Sequence[_T]) -> Sequence[_T]: ...\ndef contains(__a: Container[object], __b: object) -> bool: ...\ndef countOf(__a: Iterable[object], __b: object) -> int: ...\n@overload\ndef delitem(__a: MutableSequence[Any], __b: SupportsIndex) -> None: ...\n@overload\ndef delitem(__a: MutableSequence[Any], __b: slice) -> None: ...\n@overload\ndef delitem(__a: MutableMapping[_K, Any], __b: _K) -> None: ...\n@overload\ndef getitem(__a: Sequence[_T], __b: slice) -> Sequence[_T]: ...\n@overload\ndef getitem(__a: SupportsGetItem[_K, _V], __b: _K) -> _V: ...\ndef indexOf(__a: Iterable[_T], __b: _T) -> int: ...\n@overload\ndef setitem(__a: MutableSequence[_T], __b: SupportsIndex, __c: _T) -> None: ...\n@overload\ndef setitem(__a: MutableSequence[_T], __b: slice, __c: Sequence[_T]) -> None: ...\n@overload\ndef setitem(__a: MutableMapping[_K, _V], __b: _K, __c: _V) -> None: ...\ndef length_hint(__obj: object, __default: int = 0) -> int: ...\n@final\nclass attrgetter(Generic[_T_co]):\n    @overload\n    def __new__(cls, attr: str) -> attrgetter[Any]: ...\n    @overload\n    def __new__(cls, attr: str, __attr2: str) -> attrgetter[tuple[Any, Any]]: ...\n    @overload\n    def __new__(cls, attr: str, __attr2: str, __attr3: str) -> attrgetter[tuple[Any, Any, Any]]: ...\n    @overload\n    def __new__(cls, attr: str, __attr2: str, __attr3: str, __attr4: str) -> attrgetter[tuple[Any, Any, Any, Any]]: ...\n    @overload\n    def __new__(cls, attr: str, *attrs: str) -> attrgetter[tuple[Any, ...]]: ...\n    def __call__(self, obj: Any) -> _T_co: ...\n\n@final\nclass itemgetter(Generic[_T_co]):\n    # mypy lacks support for PEP 646 https://github.com/python/mypy/issues/12280\n    # So we have to define all of these overloads to simulate unpacking the arguments\n    @overload\n    def __new__(cls, item: _T_co) -> itemgetter[_T_co]: ...\n    @overload\n    def __new__(cls, item: _T_co, __item2: _T_co) -> itemgetter[tuple[_T_co, _T_co]]: ...\n    @overload\n    def __new__(cls, item: _T_co, __item2: _T_co, __item3: _T_co) -> itemgetter[tuple[_T_co, _T_co, _T_co]]: ...\n    @overload\n    def __new__(\n        cls, item: _T_co, __item2: _T_co, __item3: _T_co, __item4: _T_co\n    ) -> itemgetter[tuple[_T_co, _T_co, _T_co, _T_co]]: ...\n    @overload\n    def __new__(\n        cls, item: _T_co, __item2: _T_co, __item3: _T_co, __item4: _T_co, *items: _T_co\n    ) -> itemgetter[tuple[_T_co, ...]]: ...\n    # __key: _KT_contra in SupportsGetItem seems to be causing variance issues, ie:\n    # TypeVar \"_KT_contra@SupportsGetItem\" is contravariant\n    #   \"tuple[int, int]\" is incompatible with protocol \"SupportsIndex\"\n    # preventing [_T_co, ...] instead of [Any, ...]\n    #\n    # A suspected mypy issue prevents using [..., _T] instead of [..., Any] here.\n    # https://github.com/python/mypy/issues/14032\n    def __call__(self, obj: SupportsGetItem[Any, Any]) -> Any: ...\n\n@final\nclass methodcaller:\n    def __init__(self, __name: str, *args: Any, **kwargs: Any) -> None: ...\n    def __call__(self, obj: Any) -> Any: ...\n\ndef iadd(__a: Any, __b: Any) -> Any: ...\ndef iand(__a: Any, __b: Any) -> Any: ...\ndef iconcat(__a: Any, __b: Any) -> Any: ...\ndef ifloordiv(__a: Any, __b: Any) -> Any: ...\ndef ilshift(__a: Any, __b: Any) -> Any: ...\ndef imod(__a: Any, __b: Any) -> Any: ...\ndef imul(__a: Any, __b: Any) -> Any: ...\ndef imatmul(__a: Any, __b: Any) -> Any: ...\ndef ior(__a: Any, __b: Any) -> Any: ...\ndef ipow(__a: Any, __b: Any) -> Any: ...\ndef irshift(__a: Any, __b: Any) -> Any: ...\ndef isub(__a: Any, __b: Any) -> Any: ...\ndef itruediv(__a: Any, __b: Any) -> Any: ...\ndef ixor(__a: Any, __b: Any) -> Any: ...\n\nif sys.version_info >= (3, 11):\n    def call(__obj: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R: ...\n\ndef _compare_digest(__a: AnyStr, __b: AnyStr) -> bool: ...\n",
  "/typeshed/stdlib/_osx_support.pyi": "import sys\nfrom collections.abc import Iterable, Sequence\nfrom typing import TypeVar\n\n_T = TypeVar(\"_T\")\n_K = TypeVar(\"_K\")\n_V = TypeVar(\"_V\")\n\n__all__ = [\"compiler_fixup\", \"customize_config_vars\", \"customize_compiler\", \"get_platform_osx\"]\n\n_UNIVERSAL_CONFIG_VARS: tuple[str, ...]  # undocumented\n_COMPILER_CONFIG_VARS: tuple[str, ...]  # undocumented\n_INITPRE: str  # undocumented\n\ndef _find_executable(executable: str, path: str | None = None) -> str | None: ...  # undocumented\n\nif sys.version_info >= (3, 8):\n    def _read_output(commandstring: str, capture_stderr: bool = False) -> str | None: ...  # undocumented\n\nelse:\n    def _read_output(commandstring: str) -> str | None: ...  # undocumented\n\ndef _find_build_tool(toolname: str) -> str: ...  # undocumented\n\n_SYSTEM_VERSION: str | None  # undocumented\n\ndef _get_system_version() -> str: ...  # undocumented\ndef _remove_original_values(_config_vars: dict[str, str]) -> None: ...  # undocumented\ndef _save_modified_value(_config_vars: dict[str, str], cv: str, newvalue: str) -> None: ...  # undocumented\ndef _supports_universal_builds() -> bool: ...  # undocumented\ndef _find_appropriate_compiler(_config_vars: dict[str, str]) -> dict[str, str]: ...  # undocumented\ndef _remove_universal_flags(_config_vars: dict[str, str]) -> dict[str, str]: ...  # undocumented\ndef _remove_unsupported_archs(_config_vars: dict[str, str]) -> dict[str, str]: ...  # undocumented\ndef _override_all_archs(_config_vars: dict[str, str]) -> dict[str, str]: ...  # undocumented\ndef _check_for_unavailable_sdk(_config_vars: dict[str, str]) -> dict[str, str]: ...  # undocumented\ndef compiler_fixup(compiler_so: Iterable[str], cc_args: Sequence[str]) -> list[str]: ...\ndef customize_config_vars(_config_vars: dict[str, str]) -> dict[str, str]: ...\ndef customize_compiler(_config_vars: dict[str, str]) -> dict[str, str]: ...\ndef get_platform_osx(\n    _config_vars: dict[str, str], osname: _T, release: _K, machine: _V\n) -> tuple[str | _T, str | _K, str | _V]: ...\n",
  "/typeshed/stdlib/_posixsubprocess.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Callable, Sequence\nfrom typing_extensions import SupportsIndex\n\nif sys.platform != \"win32\":\n    def cloexec_pipe() -> tuple[int, int]: ...\n    def fork_exec(\n        __process_args: Sequence[StrOrBytesPath] | None,\n        __executable_list: Sequence[bytes],\n        __close_fds: bool,\n        __fds_to_keep: tuple[int, ...],\n        __cwd_obj: str,\n        __env_list: Sequence[bytes] | None,\n        __p2cread: int,\n        __p2cwrite: int,\n        __c2pred: int,\n        __c2pwrite: int,\n        __errread: int,\n        __errwrite: int,\n        __errpipe_read: int,\n        __errpipe_write: int,\n        __restore_signals: int,\n        __call_setsid: int,\n        __pgid_to_set: int,\n        __gid_object: SupportsIndex | None,\n        __groups_list: list[int] | None,\n        __uid_object: SupportsIndex | None,\n        __child_umask: int,\n        __preexec_fn: Callable[[], None],\n        __allow_vfork: bool,\n    ) -> int: ...\n",
  "/typeshed/stdlib/_py_abc.pyi": "import _typeshed\nfrom typing import Any, NewType, TypeVar\n\n_T = TypeVar(\"_T\")\n\n_CacheToken = NewType(\"_CacheToken\", int)\n\ndef get_cache_token() -> _CacheToken: ...\n\nclass ABCMeta(type):\n    def __new__(\n        __mcls: type[_typeshed.Self], __name: str, __bases: tuple[type[Any], ...], __namespace: dict[str, Any]\n    ) -> _typeshed.Self: ...\n    def register(cls, subclass: type[_T]) -> type[_T]: ...\n",
  "/typeshed/stdlib/_pydecimal.pyi": "# This is a slight lie, the implementations aren't exactly identical\n# However, in all likelihood, the differences are inconsequential\nfrom _decimal import *\n\n__all__ = [\n    \"Decimal\",\n    \"Context\",\n    \"DecimalTuple\",\n    \"DefaultContext\",\n    \"BasicContext\",\n    \"ExtendedContext\",\n    \"DecimalException\",\n    \"Clamped\",\n    \"InvalidOperation\",\n    \"DivisionByZero\",\n    \"Inexact\",\n    \"Rounded\",\n    \"Subnormal\",\n    \"Overflow\",\n    \"Underflow\",\n    \"FloatOperation\",\n    \"DivisionImpossible\",\n    \"InvalidContext\",\n    \"ConversionSyntax\",\n    \"DivisionUndefined\",\n    \"ROUND_DOWN\",\n    \"ROUND_HALF_UP\",\n    \"ROUND_HALF_EVEN\",\n    \"ROUND_CEILING\",\n    \"ROUND_FLOOR\",\n    \"ROUND_UP\",\n    \"ROUND_HALF_DOWN\",\n    \"ROUND_05UP\",\n    \"setcontext\",\n    \"getcontext\",\n    \"localcontext\",\n    \"MAX_PREC\",\n    \"MAX_EMAX\",\n    \"MIN_EMIN\",\n    \"MIN_ETINY\",\n    \"HAVE_THREADS\",\n    \"HAVE_CONTEXTVAR\",\n]\n",
  "/typeshed/stdlib/_random.pyi": "from typing_extensions import TypeAlias\n\n# Actually Tuple[(int,) * 625]\n_State: TypeAlias = tuple[int, ...]\n\nclass Random:\n    def __init__(self, seed: object = ...) -> None: ...\n    def seed(self, __n: object = None) -> None: ...\n    def getstate(self) -> _State: ...\n    def setstate(self, __state: _State) -> None: ...\n    def random(self) -> float: ...\n    def getrandbits(self, __k: int) -> int: ...\n",
  "/typeshed/stdlib/_sitebuiltins.pyi": "from collections.abc import Iterable\nfrom typing import ClassVar, NoReturn\nfrom typing_extensions import Literal\n\nclass Quitter:\n    name: str\n    eof: str\n    def __init__(self, name: str, eof: str) -> None: ...\n    def __call__(self, code: int | None = None) -> NoReturn: ...\n\nclass _Printer:\n    MAXLINES: ClassVar[Literal[23]]\n    def __init__(self, name: str, data: str, files: Iterable[str] = (), dirs: Iterable[str] = ()) -> None: ...\n    def __call__(self) -> None: ...\n\nclass _Helper:\n    def __call__(self, request: object) -> None: ...\n",
  "/typeshed/stdlib/_socket.pyi": "import sys\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom collections.abc import Iterable\nfrom typing import Any, SupportsInt, overload\nfrom typing_extensions import TypeAlias\n\nif sys.version_info >= (3, 8):\n    from typing import SupportsIndex\n\n    _FD: TypeAlias = SupportsIndex\nelse:\n    _FD: TypeAlias = SupportsInt\n\n_CMSG: TypeAlias = tuple[int, int, bytes]\n_CMSGArg: TypeAlias = tuple[int, int, ReadableBuffer]\n\n# Addresses can be either tuples of varying lengths (AF_INET, AF_INET6,\n# AF_NETLINK, AF_TIPC) or strings/buffers (AF_UNIX).\n# See getsockaddrarg() in socketmodule.c.\n_Address: TypeAlias = tuple[Any, ...] | str | ReadableBuffer\n_RetAddress: TypeAlias = Any\n\n# ----- Constants -----\n# Some socket families are listed in the \"Socket families\" section of the docs,\n# but not the \"Constants\" section. These are listed at the end of the list of\n# constants.\n#\n# Besides those and the first few constants listed, the constants are listed in\n# documentation order.\n\nhas_ipv6: bool\n\nAF_INET: int\nAF_INET6: int\n\nSOCK_STREAM: int\nSOCK_DGRAM: int\nSOCK_RAW: int\nSOCK_RDM: int\nSOCK_SEQPACKET: int\n\nif sys.platform == \"linux\":\n    SOCK_CLOEXEC: int\n    SOCK_NONBLOCK: int\n\n# Address families not mentioned in the docs\nAF_APPLETALK: int\nAF_DECnet: int\nAF_IPX: int\nAF_SNA: int\nAF_UNSPEC: int\n\nif sys.platform != \"win32\":\n    AF_ROUTE: int\n    AF_SYSTEM: int\n    AF_UNIX: int\n\nif sys.platform != \"darwin\":\n    AF_IRDA: int\n\nif sys.platform != \"darwin\" and sys.platform != \"win32\":\n    AF_AAL5: int\n    AF_ASH: int\n    AF_ATMPVC: int\n    AF_ATMSVC: int\n    AF_AX25: int\n    AF_BRIDGE: int\n    AF_ECONET: int\n    AF_KEY: int\n    AF_LLC: int\n    AF_NETBEUI: int\n    AF_NETROM: int\n    AF_PPPOX: int\n    AF_ROSE: int\n    AF_SECURITY: int\n    AF_WANPIPE: int\n    AF_X25: int\n\n# The \"many constants\" referenced by the docs\nSOMAXCONN: int\nAI_ADDRCONFIG: int\nAI_ALL: int\nAI_CANONNAME: int\nAI_NUMERICHOST: int\nAI_NUMERICSERV: int\nAI_PASSIVE: int\nAI_V4MAPPED: int\nEAI_AGAIN: int\nEAI_BADFLAGS: int\nEAI_FAIL: int\nEAI_FAMILY: int\nEAI_MEMORY: int\nEAI_NODATA: int\nEAI_NONAME: int\nEAI_SERVICE: int\nEAI_SOCKTYPE: int\nINADDR_ALLHOSTS_GROUP: int\nINADDR_ANY: int\nINADDR_BROADCAST: int\nINADDR_LOOPBACK: int\nINADDR_MAX_LOCAL_GROUP: int\nINADDR_NONE: int\nINADDR_UNSPEC_GROUP: int\nIPPORT_RESERVED: int\nIPPORT_USERRESERVED: int\n\nif sys.platform != \"win32\" or sys.version_info >= (3, 8):\n    IPPROTO_AH: int\n    IPPROTO_DSTOPTS: int\n    IPPROTO_EGP: int\n    IPPROTO_ESP: int\n    IPPROTO_FRAGMENT: int\n    IPPROTO_GGP: int\n    IPPROTO_HOPOPTS: int\n    IPPROTO_ICMPV6: int\n    IPPROTO_IDP: int\n    IPPROTO_IGMP: int\n    IPPROTO_IPV4: int\n    IPPROTO_IPV6: int\n    IPPROTO_MAX: int\n    IPPROTO_ND: int\n    IPPROTO_NONE: int\n    IPPROTO_PIM: int\n    IPPROTO_PUP: int\n    IPPROTO_ROUTING: int\n    IPPROTO_SCTP: int\n\n    if sys.platform != \"darwin\":\n        IPPROTO_CBT: int\n        IPPROTO_ICLFXBM: int\n        IPPROTO_IGP: int\n        IPPROTO_L2TP: int\n        IPPROTO_PGM: int\n        IPPROTO_RDP: int\n        IPPROTO_ST: int\n\nIPPROTO_ICMP: int\nIPPROTO_IP: int\nIPPROTO_RAW: int\nIPPROTO_TCP: int\nIPPROTO_UDP: int\nIPV6_CHECKSUM: int\nIPV6_JOIN_GROUP: int\nIPV6_LEAVE_GROUP: int\nIPV6_MULTICAST_HOPS: int\nIPV6_MULTICAST_IF: int\nIPV6_MULTICAST_LOOP: int\nIPV6_RECVTCLASS: int\nIPV6_TCLASS: int\nIPV6_UNICAST_HOPS: int\nIPV6_V6ONLY: int\n\nif sys.platform != \"darwin\" or sys.version_info >= (3, 9):\n    IPV6_DONTFRAG: int\n    IPV6_HOPLIMIT: int\n    IPV6_HOPOPTS: int\n    IPV6_PKTINFO: int\n    IPV6_RECVRTHDR: int\n    IPV6_RTHDR: int\n\nIP_ADD_MEMBERSHIP: int\nIP_DROP_MEMBERSHIP: int\nIP_HDRINCL: int\nIP_MULTICAST_IF: int\nIP_MULTICAST_LOOP: int\nIP_MULTICAST_TTL: int\nIP_OPTIONS: int\nIP_RECVDSTADDR: int\nif sys.version_info >= (3, 10):\n    IP_RECVTOS: int\nelif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    IP_RECVTOS: int\nIP_TOS: int\nIP_TTL: int\nMSG_CTRUNC: int\nMSG_DONTROUTE: int\n\nif sys.platform != \"darwin\":\n    MSG_ERRQUEUE: int\n\nMSG_OOB: int\nMSG_PEEK: int\nMSG_TRUNC: int\nMSG_WAITALL: int\nNI_DGRAM: int\nNI_MAXHOST: int\nNI_MAXSERV: int\nNI_NAMEREQD: int\nNI_NOFQDN: int\nNI_NUMERICHOST: int\nNI_NUMERICSERV: int\nSHUT_RD: int\nSHUT_RDWR: int\nSHUT_WR: int\nSOL_IP: int\nSOL_SOCKET: int\nSOL_TCP: int\nSOL_UDP: int\nSO_ACCEPTCONN: int\nSO_BROADCAST: int\nSO_DEBUG: int\nSO_DONTROUTE: int\nSO_ERROR: int\nSO_KEEPALIVE: int\nSO_LINGER: int\nSO_OOBINLINE: int\nSO_RCVBUF: int\nSO_RCVLOWAT: int\nSO_RCVTIMEO: int\nSO_REUSEADDR: int\nSO_SNDBUF: int\nSO_SNDLOWAT: int\nSO_SNDTIMEO: int\nSO_TYPE: int\nSO_USELOOPBACK: int\nif sys.platform == \"linux\" and sys.version_info >= (3, 11):\n    SO_INCOMING_CPU: int\nTCP_FASTOPEN: int\nTCP_KEEPCNT: int\nTCP_KEEPINTVL: int\n\nif sys.platform != \"darwin\":\n    TCP_KEEPIDLE: int\n\nTCP_MAXSEG: int\nTCP_NODELAY: int\nif sys.platform != \"win32\":\n    TCP_NOTSENT_LOWAT: int\nif sys.version_info >= (3, 10) and sys.platform == \"darwin\":\n    TCP_KEEPALIVE: int\nif sys.version_info >= (3, 11) and sys.platform == \"darwin\":\n    TCP_CONNECTION_INFO: int\n\nif sys.platform != \"darwin\":\n    MSG_BCAST: int\n    MSG_MCAST: int\n    SO_EXCLUSIVEADDRUSE: int\n\nif sys.platform != \"win32\":\n    AI_DEFAULT: int\n    AI_MASK: int\n    AI_V4MAPPED_CFG: int\n    EAI_ADDRFAMILY: int\n    EAI_BADHINTS: int\n    EAI_MAX: int\n    EAI_OVERFLOW: int\n    EAI_PROTOCOL: int\n    EAI_SYSTEM: int\n    IPPROTO_EON: int\n    IPPROTO_GRE: int\n    IPPROTO_HELLO: int\n    IPPROTO_IPCOMP: int\n    IPPROTO_IPIP: int\n    IPPROTO_RSVP: int\n    IPPROTO_TP: int\n    IPPROTO_XTP: int\n    IPV6_RTHDR_TYPE_0: int\n    IP_DEFAULT_MULTICAST_LOOP: int\n    IP_DEFAULT_MULTICAST_TTL: int\n    IP_MAX_MEMBERSHIPS: int\n    IP_RECVOPTS: int\n    IP_RECVRETOPTS: int\n    IP_RETOPTS: int\n    LOCAL_PEERCRED: int\n    MSG_DONTWAIT: int\n    MSG_EOF: int\n    MSG_EOR: int\n    MSG_NOSIGNAL: int  # Sometimes this exists on darwin, sometimes not\n    SCM_CREDS: int\n    SCM_RIGHTS: int\n    SO_REUSEPORT: int\n\nif sys.platform != \"win32\":\n    if sys.platform != \"darwin\" or sys.version_info >= (3, 9):\n        IPV6_DSTOPTS: int\n        IPV6_NEXTHOP: int\n        IPV6_PATHMTU: int\n        IPV6_RECVDSTOPTS: int\n        IPV6_RECVHOPLIMIT: int\n        IPV6_RECVHOPOPTS: int\n        IPV6_RECVPATHMTU: int\n        IPV6_RECVPKTINFO: int\n        IPV6_RTHDRDSTOPTS: int\n        IPV6_USE_MIN_MTU: int\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    IPPROTO_BIP: int\n    IPPROTO_MOBILE: int\n    IPPROTO_VRRP: int\n    IPX_TYPE: int\n    IP_TRANSPARENT: int\n    MSG_BTAG: int\n    MSG_CMSG_CLOEXEC: int\n    MSG_CONFIRM: int\n    MSG_ETAG: int\n    MSG_FASTOPEN: int\n    MSG_MORE: int\n    MSG_NOTIFICATION: int\n    SCM_CREDENTIALS: int\n    SOL_ATALK: int\n    SOL_AX25: int\n    SOL_HCI: int\n    SOL_IPX: int\n    SOL_NETROM: int\n    SOL_ROSE: int\n    SO_BINDTODEVICE: int\n    SO_MARK: int\n    SO_PASSCRED: int\n    SO_PEERCRED: int\n    SO_PRIORITY: int\n    SO_SETFIB: int\n    TCP_CORK: int\n    TCP_DEFER_ACCEPT: int\n    TCP_INFO: int\n    TCP_LINGER2: int\n    TCP_QUICKACK: int\n    TCP_SYNCNT: int\n    TCP_WINDOW_CLAMP: int\n\n# Specifically-documented constants\n\nif sys.platform == \"linux\":\n    AF_CAN: int\n    PF_CAN: int\n    SOL_CAN_BASE: int\n    SOL_CAN_RAW: int\n    CAN_EFF_FLAG: int\n    CAN_EFF_MASK: int\n    CAN_ERR_FLAG: int\n    CAN_ERR_MASK: int\n    CAN_RAW: int\n    CAN_RAW_ERR_FILTER: int\n    CAN_RAW_FILTER: int\n    CAN_RAW_LOOPBACK: int\n    CAN_RAW_RECV_OWN_MSGS: int\n    CAN_RTR_FLAG: int\n    CAN_SFF_MASK: int\n\n    CAN_BCM: int\n    CAN_BCM_TX_SETUP: int\n    CAN_BCM_TX_DELETE: int\n    CAN_BCM_TX_READ: int\n    CAN_BCM_TX_SEND: int\n    CAN_BCM_RX_SETUP: int\n    CAN_BCM_RX_DELETE: int\n    CAN_BCM_RX_READ: int\n    CAN_BCM_TX_STATUS: int\n    CAN_BCM_TX_EXPIRED: int\n    CAN_BCM_RX_STATUS: int\n    CAN_BCM_RX_TIMEOUT: int\n    CAN_BCM_RX_CHANGED: int\n\n    CAN_RAW_FD_FRAMES: int\n\nif sys.platform == \"linux\" and sys.version_info >= (3, 8):\n    CAN_BCM_SETTIMER: int\n    CAN_BCM_STARTTIMER: int\n    CAN_BCM_TX_COUNTEVT: int\n    CAN_BCM_TX_ANNOUNCE: int\n    CAN_BCM_TX_CP_CAN_ID: int\n    CAN_BCM_RX_FILTER_ID: int\n    CAN_BCM_RX_CHECK_DLC: int\n    CAN_BCM_RX_NO_AUTOTIMER: int\n    CAN_BCM_RX_ANNOUNCE_RESUME: int\n    CAN_BCM_TX_RESET_MULTI_IDX: int\n    CAN_BCM_RX_RTR_FRAME: int\n    CAN_BCM_CAN_FD_FRAME: int\n\nif sys.platform == \"linux\":\n    CAN_ISOTP: int\n\nif sys.platform == \"linux\" and sys.version_info >= (3, 9):\n    CAN_J1939: int\n    CAN_RAW_JOIN_FILTERS: int\n\n    J1939_MAX_UNICAST_ADDR: int\n    J1939_IDLE_ADDR: int\n    J1939_NO_ADDR: int\n    J1939_NO_NAME: int\n    J1939_PGN_REQUEST: int\n    J1939_PGN_ADDRESS_CLAIMED: int\n    J1939_PGN_ADDRESS_COMMANDED: int\n    J1939_PGN_PDU1_MAX: int\n    J1939_PGN_MAX: int\n    J1939_NO_PGN: int\n\n    SO_J1939_FILTER: int\n    SO_J1939_PROMISC: int\n    SO_J1939_SEND_PRIO: int\n    SO_J1939_ERRQUEUE: int\n\n    SCM_J1939_DEST_ADDR: int\n    SCM_J1939_DEST_NAME: int\n    SCM_J1939_PRIO: int\n    SCM_J1939_ERRQUEUE: int\n\n    J1939_NLA_PAD: int\n    J1939_NLA_BYTES_ACKED: int\n\n    J1939_EE_INFO_NONE: int\n    J1939_EE_INFO_TX_ABORT: int\n\n    J1939_FILTER_MAX: int\n\nif sys.platform == \"linux\" and sys.version_info >= (3, 10):\n    IPPROTO_MPTCP: int\n\nif sys.platform == \"linux\":\n    AF_PACKET: int\n    PF_PACKET: int\n    PACKET_BROADCAST: int\n    PACKET_FASTROUTE: int\n    PACKET_HOST: int\n    PACKET_LOOPBACK: int\n    PACKET_MULTICAST: int\n    PACKET_OTHERHOST: int\n    PACKET_OUTGOING: int\n\nif sys.platform == \"linux\":\n    AF_RDS: int\n    PF_RDS: int\n    SOL_RDS: int\n    RDS_CANCEL_SENT_TO: int\n    RDS_CMSG_RDMA_ARGS: int\n    RDS_CMSG_RDMA_DEST: int\n    RDS_CMSG_RDMA_MAP: int\n    RDS_CMSG_RDMA_STATUS: int\n    RDS_CMSG_RDMA_UPDATE: int\n    RDS_CONG_MONITOR: int\n    RDS_FREE_MR: int\n    RDS_GET_MR: int\n    RDS_GET_MR_FOR_DEST: int\n    RDS_RDMA_DONTWAIT: int\n    RDS_RDMA_FENCE: int\n    RDS_RDMA_INVALIDATE: int\n    RDS_RDMA_NOTIFY_ME: int\n    RDS_RDMA_READWRITE: int\n    RDS_RDMA_SILENT: int\n    RDS_RDMA_USE_ONCE: int\n    RDS_RECVERR: int\n\nif sys.platform == \"win32\":\n    SIO_RCVALL: int\n    SIO_KEEPALIVE_VALS: int\n    SIO_LOOPBACK_FAST_PATH: int\n    RCVALL_MAX: int\n    RCVALL_OFF: int\n    RCVALL_ON: int\n    RCVALL_SOCKETLEVELONLY: int\n\nif sys.platform == \"linux\":\n    AF_TIPC: int\n    SOL_TIPC: int\n    TIPC_ADDR_ID: int\n    TIPC_ADDR_NAME: int\n    TIPC_ADDR_NAMESEQ: int\n    TIPC_CFG_SRV: int\n    TIPC_CLUSTER_SCOPE: int\n    TIPC_CONN_TIMEOUT: int\n    TIPC_CRITICAL_IMPORTANCE: int\n    TIPC_DEST_DROPPABLE: int\n    TIPC_HIGH_IMPORTANCE: int\n    TIPC_IMPORTANCE: int\n    TIPC_LOW_IMPORTANCE: int\n    TIPC_MEDIUM_IMPORTANCE: int\n    TIPC_NODE_SCOPE: int\n    TIPC_PUBLISHED: int\n    TIPC_SRC_DROPPABLE: int\n    TIPC_SUBSCR_TIMEOUT: int\n    TIPC_SUB_CANCEL: int\n    TIPC_SUB_PORTS: int\n    TIPC_SUB_SERVICE: int\n    TIPC_TOP_SRV: int\n    TIPC_WAIT_FOREVER: int\n    TIPC_WITHDRAWN: int\n    TIPC_ZONE_SCOPE: int\n\nif sys.platform == \"linux\":\n    AF_ALG: int\n    SOL_ALG: int\n    ALG_OP_DECRYPT: int\n    ALG_OP_ENCRYPT: int\n    ALG_OP_SIGN: int\n    ALG_OP_VERIFY: int\n    ALG_SET_AEAD_ASSOCLEN: int\n    ALG_SET_AEAD_AUTHSIZE: int\n    ALG_SET_IV: int\n    ALG_SET_KEY: int\n    ALG_SET_OP: int\n    ALG_SET_PUBKEY: int\n\nif sys.platform == \"linux\":\n    AF_VSOCK: int\n    IOCTL_VM_SOCKETS_GET_LOCAL_CID: int\n    VMADDR_CID_ANY: int\n    VMADDR_CID_HOST: int\n    VMADDR_PORT_ANY: int\n    SO_VM_SOCKETS_BUFFER_MAX_SIZE: int\n    SO_VM_SOCKETS_BUFFER_SIZE: int\n    SO_VM_SOCKETS_BUFFER_MIN_SIZE: int\n    VM_SOCKETS_INVALID_VERSION: int\n\nif sys.platform != \"win32\" or sys.version_info >= (3, 9):\n    AF_LINK: int\n\n# BDADDR_* and HCI_* listed with other bluetooth constants below\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    SO_DOMAIN: int\n    SO_PASSSEC: int\n    SO_PEERSEC: int\n    SO_PROTOCOL: int\n    TCP_CONGESTION: int\n    TCP_USER_TIMEOUT: int\n\nif sys.platform == \"linux\" and sys.version_info >= (3, 8):\n    AF_QIPCRTR: int\n\n# Semi-documented constants\n# (Listed under \"Socket families\" in the docs, but not \"Constants\")\n\nif sys.platform == \"linux\":\n    # Netlink is defined by Linux\n    AF_NETLINK: int\n    NETLINK_ARPD: int\n    NETLINK_CRYPTO: int\n    NETLINK_DNRTMSG: int\n    NETLINK_FIREWALL: int\n    NETLINK_IP6_FW: int\n    NETLINK_NFLOG: int\n    NETLINK_ROUTE6: int\n    NETLINK_ROUTE: int\n    NETLINK_SKIP: int\n    NETLINK_TAPBASE: int\n    NETLINK_TCPDIAG: int\n    NETLINK_USERSOCK: int\n    NETLINK_W1: int\n    NETLINK_XFRM: int\n\nif sys.platform != \"darwin\":\n    if sys.platform != \"win32\" or sys.version_info >= (3, 9):\n        AF_BLUETOOTH: int\n        BDADDR_ANY: str\n        BDADDR_LOCAL: str\n        BTPROTO_RFCOMM: int\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    # Linux and some BSD support is explicit in the docs\n    # Windows and macOS do not support in practice\n    BTPROTO_HCI: int\n    BTPROTO_L2CAP: int\n    BTPROTO_SCO: int  # not in FreeBSD\n    HCI_FILTER: int  # not in NetBSD or DragonFlyBSD\n    # not in FreeBSD, NetBSD, or DragonFlyBSD\n    HCI_TIME_STAMP: int\n    HCI_DATA_DIR: int\n\nif sys.platform == \"darwin\":\n    # PF_SYSTEM is defined by macOS\n    PF_SYSTEM: int\n    SYSPROTO_CONTROL: int\n\n# ----- Exceptions -----\n\nerror = OSError\n\nclass herror(error): ...\nclass gaierror(error): ...\n\nif sys.version_info >= (3, 10):\n    timeout = TimeoutError\nelse:\n    class timeout(error): ...\n\n# ----- Classes -----\n\nclass socket:\n    @property\n    def family(self) -> int: ...\n    @property\n    def type(self) -> int: ...\n    @property\n    def proto(self) -> int: ...\n    @property\n    def timeout(self) -> float | None: ...\n    if sys.platform == \"win32\":\n        def __init__(self, family: int = ..., type: int = ..., proto: int = ..., fileno: _FD | bytes | None = ...) -> None: ...\n    else:\n        def __init__(self, family: int = ..., type: int = ..., proto: int = ..., fileno: _FD | None = ...) -> None: ...\n\n    def bind(self, __address: _Address) -> None: ...\n    def close(self) -> None: ...\n    def connect(self, __address: _Address) -> None: ...\n    def connect_ex(self, __address: _Address) -> int: ...\n    def detach(self) -> int: ...\n    def fileno(self) -> int: ...\n    def getpeername(self) -> _RetAddress: ...\n    def getsockname(self) -> _RetAddress: ...\n    @overload\n    def getsockopt(self, __level: int, __optname: int) -> int: ...\n    @overload\n    def getsockopt(self, __level: int, __optname: int, __buflen: int) -> bytes: ...\n    def getblocking(self) -> bool: ...\n    def gettimeout(self) -> float | None: ...\n    if sys.platform == \"win32\":\n        def ioctl(self, __control: int, __option: int | tuple[int, int, int] | bool) -> None: ...\n\n    def listen(self, __backlog: int = ...) -> None: ...\n    def recv(self, __bufsize: int, __flags: int = ...) -> bytes: ...\n    def recvfrom(self, __bufsize: int, __flags: int = ...) -> tuple[bytes, _RetAddress]: ...\n    if sys.platform != \"win32\":\n        def recvmsg(self, __bufsize: int, __ancbufsize: int = ..., __flags: int = ...) -> tuple[bytes, list[_CMSG], int, Any]: ...\n        def recvmsg_into(\n            self, __buffers: Iterable[WriteableBuffer], __ancbufsize: int = ..., __flags: int = ...\n        ) -> tuple[int, list[_CMSG], int, Any]: ...\n\n    def recvfrom_into(self, buffer: WriteableBuffer, nbytes: int = ..., flags: int = ...) -> tuple[int, _RetAddress]: ...\n    def recv_into(self, buffer: WriteableBuffer, nbytes: int = ..., flags: int = ...) -> int: ...\n    def send(self, __data: ReadableBuffer, __flags: int = ...) -> int: ...\n    def sendall(self, __data: ReadableBuffer, __flags: int = ...) -> None: ...\n    @overload\n    def sendto(self, __data: ReadableBuffer, __address: _Address) -> int: ...\n    @overload\n    def sendto(self, __data: ReadableBuffer, __flags: int, __address: _Address) -> int: ...\n    if sys.platform != \"win32\":\n        def sendmsg(\n            self,\n            __buffers: Iterable[ReadableBuffer],\n            __ancdata: Iterable[_CMSGArg] = ...,\n            __flags: int = ...,\n            __address: _Address | None = ...,\n        ) -> int: ...\n    if sys.platform == \"linux\":\n        def sendmsg_afalg(\n            self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...\n        ) -> int: ...\n\n    def setblocking(self, __flag: bool) -> None: ...\n    def settimeout(self, __value: float | None) -> None: ...\n    @overload\n    def setsockopt(self, __level: int, __optname: int, __value: int | ReadableBuffer) -> None: ...\n    @overload\n    def setsockopt(self, __level: int, __optname: int, __value: None, __optlen: int) -> None: ...\n    if sys.platform == \"win32\":\n        def share(self, __process_id: int) -> bytes: ...\n\n    def shutdown(self, __how: int) -> None: ...\n\nSocketType = socket\n\n# ----- Functions -----\n\ndef close(__fd: _FD) -> None: ...\ndef dup(__fd: _FD) -> int: ...\n\n# the 5th tuple item is an address\ndef getaddrinfo(\n    host: bytes | str | None,\n    port: bytes | str | int | None,\n    family: int = ...,\n    type: int = ...,\n    proto: int = ...,\n    flags: int = ...,\n) -> list[tuple[int, int, int, str, tuple[str, int] | tuple[str, int, int, int]]]: ...\ndef gethostbyname(__hostname: str) -> str: ...\ndef gethostbyname_ex(__hostname: str) -> tuple[str, list[str], list[str]]: ...\ndef gethostname() -> str: ...\ndef gethostbyaddr(__ip_address: str) -> tuple[str, list[str], list[str]]: ...\ndef getnameinfo(__sockaddr: tuple[str, int] | tuple[str, int, int, int], __flags: int) -> tuple[str, str]: ...\ndef getprotobyname(__protocolname: str) -> int: ...\ndef getservbyname(__servicename: str, __protocolname: str = ...) -> int: ...\ndef getservbyport(__port: int, __protocolname: str = ...) -> str: ...\ndef ntohl(__x: int) -> int: ...  # param & ret val are 32-bit ints\ndef ntohs(__x: int) -> int: ...  # param & ret val are 16-bit ints\ndef htonl(__x: int) -> int: ...  # param & ret val are 32-bit ints\ndef htons(__x: int) -> int: ...  # param & ret val are 16-bit ints\ndef inet_aton(__ip_string: str) -> bytes: ...  # ret val 4 bytes in length\ndef inet_ntoa(__packed_ip: ReadableBuffer) -> str: ...\ndef inet_pton(__address_family: int, __ip_string: str) -> bytes: ...\ndef inet_ntop(__address_family: int, __packed_ip: ReadableBuffer) -> str: ...\ndef getdefaulttimeout() -> float | None: ...\ndef setdefaulttimeout(__timeout: float | None) -> None: ...\n\nif sys.platform != \"win32\":\n    def sethostname(__name: str) -> None: ...\n    def CMSG_LEN(__length: int) -> int: ...\n    def CMSG_SPACE(__length: int) -> int: ...\n    def socketpair(__family: int = ..., __type: int = ..., __proto: int = ...) -> tuple[socket, socket]: ...\n\n# Windows added these in 3.8, but didn't have them before\nif sys.platform != \"win32\" or sys.version_info >= (3, 8):\n    def if_nameindex() -> list[tuple[int, str]]: ...\n    def if_nametoindex(__name: str) -> int: ...\n    def if_indextoname(__index: int) -> str: ...\n",
  "/typeshed/stdlib/_stat.pyi": "import sys\nfrom typing_extensions import Literal\n\nSF_APPEND: Literal[0x00040000]\nSF_ARCHIVED: Literal[0x00010000]\nSF_IMMUTABLE: Literal[0x00020000]\nSF_NOUNLINK: Literal[0x00100000]\nSF_SNAPSHOT: Literal[0x00200000]\n\nST_MODE: Literal[0]\nST_INO: Literal[1]\nST_DEV: Literal[2]\nST_NLINK: Literal[3]\nST_UID: Literal[4]\nST_GID: Literal[5]\nST_SIZE: Literal[6]\nST_ATIME: Literal[7]\nST_MTIME: Literal[8]\nST_CTIME: Literal[9]\n\nS_IFIFO: Literal[0o010000]\nS_IFLNK: Literal[0o120000]\nS_IFREG: Literal[0o100000]\nS_IFSOCK: Literal[0o140000]\nS_IFBLK: Literal[0o060000]\nS_IFCHR: Literal[0o020000]\nS_IFDIR: Literal[0o040000]\n\n# These are 0 on systems that don't support the specific kind of file.\n# Example: Linux doesn't support door files, so S_IFDOOR is 0 on linux.\nS_IFDOOR: int\nS_IFPORT: int\nS_IFWHT: int\n\nS_ISUID: Literal[0o4000]\nS_ISGID: Literal[0o2000]\nS_ISVTX: Literal[0o1000]\n\nS_IRWXU: Literal[0o0700]\nS_IRUSR: Literal[0o0400]\nS_IWUSR: Literal[0o0200]\nS_IXUSR: Literal[0o0100]\n\nS_IRWXG: Literal[0o0070]\nS_IRGRP: Literal[0o0040]\nS_IWGRP: Literal[0o0020]\nS_IXGRP: Literal[0o0010]\n\nS_IRWXO: Literal[0o0007]\nS_IROTH: Literal[0o0004]\nS_IWOTH: Literal[0o0002]\nS_IXOTH: Literal[0o0001]\n\nS_ENFMT: Literal[0o2000]\nS_IREAD: Literal[0o0400]\nS_IWRITE: Literal[0o0200]\nS_IEXEC: Literal[0o0100]\n\nUF_APPEND: Literal[0x00000004]\nUF_COMPRESSED: Literal[0x00000020]  # OS X 10.6+ only\nUF_HIDDEN: Literal[0x00008000]  # OX X 10.5+ only\nUF_IMMUTABLE: Literal[0x00000002]\nUF_NODUMP: Literal[0x00000001]\nUF_NOUNLINK: Literal[0x00000010]\nUF_OPAQUE: Literal[0x00000008]\n\ndef S_IMODE(mode: int) -> int: ...\ndef S_IFMT(mode: int) -> int: ...\ndef S_ISBLK(mode: int) -> bool: ...\ndef S_ISCHR(mode: int) -> bool: ...\ndef S_ISDIR(mode: int) -> bool: ...\ndef S_ISDOOR(mode: int) -> bool: ...\ndef S_ISFIFO(mode: int) -> bool: ...\ndef S_ISLNK(mode: int) -> bool: ...\ndef S_ISPORT(mode: int) -> bool: ...\ndef S_ISREG(mode: int) -> bool: ...\ndef S_ISSOCK(mode: int) -> bool: ...\ndef S_ISWHT(mode: int) -> bool: ...\ndef filemode(mode: int) -> str: ...\n\nif sys.platform == \"win32\" and sys.version_info >= (3, 8):\n    IO_REPARSE_TAG_SYMLINK: int\n    IO_REPARSE_TAG_MOUNT_POINT: int\n    IO_REPARSE_TAG_APPEXECLINK: int\n\nif sys.platform == \"win32\":\n    FILE_ATTRIBUTE_ARCHIVE: Literal[32]\n    FILE_ATTRIBUTE_COMPRESSED: Literal[2048]\n    FILE_ATTRIBUTE_DEVICE: Literal[64]\n    FILE_ATTRIBUTE_DIRECTORY: Literal[16]\n    FILE_ATTRIBUTE_ENCRYPTED: Literal[16384]\n    FILE_ATTRIBUTE_HIDDEN: Literal[2]\n    FILE_ATTRIBUTE_INTEGRITY_STREAM: Literal[32768]\n    FILE_ATTRIBUTE_NORMAL: Literal[128]\n    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: Literal[8192]\n    FILE_ATTRIBUTE_NO_SCRUB_DATA: Literal[131072]\n    FILE_ATTRIBUTE_OFFLINE: Literal[4096]\n    FILE_ATTRIBUTE_READONLY: Literal[1]\n    FILE_ATTRIBUTE_REPARSE_POINT: Literal[1024]\n    FILE_ATTRIBUTE_SPARSE_FILE: Literal[512]\n    FILE_ATTRIBUTE_SYSTEM: Literal[4]\n    FILE_ATTRIBUTE_TEMPORARY: Literal[256]\n    FILE_ATTRIBUTE_VIRTUAL: Literal[65536]\n",
  "/typeshed/stdlib/_thread.pyi": "import sys\nfrom _typeshed import structseq\nfrom collections.abc import Callable\nfrom threading import Thread\nfrom types import TracebackType\nfrom typing import Any, NoReturn\nfrom typing_extensions import Final, final\n\nerror = RuntimeError\n\ndef _count() -> int: ...\n@final\nclass LockType:\n    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...\n    def release(self) -> None: ...\n    def locked(self) -> bool: ...\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n\ndef start_new_thread(function: Callable[..., object], args: tuple[Any, ...], kwargs: dict[str, Any] = ...) -> int: ...\ndef interrupt_main() -> None: ...\ndef exit() -> NoReturn: ...\ndef allocate_lock() -> LockType: ...\ndef get_ident() -> int: ...\ndef stack_size(size: int = ...) -> int: ...\n\nTIMEOUT_MAX: float\n\nif sys.version_info >= (3, 8):\n    def get_native_id() -> int: ...  # only available on some platforms\n    @final\n    class _ExceptHookArgs(structseq[Any], tuple[type[BaseException], BaseException | None, TracebackType | None, Thread | None]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\"exc_type\", \"exc_value\", \"exc_traceback\", \"thread\")\n        @property\n        def exc_type(self) -> type[BaseException]: ...\n        @property\n        def exc_value(self) -> BaseException | None: ...\n        @property\n        def exc_traceback(self) -> TracebackType | None: ...\n        @property\n        def thread(self) -> Thread | None: ...\n    _excepthook: Callable[[_ExceptHookArgs], Any]\n",
  "/typeshed/stdlib/_threading_local.pyi": "from typing import Any\nfrom typing_extensions import TypeAlias\nfrom weakref import ReferenceType\n\n__all__ = [\"local\"]\n_LocalDict: TypeAlias = dict[Any, Any]\n\nclass _localimpl:\n    key: str\n    dicts: dict[int, tuple[ReferenceType[Any], _LocalDict]]\n    def get_dict(self) -> _LocalDict: ...\n    def create_dict(self) -> _LocalDict: ...\n\nclass local:\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n",
  "/typeshed/stdlib/_tkinter.pyi": "import sys\nfrom typing import Any, ClassVar\nfrom typing_extensions import Literal, final\n\n# _tkinter is meant to be only used internally by tkinter, but some tkinter\n# functions e.g. return _tkinter.Tcl_Obj objects. Tcl_Obj represents a Tcl\n# object that hasn't been converted to a string.\n#\n# There are not many ways to get Tcl_Objs from tkinter, and I'm not sure if the\n# only existing ways are supposed to return Tcl_Objs as opposed to returning\n# strings. Here's one of these things that return Tcl_Objs:\n#\n#    >>> import tkinter\n#    >>> text = tkinter.Text()\n#    >>> text.tag_add('foo', '1.0', 'end')\n#    >>> text.tag_ranges('foo')\n#    (<textindex object: '1.0'>, <textindex object: '2.0'>)\n@final\nclass Tcl_Obj:\n    @property\n    def string(self) -> str: ...\n    @property\n    def typename(self) -> str: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __eq__(self, __value): ...\n    def __ge__(self, __value): ...\n    def __gt__(self, __value): ...\n    def __le__(self, __value): ...\n    def __lt__(self, __value): ...\n    def __ne__(self, __value): ...\n\nclass TclError(Exception): ...\n\n# This class allows running Tcl code. Tkinter uses it internally a lot, and\n# it's often handy to drop a piece of Tcl code into a tkinter program. Example:\n#\n#    >>> import tkinter, _tkinter\n#    >>> tkapp = tkinter.Tk().tk\n#    >>> isinstance(tkapp, _tkinter.TkappType)\n#    True\n#    >>> tkapp.call('set', 'foo', (1,2,3))\n#    (1, 2, 3)\n#    >>> tkapp.eval('return $foo')\n#    '1 2 3'\n#    >>>\n#\n# call args can be pretty much anything. Also, call(some_tuple) is same as call(*some_tuple).\n#\n# eval always returns str because _tkinter_tkapp_eval_impl in _tkinter.c calls\n# Tkapp_UnicodeResult, and it returns a string when it succeeds.\n@final\nclass TkappType:\n    # Please keep in sync with tkinter.Tk\n    def adderrorinfo(self, __msg): ...\n    def call(self, __command: Any, *args: Any) -> Any: ...\n    def createcommand(self, __name, __func): ...\n    if sys.platform != \"win32\":\n        def createfilehandler(self, __file, __mask, __func): ...\n        def deletefilehandler(self, __file): ...\n\n    def createtimerhandler(self, __milliseconds, __func): ...\n    def deletecommand(self, __name): ...\n    def dooneevent(self, __flags: int = 0): ...\n    def eval(self, __script: str) -> str: ...\n    def evalfile(self, __fileName): ...\n    def exprboolean(self, __s): ...\n    def exprdouble(self, __s): ...\n    def exprlong(self, __s): ...\n    def exprstring(self, __s): ...\n    def getboolean(self, __arg): ...\n    def getdouble(self, __arg): ...\n    def getint(self, __arg): ...\n    def getvar(self, *args, **kwargs): ...\n    def globalgetvar(self, *args, **kwargs): ...\n    def globalsetvar(self, *args, **kwargs): ...\n    def globalunsetvar(self, *args, **kwargs): ...\n    def interpaddr(self): ...\n    def loadtk(self) -> None: ...\n    def mainloop(self, __threshold: int = 0): ...\n    def quit(self): ...\n    def record(self, __script): ...\n    def setvar(self, *ags, **kwargs): ...\n    if sys.version_info < (3, 11):\n        def split(self, __arg): ...\n\n    def splitlist(self, __arg): ...\n    def unsetvar(self, *args, **kwargs): ...\n    def wantobjects(self, *args, **kwargs): ...\n    def willdispatch(self): ...\n\n# These should be kept in sync with tkinter.tix constants, except ALL_EVENTS which doesn't match TCL_ALL_EVENTS\nALL_EVENTS: Literal[-3]\nFILE_EVENTS: Literal[8]\nIDLE_EVENTS: Literal[32]\nTIMER_EVENTS: Literal[16]\nWINDOW_EVENTS: Literal[4]\n\nDONT_WAIT: Literal[2]\nEXCEPTION: Literal[8]\nREADABLE: Literal[2]\nWRITABLE: Literal[4]\n\nTCL_VERSION: str\nTK_VERSION: str\n\n@final\nclass TkttType:\n    def deletetimerhandler(self): ...\n\nif sys.version_info >= (3, 8):\n    def create(\n        __screenName: str | None = None,\n        __baseName: str = \"\",\n        __className: str = \"Tk\",\n        __interactive: bool = False,\n        __wantobjects: bool = False,\n        __wantTk: bool = True,\n        __sync: bool = False,\n        __use: str | None = None,\n    ): ...\n\nelse:\n    def create(\n        __screenName: str | None = None,\n        __baseName: str | None = None,\n        __className: str = \"Tk\",\n        __interactive: bool = False,\n        __wantobjects: bool = False,\n        __wantTk: bool = True,\n        __sync: bool = False,\n        __use: str | None = None,\n    ): ...\n\ndef getbusywaitinterval(): ...\ndef setbusywaitinterval(__new_val): ...\n",
  "/typeshed/stdlib/_tracemalloc.pyi": "import sys\nfrom collections.abc import Sequence\nfrom tracemalloc import _FrameTuple, _TraceTuple\n\ndef _get_object_traceback(__obj: object) -> Sequence[_FrameTuple] | None: ...\ndef _get_traces() -> Sequence[_TraceTuple]: ...\ndef clear_traces() -> None: ...\ndef get_traceback_limit() -> int: ...\ndef get_traced_memory() -> tuple[int, int]: ...\ndef get_tracemalloc_memory() -> int: ...\ndef is_tracing() -> bool: ...\n\nif sys.version_info >= (3, 9):\n    def reset_peak() -> None: ...\n\ndef start(__nframe: int = 1) -> None: ...\ndef stop() -> None: ...\n",
  "/typeshed/stdlib/_warnings.pyi": "from typing import Any, overload\n\n_defaultaction: str\n_onceregistry: dict[Any, Any]\nfilters: list[tuple[str, str | None, type[Warning], str | None, int]]\n\n@overload\ndef warn(message: str, category: type[Warning] | None = None, stacklevel: int = 1, source: Any | None = None) -> None: ...\n@overload\ndef warn(message: Warning, category: Any = None, stacklevel: int = 1, source: Any | None = None) -> None: ...\n@overload\ndef warn_explicit(\n    message: str,\n    category: type[Warning],\n    filename: str,\n    lineno: int,\n    module: str | None = ...,\n    registry: dict[str | tuple[str, type[Warning], int], int] | None = ...,\n    module_globals: dict[str, Any] | None = ...,\n    source: Any | None = ...,\n) -> None: ...\n@overload\ndef warn_explicit(\n    message: Warning,\n    category: Any,\n    filename: str,\n    lineno: int,\n    module: str | None = ...,\n    registry: dict[str | tuple[str, type[Warning], int], int] | None = ...,\n    module_globals: dict[str, Any] | None = ...,\n    source: Any | None = ...,\n) -> None: ...\n",
  "/typeshed/stdlib/_weakref.pyi": "import sys\nfrom collections.abc import Callable\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import Self, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_C = TypeVar(\"_C\", bound=Callable[..., Any])\n_T = TypeVar(\"_T\")\n\n@final\nclass CallableProxyType(Generic[_C]):  # \"weakcallableproxy\"\n    def __getattr__(self, attr: str) -> Any: ...\n    __call__: _C\n\n@final\nclass ProxyType(Generic[_T]):  # \"weakproxy\"\n    def __getattr__(self, attr: str) -> Any: ...\n\nclass ReferenceType(Generic[_T]):\n    __callback__: Callable[[ReferenceType[_T]], Any]\n    def __new__(cls, __o: _T, __callback: Callable[[ReferenceType[_T]], Any] | None = ...) -> Self: ...\n    def __call__(self) -> _T | None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nref = ReferenceType\n\ndef getweakrefcount(__object: Any) -> int: ...\ndef getweakrefs(__object: Any) -> list[Any]: ...\n\n# Return CallableProxyType if object is callable, ProxyType otherwise\n@overload\ndef proxy(__object: _C, __callback: Callable[[_C], Any] | None = None) -> CallableProxyType[_C]: ...\n@overload\ndef proxy(__object: _T, __callback: Callable[[_T], Any] | None = None) -> Any: ...\n",
  "/typeshed/stdlib/_weakrefset.pyi": "import sys\nfrom collections.abc import Iterable, Iterator, MutableSet\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import Self\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\"WeakSet\"]\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n\nclass WeakSet(MutableSet[_T], Generic[_T]):\n    @overload\n    def __init__(self, data: None = None) -> None: ...\n    @overload\n    def __init__(self, data: Iterable[_T]) -> None: ...\n    def add(self, item: _T) -> None: ...\n    def discard(self, item: _T) -> None: ...\n    def copy(self) -> Self: ...\n    def remove(self, item: _T) -> None: ...\n    def update(self, other: Iterable[_T]) -> None: ...\n    def __contains__(self, item: object) -> bool: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __ior__(self, other: Iterable[_T]) -> Self: ...  # type: ignore[override,misc]\n    def difference(self, other: Iterable[_T]) -> Self: ...\n    def __sub__(self, other: Iterable[Any]) -> Self: ...\n    def difference_update(self, other: Iterable[Any]) -> None: ...\n    def __isub__(self, other: Iterable[Any]) -> Self: ...\n    def intersection(self, other: Iterable[_T]) -> Self: ...\n    def __and__(self, other: Iterable[Any]) -> Self: ...\n    def intersection_update(self, other: Iterable[Any]) -> None: ...\n    def __iand__(self, other: Iterable[Any]) -> Self: ...\n    def issubset(self, other: Iterable[_T]) -> bool: ...\n    def __le__(self, other: Iterable[_T]) -> bool: ...\n    def __lt__(self, other: Iterable[_T]) -> bool: ...\n    def issuperset(self, other: Iterable[_T]) -> bool: ...\n    def __ge__(self, other: Iterable[_T]) -> bool: ...\n    def __gt__(self, other: Iterable[_T]) -> bool: ...\n    def __eq__(self, other: object) -> bool: ...\n    def symmetric_difference(self, other: Iterable[_S]) -> WeakSet[_S | _T]: ...\n    def __xor__(self, other: Iterable[_S]) -> WeakSet[_S | _T]: ...\n    def symmetric_difference_update(self, other: Iterable[_T]) -> None: ...\n    def __ixor__(self, other: Iterable[_T]) -> Self: ...  # type: ignore[override,misc]\n    def union(self, other: Iterable[_S]) -> WeakSet[_S | _T]: ...\n    def __or__(self, other: Iterable[_S]) -> WeakSet[_S | _T]: ...\n    def isdisjoint(self, other: Iterable[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n",
  "/typeshed/stdlib/_winapi.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Sequence\nfrom typing import Any, NoReturn, overload\nfrom typing_extensions import Literal, final\n\nif sys.platform == \"win32\":\n    ABOVE_NORMAL_PRIORITY_CLASS: Literal[0x8000]\n    BELOW_NORMAL_PRIORITY_CLASS: Literal[0x4000]\n\n    CREATE_BREAKAWAY_FROM_JOB: Literal[0x1000000]\n    CREATE_DEFAULT_ERROR_MODE: Literal[0x4000000]\n    CREATE_NO_WINDOW: Literal[0x8000000]\n    CREATE_NEW_CONSOLE: Literal[0x10]\n    CREATE_NEW_PROCESS_GROUP: Literal[0x200]\n\n    DETACHED_PROCESS: Literal[8]\n    DUPLICATE_CLOSE_SOURCE: Literal[1]\n    DUPLICATE_SAME_ACCESS: Literal[2]\n\n    ERROR_ALREADY_EXISTS: Literal[183]\n    ERROR_BROKEN_PIPE: Literal[109]\n    ERROR_IO_PENDING: Literal[997]\n    ERROR_MORE_DATA: Literal[234]\n    ERROR_NETNAME_DELETED: Literal[64]\n    ERROR_NO_DATA: Literal[232]\n    ERROR_NO_SYSTEM_RESOURCES: Literal[1450]\n    ERROR_OPERATION_ABORTED: Literal[995]\n    ERROR_PIPE_BUSY: Literal[231]\n    ERROR_PIPE_CONNECTED: Literal[535]\n    ERROR_SEM_TIMEOUT: Literal[121]\n\n    FILE_FLAG_FIRST_PIPE_INSTANCE: Literal[0x80000]\n    FILE_FLAG_OVERLAPPED: Literal[0x40000000]\n\n    FILE_GENERIC_READ: Literal[1179785]\n    FILE_GENERIC_WRITE: Literal[1179926]\n\n    if sys.version_info >= (3, 8):\n        FILE_MAP_ALL_ACCESS: Literal[983071]\n        FILE_MAP_COPY: Literal[1]\n        FILE_MAP_EXECUTE: Literal[32]\n        FILE_MAP_READ: Literal[4]\n        FILE_MAP_WRITE: Literal[2]\n\n    FILE_TYPE_CHAR: Literal[2]\n    FILE_TYPE_DISK: Literal[1]\n    FILE_TYPE_PIPE: Literal[3]\n    FILE_TYPE_REMOTE: Literal[32768]\n    FILE_TYPE_UNKNOWN: Literal[0]\n\n    GENERIC_READ: Literal[0x80000000]\n    GENERIC_WRITE: Literal[0x40000000]\n    HIGH_PRIORITY_CLASS: Literal[0x80]\n    INFINITE: Literal[0xFFFFFFFF]\n    if sys.version_info >= (3, 8):\n        # Ignore the flake8 error -- flake8-pyi assumes\n        # most numbers this long will be implementation details,\n        # but here we can see that it's a power of 2\n        INVALID_HANDLE_VALUE: Literal[0xFFFFFFFFFFFFFFFF]  # noqa: Y054\n    IDLE_PRIORITY_CLASS: Literal[0x40]\n    NORMAL_PRIORITY_CLASS: Literal[0x20]\n    REALTIME_PRIORITY_CLASS: Literal[0x100]\n    NMPWAIT_WAIT_FOREVER: Literal[0xFFFFFFFF]\n\n    if sys.version_info >= (3, 8):\n        MEM_COMMIT: Literal[0x1000]\n        MEM_FREE: Literal[0x10000]\n        MEM_IMAGE: Literal[0x1000000]\n        MEM_MAPPED: Literal[0x40000]\n        MEM_PRIVATE: Literal[0x20000]\n        MEM_RESERVE: Literal[0x2000]\n\n    NULL: Literal[0]\n    OPEN_EXISTING: Literal[3]\n\n    PIPE_ACCESS_DUPLEX: Literal[3]\n    PIPE_ACCESS_INBOUND: Literal[1]\n    PIPE_READMODE_MESSAGE: Literal[2]\n    PIPE_TYPE_MESSAGE: Literal[4]\n    PIPE_UNLIMITED_INSTANCES: Literal[255]\n    PIPE_WAIT: Literal[0]\n\n    if sys.version_info >= (3, 8):\n        PAGE_EXECUTE: Literal[0x10]\n        PAGE_EXECUTE_READ: Literal[0x20]\n        PAGE_EXECUTE_READWRITE: Literal[0x40]\n        PAGE_EXECUTE_WRITECOPY: Literal[0x80]\n        PAGE_GUARD: Literal[0x100]\n        PAGE_NOACCESS: Literal[0x1]\n        PAGE_NOCACHE: Literal[0x200]\n        PAGE_READONLY: Literal[0x2]\n        PAGE_READWRITE: Literal[0x4]\n        PAGE_WRITECOMBINE: Literal[0x400]\n        PAGE_WRITECOPY: Literal[0x8]\n\n    PROCESS_ALL_ACCESS: Literal[0x1FFFFF]\n    PROCESS_DUP_HANDLE: Literal[0x40]\n\n    if sys.version_info >= (3, 8):\n        SEC_COMMIT: Literal[0x8000000]\n        SEC_IMAGE: Literal[0x1000000]\n        SEC_LARGE_PAGES: Literal[0x80000000]\n        SEC_NOCACHE: Literal[0x10000000]\n        SEC_RESERVE: Literal[0x4000000]\n        SEC_WRITECOMBINE: Literal[0x40000000]\n\n    STARTF_USESHOWWINDOW: Literal[0x1]\n    STARTF_USESTDHANDLES: Literal[0x100]\n\n    STD_ERROR_HANDLE: Literal[0xFFFFFFF4]\n    STD_OUTPUT_HANDLE: Literal[0xFFFFFFF5]\n    STD_INPUT_HANDLE: Literal[0xFFFFFFF6]\n\n    STILL_ACTIVE: Literal[259]\n    SW_HIDE: Literal[0]\n    if sys.version_info >= (3, 8):\n        SYNCHRONIZE: Literal[0x100000]\n    WAIT_ABANDONED_0: Literal[128]\n    WAIT_OBJECT_0: Literal[0]\n    WAIT_TIMEOUT: Literal[258]\n\n    if sys.version_info >= (3, 10):\n        LOCALE_NAME_INVARIANT: str\n        LOCALE_NAME_MAX_LENGTH: int\n        LOCALE_NAME_SYSTEM_DEFAULT: str\n        LOCALE_NAME_USER_DEFAULT: str | None\n\n        LCMAP_FULLWIDTH: int\n        LCMAP_HALFWIDTH: int\n        LCMAP_HIRAGANA: int\n        LCMAP_KATAKANA: int\n        LCMAP_LINGUISTIC_CASING: int\n        LCMAP_LOWERCASE: int\n        LCMAP_SIMPLIFIED_CHINESE: int\n        LCMAP_TITLECASE: int\n        LCMAP_TRADITIONAL_CHINESE: int\n        LCMAP_UPPERCASE: int\n\n    def CloseHandle(__handle: int) -> None: ...\n    @overload\n    def ConnectNamedPipe(handle: int, overlapped: Literal[True]) -> Overlapped: ...\n    @overload\n    def ConnectNamedPipe(handle: int, overlapped: Literal[False] = False) -> None: ...\n    @overload\n    def ConnectNamedPipe(handle: int, overlapped: bool) -> Overlapped | None: ...\n    def CreateFile(\n        __file_name: str,\n        __desired_access: int,\n        __share_mode: int,\n        __security_attributes: int,\n        __creation_disposition: int,\n        __flags_and_attributes: int,\n        __template_file: int,\n    ) -> int: ...\n    def CreateJunction(__src_path: str, __dst_path: str) -> None: ...\n    def CreateNamedPipe(\n        __name: str,\n        __open_mode: int,\n        __pipe_mode: int,\n        __max_instances: int,\n        __out_buffer_size: int,\n        __in_buffer_size: int,\n        __default_timeout: int,\n        __security_attributes: int,\n    ) -> int: ...\n    def CreatePipe(__pipe_attrs: Any, __size: int) -> tuple[int, int]: ...\n    def CreateProcess(\n        __application_name: str | None,\n        __command_line: str | None,\n        __proc_attrs: Any,\n        __thread_attrs: Any,\n        __inherit_handles: bool,\n        __creation_flags: int,\n        __env_mapping: dict[str, str],\n        __current_directory: str | None,\n        __startup_info: Any,\n    ) -> tuple[int, int, int, int]: ...\n    def DuplicateHandle(\n        __source_process_handle: int,\n        __source_handle: int,\n        __target_process_handle: int,\n        __desired_access: int,\n        __inherit_handle: bool,\n        __options: int = 0,\n    ) -> int: ...\n    def ExitProcess(__ExitCode: int) -> NoReturn: ...\n    def GetACP() -> int: ...\n    def GetFileType(handle: int) -> int: ...\n    def GetCurrentProcess() -> int: ...\n    def GetExitCodeProcess(__process: int) -> int: ...\n    def GetLastError() -> int: ...\n    def GetModuleFileName(__module_handle: int) -> str: ...\n    def GetStdHandle(__std_handle: int) -> int: ...\n    def GetVersion() -> int: ...\n    def OpenProcess(__desired_access: int, __inherit_handle: bool, __process_id: int) -> int: ...\n    def PeekNamedPipe(__handle: int, __size: int = 0) -> tuple[int, int] | tuple[bytes, int, int]: ...\n    if sys.version_info >= (3, 10):\n        def LCMapStringEx(locale: str, flags: int, src: str) -> str: ...\n        def UnmapViewOfFile(__address: int) -> None: ...\n\n    @overload\n    def ReadFile(handle: int, size: int, overlapped: Literal[True]) -> tuple[Overlapped, int]: ...\n    @overload\n    def ReadFile(handle: int, size: int, overlapped: Literal[False] = False) -> tuple[bytes, int]: ...\n    @overload\n    def ReadFile(handle: int, size: int, overlapped: int | bool) -> tuple[Any, int]: ...\n    def SetNamedPipeHandleState(\n        __named_pipe: int, __mode: int | None, __max_collection_count: int | None, __collect_data_timeout: int | None\n    ) -> None: ...\n    def TerminateProcess(__handle: int, __exit_code: int) -> None: ...\n    def WaitForMultipleObjects(__handle_seq: Sequence[int], __wait_flag: bool, __milliseconds: int = 0xFFFFFFFF) -> int: ...\n    def WaitForSingleObject(__handle: int, __milliseconds: int) -> int: ...\n    def WaitNamedPipe(__name: str, __timeout: int) -> None: ...\n    @overload\n    def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: Literal[True]) -> tuple[Overlapped, int]: ...\n    @overload\n    def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: Literal[False] = False) -> tuple[int, int]: ...\n    @overload\n    def WriteFile(handle: int, buffer: ReadableBuffer, overlapped: int | bool) -> tuple[Any, int]: ...\n    @final\n    class Overlapped:\n        event: int\n        def GetOverlappedResult(self, __wait: bool) -> tuple[int, int]: ...\n        def cancel(self) -> None: ...\n        def getbuffer(self) -> bytes | None: ...\n",
  "/typeshed/stdlib/abc.pyi": "import _typeshed\nimport sys\nfrom _typeshed import SupportsWrite\nfrom collections.abc import Callable\nfrom typing import Any, TypeVar\nfrom typing_extensions import Concatenate, Literal, ParamSpec\n\n_T = TypeVar(\"_T\")\n_R_co = TypeVar(\"_R_co\", covariant=True)\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    if sys.version_info >= (3, 11):\n        def __new__(\n            __mcls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwargs: Any\n        ) -> _typeshed.Self: ...\n    else:\n        def __new__(\n            mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs: Any\n        ) -> _typeshed.Self: ...\n\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> bool: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: type) -> bool: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = None) -> None: ...\n    def register(cls: ABCMeta, subclass: type[_T]) -> type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractclassmethod(classmethod[_T, _P, _R_co]):\n    __isabstractmethod__: Literal[True]\n    def __init__(self, callable: Callable[Concatenate[_T, _P], _R_co]) -> None: ...\n\nclass abstractstaticmethod(staticmethod[_P, _R_co]):\n    __isabstractmethod__: Literal[True]\n    def __init__(self, callable: Callable[_P, _R_co]) -> None: ...\n\nclass abstractproperty(property):\n    __isabstractmethod__: Literal[True]\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n\nif sys.version_info >= (3, 10):\n    def update_abstractmethods(cls: type[_T]) -> type[_T]: ...\n",
  "/typeshed/stdlib/aifc.pyi": "import sys\nfrom types import TracebackType\nfrom typing import IO, Any, NamedTuple, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"Error\", \"open\"]\nelse:\n    __all__ = [\"Error\", \"open\", \"openfp\"]\n\nclass Error(Exception): ...\n\nclass _aifc_params(NamedTuple):\n    nchannels: int\n    sampwidth: int\n    framerate: int\n    nframes: int\n    comptype: bytes\n    compname: bytes\n\n_File: TypeAlias = str | IO[bytes]\n_Marker: TypeAlias = tuple[int, int, bytes]\n\nclass Aifc_read:\n    def __init__(self, f: _File) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def initfp(self, file: IO[bytes]) -> None: ...\n    def getfp(self) -> IO[bytes]: ...\n    def rewind(self) -> None: ...\n    def close(self) -> None: ...\n    def tell(self) -> int: ...\n    def getnchannels(self) -> int: ...\n    def getnframes(self) -> int: ...\n    def getsampwidth(self) -> int: ...\n    def getframerate(self) -> int: ...\n    def getcomptype(self) -> bytes: ...\n    def getcompname(self) -> bytes: ...\n    def getparams(self) -> _aifc_params: ...\n    def getmarkers(self) -> list[_Marker] | None: ...\n    def getmark(self, id: int) -> _Marker: ...\n    def setpos(self, pos: int) -> None: ...\n    def readframes(self, nframes: int) -> bytes: ...\n\nclass Aifc_write:\n    def __init__(self, f: _File) -> None: ...\n    def __del__(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def initfp(self, file: IO[bytes]) -> None: ...\n    def aiff(self) -> None: ...\n    def aifc(self) -> None: ...\n    def setnchannels(self, nchannels: int) -> None: ...\n    def getnchannels(self) -> int: ...\n    def setsampwidth(self, sampwidth: int) -> None: ...\n    def getsampwidth(self) -> int: ...\n    def setframerate(self, framerate: int) -> None: ...\n    def getframerate(self) -> int: ...\n    def setnframes(self, nframes: int) -> None: ...\n    def getnframes(self) -> int: ...\n    def setcomptype(self, comptype: bytes, compname: bytes) -> None: ...\n    def getcomptype(self) -> bytes: ...\n    def getcompname(self) -> bytes: ...\n    def setparams(self, params: tuple[int, int, int, int, bytes, bytes]) -> None: ...\n    def getparams(self) -> _aifc_params: ...\n    def setmark(self, id: int, pos: int, name: bytes) -> None: ...\n    def getmark(self, id: int) -> _Marker: ...\n    def getmarkers(self) -> list[_Marker] | None: ...\n    def tell(self) -> int: ...\n    def writeframesraw(self, data: Any) -> None: ...  # Actual type for data is Buffer Protocol\n    def writeframes(self, data: Any) -> None: ...\n    def close(self) -> None: ...\n\n@overload\ndef open(f: _File, mode: Literal[\"r\", \"rb\"]) -> Aifc_read: ...\n@overload\ndef open(f: _File, mode: Literal[\"w\", \"wb\"]) -> Aifc_write: ...\n@overload\ndef open(f: _File, mode: str | None = None) -> Any: ...\n\nif sys.version_info < (3, 9):\n    @overload\n    def openfp(f: _File, mode: Literal[\"r\", \"rb\"]) -> Aifc_read: ...\n    @overload\n    def openfp(f: _File, mode: Literal[\"w\", \"wb\"]) -> Aifc_write: ...\n    @overload\n    def openfp(f: _File, mode: str | None = None) -> Any: ...\n",
  "/typeshed/stdlib/antigravity.pyi": "from _typeshed import ReadableBuffer\n\ndef geohash(latitude: float, longitude: float, datedow: ReadableBuffer) -> None: ...\n",
  "/typeshed/stdlib/array.pyi": "import sys\nfrom _typeshed import ReadableBuffer, SupportsRead, SupportsWrite\nfrom collections.abc import Iterable\n\n# pytype crashes if array inherits from collections.abc.MutableSequence instead of typing.MutableSequence\nfrom typing import Any, Generic, MutableSequence, TypeVar, overload  # noqa: Y022\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias\n\n_IntTypeCode: TypeAlias = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode: TypeAlias = Literal[\"f\", \"d\"]\n_UnicodeTypeCode: TypeAlias = Literal[\"u\"]\n_TypeCode: TypeAlias = _IntTypeCode | _FloatTypeCode | _UnicodeTypeCode\n\n_T = TypeVar(\"_T\", int, float, str)\n\ntypecodes: str\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @property\n    def typecode(self) -> _TypeCode: ...\n    @property\n    def itemsize(self) -> int: ...\n    @overload\n    def __init__(self: array[int], __typecode: _IntTypeCode, __initializer: bytes | bytearray | Iterable[int] = ...) -> None: ...\n    @overload\n    def __init__(\n        self: array[float], __typecode: _FloatTypeCode, __initializer: bytes | bytearray | Iterable[float] = ...\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[str], __typecode: _UnicodeTypeCode, __initializer: bytes | bytearray | Iterable[str] = ...\n    ) -> None: ...\n    @overload\n    def __init__(self, __typecode: str, __initializer: Iterable[_T]) -> None: ...\n    @overload\n    def __init__(self, __typecode: str, __initializer: bytes | bytearray = ...) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def buffer_info(self) -> tuple[int, int]: ...\n    def byteswap(self) -> None: ...\n    def count(self, __v: _T) -> int: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def frombytes(self, __buffer: ReadableBuffer) -> None: ...\n    def fromfile(self, __f: SupportsRead[bytes], __n: int) -> None: ...\n    def fromlist(self, __list: list[_T]) -> None: ...\n    def fromunicode(self, __ustr: str) -> None: ...\n    if sys.version_info >= (3, 10):\n        def index(self, __v: _T, __start: int = 0, __stop: int = sys.maxsize) -> int: ...\n    else:\n        def index(self, __v: _T) -> int: ...  # type: ignore[override]\n\n    def insert(self, __i: int, __v: _T) -> None: ...\n    def pop(self, __i: int = -1) -> _T: ...\n    def remove(self, __v: _T) -> None: ...\n    def tobytes(self) -> bytes: ...\n    def tofile(self, __f: SupportsWrite[bytes]) -> None: ...\n    def tolist(self) -> list[_T]: ...\n    def tounicode(self) -> str: ...\n    if sys.version_info < (3, 9):\n        def fromstring(self, __buffer: str | ReadableBuffer) -> None: ...\n        def tostring(self) -> bytes: ...\n\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, __key: slice) -> array[_T]: ...\n    @overload  # type: ignore[override]\n    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: array[_T]) -> None: ...\n    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...\n    def __add__(self, __value: array[_T]) -> array[_T]: ...\n    def __ge__(self, __value: array[_T]) -> bool: ...\n    def __gt__(self, __value: array[_T]) -> bool: ...\n    def __iadd__(self, __value: array[_T]) -> Self: ...  # type: ignore[override]\n    def __imul__(self, __value: int) -> Self: ...\n    def __le__(self, __value: array[_T]) -> bool: ...\n    def __lt__(self, __value: array[_T]) -> bool: ...\n    def __mul__(self, __value: int) -> array[_T]: ...\n    def __rmul__(self, __value: int) -> array[_T]: ...\n    def __copy__(self) -> array[_T]: ...\n    def __deepcopy__(self, __unused: Any) -> array[_T]: ...\n\nArrayType = array\n",
  "/typeshed/stdlib/ast.pyi": "import os\nimport sys\nfrom _ast import *\nfrom _typeshed import ReadableBuffer, Unused\nfrom collections.abc import Iterator\nfrom typing import Any, TypeVar, overload\nfrom typing_extensions import Literal\n\nif sys.version_info >= (3, 8):\n    class _ABC(type):\n        if sys.version_info >= (3, 9):\n            def __init__(cls, *args: Unused) -> None: ...\n\n    class Num(Constant, metaclass=_ABC):\n        value: int | float | complex\n\n    class Str(Constant, metaclass=_ABC):\n        value: str\n        # Aliases for value, for backwards compatibility\n        s: str\n\n    class Bytes(Constant, metaclass=_ABC):\n        value: bytes\n        # Aliases for value, for backwards compatibility\n        s: bytes\n\n    class NameConstant(Constant, metaclass=_ABC): ...\n    class Ellipsis(Constant, metaclass=_ABC): ...\n\nif sys.version_info >= (3, 9):\n    class slice(AST): ...\n    class ExtSlice(slice): ...\n    class Index(slice): ...\n    class Suite(mod): ...\n    class AugLoad(expr_context): ...\n    class AugStore(expr_context): ...\n    class Param(expr_context): ...\n\nclass NodeVisitor:\n    def visit(self, node: AST) -> Any: ...\n    def generic_visit(self, node: AST) -> Any: ...\n    def visit_Module(self, node: Module) -> Any: ...\n    def visit_Interactive(self, node: Interactive) -> Any: ...\n    def visit_Expression(self, node: Expression) -> Any: ...\n    def visit_FunctionDef(self, node: FunctionDef) -> Any: ...\n    def visit_AsyncFunctionDef(self, node: AsyncFunctionDef) -> Any: ...\n    def visit_ClassDef(self, node: ClassDef) -> Any: ...\n    def visit_Return(self, node: Return) -> Any: ...\n    def visit_Delete(self, node: Delete) -> Any: ...\n    def visit_Assign(self, node: Assign) -> Any: ...\n    def visit_AugAssign(self, node: AugAssign) -> Any: ...\n    def visit_AnnAssign(self, node: AnnAssign) -> Any: ...\n    def visit_For(self, node: For) -> Any: ...\n    def visit_AsyncFor(self, node: AsyncFor) -> Any: ...\n    def visit_While(self, node: While) -> Any: ...\n    def visit_If(self, node: If) -> Any: ...\n    def visit_With(self, node: With) -> Any: ...\n    def visit_AsyncWith(self, node: AsyncWith) -> Any: ...\n    def visit_Raise(self, node: Raise) -> Any: ...\n    def visit_Try(self, node: Try) -> Any: ...\n    def visit_Assert(self, node: Assert) -> Any: ...\n    def visit_Import(self, node: Import) -> Any: ...\n    def visit_ImportFrom(self, node: ImportFrom) -> Any: ...\n    def visit_Global(self, node: Global) -> Any: ...\n    def visit_Nonlocal(self, node: Nonlocal) -> Any: ...\n    def visit_Expr(self, node: Expr) -> Any: ...\n    def visit_Pass(self, node: Pass) -> Any: ...\n    def visit_Break(self, node: Break) -> Any: ...\n    def visit_Continue(self, node: Continue) -> Any: ...\n    def visit_Slice(self, node: Slice) -> Any: ...\n    def visit_BoolOp(self, node: BoolOp) -> Any: ...\n    def visit_BinOp(self, node: BinOp) -> Any: ...\n    def visit_UnaryOp(self, node: UnaryOp) -> Any: ...\n    def visit_Lambda(self, node: Lambda) -> Any: ...\n    def visit_IfExp(self, node: IfExp) -> Any: ...\n    def visit_Dict(self, node: Dict) -> Any: ...\n    def visit_Set(self, node: Set) -> Any: ...\n    def visit_ListComp(self, node: ListComp) -> Any: ...\n    def visit_SetComp(self, node: SetComp) -> Any: ...\n    def visit_DictComp(self, node: DictComp) -> Any: ...\n    def visit_GeneratorExp(self, node: GeneratorExp) -> Any: ...\n    def visit_Await(self, node: Await) -> Any: ...\n    def visit_Yield(self, node: Yield) -> Any: ...\n    def visit_YieldFrom(self, node: YieldFrom) -> Any: ...\n    def visit_Compare(self, node: Compare) -> Any: ...\n    def visit_Call(self, node: Call) -> Any: ...\n    def visit_FormattedValue(self, node: FormattedValue) -> Any: ...\n    def visit_JoinedStr(self, node: JoinedStr) -> Any: ...\n    def visit_Constant(self, node: Constant) -> Any: ...\n    if sys.version_info >= (3, 8):\n        def visit_NamedExpr(self, node: NamedExpr) -> Any: ...\n        def visit_TypeIgnore(self, node: TypeIgnore) -> Any: ...\n\n    def visit_Attribute(self, node: Attribute) -> Any: ...\n    def visit_Subscript(self, node: Subscript) -> Any: ...\n    def visit_Starred(self, node: Starred) -> Any: ...\n    def visit_Name(self, node: Name) -> Any: ...\n    def visit_List(self, node: List) -> Any: ...\n    def visit_Tuple(self, node: Tuple) -> Any: ...\n    def visit_Del(self, node: Del) -> Any: ...\n    def visit_Load(self, node: Load) -> Any: ...\n    def visit_Store(self, node: Store) -> Any: ...\n    def visit_And(self, node: And) -> Any: ...\n    def visit_Or(self, node: Or) -> Any: ...\n    def visit_Add(self, node: Add) -> Any: ...\n    def visit_BitAnd(self, node: BitAnd) -> Any: ...\n    def visit_BitOr(self, node: BitOr) -> Any: ...\n    def visit_BitXor(self, node: BitXor) -> Any: ...\n    def visit_Div(self, node: Div) -> Any: ...\n    def visit_FloorDiv(self, node: FloorDiv) -> Any: ...\n    def visit_LShift(self, node: LShift) -> Any: ...\n    def visit_Mod(self, node: Mod) -> Any: ...\n    def visit_Mult(self, node: Mult) -> Any: ...\n    def visit_MatMult(self, node: MatMult) -> Any: ...\n    def visit_Pow(self, node: Pow) -> Any: ...\n    def visit_RShift(self, node: RShift) -> Any: ...\n    def visit_Sub(self, node: Sub) -> Any: ...\n    def visit_Invert(self, node: Invert) -> Any: ...\n    def visit_Not(self, node: Not) -> Any: ...\n    def visit_UAdd(self, node: UAdd) -> Any: ...\n    def visit_USub(self, node: USub) -> Any: ...\n    def visit_Eq(self, node: Eq) -> Any: ...\n    def visit_Gt(self, node: Gt) -> Any: ...\n    def visit_GtE(self, node: GtE) -> Any: ...\n    def visit_In(self, node: In) -> Any: ...\n    def visit_Is(self, node: Is) -> Any: ...\n    def visit_IsNot(self, node: IsNot) -> Any: ...\n    def visit_Lt(self, node: Lt) -> Any: ...\n    def visit_LtE(self, node: LtE) -> Any: ...\n    def visit_NotEq(self, node: NotEq) -> Any: ...\n    def visit_NotIn(self, node: NotIn) -> Any: ...\n    def visit_comprehension(self, node: comprehension) -> Any: ...\n    def visit_ExceptHandler(self, node: ExceptHandler) -> Any: ...\n    def visit_arguments(self, node: arguments) -> Any: ...\n    def visit_arg(self, node: arg) -> Any: ...\n    def visit_keyword(self, node: keyword) -> Any: ...\n    def visit_alias(self, node: alias) -> Any: ...\n    def visit_withitem(self, node: withitem) -> Any: ...\n    if sys.version_info >= (3, 10):\n        def visit_Match(self, node: Match) -> Any: ...\n        def visit_MatchValue(self, node: MatchValue) -> Any: ...\n        def visit_MatchSequence(self, node: MatchSequence) -> Any: ...\n        def visit_MatchStar(self, node: MatchStar) -> Any: ...\n        def visit_MatchMapping(self, node: MatchMapping) -> Any: ...\n        def visit_MatchClass(self, node: MatchClass) -> Any: ...\n        def visit_MatchAs(self, node: MatchAs) -> Any: ...\n        def visit_MatchOr(self, node: MatchOr) -> Any: ...\n\n    if sys.version_info >= (3, 11):\n        def visit_TryStar(self, node: TryStar) -> Any: ...\n\n    # visit methods for deprecated nodes\n    def visit_ExtSlice(self, node: ExtSlice) -> Any: ...\n    def visit_Index(self, node: Index) -> Any: ...\n    def visit_Suite(self, node: Suite) -> Any: ...\n    def visit_AugLoad(self, node: AugLoad) -> Any: ...\n    def visit_AugStore(self, node: AugStore) -> Any: ...\n    def visit_Param(self, node: Param) -> Any: ...\n    def visit_Num(self, node: Num) -> Any: ...\n    def visit_Str(self, node: Str) -> Any: ...\n    def visit_Bytes(self, node: Bytes) -> Any: ...\n    def visit_NameConstant(self, node: NameConstant) -> Any: ...\n    def visit_Ellipsis(self, node: Ellipsis) -> Any: ...\n\nclass NodeTransformer(NodeVisitor):\n    def generic_visit(self, node: AST) -> AST: ...\n    # TODO: Override the visit_* methods with better return types.\n    #       The usual return type is AST | None, but Iterable[AST]\n    #       is also allowed in some cases -- this needs to be mapped.\n\n_T = TypeVar(\"_T\", bound=AST)\n\nif sys.version_info >= (3, 8):\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any] = \"<unknown>\",\n        mode: Literal[\"exec\"] = \"exec\",\n        *,\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> Module: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any],\n        mode: Literal[\"eval\"],\n        *,\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> Expression: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any],\n        mode: Literal[\"func_type\"],\n        *,\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> FunctionType: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any],\n        mode: Literal[\"single\"],\n        *,\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> Interactive: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        *,\n        mode: Literal[\"eval\"],\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> Expression: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        *,\n        mode: Literal[\"func_type\"],\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> FunctionType: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        *,\n        mode: Literal[\"single\"],\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> Interactive: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any] = \"<unknown>\",\n        mode: str = \"exec\",\n        *,\n        type_comments: bool = False,\n        feature_version: None | int | tuple[int, int] = None,\n    ) -> AST: ...\n\nelse:\n    @overload\n    def parse(\n        source: str | ReadableBuffer,\n        filename: str | ReadableBuffer | os.PathLike[Any] = \"<unknown>\",\n        mode: Literal[\"exec\"] = \"exec\",\n    ) -> Module: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer, filename: str | ReadableBuffer | os.PathLike[Any], mode: Literal[\"eval\"]\n    ) -> Expression: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer, filename: str | ReadableBuffer | os.PathLike[Any], mode: Literal[\"single\"]\n    ) -> Interactive: ...\n    @overload\n    def parse(source: str | ReadableBuffer, *, mode: Literal[\"eval\"]) -> Expression: ...\n    @overload\n    def parse(source: str | ReadableBuffer, *, mode: Literal[\"single\"]) -> Interactive: ...\n    @overload\n    def parse(\n        source: str | ReadableBuffer, filename: str | ReadableBuffer | os.PathLike[Any] = \"<unknown>\", mode: str = \"exec\"\n    ) -> AST: ...\n\nif sys.version_info >= (3, 9):\n    def unparse(ast_obj: AST) -> str: ...\n\ndef copy_location(new_node: _T, old_node: AST) -> _T: ...\n\nif sys.version_info >= (3, 9):\n    def dump(\n        node: AST, annotate_fields: bool = True, include_attributes: bool = False, *, indent: int | str | None = None\n    ) -> str: ...\n\nelse:\n    def dump(node: AST, annotate_fields: bool = True, include_attributes: bool = False) -> str: ...\n\ndef fix_missing_locations(node: _T) -> _T: ...\ndef get_docstring(node: AsyncFunctionDef | FunctionDef | ClassDef | Module, clean: bool = True) -> str | None: ...\ndef increment_lineno(node: _T, n: int = 1) -> _T: ...\ndef iter_child_nodes(node: AST) -> Iterator[AST]: ...\ndef iter_fields(node: AST) -> Iterator[tuple[str, Any]]: ...\ndef literal_eval(node_or_string: str | AST) -> Any: ...\n\nif sys.version_info >= (3, 8):\n    def get_source_segment(source: str, node: AST, *, padded: bool = False) -> str | None: ...\n\ndef walk(node: AST) -> Iterator[AST]: ...\n\nif sys.version_info >= (3, 9):\n    def main() -> None: ...\n",
  "/typeshed/stdlib/asynchat.pyi": "import asyncore\nfrom abc import abstractmethod\n\nclass simple_producer:\n    def __init__(self, data: bytes, buffer_size: int = 512) -> None: ...\n    def more(self) -> bytes: ...\n\nclass async_chat(asyncore.dispatcher):\n    ac_in_buffer_size: int\n    ac_out_buffer_size: int\n    @abstractmethod\n    def collect_incoming_data(self, data: bytes) -> None: ...\n    @abstractmethod\n    def found_terminator(self) -> None: ...\n    def set_terminator(self, term: bytes | int | None) -> None: ...\n    def get_terminator(self) -> bytes | int | None: ...\n    def push(self, data: bytes) -> None: ...\n    def push_with_producer(self, producer: simple_producer) -> None: ...\n    def close_when_done(self) -> None: ...\n    def initiate_send(self) -> None: ...\n    def discard_buffers(self) -> None: ...\n",
  "/typeshed/stdlib/asyncore.pyi": "import sys\nfrom _typeshed import FileDescriptorLike, ReadableBuffer\nfrom socket import socket\nfrom typing import Any, overload\nfrom typing_extensions import TypeAlias\n\n# cyclic dependence with asynchat\n_MapType: TypeAlias = dict[int, Any]\n_Socket: TypeAlias = socket\n\nsocket_map: _MapType  # undocumented\n\nclass ExitNow(Exception): ...\n\ndef read(obj: Any) -> None: ...\ndef write(obj: Any) -> None: ...\ndef readwrite(obj: Any, flags: int) -> None: ...\ndef poll(timeout: float = 0.0, map: _MapType | None = None) -> None: ...\ndef poll2(timeout: float = 0.0, map: _MapType | None = None) -> None: ...\n\npoll3 = poll2\n\ndef loop(timeout: float = 30.0, use_poll: bool = False, map: _MapType | None = None, count: int | None = None) -> None: ...\n\n# Not really subclass of socket.socket; it's only delegation.\n# It is not covariant to it.\nclass dispatcher:\n    debug: bool\n    connected: bool\n    accepting: bool\n    connecting: bool\n    closing: bool\n    ignore_log_types: frozenset[str]\n    socket: _Socket | None\n    def __init__(self, sock: _Socket | None = None, map: _MapType | None = None) -> None: ...\n    def add_channel(self, map: _MapType | None = None) -> None: ...\n    def del_channel(self, map: _MapType | None = None) -> None: ...\n    def create_socket(self, family: int = ..., type: int = ...) -> None: ...\n    def set_socket(self, sock: _Socket, map: _MapType | None = None) -> None: ...\n    def set_reuse_addr(self) -> None: ...\n    def readable(self) -> bool: ...\n    def writable(self) -> bool: ...\n    def listen(self, num: int) -> None: ...\n    def bind(self, addr: tuple[Any, ...] | str) -> None: ...\n    def connect(self, address: tuple[Any, ...] | str) -> None: ...\n    def accept(self) -> tuple[_Socket, Any] | None: ...\n    def send(self, data: ReadableBuffer) -> int: ...\n    def recv(self, buffer_size: int) -> bytes: ...\n    def close(self) -> None: ...\n    def log(self, message: Any) -> None: ...\n    def log_info(self, message: Any, type: str = \"info\") -> None: ...\n    def handle_read_event(self) -> None: ...\n    def handle_connect_event(self) -> None: ...\n    def handle_write_event(self) -> None: ...\n    def handle_expt_event(self) -> None: ...\n    def handle_error(self) -> None: ...\n    def handle_expt(self) -> None: ...\n    def handle_read(self) -> None: ...\n    def handle_write(self) -> None: ...\n    def handle_connect(self) -> None: ...\n    def handle_accept(self) -> None: ...\n    def handle_close(self) -> None: ...\n\nclass dispatcher_with_send(dispatcher):\n    def initiate_send(self) -> None: ...\n    # incompatible signature:\n    # def send(self, data: bytes) -> int | None: ...\n\ndef compact_traceback() -> tuple[tuple[str, str, str], type, type, str]: ...\ndef close_all(map: _MapType | None = None, ignore_all: bool = False) -> None: ...\n\nif sys.platform != \"win32\":\n    class file_wrapper:\n        fd: int\n        def __init__(self, fd: int) -> None: ...\n        def recv(self, bufsize: int, flags: int = ...) -> bytes: ...\n        def send(self, data: bytes, flags: int = ...) -> int: ...\n        @overload\n        def getsockopt(self, level: int, optname: int, buflen: None = None) -> int: ...\n        @overload\n        def getsockopt(self, level: int, optname: int, buflen: int) -> bytes: ...\n        def read(self, bufsize: int, flags: int = ...) -> bytes: ...\n        def write(self, data: bytes, flags: int = ...) -> int: ...\n        def close(self) -> None: ...\n        def fileno(self) -> int: ...\n\n    class file_dispatcher(dispatcher):\n        def __init__(self, fd: FileDescriptorLike, map: _MapType | None = None) -> None: ...\n        def set_file(self, fd: int) -> None: ...\n",
  "/typeshed/stdlib/atexit.pyi": "from collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n\ndef _clear() -> None: ...\ndef _ncallbacks() -> int: ...\ndef _run_exitfuncs() -> None: ...\ndef register(func: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Callable[_P, _T]: ...\ndef unregister(func: Callable[..., object]) -> None: ...\n",
  "/typeshed/stdlib/audioop.pyi": "from typing_extensions import TypeAlias\n\n_AdpcmState: TypeAlias = tuple[int, int]\n_RatecvState: TypeAlias = tuple[int, tuple[tuple[int, int], ...]]\n\nclass error(Exception): ...\n\ndef add(__fragment1: bytes, __fragment2: bytes, __width: int) -> bytes: ...\ndef adpcm2lin(__fragment: bytes, __width: int, __state: _AdpcmState | None) -> tuple[bytes, _AdpcmState]: ...\ndef alaw2lin(__fragment: bytes, __width: int) -> bytes: ...\ndef avg(__fragment: bytes, __width: int) -> int: ...\ndef avgpp(__fragment: bytes, __width: int) -> int: ...\ndef bias(__fragment: bytes, __width: int, __bias: int) -> bytes: ...\ndef byteswap(__fragment: bytes, __width: int) -> bytes: ...\ndef cross(__fragment: bytes, __width: int) -> int: ...\ndef findfactor(__fragment: bytes, __reference: bytes) -> float: ...\ndef findfit(__fragment: bytes, __reference: bytes) -> tuple[int, float]: ...\ndef findmax(__fragment: bytes, __length: int) -> int: ...\ndef getsample(__fragment: bytes, __width: int, __index: int) -> int: ...\ndef lin2adpcm(__fragment: bytes, __width: int, __state: _AdpcmState | None) -> tuple[bytes, _AdpcmState]: ...\ndef lin2alaw(__fragment: bytes, __width: int) -> bytes: ...\ndef lin2lin(__fragment: bytes, __width: int, __newwidth: int) -> bytes: ...\ndef lin2ulaw(__fragment: bytes, __width: int) -> bytes: ...\ndef max(__fragment: bytes, __width: int) -> int: ...\ndef maxpp(__fragment: bytes, __width: int) -> int: ...\ndef minmax(__fragment: bytes, __width: int) -> tuple[int, int]: ...\ndef mul(__fragment: bytes, __width: int, __factor: float) -> bytes: ...\ndef ratecv(\n    __fragment: bytes,\n    __width: int,\n    __nchannels: int,\n    __inrate: int,\n    __outrate: int,\n    __state: _RatecvState | None,\n    __weightA: int = 1,\n    __weightB: int = 0,\n) -> tuple[bytes, _RatecvState]: ...\ndef reverse(__fragment: bytes, __width: int) -> bytes: ...\ndef rms(__fragment: bytes, __width: int) -> int: ...\ndef tomono(__fragment: bytes, __width: int, __lfactor: float, __rfactor: float) -> bytes: ...\ndef tostereo(__fragment: bytes, __width: int, __lfactor: float, __rfactor: float) -> bytes: ...\ndef ulaw2lin(__fragment: bytes, __width: int) -> bytes: ...\n",
  "/typeshed/stdlib/base64.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom typing import IO\n\n__all__ = [\n    \"encode\",\n    \"decode\",\n    \"encodebytes\",\n    \"decodebytes\",\n    \"b64encode\",\n    \"b64decode\",\n    \"b32encode\",\n    \"b32decode\",\n    \"b16encode\",\n    \"b16decode\",\n    \"b85encode\",\n    \"b85decode\",\n    \"a85encode\",\n    \"a85decode\",\n    \"standard_b64encode\",\n    \"standard_b64decode\",\n    \"urlsafe_b64encode\",\n    \"urlsafe_b64decode\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"b32hexencode\", \"b32hexdecode\"]\n\ndef b64encode(s: ReadableBuffer, altchars: ReadableBuffer | None = None) -> bytes: ...\ndef b64decode(s: str | ReadableBuffer, altchars: ReadableBuffer | None = None, validate: bool = False) -> bytes: ...\ndef standard_b64encode(s: ReadableBuffer) -> bytes: ...\ndef standard_b64decode(s: str | ReadableBuffer) -> bytes: ...\ndef urlsafe_b64encode(s: ReadableBuffer) -> bytes: ...\ndef urlsafe_b64decode(s: str | ReadableBuffer) -> bytes: ...\ndef b32encode(s: ReadableBuffer) -> bytes: ...\ndef b32decode(s: str | ReadableBuffer, casefold: bool = False, map01: bytes | None = None) -> bytes: ...\ndef b16encode(s: ReadableBuffer) -> bytes: ...\ndef b16decode(s: str | ReadableBuffer, casefold: bool = False) -> bytes: ...\n\nif sys.version_info >= (3, 10):\n    def b32hexencode(s: ReadableBuffer) -> bytes: ...\n    def b32hexdecode(s: str | ReadableBuffer, casefold: bool = False) -> bytes: ...\n\ndef a85encode(\n    b: ReadableBuffer, *, foldspaces: bool = False, wrapcol: int = 0, pad: bool = False, adobe: bool = False\n) -> bytes: ...\ndef a85decode(\n    b: str | ReadableBuffer, *, foldspaces: bool = False, adobe: bool = False, ignorechars: bytearray | bytes = b\" \\t\\n\\r\\x0b\"\n) -> bytes: ...\ndef b85encode(b: ReadableBuffer, pad: bool = False) -> bytes: ...\ndef b85decode(b: str | ReadableBuffer) -> bytes: ...\ndef decode(input: IO[bytes], output: IO[bytes]) -> None: ...\ndef encode(input: IO[bytes], output: IO[bytes]) -> None: ...\ndef encodebytes(s: ReadableBuffer) -> bytes: ...\ndef decodebytes(s: ReadableBuffer) -> bytes: ...\n\nif sys.version_info < (3, 9):\n    def encodestring(s: ReadableBuffer) -> bytes: ...\n    def decodestring(s: ReadableBuffer) -> bytes: ...\n",
  "/typeshed/stdlib/bdb.pyi": "import sys\nfrom _typeshed import ExcInfo, TraceFunction\nfrom collections.abc import Callable, Iterable, Mapping\nfrom types import CodeType, FrameType, TracebackType\nfrom typing import IO, Any, SupportsInt, TypeVar\nfrom typing_extensions import Literal, ParamSpec\n\n__all__ = [\"BdbQuit\", \"Bdb\", \"Breakpoint\"]\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n\nGENERATOR_AND_COROUTINE_FLAGS: Literal[672]\n\nclass BdbQuit(Exception): ...\n\nclass Bdb:\n    skip: set[str] | None\n    breaks: dict[str, list[int]]\n    fncache: dict[str, str]\n    frame_returning: FrameType | None\n    botframe: FrameType | None\n    quitting: bool\n    stopframe: FrameType | None\n    returnframe: FrameType | None\n    stoplineno: int\n    def __init__(self, skip: Iterable[str] | None = None) -> None: ...\n    def canonic(self, filename: str) -> str: ...\n    def reset(self) -> None: ...\n    def trace_dispatch(self, frame: FrameType, event: str, arg: Any) -> TraceFunction: ...\n    def dispatch_line(self, frame: FrameType) -> TraceFunction: ...\n    def dispatch_call(self, frame: FrameType, arg: None) -> TraceFunction: ...\n    def dispatch_return(self, frame: FrameType, arg: Any) -> TraceFunction: ...\n    def dispatch_exception(self, frame: FrameType, arg: ExcInfo) -> TraceFunction: ...\n    def is_skipped_module(self, module_name: str) -> bool: ...\n    def stop_here(self, frame: FrameType) -> bool: ...\n    def break_here(self, frame: FrameType) -> bool: ...\n    def do_clear(self, arg: Any) -> bool | None: ...\n    def break_anywhere(self, frame: FrameType) -> bool: ...\n    def user_call(self, frame: FrameType, argument_list: None) -> None: ...\n    def user_line(self, frame: FrameType) -> None: ...\n    def user_return(self, frame: FrameType, return_value: Any) -> None: ...\n    def user_exception(self, frame: FrameType, exc_info: ExcInfo) -> None: ...\n    def set_until(self, frame: FrameType, lineno: int | None = None) -> None: ...\n    def set_step(self) -> None: ...\n    def set_next(self, frame: FrameType) -> None: ...\n    def set_return(self, frame: FrameType) -> None: ...\n    def set_trace(self, frame: FrameType | None = None) -> None: ...\n    def set_continue(self) -> None: ...\n    def set_quit(self) -> None: ...\n    def set_break(\n        self, filename: str, lineno: int, temporary: bool = False, cond: str | None = None, funcname: str | None = None\n    ) -> None: ...\n    def clear_break(self, filename: str, lineno: int) -> None: ...\n    def clear_bpbynumber(self, arg: SupportsInt) -> None: ...\n    def clear_all_file_breaks(self, filename: str) -> None: ...\n    def clear_all_breaks(self) -> None: ...\n    def get_bpbynumber(self, arg: SupportsInt) -> Breakpoint: ...\n    def get_break(self, filename: str, lineno: int) -> bool: ...\n    def get_breaks(self, filename: str, lineno: int) -> list[Breakpoint]: ...\n    def get_file_breaks(self, filename: str) -> list[Breakpoint]: ...\n    def get_all_breaks(self) -> list[Breakpoint]: ...\n    def get_stack(self, f: FrameType | None, t: TracebackType | None) -> tuple[list[tuple[FrameType, int]], int]: ...\n    def format_stack_entry(self, frame_lineno: int, lprefix: str = \": \") -> str: ...\n    def run(\n        self, cmd: str | CodeType, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None\n    ) -> None: ...\n    def runeval(self, expr: str, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None) -> None: ...\n    def runctx(self, cmd: str | CodeType, globals: dict[str, Any] | None, locals: Mapping[str, Any] | None) -> None: ...\n    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> _T | None: ...\n\nclass Breakpoint:\n    next: int\n    bplist: dict[tuple[str, int], list[Breakpoint]]\n    bpbynumber: list[Breakpoint | None]\n\n    funcname: str | None\n    func_first_executable_line: int | None\n    file: str\n    line: int\n    temporary: bool\n    cond: str | None\n    enabled: bool\n    ignore: int\n    hits: int\n    number: int\n    def __init__(\n        self, file: str, line: int, temporary: bool = False, cond: str | None = None, funcname: str | None = None\n    ) -> None: ...\n    if sys.version_info >= (3, 11):\n        @staticmethod\n        def clearBreakpoints() -> None: ...\n\n    def deleteMe(self) -> None: ...\n    def enable(self) -> None: ...\n    def disable(self) -> None: ...\n    def bpprint(self, out: IO[str] | None = None) -> None: ...\n    def bpformat(self) -> str: ...\n\ndef checkfuncname(b: Breakpoint, frame: FrameType) -> bool: ...\ndef effective(file: str, line: int, frame: FrameType) -> tuple[Breakpoint, bool] | tuple[None, None]: ...\ndef set_trace() -> None: ...\n",
  "/typeshed/stdlib/binascii.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom typing_extensions import TypeAlias\n\n# Many functions in binascii accept buffer objects\n# or ASCII-only strings.\n_AsciiBuffer: TypeAlias = str | ReadableBuffer\n\ndef a2b_uu(__data: _AsciiBuffer) -> bytes: ...\ndef b2a_uu(__data: ReadableBuffer, *, backtick: bool = False) -> bytes: ...\n\nif sys.version_info >= (3, 11):\n    def a2b_base64(__data: _AsciiBuffer, *, strict_mode: bool = False) -> bytes: ...\n\nelse:\n    def a2b_base64(__data: _AsciiBuffer) -> bytes: ...\n\ndef b2a_base64(__data: ReadableBuffer, *, newline: bool = True) -> bytes: ...\ndef a2b_qp(data: _AsciiBuffer, header: bool = False) -> bytes: ...\ndef b2a_qp(data: ReadableBuffer, quotetabs: bool = False, istext: bool = True, header: bool = False) -> bytes: ...\n\nif sys.version_info < (3, 11):\n    def a2b_hqx(__data: _AsciiBuffer) -> bytes: ...\n    def rledecode_hqx(__data: ReadableBuffer) -> bytes: ...\n    def rlecode_hqx(__data: ReadableBuffer) -> bytes: ...\n    def b2a_hqx(__data: ReadableBuffer) -> bytes: ...\n\ndef crc_hqx(__data: ReadableBuffer, __crc: int) -> int: ...\ndef crc32(__data: ReadableBuffer, __crc: int = 0) -> int: ...\n\nif sys.version_info >= (3, 8):\n    # sep must be str or bytes, not bytearray or any other buffer\n    def b2a_hex(data: ReadableBuffer, sep: str | bytes = ..., bytes_per_sep: int = ...) -> bytes: ...\n    def hexlify(data: ReadableBuffer, sep: str | bytes = ..., bytes_per_sep: int = ...) -> bytes: ...\n\nelse:\n    def b2a_hex(__data: ReadableBuffer) -> bytes: ...\n    def hexlify(__data: ReadableBuffer) -> bytes: ...\n\ndef a2b_hex(__hexstr: _AsciiBuffer) -> bytes: ...\ndef unhexlify(__hexstr: _AsciiBuffer) -> bytes: ...\n\nclass Error(ValueError): ...\nclass Incomplete(Exception): ...\n",
  "/typeshed/stdlib/binhex.pyi": "from _typeshed import _BufferWithLen\nfrom typing import IO, Any\nfrom typing_extensions import Literal, TypeAlias\n\n__all__ = [\"binhex\", \"hexbin\", \"Error\"]\n\nclass Error(Exception): ...\n\nREASONABLY_LARGE: Literal[32768]\nLINELEN: Literal[64]\nRUNCHAR: Literal[b\"\\x90\"]\n\nclass FInfo:\n    Type: str\n    Creator: str\n    Flags: int\n\n_FileInfoTuple: TypeAlias = tuple[str, FInfo, int, int]\n_FileHandleUnion: TypeAlias = str | IO[bytes]\n\ndef getfileinfo(name: str) -> _FileInfoTuple: ...\n\nclass openrsrc:\n    def __init__(self, *args: Any) -> None: ...\n    def read(self, *args: Any) -> bytes: ...\n    def write(self, *args: Any) -> None: ...\n    def close(self) -> None: ...\n\nclass BinHex:\n    def __init__(self, name_finfo_dlen_rlen: _FileInfoTuple, ofp: _FileHandleUnion) -> None: ...\n    def write(self, data: _BufferWithLen) -> None: ...\n    def close_data(self) -> None: ...\n    def write_rsrc(self, data: _BufferWithLen) -> None: ...\n    def close(self) -> None: ...\n\ndef binhex(inp: str, out: str) -> None: ...\n\nclass HexBin:\n    def __init__(self, ifp: _FileHandleUnion) -> None: ...\n    def read(self, *n: int) -> bytes: ...\n    def close_data(self) -> None: ...\n    def read_rsrc(self, *n: int) -> bytes: ...\n    def close(self) -> None: ...\n\ndef hexbin(inp: str, out: str) -> None: ...\n",
  "/typeshed/stdlib/bisect.pyi": "from _bisect import *\n\nbisect = bisect_right\ninsort = insort_right\n",
  "/typeshed/stdlib/builtins.pyi": "import _ast\nimport _typeshed\nimport sys\nimport types\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import (\n    AnyStr_co,\n    FileDescriptorOrPath,\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    SupportsAdd,\n    SupportsAiter,\n    SupportsAnext,\n    SupportsDivMod,\n    SupportsIter,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsNext,\n    SupportsRAdd,\n    SupportsRDivMod,\n    SupportsRichComparison,\n    SupportsRichComparisonT,\n    SupportsTrunc,\n    SupportsWrite,\n)\nfrom collections.abc import Awaitable, Callable, Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet, Sized\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom types import CodeType, TracebackType, _Cell\n\n# mypy crashes if any of {ByteString, Sequence, MutableSequence, Mapping, MutableMapping} are imported from collections.abc in builtins.pyi\nfrom typing import (  # noqa: Y022\n    IO,\n    Any,\n    BinaryIO,\n    ByteString,\n    ClassVar,\n    Generic,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    NoReturn,\n    Protocol,\n    Sequence,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    TypeVar,\n    overload,\n    type_check_only,\n)\nfrom typing_extensions import Concatenate, Literal, LiteralString, ParamSpec, Self, SupportsIndex, TypeAlias, TypeGuard, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_R_co = TypeVar(\"_R_co\", covariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_SupportsNextT = TypeVar(\"_SupportsNextT\", bound=SupportsNext[Any], covariant=True)\n_SupportsAnextT = TypeVar(\"_SupportsAnextT\", bound=SupportsAnext[Any], covariant=True)\n_AwaitableT = TypeVar(\"_AwaitableT\", bound=Awaitable[Any])\n_AwaitableT_co = TypeVar(\"_AwaitableT_co\", bound=Awaitable[Any], covariant=True)\n_P = ParamSpec(\"_P\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self) -> type[Self]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: type[object]) -> None: ...  # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls) -> Self: ...\n    # N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.\n    # Overriding them in subclasses has different semantics, even if the override has an identical signature.\n    def __setattr__(self, __name: str, __value: Any) -> None: ...\n    def __delattr__(self, __name: str) -> None: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __str__(self) -> str: ...  # noqa: Y029\n    def __repr__(self) -> str: ...  # noqa: Y029\n    def __hash__(self) -> int: ...\n    def __format__(self, __format_spec: str) -> str: ...\n    def __getattribute__(self, __name: str) -> Any: ...\n    def __sizeof__(self) -> int: ...\n    # return type of pickle methods is rather hard to express in the current type system\n    # see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__\n    def __reduce__(self) -> str | tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, __protocol: SupportsIndex) -> str | tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, __protocol: int) -> str | tuple[Any, ...]: ...\n\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n    @classmethod\n    def __subclasshook__(cls, __subclass: type) -> bool: ...\n\nclass staticmethod(Generic[_P, _R_co]):\n    @property\n    def __func__(self) -> Callable[_P, _R_co]: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    def __init__(self, __f: Callable[_P, _R_co]) -> None: ...\n    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...\n    if sys.version_info >= (3, 10):\n        __name__: str\n        __qualname__: str\n        @property\n        def __wrapped__(self) -> Callable[_P, _R_co]: ...\n        def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...\n\nclass classmethod(Generic[_T, _P, _R_co]):\n    @property\n    def __func__(self) -> Callable[Concatenate[_T, _P], _R_co]: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    def __init__(self, __f: Callable[Concatenate[_T, _P], _R_co]) -> None: ...\n    def __get__(self, __instance: _T, __owner: type[_T] | None = None) -> Callable[_P, _R_co]: ...\n    if sys.version_info >= (3, 10):\n        __name__: str\n        __qualname__: str\n        @property\n        def __wrapped__(self) -> Callable[Concatenate[_T, _P], _R_co]: ...\n\nclass type:\n    @property\n    def __base__(self) -> type: ...\n    __bases__: tuple[type, ...]\n    @property\n    def __basicsize__(self) -> int: ...\n    @property\n    def __dict__(self) -> types.MappingProxyType[str, Any]: ...  # type: ignore[override]\n    @property\n    def __dictoffset__(self) -> int: ...\n    @property\n    def __flags__(self) -> int: ...\n    @property\n    def __itemsize__(self) -> int: ...\n    __module__: str\n    @property\n    def __mro__(self) -> tuple[type, ...]: ...\n    __name__: str\n    __qualname__: str\n    @property\n    def __text_signature__(self) -> str | None: ...\n    @property\n    def __weakrefoffset__(self) -> int: ...\n    @overload\n    def __init__(self, __o: object) -> None: ...\n    @overload\n    def __init__(self, __name: str, __bases: tuple[type, ...], __dict: dict[str, Any], **kwds: Any) -> None: ...\n    @overload\n    def __new__(cls, __o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: type[_typeshed.Self], __name: str, __bases: tuple[type, ...], __namespace: dict[str, Any], **kwds: Any\n    ) -> _typeshed.Self: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...\n    # Note: the documentation doesn't specify what the return type is, the standard\n    # implementation seems to be returning a list.\n    def mro(self) -> list[type]: ...\n    def __instancecheck__(self, __instance: Any) -> bool: ...\n    def __subclasscheck__(self, __subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(metacls, __name: str, __bases: tuple[type, ...], **kwds: Any) -> Mapping[str, object]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, __value: Any) -> types.UnionType: ...\n        def __ror__(self, __value: Any) -> types.UnionType: ...\n\nclass super:\n    @overload\n    def __init__(self, __t: Any, __obj: Any) -> None: ...\n    @overload\n    def __init__(self, __t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\n_PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n_NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]\n_LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed\n\nclass int:\n    @overload\n    def __new__(cls, __x: str | ReadableBuffer | SupportsInt | SupportsIndex | SupportsTrunc = ...) -> Self: ...\n    @overload\n    def __new__(cls, __x: str | bytes | bytearray, base: SupportsIndex) -> Self: ...\n    if sys.version_info >= (3, 8):\n        def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...\n\n    @property\n    def real(self) -> int: ...\n    @property\n    def imag(self) -> Literal[0]: ...\n    @property\n    def numerator(self) -> int: ...\n    @property\n    def denominator(self) -> Literal[1]: ...\n    def conjugate(self) -> int: ...\n    def bit_length(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        def bit_count(self) -> int: ...\n\n    if sys.version_info >= (3, 11):\n        def to_bytes(\n            self, length: SupportsIndex = 1, byteorder: Literal[\"little\", \"big\"] = \"big\", *, signed: bool = False\n        ) -> bytes: ...\n        @classmethod\n        def from_bytes(\n            cls,\n            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,\n            byteorder: Literal[\"little\", \"big\"] = \"big\",\n            *,\n            signed: bool = False,\n        ) -> Self: ...\n    else:\n        def to_bytes(self, length: SupportsIndex, byteorder: Literal[\"little\", \"big\"], *, signed: bool = False) -> bytes: ...\n        @classmethod\n        def from_bytes(\n            cls,\n            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,\n            byteorder: Literal[\"little\", \"big\"],\n            *,\n            signed: bool = False,\n        ) -> Self: ...\n\n    def __add__(self, __value: int) -> int: ...\n    def __sub__(self, __value: int) -> int: ...\n    def __mul__(self, __value: int) -> int: ...\n    def __floordiv__(self, __value: int) -> int: ...\n    def __truediv__(self, __value: int) -> float: ...\n    def __mod__(self, __value: int) -> int: ...\n    def __divmod__(self, __value: int) -> tuple[int, int]: ...\n    def __radd__(self, __value: int) -> int: ...\n    def __rsub__(self, __value: int) -> int: ...\n    def __rmul__(self, __value: int) -> int: ...\n    def __rfloordiv__(self, __value: int) -> int: ...\n    def __rtruediv__(self, __value: int) -> float: ...\n    def __rmod__(self, __value: int) -> int: ...\n    def __rdivmod__(self, __value: int) -> tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[0]) -> Literal[1]: ...\n    @overload\n    def __pow__(self, __value: Literal[0], __mod: None) -> Literal[1]: ...\n    @overload\n    def __pow__(self, __value: _PositiveInteger, __mod: None = None) -> int: ...\n    @overload\n    def __pow__(self, __value: _NegativeInteger, __mod: None = None) -> float: ...\n    # positive x -> int; negative x -> float\n    # return type must be Any as `int | float` causes too many false-positive errors\n    @overload\n    def __pow__(self, __value: int, __mod: None = None) -> Any: ...\n    @overload\n    def __pow__(self, __value: int, __mod: int) -> int: ...\n    def __rpow__(self, __value: int, __mod: int | None = None) -> Any: ...\n    def __and__(self, __value: int) -> int: ...\n    def __or__(self, __value: int) -> int: ...\n    def __xor__(self, __value: int) -> int: ...\n    def __lshift__(self, __value: int) -> int: ...\n    def __rshift__(self, __value: int) -> int: ...\n    def __rand__(self, __value: int) -> int: ...\n    def __ror__(self, __value: int) -> int: ...\n    def __rxor__(self, __value: int) -> int: ...\n    def __rlshift__(self, __value: int) -> int: ...\n    def __rrshift__(self, __value: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, __ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> tuple[int]: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __lt__(self, __value: int) -> bool: ...\n    def __le__(self, __value: int) -> bool: ...\n    def __gt__(self, __value: int) -> bool: ...\n    def __ge__(self, __value: int) -> bool: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(cls, __x: SupportsFloat | SupportsIndex | str | ReadableBuffer = ...) -> Self: ...\n    def as_integer_ratio(self) -> tuple[int, int]: ...\n    def hex(self) -> str: ...\n    def is_integer(self) -> bool: ...\n    @classmethod\n    def fromhex(cls, __string: str) -> Self: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> float: ...\n    def __add__(self, __value: float) -> float: ...\n    def __sub__(self, __value: float) -> float: ...\n    def __mul__(self, __value: float) -> float: ...\n    def __floordiv__(self, __value: float) -> float: ...\n    def __truediv__(self, __value: float) -> float: ...\n    def __mod__(self, __value: float) -> float: ...\n    def __divmod__(self, __value: float) -> tuple[float, float]: ...\n    @overload\n    def __pow__(self, __value: int, __mod: None = None) -> float: ...\n    # positive x -> float; negative x -> complex\n    # return type must be Any as `float | complex` causes too many false-positive errors\n    @overload\n    def __pow__(self, __value: float, __mod: None = None) -> Any: ...\n    def __radd__(self, __value: float) -> float: ...\n    def __rsub__(self, __value: float) -> float: ...\n    def __rmul__(self, __value: float) -> float: ...\n    def __rfloordiv__(self, __value: float) -> float: ...\n    def __rtruediv__(self, __value: float) -> float: ...\n    def __rmod__(self, __value: float) -> float: ...\n    def __rdivmod__(self, __value: float) -> tuple[float, float]: ...\n    @overload\n    def __rpow__(self, __value: _PositiveInteger, __mod: None = None) -> float: ...\n    @overload\n    def __rpow__(self, __value: _NegativeInteger, __mod: None = None) -> complex: ...\n    # Returning `complex` for the general case gives too many false-positive errors.\n    @overload\n    def __rpow__(self, __value: float, __mod: None = None) -> Any: ...\n    def __getnewargs__(self) -> tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n\n    @overload\n    def __round__(self, __ndigits: None = None) -> int: ...\n    @overload\n    def __round__(self, __ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __lt__(self, __value: float) -> bool: ...\n    def __le__(self, __value: float) -> bool: ...\n    def __gt__(self, __value: float) -> bool: ...\n    def __ge__(self, __value: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    if sys.version_info >= (3, 8):\n        # Python doesn't currently accept SupportsComplex for the second argument\n        @overload\n        def __new__(\n            cls,\n            real: complex | SupportsComplex | SupportsFloat | SupportsIndex = ...,\n            imag: complex | SupportsFloat | SupportsIndex = ...,\n        ) -> Self: ...\n        @overload\n        def __new__(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...\n    else:\n        @overload\n        def __new__(cls, real: complex | SupportsComplex | SupportsFloat = ..., imag: complex | SupportsFloat = ...) -> Self: ...\n        @overload\n        def __new__(cls, real: str | SupportsComplex | SupportsFloat | complex) -> Self: ...\n\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> complex: ...\n    def __add__(self, __value: complex) -> complex: ...\n    def __sub__(self, __value: complex) -> complex: ...\n    def __mul__(self, __value: complex) -> complex: ...\n    def __pow__(self, __value: complex, __mod: None = None) -> complex: ...\n    def __truediv__(self, __value: complex) -> complex: ...\n    def __radd__(self, __value: complex) -> complex: ...\n    def __rsub__(self, __value: complex) -> complex: ...\n    def __rmul__(self, __value: complex) -> complex: ...\n    def __rpow__(self, __value: complex, __mod: None = None) -> complex: ...\n    def __rtruediv__(self, __value: complex) -> complex: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __abs__(self) -> float: ...\n    def __bool__(self) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __complex__(self) -> complex: ...\n\nclass _FormatMapMapping(Protocol):\n    def __getitem__(self, __key: str) -> Any: ...\n\nclass _TranslateTable(Protocol):\n    def __getitem__(self, __key: int) -> str | int | None: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls, object: object = ...) -> Self: ...\n    @overload\n    def __new__(cls, object: ReadableBuffer, encoding: str = ..., errors: str = ...) -> Self: ...\n    @overload\n    def capitalize(self: LiteralString) -> LiteralString: ...\n    @overload\n    def capitalize(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def casefold(self: LiteralString) -> LiteralString: ...\n    @overload\n    def casefold(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def center(self: LiteralString, __width: SupportsIndex, __fillchar: LiteralString = \" \") -> LiteralString: ...\n    @overload\n    def center(self, __width: SupportsIndex, __fillchar: str = \" \") -> str: ...  # type: ignore[misc]\n    def count(self, x: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...\n    def encode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> bytes: ...\n    def endswith(\n        self, __suffix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        @overload\n        def expandtabs(self: LiteralString, tabsize: SupportsIndex = 8) -> LiteralString: ...\n        @overload\n        def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...  # type: ignore[misc]\n    else:\n        @overload\n        def expandtabs(self: LiteralString, tabsize: int = 8) -> LiteralString: ...\n        @overload\n        def expandtabs(self, tabsize: int = 8) -> str: ...  # type: ignore[misc]\n\n    def find(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...\n    @overload\n    def format(self: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...\n    @overload\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def format_map(self, map: _FormatMapMapping) -> str: ...\n    def index(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    @overload\n    def join(self: LiteralString, __iterable: Iterable[LiteralString]) -> LiteralString: ...\n    @overload\n    def join(self, __iterable: Iterable[str]) -> str: ...  # type: ignore[misc]\n    @overload\n    def ljust(self: LiteralString, __width: SupportsIndex, __fillchar: LiteralString = \" \") -> LiteralString: ...\n    @overload\n    def ljust(self, __width: SupportsIndex, __fillchar: str = \" \") -> str: ...  # type: ignore[misc]\n    @overload\n    def lower(self: LiteralString) -> LiteralString: ...\n    @overload\n    def lower(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def lstrip(self: LiteralString, __chars: LiteralString | None = None) -> LiteralString: ...\n    @overload\n    def lstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]\n    @overload\n    def partition(self: LiteralString, __sep: LiteralString) -> tuple[LiteralString, LiteralString, LiteralString]: ...\n    @overload\n    def partition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]\n    @overload\n    def replace(\n        self: LiteralString, __old: LiteralString, __new: LiteralString, __count: SupportsIndex = -1\n    ) -> LiteralString: ...\n    @overload\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = -1) -> str: ...  # type: ignore[misc]\n    if sys.version_info >= (3, 9):\n        @overload\n        def removeprefix(self: LiteralString, __prefix: LiteralString) -> LiteralString: ...\n        @overload\n        def removeprefix(self, __prefix: str) -> str: ...  # type: ignore[misc]\n        @overload\n        def removesuffix(self: LiteralString, __suffix: LiteralString) -> LiteralString: ...\n        @overload\n        def removesuffix(self, __suffix: str) -> str: ...  # type: ignore[misc]\n\n    def rfind(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...\n    def rindex(self, __sub: str, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...) -> int: ...\n    @overload\n    def rjust(self: LiteralString, __width: SupportsIndex, __fillchar: LiteralString = \" \") -> LiteralString: ...\n    @overload\n    def rjust(self, __width: SupportsIndex, __fillchar: str = \" \") -> str: ...  # type: ignore[misc]\n    @overload\n    def rpartition(self: LiteralString, __sep: LiteralString) -> tuple[LiteralString, LiteralString, LiteralString]: ...\n    @overload\n    def rpartition(self, __sep: str) -> tuple[str, str, str]: ...  # type: ignore[misc]\n    @overload\n    def rsplit(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...\n    @overload\n    def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]\n    @overload\n    def rstrip(self: LiteralString, __chars: LiteralString | None = None) -> LiteralString: ...\n    @overload\n    def rstrip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]\n    @overload\n    def split(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...\n    @overload\n    def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]\n    @overload\n    def splitlines(self: LiteralString, keepends: bool = False) -> list[LiteralString]: ...\n    @overload\n    def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]\n    def startswith(\n        self, __prefix: str | tuple[str, ...], __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> bool: ...\n    @overload\n    def strip(self: LiteralString, __chars: LiteralString | None = None) -> LiteralString: ...\n    @overload\n    def strip(self, __chars: str | None = None) -> str: ...  # type: ignore[misc]\n    @overload\n    def swapcase(self: LiteralString) -> LiteralString: ...\n    @overload\n    def swapcase(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def title(self: LiteralString) -> LiteralString: ...\n    @overload\n    def title(self) -> str: ...  # type: ignore[misc]\n    def translate(self, __table: _TranslateTable) -> str: ...\n    @overload\n    def upper(self: LiteralString) -> LiteralString: ...\n    @overload\n    def upper(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def zfill(self: LiteralString, __width: SupportsIndex) -> LiteralString: ...\n    @overload\n    def zfill(self, __width: SupportsIndex) -> str: ...  # type: ignore[misc]\n    @staticmethod\n    @overload\n    def maketrans(__x: dict[int, _T] | dict[str, _T] | dict[str | int, _T]) -> dict[int, _T]: ...\n    @staticmethod\n    @overload\n    def maketrans(__x: str, __y: str) -> dict[int, int]: ...\n    @staticmethod\n    @overload\n    def maketrans(__x: str, __y: str, __z: str) -> dict[int, int | None]: ...\n    @overload\n    def __add__(self: LiteralString, __value: LiteralString) -> LiteralString: ...\n    @overload\n    def __add__(self, __value: str) -> str: ...  # type: ignore[misc]\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, __key: str) -> bool: ...  # type: ignore[override]\n    def __eq__(self, __value: object) -> bool: ...\n    def __ge__(self, __value: str) -> bool: ...\n    def __getitem__(self, __key: SupportsIndex | slice) -> str: ...\n    def __gt__(self, __value: str) -> bool: ...\n    @overload\n    def __iter__(self: LiteralString) -> Iterator[LiteralString]: ...\n    @overload\n    def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]\n    def __le__(self, __value: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, __value: str) -> bool: ...\n    @overload\n    def __mod__(self: LiteralString, __value: LiteralString | tuple[LiteralString, ...]) -> LiteralString: ...\n    @overload\n    def __mod__(self, __value: Any) -> str: ...\n    @overload\n    def __mul__(self: LiteralString, __value: SupportsIndex) -> LiteralString: ...\n    @overload\n    def __mul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]\n    def __ne__(self, __value: object) -> bool: ...\n    @overload\n    def __rmul__(self: LiteralString, __value: SupportsIndex) -> LiteralString: ...\n    @overload\n    def __rmul__(self, __value: SupportsIndex) -> str: ...  # type: ignore[misc]\n    def __getnewargs__(self) -> tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls, __o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer) -> Self: ...\n    @overload\n    def __new__(cls, __string: str, encoding: str, errors: str = ...) -> Self: ...\n    @overload\n    def __new__(cls) -> Self: ...\n    def capitalize(self) -> bytes: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = b\" \") -> bytes: ...\n    def count(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def decode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\n    def endswith(\n        self,\n        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytes: ...\n\n    def find(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n\n    def index(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytes: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b\" \") -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...\n    def partition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...\n    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytes: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: ReadableBuffer) -> bytes: ...\n        def removesuffix(self, __suffix: ReadableBuffer) -> bytes: ...\n\n    def rfind(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rindex(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b\" \") -> bytes: ...\n    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytes, bytes, bytes]: ...\n    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...\n    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...\n    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...\n    def splitlines(self, keepends: bool = False) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: ReadableBuffer | None = None) -> bytes: ...\n    def swapcase(self) -> bytes: ...\n    def title(self) -> bytes: ...\n    def translate(self, __table: ReadableBuffer | None, delete: bytes = b\"\") -> bytes: ...\n    def upper(self) -> bytes: ...\n    def zfill(self, __width: SupportsIndex) -> bytes: ...\n    @classmethod\n    def fromhex(cls, __string: str) -> Self: ...\n    @staticmethod\n    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, __key: slice) -> bytes: ...\n    def __add__(self, __value: ReadableBuffer) -> bytes: ...\n    def __mul__(self, __value: SupportsIndex) -> bytes: ...\n    def __rmul__(self, __value: SupportsIndex) -> bytes: ...\n    def __mod__(self, __value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __lt__(self, __value: bytes) -> bool: ...\n    def __le__(self, __value: bytes) -> bool: ...\n    def __gt__(self, __value: bytes) -> bool: ...\n    def __ge__(self, __value: bytes) -> bool: ...\n    def __getnewargs__(self) -> tuple[bytes]: ...\n    if sys.version_info >= (3, 11):\n        def __bytes__(self) -> bytes: ...\n\nclass bytearray(MutableSequence[int], ByteString):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, __ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer) -> None: ...\n    @overload\n    def __init__(self, __string: str, encoding: str, errors: str = ...) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def capitalize(self) -> bytearray: ...\n    def center(self, __width: SupportsIndex, __fillchar: bytes = b\" \") -> bytearray: ...\n    def count(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def copy(self) -> bytearray: ...\n    def decode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\n    def endswith(\n        self,\n        __suffix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...\n    else:\n        def expandtabs(self, tabsize: int = ...) -> bytearray: ...\n\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def find(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n\n    def index(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def insert(self, __index: SupportsIndex, __item: SupportsIndex) -> None: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ReadableBuffer]) -> bytearray: ...\n    def ljust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b\" \") -> bytearray: ...\n    def lower(self) -> bytearray: ...\n    def lstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...\n    def partition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...\n    def pop(self, __index: int = -1) -> int: ...\n    def remove(self, __value: int) -> None: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: ReadableBuffer) -> bytearray: ...\n        def removesuffix(self, __suffix: ReadableBuffer) -> bytearray: ...\n\n    def replace(self, __old: ReadableBuffer, __new: ReadableBuffer, __count: SupportsIndex = -1) -> bytearray: ...\n    def rfind(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rindex(\n        self, __sub: ReadableBuffer | SupportsIndex, __start: SupportsIndex | None = ..., __end: SupportsIndex | None = ...\n    ) -> int: ...\n    def rjust(self, __width: SupportsIndex, __fillchar: bytes | bytearray = b\" \") -> bytearray: ...\n    def rpartition(self, __sep: ReadableBuffer) -> tuple[bytearray, bytearray, bytearray]: ...\n    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...\n    def rstrip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...\n    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...\n    def splitlines(self, keepends: bool = False) -> list[bytearray]: ...\n    def startswith(\n        self,\n        __prefix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: ReadableBuffer | None = None) -> bytearray: ...\n    def swapcase(self) -> bytearray: ...\n    def title(self) -> bytearray: ...\n    def translate(self, __table: ReadableBuffer | None, delete: bytes = b\"\") -> bytearray: ...\n    def upper(self) -> bytearray: ...\n    def zfill(self, __width: SupportsIndex) -> bytearray: ...\n    @classmethod\n    def fromhex(cls, __string: str) -> Self: ...\n    @staticmethod\n    def maketrans(__frm: ReadableBuffer, __to: ReadableBuffer) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, __key: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, __key: SupportsIndex, __value: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...\n    def __add__(self, __value: ReadableBuffer) -> bytearray: ...\n    # The superclass wants us to accept Iterable[int], but that fails at runtime.\n    def __iadd__(self, __value: ReadableBuffer) -> Self: ...  # type: ignore[override]\n    def __mul__(self, __value: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, __value: SupportsIndex) -> bytearray: ...\n    def __imul__(self, __value: SupportsIndex) -> Self: ...\n    def __mod__(self, __value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, __key: SupportsIndex | ReadableBuffer) -> bool: ...  # type: ignore[override]\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n    def __lt__(self, __value: ReadableBuffer) -> bool: ...\n    def __le__(self, __value: ReadableBuffer) -> bool: ...\n    def __gt__(self, __value: ReadableBuffer) -> bool: ...\n    def __ge__(self, __value: ReadableBuffer) -> bool: ...\n    def __alloc__(self) -> int: ...\n\n@final\nclass memoryview(Sequence[int]):\n    @property\n    def format(self) -> str: ...\n    @property\n    def itemsize(self) -> int: ...\n    @property\n    def shape(self) -> tuple[int, ...] | None: ...\n    @property\n    def strides(self) -> tuple[int, ...] | None: ...\n    @property\n    def suboffsets(self) -> tuple[int, ...] | None: ...\n    @property\n    def readonly(self) -> bool: ...\n    @property\n    def ndim(self) -> int: ...\n    @property\n    def obj(self) -> ReadableBuffer: ...\n    @property\n    def c_contiguous(self) -> bool: ...\n    @property\n    def f_contiguous(self) -> bool: ...\n    @property\n    def contiguous(self) -> bool: ...\n    @property\n    def nbytes(self) -> int: ...\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, __exc_type: type[BaseException] | None, __exc_val: BaseException | None, __exc_tb: TracebackType | None\n    ) -> None: ...\n    def cast(self, format: str, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, __key: slice) -> memoryview: ...\n    def __contains__(self, __x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: ReadableBuffer) -> None: ...\n    @overload\n    def __setitem__(self, __key: SupportsIndex, __value: SupportsIndex) -> None: ...\n    if sys.version_info >= (3, 10):\n        def tobytes(self, order: Literal[\"C\", \"F\", \"A\"] | None = \"C\") -> bytes: ...\n    elif sys.version_info >= (3, 8):\n        def tobytes(self, order: Literal[\"C\", \"F\", \"A\"] | None = None) -> bytes: ...\n    else:\n        def tobytes(self) -> bytes: ...\n\n    def tolist(self) -> list[int]: ...\n    if sys.version_info >= (3, 8):\n        def toreadonly(self) -> memoryview: ...\n\n    def release(self) -> None: ...\n    if sys.version_info >= (3, 8):\n        def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...\n    else:\n        def hex(self) -> str: ...\n\n@final\nclass bool(int):\n    def __new__(cls, __o: object = ...) -> Self: ...\n    # The following overloads could be represented more elegantly with a TypeVar(\"_B\", bool, int),\n    # however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).\n    @overload\n    def __and__(self, __value: bool) -> bool: ...\n    @overload\n    def __and__(self, __value: int) -> int: ...\n    @overload\n    def __or__(self, __value: bool) -> bool: ...\n    @overload\n    def __or__(self, __value: int) -> int: ...\n    @overload\n    def __xor__(self, __value: bool) -> bool: ...\n    @overload\n    def __xor__(self, __value: int) -> int: ...\n    @overload\n    def __rand__(self, __value: bool) -> bool: ...\n    @overload\n    def __rand__(self, __value: int) -> int: ...\n    @overload\n    def __ror__(self, __value: bool) -> bool: ...\n    @overload\n    def __ror__(self, __value: int) -> int: ...\n    @overload\n    def __rxor__(self, __value: bool) -> bool: ...\n    @overload\n    def __rxor__(self, __value: int) -> int: ...\n    def __getnewargs__(self) -> tuple[int]: ...\n\n@final\nclass slice:\n    @property\n    def start(self) -> Any: ...\n    @property\n    def step(self) -> Any: ...\n    @property\n    def stop(self) -> Any: ...\n    @overload\n    def __init__(self, __stop: Any) -> None: ...\n    @overload\n    def __init__(self, __start: Any, __stop: Any, __step: Any = ...) -> None: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def indices(self, __len: SupportsIndex) -> tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls, __iterable: Iterable[_T_co] = ...) -> Self: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, __key: object) -> bool: ...\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> _T_co: ...\n    @overload\n    def __getitem__(self, __key: slice) -> tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, __value: tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, __value: tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, __value: tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, __value: tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, __value: tuple[_T_co, ...]) -> tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, __value: tuple[_T, ...]) -> tuple[_T_co | _T, ...]: ...\n    def __mul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...\n    def __rmul__(self, __value: SupportsIndex) -> tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(self, __value: Any, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\n# Doesn't exist at runtime, but deleting this breaks mypy. See #2999\n@final\n@type_check_only\nclass function:\n    # Make sure this class definition stays roughly in line with `types.FunctionType`\n    @property\n    def __closure__(self) -> tuple[_Cell, ...] | None: ...\n    __code__: CodeType\n    __defaults__: tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    @property\n    def __globals__(self) -> dict[str, Any]: ...\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    if sys.version_info >= (3, 10):\n        @property\n        def __builtins__(self) -> dict[str, Any]: ...\n\n    __module__: str\n    # mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.\n    def __get__(self, __instance: object, __owner: type | None = None) -> Any: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[_T]) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = -1) -> _T: ...\n    # Signature of `list.index` should be kept in line with `collections.UserList.index()`\n    # and multiprocessing.managers.ListProxy.index()\n    def index(self, __value: _T, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`\n    # and multiprocessing.managers.ListProxy.sort()\n    #\n    # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]\n    # to work around invariance\n    @overload\n    def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...\n    @overload\n    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    @overload\n    def __getitem__(self, __i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, __s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: Iterable[_T]) -> None: ...\n    def __delitem__(self, __key: SupportsIndex | slice) -> None: ...\n    # Overloading looks unnecessary, but is needed to work around complex mypy problems\n    @overload\n    def __add__(self, __value: list[_T]) -> list[_T]: ...\n    @overload\n    def __add__(self, __value: list[_S]) -> list[_S | _T]: ...\n    def __iadd__(self, __value: Iterable[_T]) -> Self: ...  # type: ignore[misc]\n    def __mul__(self, __value: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, __value: SupportsIndex) -> list[_T]: ...\n    def __imul__(self, __value: SupportsIndex) -> Self: ...\n    def __contains__(self, __key: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, __value: list[_T]) -> bool: ...\n    def __ge__(self, __value: list[_T]) -> bool: ...\n    def __lt__(self, __value: list[_T]) -> bool: ...\n    def __le__(self, __value: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    # __init__ should be kept roughly in line with `collections.UserDict.__init__`, which has similar semantics\n    # Also multiprocessing.managers.SyncManager.dict()\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __map: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], __map: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> None: ...\n    # Next overload is for dict(string.split(sep) for string in iterable)\n    # Cannot be Iterable[Sequence[_T]] or otherwise dict([\"foo\", \"bar\", \"baz\"]) is not an error\n    @overload\n    def __init__(self: dict[str, str], __iterable: Iterable[list[str]]) -> None: ...\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def keys(self) -> dict_keys[_KT, _VT]: ...\n    def values(self) -> dict_values[_KT, _VT]: ...\n    def items(self) -> dict_items[_KT, _VT]: ...\n    # Signature of `dict.fromkeys` should be kept identical to `fromkeys` methods of `OrderedDict`/`ChainMap`/`UserDict` in `collections`\n    # TODO: the true signature of `dict.fromkeys` is not expressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: None = None) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    # Positional-only in dict, but not in MutableMapping\n    @overload\n    def get(self, __key: _KT) -> _VT | None: ...\n    @overload\n    def get(self, __key: _KT, __default: _VT | _T) -> _VT | _T: ...\n    @overload\n    def pop(self, __key: _KT) -> _VT: ...\n    @overload\n    def pop(self, __key: _KT, __default: _VT | _T) -> _VT | _T: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, __key: _KT) -> _VT: ...\n    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...\n    def __delitem__(self, __key: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        # dict.__ior__ should be kept roughly in line with MutableMapping.update()\n        @overload  # type: ignore[misc]\n        def __ior__(self, __value: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n        @overload\n        def __ior__(self, __value: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass set(MutableSet[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[_T]) -> None: ...\n    def add(self, __element: _T) -> None: ...\n    def copy(self) -> set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, __element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, __s: Iterable[Any]) -> bool: ...\n    def issubset(self, __s: Iterable[Any]) -> bool: ...\n    def issuperset(self, __s: Iterable[Any]) -> bool: ...\n    def remove(self, __element: _T) -> None: ...\n    def symmetric_difference(self, __s: Iterable[_T]) -> set[_T]: ...\n    def symmetric_difference_update(self, __s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, __o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __and__(self, __value: AbstractSet[object]) -> set[_T]: ...\n    def __iand__(self, __value: AbstractSet[object]) -> Self: ...\n    def __or__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...\n    def __ior__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]\n    def __sub__(self, __value: AbstractSet[_T | None]) -> set[_T]: ...\n    def __isub__(self, __value: AbstractSet[object]) -> Self: ...\n    def __xor__(self, __value: AbstractSet[_S]) -> set[_T | _S]: ...\n    def __ixor__(self, __value: AbstractSet[_T]) -> Self: ...  # type: ignore[override,misc]\n    def __le__(self, __value: AbstractSet[object]) -> bool: ...\n    def __lt__(self, __value: AbstractSet[object]) -> bool: ...\n    def __ge__(self, __value: AbstractSet[object]) -> bool: ...\n    def __gt__(self, __value: AbstractSet[object]) -> bool: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls) -> Self: ...\n    @overload\n    def __new__(cls, __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> frozenset[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...\n    def isdisjoint(self, __s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, __s: Iterable[object]) -> bool: ...\n    def issuperset(self, __s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, __s: Iterable[_T_co]) -> frozenset[_T_co]: ...\n    def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, __o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __and__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...\n    def __or__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...\n    def __sub__(self, __value: AbstractSet[_T_co]) -> frozenset[_T_co]: ...\n    def __xor__(self, __value: AbstractSet[_S]) -> frozenset[_T_co | _S]: ...\n    def __le__(self, __value: AbstractSet[object]) -> bool: ...\n    def __lt__(self, __value: AbstractSet[object]) -> bool: ...\n    def __ge__(self, __value: AbstractSet[object]) -> bool: ...\n    def __gt__(self, __value: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\n@final\nclass range(Sequence[int]):\n    @property\n    def start(self) -> int: ...\n    @property\n    def stop(self) -> int: ...\n    @property\n    def step(self) -> int: ...\n    @overload\n    def __init__(self, __stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(self, __start: SupportsIndex, __stop: SupportsIndex, __step: SupportsIndex = ...) -> None: ...\n    def count(self, __value: int) -> int: ...\n    def index(self, __value: int) -> int: ...  # type: ignore[override]\n    def __len__(self) -> int: ...\n    def __contains__(self, __key: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, __key: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, __key: slice) -> range: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property:\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    __isabstractmethod__: bool\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, __fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, __fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, __fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, __instance: Any) -> None: ...\n\n@final\nclass _NotImplementedType(Any):\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore[valid-type]  # pyright: ignore[reportGeneralTypeIssues]\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef ascii(__obj: object) -> str: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\ndef breakpoint(*args: Any, **kws: Any) -> None: ...\ndef callable(__obj: object) -> TypeGuard[Callable[..., object]]: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\nclass _PathLike(Protocol[AnyStr_co]):\n    def __fspath__(self) -> AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__async_iterable: SupportsAiter[_SupportsAnextT]) -> _SupportsAnextT: ...\n\n    class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):\n        def __anext__(self) -> _AwaitableT_co: ...\n\n    @overload\n    # `anext` is not, in fact, an async function. When default is not provided\n    # `anext` is just a passthrough for `obj.__anext__`\n    # See discussion in #7491 and pure-Python implementation of `anext` at https://github.com/python/cpython/blob/ea786a882b9ed4261eafabad6011bc7ef3b5bf94/Lib/test/test_asyncgen.py#L52-L80\n    def anext(__i: _SupportsSynchronousAnext[_AwaitableT]) -> _AwaitableT: ...\n    @overload\n    async def anext(__i: SupportsAnext[_T], default: _VT) -> _T | _VT: ...\n\n# compile() returns a CodeType, unless the flags argument includes PyCF_ONLY_AST (=1024),\n# in which case it returns ast.AST. We have overloads for flag 0 (the default) and for\n# explicitly passing PyCF_ONLY_AST. We fall back to Any for other values of flags.\nif sys.version_info >= (3, 8):\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: Literal[0],\n        dont_inherit: bool = False,\n        optimize: int = -1,\n        *,\n        _feature_version: int = -1,\n    ) -> CodeType: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        *,\n        dont_inherit: bool = False,\n        optimize: int = -1,\n        _feature_version: int = -1,\n    ) -> CodeType: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: Literal[1024],\n        dont_inherit: bool = False,\n        optimize: int = -1,\n        *,\n        _feature_version: int = -1,\n    ) -> _ast.AST: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: int,\n        dont_inherit: bool = False,\n        optimize: int = -1,\n        *,\n        _feature_version: int = -1,\n    ) -> Any: ...\n\nelse:\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: Literal[0],\n        dont_inherit: bool = False,\n        optimize: int = -1,\n    ) -> CodeType: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        *,\n        dont_inherit: bool = False,\n        optimize: int = -1,\n    ) -> CodeType: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: Literal[1024],\n        dont_inherit: bool = False,\n        optimize: int = -1,\n    ) -> _ast.AST: ...\n    @overload\n    def compile(\n        source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n        filename: str | ReadableBuffer | _PathLike[Any],\n        mode: str,\n        flags: int,\n        dont_inherit: bool = False,\n        optimize: int = -1,\n    ) -> Any: ...\n\ndef copyright() -> None: ...\ndef credits() -> None: ...\ndef delattr(__obj: object, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\n\n# The `globals` argument to `eval` has to be `dict[str, Any]` rather than `dict[str, object]` due to invariance.\n# (The `globals` argument has to be a \"real dict\", rather than any old mapping, unlike the `locals` argument.)\ndef eval(\n    __source: str | ReadableBuffer | CodeType,\n    __globals: dict[str, Any] | None = None,\n    __locals: Mapping[str, object] | None = None,\n) -> Any: ...\n\n# Comment above regarding `eval` applies to `exec` as well\nif sys.version_info >= (3, 11):\n    def exec(\n        __source: str | ReadableBuffer | CodeType,\n        __globals: dict[str, Any] | None = None,\n        __locals: Mapping[str, object] | None = None,\n        *,\n        closure: tuple[_Cell, ...] | None = None,\n    ) -> None: ...\n\nelse:\n    def exec(\n        __source: str | ReadableBuffer | CodeType,\n        __globals: dict[str, Any] | None = None,\n        __locals: Mapping[str, object] | None = None,\n    ) -> None: ...\n\ndef exit(code: sys._ExitCode = None) -> NoReturn: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(self, __function: Callable[[_S], TypeGuard[_T]], __iterable: Iterable[_S]) -> None: ...\n    @overload\n    def __init__(self, __function: Callable[[_T], Any], __iterable: Iterable[_T]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\ndef format(__value: object, __format_spec: str = \"\") -> str: ...\n@overload\ndef getattr(__o: object, __name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None, bool\n# and basic containers help mypy out in some tricky situations involving type context\n# (aka bidirectional inference)\n@overload\ndef getattr(__o: object, __name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, __name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: list[Any]) -> Any | list[Any]: ...\n@overload\ndef getattr(__o: object, name: str, __default: dict[Any, Any]) -> Any | dict[Any, Any]: ...\n@overload\ndef getattr(__o: object, __name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(request: object = ...) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: object = \"\") -> str: ...\n\nclass _GetItemIterable(Protocol[_T_co]):\n    def __getitem__(self, __i: int) -> _T_co: ...\n\n@overload\ndef iter(__iterable: SupportsIter[_SupportsNextT]) -> _SupportsNextT: ...\n@overload\ndef iter(__iterable: _GetItemIterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: object) -> Iterator[_T]: ...\n\n# Keep this alias in sync with unittest.case._ClassInfo\nif sys.version_info >= (3, 10):\n    _ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]\nelse:\n    _ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]\n\ndef isinstance(__obj: object, __class_or_tuple: _ClassInfo) -> bool: ...\ndef issubclass(__cls: type, __class_or_tuple: _ClassInfo) -> bool: ...\ndef len(__obj: Sized) -> int: ...\ndef license() -> None: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(self, __func: Callable[[_T1, _T2], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> None: ...\n    @overload\n    def __init__(\n        self, __func: Callable[[_T1, _T2, _T3], _S], __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None\n) -> SupportsRichComparisonT: ...\n@overload\ndef max(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef max(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...\n@overload\ndef max(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsRichComparisonT, __arg2: SupportsRichComparisonT, *_args: SupportsRichComparisonT, key: None = None\n) -> SupportsRichComparisonT: ...\n@overload\ndef min(__arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None) -> SupportsRichComparisonT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef min(__iterable: Iterable[SupportsRichComparisonT], *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...\n@overload\ndef min(__iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...\n@overload\ndef next(__i: SupportsNext[_T]) -> _T: ...\n@overload\ndef next(__i: SupportsNext[_T], __default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_Opener: TypeAlias = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenTextMode = \"r\",\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> TextIOWrapper: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryMode,\n    buffering: Literal[0],\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> FileIO: ...\n\n# Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeUpdating,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedRandom: ...\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeWriting,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedWriter: ...\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeReading,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedReader: ...\n\n# Buffering cannot be determined: fall back to BinaryIO\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryMode,\n    buffering: int = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: str,\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes | bytearray) -> int: ...\n\nclass _SupportsWriteAndFlush(SupportsWrite[_T_contra], Protocol[_T_contra]):\n    def flush(self) -> None: ...\n\n@overload\ndef print(\n    *values: object,\n    sep: str | None = \" \",\n    end: str | None = \"\\n\",\n    file: SupportsWrite[str] | None = None,\n    flush: Literal[False] = False,\n) -> None: ...\n@overload\ndef print(\n    *values: object, sep: str | None = \" \", end: str | None = \"\\n\", file: _SupportsWriteAndFlush[str] | None = None, flush: bool\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3NoneOnly(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E, __modulo: None = None) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\n_SupportsSomeKindOfPow = (  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed\n    _SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]\n)\n\nif sys.version_info >= (3, 8):\n    # TODO: `pow(int, int, Literal[0])` fails at runtime,\n    # but adding a `NoReturn` overload isn't a good solution for expressing that (see #8566).\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: int, exp: Literal[0], mod: None = None) -> Literal[1]: ...\n    @overload\n    def pow(base: int, exp: _PositiveInteger, mod: None = None) -> int: ...\n    @overload\n    def pow(base: int, exp: _NegativeInteger, mod: None = None) -> float: ...\n    # int base & positive-int exp -> int; int base & negative-int exp -> float\n    # return type must be Any as `int | float` causes too many false-positive errors\n    @overload\n    def pow(base: int, exp: int, mod: None = None) -> Any: ...\n    @overload\n    def pow(base: _PositiveInteger, exp: float, mod: None = None) -> float: ...\n    @overload\n    def pow(base: _NegativeInteger, exp: float, mod: None = None) -> complex: ...\n    @overload\n    def pow(base: float, exp: int, mod: None = None) -> float: ...\n    # float base & float exp could return float or complex\n    # return type must be Any (same as complex base, complex exp),\n    # as `float | complex` causes too many false-positive errors\n    @overload\n    def pow(base: float, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> Any: ...\n    @overload\n    def pow(base: complex, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> complex: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E, mod: None = None) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3NoneOnly[_E, _T_co], exp: _E, mod: None = None) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...\n    @overload\n    def pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...\n\nelse:\n    @overload\n    def pow(__x: int, __y: int, __z: int) -> int: ...\n    @overload\n    def pow(__x: int, __y: Literal[0], __z: None = None) -> Literal[1]: ...\n    @overload\n    def pow(__x: int, __y: _PositiveInteger, __z: None = None) -> int: ...\n    @overload\n    def pow(__x: int, __y: _NegativeInteger, __z: None = None) -> float: ...\n    @overload\n    def pow(__x: int, __y: int, __z: None = None) -> Any: ...\n    @overload\n    def pow(__x: _PositiveInteger, __y: float, __z: None = None) -> float: ...\n    @overload\n    def pow(__x: _NegativeInteger, __y: float, __z: None = None) -> complex: ...\n    @overload\n    def pow(__x: float, __y: int, __z: None = None) -> float: ...\n    @overload\n    def pow(__x: float, __y: complex | _SupportsSomeKindOfPow, __z: None = None) -> Any: ...\n    @overload\n    def pow(__x: complex, __y: complex | _SupportsSomeKindOfPow, __z: None = None) -> complex: ...\n    @overload\n    def pow(__x: _SupportsPow2[_E, _T_co], __y: _E, __z: None = None) -> _T_co: ...\n    @overload\n    def pow(__x: _SupportsPow3NoneOnly[_E, _T_co], __y: _E, __z: None = None) -> _T_co: ...\n    @overload\n    def pow(__x: _SupportsPow3[_E, _M, _T_co], __y: _E, __z: _M) -> _T_co: ...\n    @overload\n    def pow(__x: _SupportsSomeKindOfPow, __y: float, __z: None = None) -> Any: ...\n    @overload\n    def pow(__x: _SupportsSomeKindOfPow, __y: complex, __z: None = None) -> complex: ...\n\ndef quit(code: sys._ExitCode = None) -> NoReturn: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n    def __length_hint__(self) -> int: ...\n\ndef repr(__obj: object) -> str: ...\n\n# See https://github.com/python/typeshed/pull/9141\n# and https://github.com/python/typeshed/pull/9151\n# on why we don't use `SupportsRound` from `typing.pyi`\n\nclass _SupportsRound1(Protocol[_T_co]):\n    def __round__(self) -> _T_co: ...\n\nclass _SupportsRound2(Protocol[_T_co]):\n    def __round__(self, __ndigits: int) -> _T_co: ...\n\n@overload\ndef round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...\n@overload\ndef round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...\n\n# See https://github.com/python/typeshed/pull/6292#discussion_r748875189\n# for why arg 3 of `setattr` should be annotated with `Any` and not `object`\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsRichComparisonT], *, key: None = None, reverse: bool = False\n) -> list[SupportsRichComparisonT]: ...\n@overload\ndef sorted(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...\n\n_AddableT1 = TypeVar(\"_AddableT1\", bound=SupportsAdd[Any, Any])\n_AddableT2 = TypeVar(\"_AddableT2\", bound=SupportsAdd[Any, Any])\n\nclass _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...\n\n_SupportsSumNoDefaultT = TypeVar(\"_SupportsSumNoDefaultT\", bound=_SupportsSumWithNoDefaultGiven)\n\n# In general, the return type of `x + x` is *not* guaranteed to be the same type as x.\n# However, we can't express that in the stub for `sum()`\n# without creating many false-positive errors (see #7578).\n# Instead, we special-case the most common examples of this: bool and literal integers.\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[bool | _LiteralInteger], start: int = 0) -> int: ...  # type: ignore[misc]\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[bool | _LiteralInteger], __start: int = 0) -> int: ...  # type: ignore[misc]\n\n@overload\ndef sum(__iterable: Iterable[_SupportsSumNoDefaultT]) -> _SupportsSumNoDefaultT | Literal[0]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_AddableT1], start: _AddableT2) -> _AddableT1 | _AddableT2: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_AddableT1], __start: _AddableT2) -> _AddableT1 | _AddableT2: ...\n\n# The argument to `vars()` has to have a `__dict__` attribute, so the second overload can't be annotated with `object`\n# (A \"SupportsDunderDict\" protocol doesn't work)\n# Use a type: ignore to make complaints about overlapping overloads go away\n@overload\ndef vars(__object: type) -> types.MappingProxyType[str, Any]: ...  # type: ignore[misc]\n@overload\ndef vars(__object: Any = ...) -> dict[str, Any]: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    if sys.version_info >= (3, 10):\n        @overload\n        def __new__(cls, __iter1: Iterable[_T1], *, strict: bool = ...) -> zip[tuple[_T1]]: ...\n        @overload\n        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], *, strict: bool = ...) -> zip[tuple[_T1, _T2]]: ...\n        @overload\n        def __new__(\n            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], *, strict: bool = ...\n        ) -> zip[tuple[_T1, _T2, _T3]]: ...\n        @overload\n        def __new__(\n            cls,\n            __iter1: Iterable[_T1],\n            __iter2: Iterable[_T2],\n            __iter3: Iterable[_T3],\n            __iter4: Iterable[_T4],\n            *,\n            strict: bool = ...,\n        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...\n        @overload\n        def __new__(\n            cls,\n            __iter1: Iterable[_T1],\n            __iter2: Iterable[_T2],\n            __iter3: Iterable[_T3],\n            __iter4: Iterable[_T4],\n            __iter5: Iterable[_T5],\n            *,\n            strict: bool = ...,\n        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n        @overload\n        def __new__(\n            cls,\n            __iter1: Iterable[Any],\n            __iter2: Iterable[Any],\n            __iter3: Iterable[Any],\n            __iter4: Iterable[Any],\n            __iter5: Iterable[Any],\n            __iter6: Iterable[Any],\n            *iterables: Iterable[Any],\n            strict: bool = ...,\n        ) -> zip[tuple[Any, ...]]: ...\n    else:\n        @overload\n        def __new__(cls, __iter1: Iterable[_T1]) -> zip[tuple[_T1]]: ...\n        @overload\n        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip[tuple[_T1, _T2]]: ...\n        @overload\n        def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> zip[tuple[_T1, _T2, _T3]]: ...\n        @overload\n        def __new__(\n            cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]\n        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...\n        @overload\n        def __new__(\n            cls,\n            __iter1: Iterable[_T1],\n            __iter2: Iterable[_T2],\n            __iter3: Iterable[_T3],\n            __iter4: Iterable[_T4],\n            __iter5: Iterable[_T5],\n        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n        @overload\n        def __new__(\n            cls,\n            __iter1: Iterable[Any],\n            __iter2: Iterable[Any],\n            __iter3: Iterable[Any],\n            __iter4: Iterable[Any],\n            __iter5: Iterable[Any],\n            __iter6: Iterable[Any],\n            *iterables: Iterable[Any],\n        ) -> zip[tuple[Any, ...]]: ...\n\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n# Signature of `builtins.__import__` should be kept identical to `importlib.__import__`\n# Return type of `__import__` should be kept the same as return type of `importlib.import_module`\ndef __import__(\n    name: str,\n    globals: Mapping[str, object] | None = None,\n    locals: Mapping[str, object] | None = None,\n    fromlist: Sequence[str] = (),\n    level: int = 0,\n) -> types.ModuleType: ...\ndef __build_class__(__func: Callable[[], _Cell | Any], __name: str, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\n@final\n@type_check_only\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException:\n    args: tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __setstate__(self, __state: dict[str, Any] | None) -> None: ...\n    def with_traceback(self, __tb: TracebackType | None) -> Self: ...\n    if sys.version_info >= (3, 11):\n        # only present after add_note() is called\n        __notes__: list[str]\n        def add_note(self, __note: str) -> None: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: sys._ExitCode\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nEnvironmentError = OSError\nIOError = OSError\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(Exception): ...\nclass AssertionError(Exception): ...\n\nclass AttributeError(Exception):\n    if sys.version_info >= (3, 10):\n        def __init__(self, *args: object, name: str | None = ..., obj: object = ...) -> None: ...\n        name: str\n        obj: object\n\nclass BufferError(Exception): ...\nclass EOFError(Exception): ...\n\nclass ImportError(Exception):\n    def __init__(self, *args: object, name: str | None = ..., path: str | None = ...) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(Exception): ...\nclass MemoryError(Exception): ...\n\nclass NameError(Exception):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass ReferenceError(Exception): ...\nclass RuntimeError(Exception): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(Exception):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass SystemError(Exception): ...\nclass TypeError(Exception): ...\nclass ValueError(Exception): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass ModuleNotFoundError(ImportError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass UnboundLocalError(NameError): ...\n\nclass BlockingIOError(OSError):\n    characters_written: int\n\nclass ChildProcessError(OSError): ...\nclass ConnectionError(OSError): ...\nclass BrokenPipeError(ConnectionError): ...\nclass ConnectionAbortedError(ConnectionError): ...\nclass ConnectionRefusedError(ConnectionError): ...\nclass ConnectionResetError(ConnectionError): ...\nclass FileExistsError(OSError): ...\nclass FileNotFoundError(OSError): ...\nclass InterruptedError(OSError): ...\nclass IsADirectoryError(OSError): ...\nclass NotADirectoryError(OSError): ...\nclass PermissionError(OSError): ...\nclass ProcessLookupError(OSError): ...\nclass TimeoutError(OSError): ...\nclass NotImplementedError(RuntimeError): ...\nclass RecursionError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\nclass UnicodeError(ValueError): ...\n\nclass UnicodeDecodeError(UnicodeError):\n    encoding: str\n    object: bytes\n    start: int\n    end: int\n    reason: str\n    def __init__(self, __encoding: str, __object: ReadableBuffer, __start: int, __end: int, __reason: str) -> None: ...\n\nclass UnicodeEncodeError(UnicodeError):\n    encoding: str\n    object: str\n    start: int\n    end: int\n    reason: str\n    def __init__(self, __encoding: str, __object: str, __start: int, __end: int, __reason: str) -> None: ...\n\nclass UnicodeTranslateError(UnicodeError):\n    encoding: None\n    object: str\n    start: int\n    end: int\n    reason: str\n    def __init__(self, __object: str, __start: int, __end: int, __reason: str) -> None: ...\n\nclass Warning(Exception): ...\nclass UserWarning(Warning): ...\nclass DeprecationWarning(Warning): ...\nclass SyntaxWarning(Warning): ...\nclass RuntimeWarning(Warning): ...\nclass FutureWarning(Warning): ...\nclass PendingDeprecationWarning(Warning): ...\nclass ImportWarning(Warning): ...\nclass UnicodeWarning(Warning): ...\nclass BytesWarning(Warning): ...\nclass ResourceWarning(Warning): ...\n\nif sys.version_info >= (3, 10):\n    class EncodingWarning(Warning): ...\n\nif sys.version_info >= (3, 11):\n    _BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True)\n    _BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n    _ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n    _ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\n\n    # See `check_exception_group.py` for use-cases and comments.\n    class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n        def __new__(cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> Self: ...\n        def __init__(self, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> None: ...\n        @property\n        def message(self) -> str: ...\n        @property\n        def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...\n        @overload\n        def subgroup(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n        @overload\n        def subgroup(\n            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n        ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...\n        @overload\n        def subgroup(\n            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]\n        ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...\n        @overload\n        def split(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]\n        ) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, __condition: Callable[[_BaseExceptionT_co | Self], bool]\n        ) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        # In reality it is `NonEmptySequence`:\n        @overload\n        def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...\n        @overload\n        def derive(self, __excs: Sequence[_BaseExceptionT]) -> BaseExceptionGroup[_BaseExceptionT]: ...\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\n    class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n        def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self: ...\n        def __init__(self, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> None: ...\n        @property\n        def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...\n        # We accept a narrower type, but that's OK.\n        @overload  # type: ignore[override]\n        def subgroup(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n        @overload\n        def subgroup(self, __condition: Callable[[_ExceptionT_co | Self], bool]) -> ExceptionGroup[_ExceptionT_co] | None: ...\n        @overload  # type: ignore[override]\n        def split(\n            self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]\n        ) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, __condition: Callable[[_ExceptionT_co | Self], bool]\n        ) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...\n",
  "/typeshed/stdlib/bz2.pyi": "import _compression\nimport sys\nfrom _compression import BaseStream\nfrom _typeshed import ReadableBuffer, StrOrBytesPath, WriteableBuffer\nfrom collections.abc import Iterable\nfrom typing import IO, Any, Protocol, TextIO, overload\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias, final\n\n__all__ = [\"BZ2File\", \"BZ2Compressor\", \"BZ2Decompressor\", \"open\", \"compress\", \"decompress\"]\n\n# The following attributes and methods are optional:\n# def fileno(self) -> int: ...\n# def close(self) -> object: ...\nclass _ReadableFileobj(_compression._Reader, Protocol): ...\n\nclass _WritableFileobj(Protocol):\n    def write(self, __b: bytes) -> object: ...\n    # The following attributes and methods are optional:\n    # def fileno(self) -> int: ...\n    # def close(self) -> object: ...\n\ndef compress(data: ReadableBuffer, compresslevel: int = 9) -> bytes: ...\ndef decompress(data: ReadableBuffer) -> bytes: ...\n\n_ReadBinaryMode: TypeAlias = Literal[\"\", \"r\", \"rb\"]\n_WriteBinaryMode: TypeAlias = Literal[\"w\", \"wb\", \"x\", \"xb\", \"a\", \"ab\"]\n_ReadTextMode: TypeAlias = Literal[\"rt\"]\n_WriteTextMode: TypeAlias = Literal[\"wt\", \"xt\", \"at\"]\n\n@overload\ndef open(\n    filename: _ReadableFileobj,\n    mode: _ReadBinaryMode = \"rb\",\n    compresslevel: int = 9,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> BZ2File: ...\n@overload\ndef open(\n    filename: _ReadableFileobj,\n    mode: _ReadTextMode,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: _WritableFileobj,\n    mode: _WriteBinaryMode,\n    compresslevel: int = 9,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> BZ2File: ...\n@overload\ndef open(\n    filename: _WritableFileobj,\n    mode: _WriteTextMode,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: StrOrBytesPath,\n    mode: _ReadBinaryMode | _WriteBinaryMode = \"rb\",\n    compresslevel: int = 9,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> BZ2File: ...\n@overload\ndef open(\n    filename: StrOrBytesPath,\n    mode: _ReadTextMode | _WriteTextMode,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: StrOrBytesPath | _ReadableFileobj | _WritableFileobj,\n    mode: str,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> BZ2File | TextIO: ...\n\nclass BZ2File(BaseStream, IO[bytes]):\n    def __enter__(self) -> Self: ...\n    if sys.version_info >= (3, 9):\n        @overload\n        def __init__(self, filename: _WritableFileobj, mode: _WriteBinaryMode, *, compresslevel: int = 9) -> None: ...\n        @overload\n        def __init__(self, filename: _ReadableFileobj, mode: _ReadBinaryMode = \"r\", *, compresslevel: int = 9) -> None: ...\n        @overload\n        def __init__(\n            self, filename: StrOrBytesPath, mode: _ReadBinaryMode | _WriteBinaryMode = \"r\", *, compresslevel: int = 9\n        ) -> None: ...\n    else:\n        @overload\n        def __init__(\n            self, filename: _WritableFileobj, mode: _WriteBinaryMode, buffering: Any | None = None, compresslevel: int = 9\n        ) -> None: ...\n        @overload\n        def __init__(\n            self, filename: _ReadableFileobj, mode: _ReadBinaryMode = \"r\", buffering: Any | None = None, compresslevel: int = 9\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            filename: StrOrBytesPath,\n            mode: _ReadBinaryMode | _WriteBinaryMode = \"r\",\n            buffering: Any | None = None,\n            compresslevel: int = 9,\n        ) -> None: ...\n\n    def read(self, size: int | None = -1) -> bytes: ...\n    def read1(self, size: int = -1) -> bytes: ...\n    def readline(self, size: SupportsIndex = -1) -> bytes: ...  # type: ignore[override]\n    def readinto(self, b: WriteableBuffer) -> int: ...\n    def readlines(self, size: SupportsIndex = -1) -> list[bytes]: ...\n    def seek(self, offset: int, whence: int = 0) -> int: ...\n    def write(self, data: ReadableBuffer) -> int: ...\n    def writelines(self, seq: Iterable[ReadableBuffer]) -> None: ...\n\n@final\nclass BZ2Compressor:\n    def __init__(self, compresslevel: int = ...) -> None: ...\n    def compress(self, __data: ReadableBuffer) -> bytes: ...\n    def flush(self) -> bytes: ...\n\n@final\nclass BZ2Decompressor:\n    def decompress(self, data: ReadableBuffer, max_length: int = -1) -> bytes: ...\n    @property\n    def eof(self) -> bool: ...\n    @property\n    def needs_input(self) -> bool: ...\n    @property\n    def unused_data(self) -> bytes: ...\n",
  "/typeshed/stdlib/cProfile.pyi": "import sys\nfrom _typeshed import StrOrBytesPath, Unused\nfrom collections.abc import Callable\nfrom types import CodeType\nfrom typing import Any, TypeVar\nfrom typing_extensions import ParamSpec, Self, TypeAlias\n\n__all__ = [\"run\", \"runctx\", \"Profile\"]\n\ndef run(statement: str, filename: str | None = None, sort: str | int = -1) -> None: ...\ndef runctx(\n    statement: str, globals: dict[str, Any], locals: dict[str, Any], filename: str | None = None, sort: str | int = -1\n) -> None: ...\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n_Label: TypeAlias = tuple[str, int, str]\n\nclass Profile:\n    stats: dict[_Label, tuple[int, int, int, int, dict[_Label, tuple[int, int, int, int]]]]  # undocumented\n    def __init__(\n        self, timer: Callable[[], float] = ..., timeunit: float = ..., subcalls: bool = ..., builtins: bool = ...\n    ) -> None: ...\n    def enable(self) -> None: ...\n    def disable(self) -> None: ...\n    def print_stats(self, sort: str | int = -1) -> None: ...\n    def dump_stats(self, file: StrOrBytesPath) -> None: ...\n    def create_stats(self) -> None: ...\n    def snapshot_stats(self) -> None: ...\n    def run(self, cmd: str) -> Self: ...\n    def runctx(self, cmd: str, globals: dict[str, Any], locals: dict[str, Any]) -> Self: ...\n    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def __enter__(self) -> Self: ...\n        def __exit__(self, *exc_info: Unused) -> None: ...\n\ndef label(code: str | CodeType) -> _Label: ...  # undocumented\n",
  "/typeshed/stdlib/calendar.pyi": "import datetime\nimport sys\nfrom _typeshed import Unused\nfrom collections.abc import Iterable, Sequence\nfrom time import struct_time\nfrom typing import ClassVar\nfrom typing_extensions import Literal, TypeAlias\n\n__all__ = [\n    \"IllegalMonthError\",\n    \"IllegalWeekdayError\",\n    \"setfirstweekday\",\n    \"firstweekday\",\n    \"isleap\",\n    \"leapdays\",\n    \"weekday\",\n    \"monthrange\",\n    \"monthcalendar\",\n    \"prmonth\",\n    \"month\",\n    \"prcal\",\n    \"calendar\",\n    \"timegm\",\n    \"month_name\",\n    \"month_abbr\",\n    \"day_name\",\n    \"day_abbr\",\n    \"Calendar\",\n    \"TextCalendar\",\n    \"HTMLCalendar\",\n    \"LocaleTextCalendar\",\n    \"LocaleHTMLCalendar\",\n    \"weekheader\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"FRIDAY\", \"MONDAY\", \"SATURDAY\", \"SUNDAY\", \"THURSDAY\", \"TUESDAY\", \"WEDNESDAY\"]\n\n_LocaleType: TypeAlias = tuple[str | None, str | None]\n\nclass IllegalMonthError(ValueError):\n    def __init__(self, month: int) -> None: ...\n\nclass IllegalWeekdayError(ValueError):\n    def __init__(self, weekday: int) -> None: ...\n\ndef isleap(year: int) -> bool: ...\ndef leapdays(y1: int, y2: int) -> int: ...\ndef weekday(year: int, month: int, day: int) -> int: ...\ndef monthrange(year: int, month: int) -> tuple[int, int]: ...\n\nclass Calendar:\n    firstweekday: int\n    def __init__(self, firstweekday: int = 0) -> None: ...\n    def getfirstweekday(self) -> int: ...\n    def setfirstweekday(self, firstweekday: int) -> None: ...\n    def iterweekdays(self) -> Iterable[int]: ...\n    def itermonthdates(self, year: int, month: int) -> Iterable[datetime.date]: ...\n    def itermonthdays2(self, year: int, month: int) -> Iterable[tuple[int, int]]: ...\n    def itermonthdays(self, year: int, month: int) -> Iterable[int]: ...\n    def monthdatescalendar(self, year: int, month: int) -> list[list[datetime.date]]: ...\n    def monthdays2calendar(self, year: int, month: int) -> list[list[tuple[int, int]]]: ...\n    def monthdayscalendar(self, year: int, month: int) -> list[list[int]]: ...\n    def yeardatescalendar(self, year: int, width: int = 3) -> list[list[int]]: ...\n    def yeardays2calendar(self, year: int, width: int = 3) -> list[list[tuple[int, int]]]: ...\n    def yeardayscalendar(self, year: int, width: int = 3) -> list[list[int]]: ...\n    def itermonthdays3(self, year: int, month: int) -> Iterable[tuple[int, int, int]]: ...\n    def itermonthdays4(self, year: int, month: int) -> Iterable[tuple[int, int, int, int]]: ...\n\nclass TextCalendar(Calendar):\n    def prweek(self, theweek: int, width: int) -> None: ...\n    def formatday(self, day: int, weekday: int, width: int) -> str: ...\n    def formatweek(self, theweek: int, width: int) -> str: ...\n    def formatweekday(self, day: int, width: int) -> str: ...\n    def formatweekheader(self, width: int) -> str: ...\n    def formatmonthname(self, theyear: int, themonth: int, width: int, withyear: bool = True) -> str: ...\n    def prmonth(self, theyear: int, themonth: int, w: int = 0, l: int = 0) -> None: ...\n    def formatmonth(self, theyear: int, themonth: int, w: int = 0, l: int = 0) -> str: ...\n    def formatyear(self, theyear: int, w: int = 2, l: int = 1, c: int = 6, m: int = 3) -> str: ...\n    def pryear(self, theyear: int, w: int = 0, l: int = 0, c: int = 6, m: int = 3) -> None: ...\n\ndef firstweekday() -> int: ...\ndef monthcalendar(year: int, month: int) -> list[list[int]]: ...\ndef prweek(theweek: int, width: int) -> None: ...\ndef week(theweek: int, width: int) -> str: ...\ndef weekheader(width: int) -> str: ...\ndef prmonth(theyear: int, themonth: int, w: int = 0, l: int = 0) -> None: ...\ndef month(theyear: int, themonth: int, w: int = 0, l: int = 0) -> str: ...\ndef calendar(theyear: int, w: int = 2, l: int = 1, c: int = 6, m: int = 3) -> str: ...\ndef prcal(theyear: int, w: int = 0, l: int = 0, c: int = 6, m: int = 3) -> None: ...\n\nclass HTMLCalendar(Calendar):\n    cssclasses: ClassVar[list[str]]\n    cssclass_noday: ClassVar[str]\n    cssclasses_weekday_head: ClassVar[list[str]]\n    cssclass_month_head: ClassVar[str]\n    cssclass_month: ClassVar[str]\n    cssclass_year: ClassVar[str]\n    cssclass_year_head: ClassVar[str]\n    def formatday(self, day: int, weekday: int) -> str: ...\n    def formatweek(self, theweek: int) -> str: ...\n    def formatweekday(self, day: int) -> str: ...\n    def formatweekheader(self) -> str: ...\n    def formatmonthname(self, theyear: int, themonth: int, withyear: bool = True) -> str: ...\n    def formatmonth(self, theyear: int, themonth: int, withyear: bool = True) -> str: ...\n    def formatyear(self, theyear: int, width: int = 3) -> str: ...\n    def formatyearpage(\n        self, theyear: int, width: int = 3, css: str | None = \"calendar.css\", encoding: str | None = None\n    ) -> str: ...\n\nclass different_locale:\n    def __init__(self, locale: _LocaleType) -> None: ...\n    def __enter__(self) -> None: ...\n    def __exit__(self, *args: Unused) -> None: ...\n\nclass LocaleTextCalendar(TextCalendar):\n    def __init__(self, firstweekday: int = 0, locale: _LocaleType | None = None) -> None: ...\n\nclass LocaleHTMLCalendar(HTMLCalendar):\n    def __init__(self, firstweekday: int = 0, locale: _LocaleType | None = None) -> None: ...\n    def formatweekday(self, day: int) -> str: ...\n    def formatmonthname(self, theyear: int, themonth: int, withyear: bool = True) -> str: ...\n\nc: TextCalendar\n\ndef setfirstweekday(firstweekday: int) -> None: ...\ndef format(cols: int, colwidth: int = 20, spacing: int = 6) -> str: ...\ndef formatstring(cols: int, colwidth: int = 20, spacing: int = 6) -> str: ...\ndef timegm(tuple: tuple[int, ...] | struct_time) -> int: ...\n\n# Data attributes\nday_name: Sequence[str]\nday_abbr: Sequence[str]\nmonth_name: Sequence[str]\nmonth_abbr: Sequence[str]\n\nMONDAY: Literal[0]\nTUESDAY: Literal[1]\nWEDNESDAY: Literal[2]\nTHURSDAY: Literal[3]\nFRIDAY: Literal[4]\nSATURDAY: Literal[5]\nSUNDAY: Literal[6]\n\nEPOCH: Literal[1970]\n",
  "/typeshed/stdlib/cgi.pyi": "import sys\nfrom _typeshed import SupportsGetItem, SupportsItemAccess, Unused\nfrom builtins import list as _list, type as _type\nfrom collections.abc import Iterable, Iterator, Mapping\nfrom email.message import Message\nfrom types import TracebackType\nfrom typing import IO, Any, Protocol\nfrom typing_extensions import Self\n\n__all__ = [\n    \"MiniFieldStorage\",\n    \"FieldStorage\",\n    \"parse\",\n    \"parse_multipart\",\n    \"parse_header\",\n    \"test\",\n    \"print_exception\",\n    \"print_environ\",\n    \"print_form\",\n    \"print_directory\",\n    \"print_arguments\",\n    \"print_environ_usage\",\n]\n\nif sys.version_info < (3, 8):\n    __all__ += [\"parse_qs\", \"parse_qsl\", \"escape\"]\n\ndef parse(\n    fp: IO[Any] | None = None,\n    environ: SupportsItemAccess[str, str] = ...,\n    keep_blank_values: bool = ...,\n    strict_parsing: bool = ...,\n    separator: str = \"&\",\n) -> dict[str, list[str]]: ...\n\nif sys.version_info < (3, 8):\n    def parse_qs(qs: str, keep_blank_values: bool = ..., strict_parsing: bool = ...) -> dict[str, list[str]]: ...\n    def parse_qsl(qs: str, keep_blank_values: bool = ..., strict_parsing: bool = ...) -> list[tuple[str, str]]: ...\n\ndef parse_multipart(\n    fp: IO[Any], pdict: SupportsGetItem[str, bytes], encoding: str = \"utf-8\", errors: str = \"replace\", separator: str = \"&\"\n) -> dict[str, list[Any]]: ...\n\nclass _Environ(Protocol):\n    def __getitem__(self, __k: str) -> str: ...\n    def keys(self) -> Iterable[str]: ...\n\ndef parse_header(line: str) -> tuple[str, dict[str, str]]: ...\ndef test(environ: _Environ = ...) -> None: ...\ndef print_environ(environ: _Environ = ...) -> None: ...\ndef print_form(form: dict[str, Any]) -> None: ...\ndef print_directory() -> None: ...\ndef print_environ_usage() -> None: ...\n\nif sys.version_info < (3, 8):\n    def escape(s: str, quote: bool | None = None) -> str: ...\n\nclass MiniFieldStorage:\n    # The first five \"Any\" attributes here are always None, but mypy doesn't support that\n    filename: Any\n    list: Any\n    type: Any\n    file: IO[bytes] | None\n    type_options: dict[Any, Any]\n    disposition: Any\n    disposition_options: dict[Any, Any]\n    headers: dict[Any, Any]\n    name: Any\n    value: Any\n    def __init__(self, name: Any, value: Any) -> None: ...\n\nclass FieldStorage:\n    FieldStorageClass: _type | None\n    keep_blank_values: int\n    strict_parsing: int\n    qs_on_post: str | None\n    headers: Mapping[str, str] | Message\n    fp: IO[bytes]\n    encoding: str\n    errors: str\n    outerboundary: bytes\n    bytes_read: int\n    limit: int | None\n    disposition: str\n    disposition_options: dict[str, str]\n    filename: str | None\n    file: IO[bytes] | None\n    type: str\n    type_options: dict[str, str]\n    innerboundary: bytes\n    length: int\n    done: int\n    list: _list[Any] | None\n    value: None | bytes | _list[Any]\n    def __init__(\n        self,\n        fp: IO[Any] | None = None,\n        headers: Mapping[str, str] | Message | None = None,\n        outerboundary: bytes = b\"\",\n        environ: SupportsGetItem[str, str] = ...,\n        keep_blank_values: int = 0,\n        strict_parsing: int = 0,\n        limit: int | None = None,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n        max_num_fields: int | None = None,\n        separator: str = \"&\",\n    ) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __getitem__(self, key: str) -> Any: ...\n    def getvalue(self, key: str, default: Any = None) -> Any: ...\n    def getfirst(self, key: str, default: Any = None) -> Any: ...\n    def getlist(self, key: str) -> _list[Any]: ...\n    def keys(self) -> _list[str]: ...\n    def __contains__(self, key: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    # In Python 3 it returns bytes or str IO depending on an internal flag\n    def make_file(self) -> IO[Any]: ...\n\ndef print_exception(\n    type: type[BaseException] | None = None,\n    value: BaseException | None = None,\n    tb: TracebackType | None = None,\n    limit: int | None = None,\n) -> None: ...\ndef print_arguments() -> None: ...\n",
  "/typeshed/stdlib/cgitb.pyi": "from _typeshed import OptExcInfo, StrOrBytesPath\nfrom collections.abc import Callable\nfrom types import FrameType, TracebackType\nfrom typing import IO, Any\nfrom typing_extensions import Final\n\n__UNDEF__: Final[object]  # undocumented sentinel\n\ndef reset() -> str: ...  # undocumented\ndef small(text: str) -> str: ...  # undocumented\ndef strong(text: str) -> str: ...  # undocumented\ndef grey(text: str) -> str: ...  # undocumented\ndef lookup(name: str, frame: FrameType, locals: dict[str, Any]) -> tuple[str | None, Any]: ...  # undocumented\ndef scanvars(\n    reader: Callable[[], bytes], frame: FrameType, locals: dict[str, Any]\n) -> list[tuple[str, str | None, Any]]: ...  # undocumented\ndef html(einfo: OptExcInfo, context: int = 5) -> str: ...\ndef text(einfo: OptExcInfo, context: int = 5) -> str: ...\n\nclass Hook:  # undocumented\n    def __init__(\n        self,\n        display: int = 1,\n        logdir: StrOrBytesPath | None = None,\n        context: int = 5,\n        file: IO[str] | None = None,\n        format: str = \"html\",\n    ) -> None: ...\n    def __call__(self, etype: type[BaseException] | None, evalue: BaseException | None, etb: TracebackType | None) -> None: ...\n    def handle(self, info: OptExcInfo | None = None) -> None: ...\n\ndef handler(info: OptExcInfo | None = None) -> None: ...\ndef enable(display: int = 1, logdir: StrOrBytesPath | None = None, context: int = 5, format: str = \"html\") -> None: ...\n",
  "/typeshed/stdlib/chunk.pyi": "from typing import IO\n\nclass Chunk:\n    closed: bool\n    align: bool\n    file: IO[bytes]\n    chunkname: bytes\n    chunksize: int\n    size_read: int\n    offset: int\n    seekable: bool\n    def __init__(self, file: IO[bytes], align: bool = True, bigendian: bool = True, inclheader: bool = False) -> None: ...\n    def getname(self) -> bytes: ...\n    def getsize(self) -> int: ...\n    def close(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def seek(self, pos: int, whence: int = 0) -> None: ...\n    def tell(self) -> int: ...\n    def read(self, size: int = -1) -> bytes: ...\n    def skip(self) -> None: ...\n",
  "/typeshed/stdlib/cmath.pyi": "import sys\nfrom typing import SupportsComplex, SupportsFloat\nfrom typing_extensions import TypeAlias\n\nif sys.version_info >= (3, 8):\n    from typing import SupportsIndex\n\ne: float\npi: float\ninf: float\ninfj: complex\nnan: float\nnanj: complex\ntau: float\n\nif sys.version_info >= (3, 8):\n    _C: TypeAlias = SupportsFloat | SupportsComplex | SupportsIndex | complex\nelse:\n    _C: TypeAlias = SupportsFloat | SupportsComplex | complex\n\ndef acos(__z: _C) -> complex: ...\ndef acosh(__z: _C) -> complex: ...\ndef asin(__z: _C) -> complex: ...\ndef asinh(__z: _C) -> complex: ...\ndef atan(__z: _C) -> complex: ...\ndef atanh(__z: _C) -> complex: ...\ndef cos(__z: _C) -> complex: ...\ndef cosh(__z: _C) -> complex: ...\ndef exp(__z: _C) -> complex: ...\ndef isclose(a: _C, b: _C, *, rel_tol: SupportsFloat = 1e-09, abs_tol: SupportsFloat = 0.0) -> bool: ...\ndef isinf(__z: _C) -> bool: ...\ndef isnan(__z: _C) -> bool: ...\ndef log(__x: _C, __y_obj: _C = ...) -> complex: ...\ndef log10(__z: _C) -> complex: ...\ndef phase(__z: _C) -> float: ...\ndef polar(__z: _C) -> tuple[float, float]: ...\ndef rect(__r: float, __phi: float) -> complex: ...\ndef sin(__z: _C) -> complex: ...\ndef sinh(__z: _C) -> complex: ...\ndef sqrt(__z: _C) -> complex: ...\ndef tan(__z: _C) -> complex: ...\ndef tanh(__z: _C) -> complex: ...\ndef isfinite(__z: _C) -> bool: ...\n",
  "/typeshed/stdlib/cmd.pyi": "from collections.abc import Callable\nfrom typing import IO, Any\nfrom typing_extensions import Literal\n\n__all__ = [\"Cmd\"]\n\nPROMPT: Literal[\"(Cmd) \"]\nIDENTCHARS: str  # Too big to be `Literal`\n\nclass Cmd:\n    prompt: str\n    identchars: str\n    ruler: str\n    lastcmd: str\n    intro: Any | None\n    doc_leader: str\n    doc_header: str\n    misc_header: str\n    undoc_header: str\n    nohelp: str\n    use_rawinput: bool\n    stdin: IO[str]\n    stdout: IO[str]\n    cmdqueue: list[str]\n    completekey: str\n    def __init__(self, completekey: str = \"tab\", stdin: IO[str] | None = None, stdout: IO[str] | None = None) -> None: ...\n    old_completer: Callable[[str, int], str | None] | None\n    def cmdloop(self, intro: Any | None = None) -> None: ...\n    def precmd(self, line: str) -> str: ...\n    def postcmd(self, stop: bool, line: str) -> bool: ...\n    def preloop(self) -> None: ...\n    def postloop(self) -> None: ...\n    def parseline(self, line: str) -> tuple[str | None, str | None, str]: ...\n    def onecmd(self, line: str) -> bool: ...\n    def emptyline(self) -> bool: ...\n    def default(self, line: str) -> None: ...\n    def completedefault(self, *ignored: Any) -> list[str]: ...\n    def completenames(self, text: str, *ignored: Any) -> list[str]: ...\n    completion_matches: list[str] | None\n    def complete(self, text: str, state: int) -> list[str] | None: ...\n    def get_names(self) -> list[str]: ...\n    # Only the first element of args matters.\n    def complete_help(self, *args: Any) -> list[str]: ...\n    def do_help(self, arg: str) -> bool | None: ...\n    def print_topics(self, header: str, cmds: list[str] | None, cmdlen: Any, maxcol: int) -> None: ...\n    def columnize(self, list: list[str] | None, displaywidth: int = 80) -> None: ...\n",
  "/typeshed/stdlib/code.pyi": "from codeop import CommandCompiler\nfrom collections.abc import Callable, Mapping\nfrom types import CodeType\nfrom typing import Any\n\n__all__ = [\"InteractiveInterpreter\", \"InteractiveConsole\", \"interact\", \"compile_command\"]\n\nclass InteractiveInterpreter:\n    locals: Mapping[str, Any]  # undocumented\n    compile: CommandCompiler  # undocumented\n    def __init__(self, locals: Mapping[str, Any] | None = None) -> None: ...\n    def runsource(self, source: str, filename: str = \"<input>\", symbol: str = \"single\") -> bool: ...\n    def runcode(self, code: CodeType) -> None: ...\n    def showsyntaxerror(self, filename: str | None = None) -> None: ...\n    def showtraceback(self) -> None: ...\n    def write(self, data: str) -> None: ...\n\nclass InteractiveConsole(InteractiveInterpreter):\n    buffer: list[str]  # undocumented\n    filename: str  # undocumented\n    def __init__(self, locals: Mapping[str, Any] | None = None, filename: str = \"<console>\") -> None: ...\n    def interact(self, banner: str | None = None, exitmsg: str | None = None) -> None: ...\n    def push(self, line: str) -> bool: ...\n    def resetbuffer(self) -> None: ...\n    def raw_input(self, prompt: str = \"\") -> str: ...\n\ndef interact(\n    banner: str | None = None,\n    readfunc: Callable[[str], str] | None = None,\n    local: Mapping[str, Any] | None = None,\n    exitmsg: str | None = None,\n) -> None: ...\ndef compile_command(source: str, filename: str = \"<input>\", symbol: str = \"single\") -> CodeType | None: ...\n",
  "/typeshed/stdlib/codecs.pyi": "import sys\nimport types\nfrom _codecs import *\nfrom _typeshed import ReadableBuffer\nfrom abc import abstractmethod\nfrom collections.abc import Callable, Generator, Iterable\nfrom typing import Any, BinaryIO, Protocol, TextIO\nfrom typing_extensions import Literal, Self\n\n__all__ = [\n    \"register\",\n    \"lookup\",\n    \"open\",\n    \"EncodedFile\",\n    \"BOM\",\n    \"BOM_BE\",\n    \"BOM_LE\",\n    \"BOM32_BE\",\n    \"BOM32_LE\",\n    \"BOM64_BE\",\n    \"BOM64_LE\",\n    \"BOM_UTF8\",\n    \"BOM_UTF16\",\n    \"BOM_UTF16_LE\",\n    \"BOM_UTF16_BE\",\n    \"BOM_UTF32\",\n    \"BOM_UTF32_LE\",\n    \"BOM_UTF32_BE\",\n    \"CodecInfo\",\n    \"Codec\",\n    \"IncrementalEncoder\",\n    \"IncrementalDecoder\",\n    \"StreamReader\",\n    \"StreamWriter\",\n    \"StreamReaderWriter\",\n    \"StreamRecoder\",\n    \"getencoder\",\n    \"getdecoder\",\n    \"getincrementalencoder\",\n    \"getincrementaldecoder\",\n    \"getreader\",\n    \"getwriter\",\n    \"encode\",\n    \"decode\",\n    \"iterencode\",\n    \"iterdecode\",\n    \"strict_errors\",\n    \"ignore_errors\",\n    \"replace_errors\",\n    \"xmlcharrefreplace_errors\",\n    \"backslashreplace_errors\",\n    \"namereplace_errors\",\n    \"register_error\",\n    \"lookup_error\",\n]\n\nBOM32_BE: Literal[b\"\\xfe\\xff\"]\nBOM32_LE: Literal[b\"\\xff\\xfe\"]\nBOM64_BE: Literal[b\"\\x00\\x00\\xfe\\xff\"]\nBOM64_LE: Literal[b\"\\xff\\xfe\\x00\\x00\"]\n\nclass _WritableStream(Protocol):\n    def write(self, __data: bytes) -> object: ...\n    def seek(self, __offset: int, __whence: int) -> object: ...\n    def close(self) -> object: ...\n\nclass _ReadableStream(Protocol):\n    def read(self, __size: int = ...) -> bytes: ...\n    def seek(self, __offset: int, __whence: int) -> object: ...\n    def close(self) -> object: ...\n\nclass _Stream(_WritableStream, _ReadableStream, Protocol): ...\n\n# TODO: this only satisfies the most common interface, where\n# bytes is the raw form and str is the cooked form.\n# In the long run, both should become template parameters maybe?\n# There *are* bytes->bytes and str->str encodings in the standard library.\n# They were much more common in Python 2 than in Python 3.\n\nclass _Encoder(Protocol):\n    def __call__(self, input: str, errors: str = ...) -> tuple[bytes, int]: ...  # signature of Codec().encode\n\nclass _Decoder(Protocol):\n    def __call__(self, input: bytes, errors: str = ...) -> tuple[str, int]: ...  # signature of Codec().decode\n\nclass _StreamReader(Protocol):\n    def __call__(self, stream: _ReadableStream, errors: str = ...) -> StreamReader: ...\n\nclass _StreamWriter(Protocol):\n    def __call__(self, stream: _WritableStream, errors: str = ...) -> StreamWriter: ...\n\nclass _IncrementalEncoder(Protocol):\n    def __call__(self, errors: str = ...) -> IncrementalEncoder: ...\n\nclass _IncrementalDecoder(Protocol):\n    def __call__(self, errors: str = ...) -> IncrementalDecoder: ...\n\nclass CodecInfo(tuple[_Encoder, _Decoder, _StreamReader, _StreamWriter]):\n    @property\n    def encode(self) -> _Encoder: ...\n    @property\n    def decode(self) -> _Decoder: ...\n    @property\n    def streamreader(self) -> _StreamReader: ...\n    @property\n    def streamwriter(self) -> _StreamWriter: ...\n    @property\n    def incrementalencoder(self) -> _IncrementalEncoder: ...\n    @property\n    def incrementaldecoder(self) -> _IncrementalDecoder: ...\n    name: str\n    def __new__(\n        cls,\n        encode: _Encoder,\n        decode: _Decoder,\n        streamreader: _StreamReader | None = None,\n        streamwriter: _StreamWriter | None = None,\n        incrementalencoder: _IncrementalEncoder | None = None,\n        incrementaldecoder: _IncrementalDecoder | None = None,\n        name: str | None = None,\n        *,\n        _is_text_encoding: bool | None = None,\n    ) -> Self: ...\n\ndef getencoder(encoding: str) -> _Encoder: ...\ndef getdecoder(encoding: str) -> _Decoder: ...\ndef getincrementalencoder(encoding: str) -> _IncrementalEncoder: ...\ndef getincrementaldecoder(encoding: str) -> _IncrementalDecoder: ...\ndef getreader(encoding: str) -> _StreamReader: ...\ndef getwriter(encoding: str) -> _StreamWriter: ...\n\nif sys.version_info >= (3, 8):\n    def open(\n        filename: str, mode: str = \"r\", encoding: str | None = None, errors: str = \"strict\", buffering: int = -1\n    ) -> StreamReaderWriter: ...\n\nelse:\n    def open(\n        filename: str, mode: str = \"r\", encoding: str | None = None, errors: str = \"strict\", buffering: int = 1\n    ) -> StreamReaderWriter: ...\n\ndef EncodedFile(file: _Stream, data_encoding: str, file_encoding: str | None = None, errors: str = \"strict\") -> StreamRecoder: ...\ndef iterencode(iterator: Iterable[str], encoding: str, errors: str = \"strict\") -> Generator[bytes, None, None]: ...\ndef iterdecode(iterator: Iterable[bytes], encoding: str, errors: str = \"strict\") -> Generator[str, None, None]: ...\n\nBOM: Literal[b\"\\xff\\xfe\", b\"\\xfe\\xff\"]  # depends on `sys.byteorder`\nBOM_BE: Literal[b\"\\xfe\\xff\"]\nBOM_LE: Literal[b\"\\xff\\xfe\"]\nBOM_UTF8: Literal[b\"\\xef\\xbb\\xbf\"]\nBOM_UTF16: Literal[b\"\\xff\\xfe\", b\"\\xfe\\xff\"]  # depends on `sys.byteorder`\nBOM_UTF16_BE: Literal[b\"\\xfe\\xff\"]\nBOM_UTF16_LE: Literal[b\"\\xff\\xfe\"]\nBOM_UTF32: Literal[b\"\\xff\\xfe\\x00\\x00\", b\"\\x00\\x00\\xfe\\xff\"]  # depends on `sys.byteorder`\nBOM_UTF32_BE: Literal[b\"\\x00\\x00\\xfe\\xff\"]\nBOM_UTF32_LE: Literal[b\"\\xff\\xfe\\x00\\x00\"]\n\ndef strict_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\ndef replace_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\ndef ignore_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\ndef xmlcharrefreplace_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\ndef backslashreplace_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\ndef namereplace_errors(exception: UnicodeError) -> tuple[str | bytes, int]: ...\n\nclass Codec:\n    # These are sort of @abstractmethod but sort of not.\n    # The StreamReader and StreamWriter subclasses only implement one.\n    def encode(self, input: str, errors: str = \"strict\") -> tuple[bytes, int]: ...\n    def decode(self, input: bytes, errors: str = \"strict\") -> tuple[str, int]: ...\n\nclass IncrementalEncoder:\n    errors: str\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    @abstractmethod\n    def encode(self, input: str, final: bool = False) -> bytes: ...\n    def reset(self) -> None: ...\n    # documentation says int but str is needed for the subclass.\n    def getstate(self) -> int | str: ...\n    def setstate(self, state: int | str) -> None: ...\n\nclass IncrementalDecoder:\n    errors: str\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    @abstractmethod\n    def decode(self, input: ReadableBuffer, final: bool = False) -> str: ...\n    def reset(self) -> None: ...\n    def getstate(self) -> tuple[bytes, int]: ...\n    def setstate(self, state: tuple[bytes, int]) -> None: ...\n\n# These are not documented but used in encodings/*.py implementations.\nclass BufferedIncrementalEncoder(IncrementalEncoder):\n    buffer: str\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    @abstractmethod\n    def _buffer_encode(self, input: str, errors: str, final: bool) -> tuple[bytes, int]: ...\n    def encode(self, input: str, final: bool = False) -> bytes: ...\n\nclass BufferedIncrementalDecoder(IncrementalDecoder):\n    buffer: bytes\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    @abstractmethod\n    def _buffer_decode(self, input: ReadableBuffer, errors: str, final: bool) -> tuple[str, int]: ...\n    def decode(self, input: ReadableBuffer, final: bool = False) -> str: ...\n\n# TODO: it is not possible to specify the requirement that all other\n# attributes and methods are passed-through from the stream.\nclass StreamWriter(Codec):\n    stream: _WritableStream\n    errors: str\n    def __init__(self, stream: _WritableStream, errors: str = \"strict\") -> None: ...\n    def write(self, object: str) -> None: ...\n    def writelines(self, list: Iterable[str]) -> None: ...\n    def reset(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, tb: types.TracebackType | None) -> None: ...\n    def __getattr__(self, name: str, getattr: Callable[[str], Any] = ...) -> Any: ...\n\nclass StreamReader(Codec):\n    stream: _ReadableStream\n    errors: str\n    def __init__(self, stream: _ReadableStream, errors: str = \"strict\") -> None: ...\n    def read(self, size: int = -1, chars: int = -1, firstline: bool = False) -> str: ...\n    def readline(self, size: int | None = None, keepends: bool = True) -> str: ...\n    def readlines(self, sizehint: int | None = None, keepends: bool = True) -> list[str]: ...\n    def reset(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, tb: types.TracebackType | None) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> str: ...\n    def __getattr__(self, name: str, getattr: Callable[[str], Any] = ...) -> Any: ...\n\n# Doesn't actually inherit from TextIO, but wraps a BinaryIO to provide text reading and writing\n# and delegates attributes to the underlying binary stream with __getattr__.\nclass StreamReaderWriter(TextIO):\n    stream: _Stream\n    def __init__(self, stream: _Stream, Reader: _StreamReader, Writer: _StreamWriter, errors: str = \"strict\") -> None: ...\n    def read(self, size: int = -1) -> str: ...\n    def readline(self, size: int | None = None) -> str: ...\n    def readlines(self, sizehint: int | None = None) -> list[str]: ...\n    def __next__(self) -> str: ...\n    def __iter__(self) -> Self: ...\n    def write(self, data: str) -> None: ...  # type: ignore[override]\n    def writelines(self, list: Iterable[str]) -> None: ...\n    def reset(self) -> None: ...\n    def seek(self, offset: int, whence: int = 0) -> None: ...  # type: ignore[override]\n    def __enter__(self) -> Self: ...\n    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, tb: types.TracebackType | None) -> None: ...\n    def __getattr__(self, name: str) -> Any: ...\n    # These methods don't actually exist directly, but they are needed to satisfy the TextIO\n    # interface. At runtime, they are delegated through __getattr__.\n    def close(self) -> None: ...\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def readable(self) -> bool: ...\n    def truncate(self, size: int | None = ...) -> int: ...\n    def seekable(self) -> bool: ...\n    def tell(self) -> int: ...\n    def writable(self) -> bool: ...\n\nclass StreamRecoder(BinaryIO):\n    def __init__(\n        self,\n        stream: _Stream,\n        encode: _Encoder,\n        decode: _Decoder,\n        Reader: _StreamReader,\n        Writer: _StreamWriter,\n        errors: str = \"strict\",\n    ) -> None: ...\n    def read(self, size: int = -1) -> bytes: ...\n    def readline(self, size: int | None = None) -> bytes: ...\n    def readlines(self, sizehint: int | None = None) -> list[bytes]: ...\n    def __next__(self) -> bytes: ...\n    def __iter__(self) -> Self: ...\n    # Base class accepts more types than just bytes\n    def write(self, data: bytes) -> None: ...  # type: ignore[override]\n    def writelines(self, list: Iterable[bytes]) -> None: ...  # type: ignore[override]\n    def reset(self) -> None: ...\n    def __getattr__(self, name: str) -> Any: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, tb: types.TracebackType | None) -> None: ...\n    def seek(self, offset: int, whence: int = 0) -> None: ...  # type: ignore[override]\n    # These methods don't actually exist directly, but they are needed to satisfy the BinaryIO\n    # interface. At runtime, they are delegated through __getattr__.\n    def close(self) -> None: ...\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def readable(self) -> bool: ...\n    def truncate(self, size: int | None = ...) -> int: ...\n    def seekable(self) -> bool: ...\n    def tell(self) -> int: ...\n    def writable(self) -> bool: ...\n",
  "/typeshed/stdlib/codeop.pyi": "from types import CodeType\n\n__all__ = [\"compile_command\", \"Compile\", \"CommandCompiler\"]\n\ndef compile_command(source: str, filename: str = \"<input>\", symbol: str = \"single\") -> CodeType | None: ...\n\nclass Compile:\n    flags: int\n    def __call__(self, source: str, filename: str, symbol: str) -> CodeType: ...\n\nclass CommandCompiler:\n    compiler: Compile\n    def __call__(self, source: str, filename: str = \"<input>\", symbol: str = \"single\") -> CodeType | None: ...\n",
  "/typeshed/stdlib/colorsys.pyi": "__all__ = [\"rgb_to_yiq\", \"yiq_to_rgb\", \"rgb_to_hls\", \"hls_to_rgb\", \"rgb_to_hsv\", \"hsv_to_rgb\"]\n\ndef rgb_to_yiq(r: float, g: float, b: float) -> tuple[float, float, float]: ...\ndef yiq_to_rgb(y: float, i: float, q: float) -> tuple[float, float, float]: ...\ndef rgb_to_hls(r: float, g: float, b: float) -> tuple[float, float, float]: ...\ndef hls_to_rgb(h: float, l: float, s: float) -> tuple[float, float, float]: ...\ndef rgb_to_hsv(r: float, g: float, b: float) -> tuple[float, float, float]: ...\ndef hsv_to_rgb(h: float, s: float, v: float) -> tuple[float, float, float]: ...\n\n# TODO undocumented\nONE_SIXTH: float\nONE_THIRD: float\nTWO_THIRD: float\n",
  "/typeshed/stdlib/compileall.pyi": "import sys\nfrom _typeshed import StrPath\nfrom py_compile import PycInvalidationMode\nfrom typing import Any, Protocol\n\n__all__ = [\"compile_dir\", \"compile_file\", \"compile_path\"]\n\nclass _SupportsSearch(Protocol):\n    def search(self, string: str) -> Any: ...\n\nif sys.version_info >= (3, 10):\n    def compile_dir(\n        dir: StrPath,\n        maxlevels: int | None = None,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        workers: int = 1,\n        invalidation_mode: PycInvalidationMode | None = None,\n        *,\n        stripdir: StrPath | None = None,\n        prependdir: StrPath | None = None,\n        limit_sl_dest: StrPath | None = None,\n        hardlink_dupes: bool = False,\n    ) -> int: ...\n    def compile_file(\n        fullname: StrPath,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        invalidation_mode: PycInvalidationMode | None = None,\n        *,\n        stripdir: StrPath | None = None,\n        prependdir: StrPath | None = None,\n        limit_sl_dest: StrPath | None = None,\n        hardlink_dupes: bool = False,\n    ) -> int: ...\n\nelif sys.version_info >= (3, 9):\n    def compile_dir(\n        dir: StrPath,\n        maxlevels: int | None = None,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        workers: int = 1,\n        invalidation_mode: PycInvalidationMode | None = None,\n        *,\n        stripdir: str | None = None,  # https://bugs.python.org/issue40447\n        prependdir: StrPath | None = None,\n        limit_sl_dest: StrPath | None = None,\n        hardlink_dupes: bool = False,\n    ) -> int: ...\n    def compile_file(\n        fullname: StrPath,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        invalidation_mode: PycInvalidationMode | None = None,\n        *,\n        stripdir: str | None = None,  # https://bugs.python.org/issue40447\n        prependdir: StrPath | None = None,\n        limit_sl_dest: StrPath | None = None,\n        hardlink_dupes: bool = False,\n    ) -> int: ...\n\nelse:\n    def compile_dir(\n        dir: StrPath,\n        maxlevels: int = 10,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        workers: int = 1,\n        invalidation_mode: PycInvalidationMode | None = None,\n    ) -> int: ...\n    def compile_file(\n        fullname: StrPath,\n        ddir: StrPath | None = None,\n        force: bool = False,\n        rx: _SupportsSearch | None = None,\n        quiet: int = 0,\n        legacy: bool = False,\n        optimize: int = -1,\n        invalidation_mode: PycInvalidationMode | None = None,\n    ) -> int: ...\n\ndef compile_path(\n    skip_curdir: bool = ...,\n    maxlevels: int = 0,\n    force: bool = False,\n    quiet: int = 0,\n    legacy: bool = False,\n    optimize: int = -1,\n    invalidation_mode: PycInvalidationMode | None = None,\n) -> int: ...\n",
  "/typeshed/stdlib/configparser.pyi": "import sys\nfrom _typeshed import StrOrBytesPath, SupportsWrite\nfrom collections.abc import Callable, ItemsView, Iterable, Iterator, Mapping, MutableMapping, Sequence\nfrom re import Pattern\nfrom typing import Any, ClassVar, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias\n\n__all__ = [\n    \"NoSectionError\",\n    \"DuplicateOptionError\",\n    \"DuplicateSectionError\",\n    \"NoOptionError\",\n    \"InterpolationError\",\n    \"InterpolationDepthError\",\n    \"InterpolationMissingOptionError\",\n    \"InterpolationSyntaxError\",\n    \"ParsingError\",\n    \"MissingSectionHeaderError\",\n    \"ConfigParser\",\n    \"SafeConfigParser\",\n    \"RawConfigParser\",\n    \"Interpolation\",\n    \"BasicInterpolation\",\n    \"ExtendedInterpolation\",\n    \"LegacyInterpolation\",\n    \"SectionProxy\",\n    \"ConverterMapping\",\n    \"DEFAULTSECT\",\n    \"MAX_INTERPOLATION_DEPTH\",\n]\n\n_Section: TypeAlias = Mapping[str, str]\n_Parser: TypeAlias = MutableMapping[str, _Section]\n_ConverterCallback: TypeAlias = Callable[[str], Any]\n_ConvertersMap: TypeAlias = dict[str, _ConverterCallback]\n_T = TypeVar(\"_T\")\n\nDEFAULTSECT: Literal[\"DEFAULT\"]\nMAX_INTERPOLATION_DEPTH: Literal[10]\n\nclass Interpolation:\n    def before_get(self, parser: _Parser, section: str, option: str, value: str, defaults: _Section) -> str: ...\n    def before_set(self, parser: _Parser, section: str, option: str, value: str) -> str: ...\n    def before_read(self, parser: _Parser, section: str, option: str, value: str) -> str: ...\n    def before_write(self, parser: _Parser, section: str, option: str, value: str) -> str: ...\n\nclass BasicInterpolation(Interpolation): ...\nclass ExtendedInterpolation(Interpolation): ...\n\nclass LegacyInterpolation(Interpolation):\n    def before_get(self, parser: _Parser, section: str, option: str, value: str, vars: _Section) -> str: ...\n\nclass RawConfigParser(_Parser):\n    _SECT_TMPL: ClassVar[str]  # undocumented\n    _OPT_TMPL: ClassVar[str]  # undocumented\n    _OPT_NV_TMPL: ClassVar[str]  # undocumented\n\n    SECTCRE: Pattern[str]\n    OPTCRE: ClassVar[Pattern[str]]\n    OPTCRE_NV: ClassVar[Pattern[str]]  # undocumented\n    NONSPACECRE: ClassVar[Pattern[str]]  # undocumented\n\n    BOOLEAN_STATES: ClassVar[Mapping[str, bool]]  # undocumented\n    default_section: str\n    @overload\n    def __init__(\n        self,\n        defaults: Mapping[str, str | None] | None = None,\n        dict_type: type[Mapping[str, str]] = ...,\n        *,\n        allow_no_value: Literal[True],\n        delimiters: Sequence[str] = (\"=\", \":\"),\n        comment_prefixes: Sequence[str] = (\"#\", \";\"),\n        inline_comment_prefixes: Sequence[str] | None = None,\n        strict: bool = True,\n        empty_lines_in_values: bool = True,\n        default_section: str = \"DEFAULT\",\n        interpolation: Interpolation | None = ...,\n        converters: _ConvertersMap = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        defaults: Mapping[str, str | None] | None,\n        dict_type: type[Mapping[str, str]],\n        allow_no_value: Literal[True],\n        *,\n        delimiters: Sequence[str] = (\"=\", \":\"),\n        comment_prefixes: Sequence[str] = (\"#\", \";\"),\n        inline_comment_prefixes: Sequence[str] | None = None,\n        strict: bool = True,\n        empty_lines_in_values: bool = True,\n        default_section: str = \"DEFAULT\",\n        interpolation: Interpolation | None = ...,\n        converters: _ConvertersMap = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        defaults: _Section | None = None,\n        dict_type: type[Mapping[str, str]] = ...,\n        allow_no_value: bool = False,\n        *,\n        delimiters: Sequence[str] = (\"=\", \":\"),\n        comment_prefixes: Sequence[str] = (\"#\", \";\"),\n        inline_comment_prefixes: Sequence[str] | None = None,\n        strict: bool = True,\n        empty_lines_in_values: bool = True,\n        default_section: str = \"DEFAULT\",\n        interpolation: Interpolation | None = ...,\n        converters: _ConvertersMap = ...,\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: str) -> SectionProxy: ...\n    def __setitem__(self, key: str, value: _Section) -> None: ...\n    def __delitem__(self, key: str) -> None: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def defaults(self) -> _Section: ...\n    def sections(self) -> list[str]: ...\n    def add_section(self, section: str) -> None: ...\n    def has_section(self, section: str) -> bool: ...\n    def options(self, section: str) -> list[str]: ...\n    def has_option(self, section: str, option: str) -> bool: ...\n    def read(self, filenames: StrOrBytesPath | Iterable[StrOrBytesPath], encoding: str | None = None) -> list[str]: ...\n    def read_file(self, f: Iterable[str], source: str | None = None) -> None: ...\n    def read_string(self, string: str, source: str = \"<string>\") -> None: ...\n    def read_dict(self, dictionary: Mapping[str, Mapping[str, Any]], source: str = \"<dict>\") -> None: ...\n    def readfp(self, fp: Iterable[str], filename: str | None = None) -> None: ...\n    # These get* methods are partially applied (with the same names) in\n    # SectionProxy; the stubs should be kept updated together\n    @overload\n    def getint(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None) -> int: ...\n    @overload\n    def getint(\n        self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None, fallback: _T = ...\n    ) -> int | _T: ...\n    @overload\n    def getfloat(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None) -> float: ...\n    @overload\n    def getfloat(\n        self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None, fallback: _T = ...\n    ) -> float | _T: ...\n    @overload\n    def getboolean(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None) -> bool: ...\n    @overload\n    def getboolean(\n        self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None, fallback: _T = ...\n    ) -> bool | _T: ...\n    def _get_conv(\n        self,\n        section: str,\n        option: str,\n        conv: Callable[[str], _T],\n        *,\n        raw: bool = False,\n        vars: _Section | None = None,\n        fallback: _T = ...,\n    ) -> _T: ...\n    # This is incompatible with MutableMapping so we ignore the type\n    @overload  # type: ignore[override]\n    def get(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None) -> str | Any: ...\n    @overload\n    def get(\n        self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None, fallback: _T\n    ) -> str | _T | Any: ...\n    @overload\n    def items(self, *, raw: bool = False, vars: _Section | None = None) -> ItemsView[str, SectionProxy]: ...\n    @overload\n    def items(self, section: str, raw: bool = False, vars: _Section | None = None) -> list[tuple[str, str]]: ...\n    def set(self, section: str, option: str, value: str | None = None) -> None: ...\n    def write(self, fp: SupportsWrite[str], space_around_delimiters: bool = True) -> None: ...\n    def remove_option(self, section: str, option: str) -> bool: ...\n    def remove_section(self, section: str) -> bool: ...\n    def optionxform(self, optionstr: str) -> str: ...\n\nclass ConfigParser(RawConfigParser):\n    # This is incompatible with MutableMapping so we ignore the type\n    @overload  # type: ignore[override]\n    def get(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None) -> str: ...\n    @overload\n    def get(self, section: str, option: str, *, raw: bool = False, vars: _Section | None = None, fallback: _T) -> str | _T: ...\n\nif sys.version_info < (3, 12):\n    class SafeConfigParser(ConfigParser): ...  # deprecated alias\n\nclass SectionProxy(MutableMapping[str, str]):\n    def __init__(self, parser: RawConfigParser, name: str) -> None: ...\n    def __getitem__(self, key: str) -> str: ...\n    def __setitem__(self, key: str, value: str) -> None: ...\n    def __delitem__(self, key: str) -> None: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    @property\n    def parser(self) -> RawConfigParser: ...\n    @property\n    def name(self) -> str: ...\n    def get(  # type: ignore[override]\n        self,\n        option: str,\n        fallback: str | None = None,\n        *,\n        raw: bool = False,\n        vars: _Section | None = None,\n        _impl: Any | None = None,\n        **kwargs: Any,\n    ) -> str | Any: ...  # can be None in RawConfigParser's sections\n    # These are partially-applied version of the methods with the same names in\n    # RawConfigParser; the stubs should be kept updated together\n    @overload\n    def getint(self, option: str, *, raw: bool = ..., vars: _Section | None = ...) -> int: ...\n    @overload\n    def getint(self, option: str, fallback: _T = ..., *, raw: bool = ..., vars: _Section | None = ...) -> int | _T: ...\n    @overload\n    def getfloat(self, option: str, *, raw: bool = ..., vars: _Section | None = ...) -> float: ...\n    @overload\n    def getfloat(self, option: str, fallback: _T = ..., *, raw: bool = ..., vars: _Section | None = ...) -> float | _T: ...\n    @overload\n    def getboolean(self, option: str, *, raw: bool = ..., vars: _Section | None = ...) -> bool: ...\n    @overload\n    def getboolean(self, option: str, fallback: _T = ..., *, raw: bool = ..., vars: _Section | None = ...) -> bool | _T: ...\n    # SectionProxy can have arbitrary attributes when custom converters are used\n    def __getattr__(self, key: str) -> Callable[..., Any]: ...\n\nclass ConverterMapping(MutableMapping[str, _ConverterCallback | None]):\n    GETTERCRE: ClassVar[Pattern[Any]]\n    def __init__(self, parser: RawConfigParser) -> None: ...\n    def __getitem__(self, key: str) -> _ConverterCallback: ...\n    def __setitem__(self, key: str, value: _ConverterCallback | None) -> None: ...\n    def __delitem__(self, key: str) -> None: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __len__(self) -> int: ...\n\nclass Error(Exception):\n    message: str\n    def __init__(self, msg: str = \"\") -> None: ...\n\nclass NoSectionError(Error):\n    section: str\n    def __init__(self, section: str) -> None: ...\n\nclass DuplicateSectionError(Error):\n    section: str\n    source: str | None\n    lineno: int | None\n    def __init__(self, section: str, source: str | None = None, lineno: int | None = None) -> None: ...\n\nclass DuplicateOptionError(Error):\n    section: str\n    option: str\n    source: str | None\n    lineno: int | None\n    def __init__(self, section: str, option: str, source: str | None = None, lineno: int | None = None) -> None: ...\n\nclass NoOptionError(Error):\n    section: str\n    option: str\n    def __init__(self, option: str, section: str) -> None: ...\n\nclass InterpolationError(Error):\n    section: str\n    option: str\n    def __init__(self, option: str, section: str, msg: str) -> None: ...\n\nclass InterpolationDepthError(InterpolationError):\n    def __init__(self, option: str, section: str, rawval: object) -> None: ...\n\nclass InterpolationMissingOptionError(InterpolationError):\n    reference: str\n    def __init__(self, option: str, section: str, rawval: object, reference: str) -> None: ...\n\nclass InterpolationSyntaxError(InterpolationError): ...\n\nclass ParsingError(Error):\n    source: str\n    errors: list[tuple[int, str]]\n    def __init__(self, source: str | None = None, filename: str | None = None) -> None: ...\n    def append(self, lineno: int, line: str) -> None: ...\n\nclass MissingSectionHeaderError(ParsingError):\n    lineno: int\n    line: str\n    def __init__(self, filename: str, lineno: int, line: str) -> None: ...\n",
  "/typeshed/stdlib/contextlib.pyi": "import abc\nimport sys\nfrom _typeshed import FileDescriptorOrPath, Unused\nfrom abc import abstractmethod\nfrom collections.abc import AsyncGenerator, AsyncIterator, Awaitable, Callable, Generator, Iterator\nfrom types import TracebackType\nfrom typing import IO, Any, Generic, Protocol, TypeVar, overload, runtime_checkable\nfrom typing_extensions import ParamSpec, Self, TypeAlias\n\n__all__ = [\n    \"contextmanager\",\n    \"closing\",\n    \"AbstractContextManager\",\n    \"ContextDecorator\",\n    \"ExitStack\",\n    \"redirect_stdout\",\n    \"redirect_stderr\",\n    \"suppress\",\n    \"AbstractAsyncContextManager\",\n    \"AsyncExitStack\",\n    \"asynccontextmanager\",\n    \"nullcontext\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"aclosing\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"chdir\"]\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_io = TypeVar(\"_T_io\", bound=IO[str] | None)\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\n_ExitFunc: TypeAlias = Callable[[type[BaseException] | None, BaseException | None, TracebackType | None], bool | None]\n_CM_EF = TypeVar(\"_CM_EF\", bound=AbstractContextManager[Any] | _ExitFunc)\n\n@runtime_checkable\nclass AbstractContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    @abstractmethod\n    def __exit__(\n        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None\n    ) -> bool | None: ...\n\n@runtime_checkable\nclass AbstractAsyncContextManager(Protocol[_T_co]):\n    async def __aenter__(self) -> _T_co: ...\n    @abstractmethod\n    async def __aexit__(\n        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None\n    ) -> bool | None: ...\n\nclass ContextDecorator:\n    def __call__(self, func: _F) -> _F: ...\n\nclass _GeneratorContextManager(AbstractContextManager[_T_co], ContextDecorator, Generic[_T_co]):\n    # __init__ and all instance attributes are actually inherited from _GeneratorContextManagerBase\n    # _GeneratorContextManagerBase is more trouble than it's worth to include in the stub; see #6676\n    def __init__(self, func: Callable[..., Iterator[_T_co]], args: tuple[Any, ...], kwds: dict[str, Any]) -> None: ...\n    gen: Generator[_T_co, Any, Any]\n    func: Callable[..., Generator[_T_co, Any, Any]]\n    args: tuple[Any, ...]\n    kwds: dict[str, Any]\n    if sys.version_info >= (3, 9):\n        def __exit__(\n            self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n    else:\n        def __exit__(\n            self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n\ndef contextmanager(func: Callable[_P, Iterator[_T_co]]) -> Callable[_P, _GeneratorContextManager[_T_co]]: ...\n\nif sys.version_info >= (3, 10):\n    _AF = TypeVar(\"_AF\", bound=Callable[..., Awaitable[Any]])\n\n    class AsyncContextDecorator:\n        def __call__(self, func: _AF) -> _AF: ...\n\n    class _AsyncGeneratorContextManager(AbstractAsyncContextManager[_T_co], AsyncContextDecorator, Generic[_T_co]):\n        # __init__ and these attributes are actually defined in the base class _GeneratorContextManagerBase,\n        # which is more trouble than it's worth to include in the stub (see #6676)\n        def __init__(self, func: Callable[..., AsyncIterator[_T_co]], args: tuple[Any, ...], kwds: dict[str, Any]) -> None: ...\n        gen: AsyncGenerator[_T_co, Any]\n        func: Callable[..., AsyncGenerator[_T_co, Any]]\n        args: tuple[Any, ...]\n        kwds: dict[str, Any]\n        async def __aexit__(\n            self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n\nelse:\n    class _AsyncGeneratorContextManager(AbstractAsyncContextManager[_T_co], Generic[_T_co]):\n        def __init__(self, func: Callable[..., AsyncIterator[_T_co]], args: tuple[Any, ...], kwds: dict[str, Any]) -> None: ...\n        gen: AsyncGenerator[_T_co, Any]\n        func: Callable[..., AsyncGenerator[_T_co, Any]]\n        args: tuple[Any, ...]\n        kwds: dict[str, Any]\n        async def __aexit__(\n            self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n\ndef asynccontextmanager(func: Callable[_P, AsyncIterator[_T_co]]) -> Callable[_P, _AsyncGeneratorContextManager[_T_co]]: ...\n\nclass _SupportsClose(Protocol):\n    def close(self) -> object: ...\n\n_SupportsCloseT = TypeVar(\"_SupportsCloseT\", bound=_SupportsClose)\n\nclass closing(AbstractContextManager[_SupportsCloseT]):\n    def __init__(self, thing: _SupportsCloseT) -> None: ...\n    def __exit__(self, *exc_info: Unused) -> None: ...\n\nif sys.version_info >= (3, 10):\n    class _SupportsAclose(Protocol):\n        def aclose(self) -> Awaitable[object]: ...\n    _SupportsAcloseT = TypeVar(\"_SupportsAcloseT\", bound=_SupportsAclose)\n\n    class aclosing(AbstractAsyncContextManager[_SupportsAcloseT]):\n        def __init__(self, thing: _SupportsAcloseT) -> None: ...\n        async def __aexit__(self, *exc_info: Unused) -> None: ...\n\nclass suppress(AbstractContextManager[None]):\n    def __init__(self, *exceptions: type[BaseException]) -> None: ...\n    def __exit__(\n        self, exctype: type[BaseException] | None, excinst: BaseException | None, exctb: TracebackType | None\n    ) -> bool: ...\n\nclass _RedirectStream(AbstractContextManager[_T_io]):\n    def __init__(self, new_target: _T_io) -> None: ...\n    def __exit__(\n        self, exctype: type[BaseException] | None, excinst: BaseException | None, exctb: TracebackType | None\n    ) -> None: ...\n\nclass redirect_stdout(_RedirectStream[_T_io]): ...\nclass redirect_stderr(_RedirectStream[_T_io]): ...\n\n# In reality this is a subclass of `AbstractContextManager`;\n# see #7961 for why we don't do that in the stub\nclass ExitStack(metaclass=abc.ABCMeta):\n    def enter_context(self, cm: AbstractContextManager[_T]) -> _T: ...\n    def push(self, exit: _CM_EF) -> _CM_EF: ...\n    def callback(self, __callback: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...\n    def pop_all(self) -> Self: ...\n    def close(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None\n    ) -> bool: ...\n\n_ExitCoroFunc: TypeAlias = Callable[\n    [type[BaseException] | None, BaseException | None, TracebackType | None], Awaitable[bool | None]\n]\n_ACM_EF = TypeVar(\"_ACM_EF\", bound=AbstractAsyncContextManager[Any] | _ExitCoroFunc)\n\n# In reality this is a subclass of `AbstractAsyncContextManager`;\n# see #7961 for why we don't do that in the stub\nclass AsyncExitStack(metaclass=abc.ABCMeta):\n    def enter_context(self, cm: AbstractContextManager[_T]) -> _T: ...\n    async def enter_async_context(self, cm: AbstractAsyncContextManager[_T]) -> _T: ...\n    def push(self, exit: _CM_EF) -> _CM_EF: ...\n    def push_async_exit(self, exit: _ACM_EF) -> _ACM_EF: ...\n    def callback(self, __callback: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...\n    def push_async_callback(\n        self, __callback: Callable[_P, Awaitable[_T]], *args: _P.args, **kwds: _P.kwargs\n    ) -> Callable[_P, Awaitable[_T]]: ...\n    def pop_all(self) -> Self: ...\n    async def aclose(self) -> None: ...\n    async def __aenter__(self) -> Self: ...\n    async def __aexit__(\n        self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None\n    ) -> bool: ...\n\nif sys.version_info >= (3, 10):\n    class nullcontext(AbstractContextManager[_T], AbstractAsyncContextManager[_T]):\n        enter_result: _T\n        @overload\n        def __init__(self: nullcontext[None], enter_result: None = None) -> None: ...\n        @overload\n        def __init__(self: nullcontext[_T], enter_result: _T) -> None: ...\n        def __enter__(self) -> _T: ...\n        def __exit__(self, *exctype: Unused) -> None: ...\n        async def __aenter__(self) -> _T: ...\n        async def __aexit__(self, *exctype: Unused) -> None: ...\n\nelse:\n    class nullcontext(AbstractContextManager[_T]):\n        enter_result: _T\n        @overload\n        def __init__(self: nullcontext[None], enter_result: None = None) -> None: ...\n        @overload\n        def __init__(self: nullcontext[_T], enter_result: _T) -> None: ...\n        def __enter__(self) -> _T: ...\n        def __exit__(self, *exctype: Unused) -> None: ...\n\nif sys.version_info >= (3, 11):\n    _T_fd_or_any_path = TypeVar(\"_T_fd_or_any_path\", bound=FileDescriptorOrPath)\n\n    class chdir(AbstractContextManager[None], Generic[_T_fd_or_any_path]):\n        path: _T_fd_or_any_path\n        def __init__(self, path: _T_fd_or_any_path) -> None: ...\n        def __enter__(self) -> None: ...\n        def __exit__(self, *excinfo: Unused) -> None: ...\n",
  "/typeshed/stdlib/contextvars.pyi": "import sys\nfrom collections.abc import Callable, Iterator, Mapping\nfrom typing import Any, ClassVar, Generic, TypeVar, overload\nfrom typing_extensions import ParamSpec, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = (\"Context\", \"ContextVar\", \"Token\", \"copy_context\")\n\n_T = TypeVar(\"_T\")\n_D = TypeVar(\"_D\")\n_P = ParamSpec(\"_P\")\n\n@final\nclass ContextVar(Generic[_T]):\n    @overload\n    def __init__(self, name: str) -> None: ...\n    @overload\n    def __init__(self, name: str, *, default: _T) -> None: ...\n    @property\n    def name(self) -> str: ...\n    @overload\n    def get(self) -> _T: ...\n    if sys.version_info >= (3, 8):\n        @overload\n        def get(self, default: _D | _T) -> _D | _T: ...\n    else:\n        @overload\n        def get(self, __default: _D | _T) -> _D | _T: ...\n\n    def set(self, __value: _T) -> Token[_T]: ...\n    def reset(self, __token: Token[_T]) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n@final\nclass Token(Generic[_T]):\n    @property\n    def var(self) -> ContextVar[_T]: ...\n    @property\n    def old_value(self) -> Any: ...  # returns either _T or MISSING, but that's hard to express\n    MISSING: ClassVar[object]\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef copy_context() -> Context: ...\n\n# It doesn't make sense to make this generic, because for most Contexts each ContextVar will have\n# a different value.\n@final\nclass Context(Mapping[ContextVar[Any], Any]):\n    def __init__(self) -> None: ...\n    @overload\n    def get(self, __key: ContextVar[_T]) -> _T | None: ...\n    @overload\n    def get(self, __key: ContextVar[_T], __default: _D) -> _T | _D: ...\n    def run(self, callable: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> _T: ...\n    def copy(self) -> Context: ...\n    def __getitem__(self, __key: ContextVar[_T]) -> _T: ...\n    def __iter__(self) -> Iterator[ContextVar[Any]]: ...\n    def __len__(self) -> int: ...\n",
  "/typeshed/stdlib/copy.pyi": "from typing import Any, TypeVar\n\n__all__ = [\"Error\", \"copy\", \"deepcopy\"]\n\n_T = TypeVar(\"_T\")\n\n# None in CPython but non-None in Jython\nPyStringMap: Any\n\n# Note: memo and _nil are internal kwargs.\ndef deepcopy(x: _T, memo: dict[int, Any] | None = None, _nil: Any = []) -> _T: ...\ndef copy(x: _T) -> _T: ...\n\nclass Error(Exception): ...\n\nerror = Error\n",
  "/typeshed/stdlib/copyreg.pyi": "from collections.abc import Callable, Hashable\nfrom typing import Any, SupportsInt, TypeVar\nfrom typing_extensions import TypeAlias\n\n_T = TypeVar(\"_T\")\n_Reduce: TypeAlias = tuple[Callable[..., _T], tuple[Any, ...]] | tuple[Callable[..., _T], tuple[Any, ...], Any | None]\n\n__all__ = [\"pickle\", \"constructor\", \"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\n\ndef pickle(\n    ob_type: type[_T],\n    pickle_function: Callable[[_T], str | _Reduce[_T]],\n    constructor_ob: Callable[[_Reduce[_T]], _T] | None = None,\n) -> None: ...\ndef constructor(object: Callable[[_Reduce[_T]], _T]) -> None: ...\ndef add_extension(module: Hashable, name: Hashable, code: SupportsInt) -> None: ...\ndef remove_extension(module: Hashable, name: Hashable, code: int) -> None: ...\ndef clear_extension_cache() -> None: ...\n\n_DispatchTableType: TypeAlias = dict[type, Callable[[Any], str | _Reduce[Any]]]  # imported by multiprocessing.reduction\ndispatch_table: _DispatchTableType  # undocumented\n",
  "/typeshed/stdlib/crypt.pyi": "import sys\n\nif sys.platform != \"win32\":\n    class _Method: ...\n    METHOD_CRYPT: _Method\n    METHOD_MD5: _Method\n    METHOD_SHA256: _Method\n    METHOD_SHA512: _Method\n    METHOD_BLOWFISH: _Method\n    methods: list[_Method]\n    def mksalt(method: _Method | None = None, *, rounds: int | None = None) -> str: ...\n    def crypt(word: str, salt: str | _Method | None = None) -> str: ...\n",
  "/typeshed/stdlib/csv.pyi": "import sys\n\n# actually csv.Dialect is a different class to _csv.Dialect at runtime, but for typing purposes, they're identical\nfrom _csv import (\n    QUOTE_ALL as QUOTE_ALL,\n    QUOTE_MINIMAL as QUOTE_MINIMAL,\n    QUOTE_NONE as QUOTE_NONE,\n    QUOTE_NONNUMERIC as QUOTE_NONNUMERIC,\n    Dialect as Dialect,\n    Error as Error,\n    __version__ as __version__,\n    _DialectLike,\n    _QuotingType,\n    _reader,\n    _writer,\n    field_size_limit as field_size_limit,\n    get_dialect as get_dialect,\n    list_dialects as list_dialects,\n    reader as reader,\n    register_dialect as register_dialect,\n    unregister_dialect as unregister_dialect,\n    writer as writer,\n)\nfrom _typeshed import SupportsWrite\nfrom collections.abc import Collection, Iterable, Iterator, Mapping, Sequence\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import Literal, Self\n\nif sys.version_info >= (3, 8):\n    from builtins import dict as _DictReadMapping\nelse:\n    from collections import OrderedDict as _DictReadMapping\n\nif sys.version_info >= (3, 12):\n    from types import GenericAlias\n\n__all__ = [\n    \"QUOTE_MINIMAL\",\n    \"QUOTE_ALL\",\n    \"QUOTE_NONNUMERIC\",\n    \"QUOTE_NONE\",\n    \"Error\",\n    \"Dialect\",\n    \"__doc__\",\n    \"excel\",\n    \"excel_tab\",\n    \"field_size_limit\",\n    \"reader\",\n    \"writer\",\n    \"register_dialect\",\n    \"get_dialect\",\n    \"list_dialects\",\n    \"Sniffer\",\n    \"unregister_dialect\",\n    \"__version__\",\n    \"DictReader\",\n    \"DictWriter\",\n    \"unix_dialect\",\n]\n\n_T = TypeVar(\"_T\")\n\nclass excel(Dialect): ...\nclass excel_tab(excel): ...\nclass unix_dialect(Dialect): ...\n\nclass DictReader(Generic[_T], Iterator[_DictReadMapping[_T | Any, str | Any]]):\n    fieldnames: Sequence[_T] | None\n    restkey: str | None\n    restval: str | None\n    reader: _reader\n    dialect: _DialectLike\n    line_num: int\n    @overload\n    def __init__(\n        self,\n        f: Iterable[str],\n        fieldnames: Sequence[_T],\n        restkey: str | None = None,\n        restval: str | None = None,\n        dialect: _DialectLike = \"excel\",\n        *,\n        delimiter: str = \",\",\n        quotechar: str | None = '\"',\n        escapechar: str | None = None,\n        doublequote: bool = True,\n        skipinitialspace: bool = False,\n        lineterminator: str = \"\\r\\n\",\n        quoting: _QuotingType = 0,\n        strict: bool = False,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: DictReader[str],\n        f: Iterable[str],\n        fieldnames: Sequence[str] | None = None,\n        restkey: str | None = None,\n        restval: str | None = None,\n        dialect: _DialectLike = \"excel\",\n        *,\n        delimiter: str = \",\",\n        quotechar: str | None = '\"',\n        escapechar: str | None = None,\n        doublequote: bool = True,\n        skipinitialspace: bool = False,\n        lineterminator: str = \"\\r\\n\",\n        quoting: _QuotingType = 0,\n        strict: bool = False,\n    ) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _DictReadMapping[_T | Any, str | Any]: ...\n    if sys.version_info >= (3, 12):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass DictWriter(Generic[_T]):\n    fieldnames: Collection[_T]\n    restval: Any | None\n    extrasaction: Literal[\"raise\", \"ignore\"]\n    writer: _writer\n    def __init__(\n        self,\n        f: SupportsWrite[str],\n        fieldnames: Collection[_T],\n        restval: Any | None = \"\",\n        extrasaction: Literal[\"raise\", \"ignore\"] = \"raise\",\n        dialect: _DialectLike = \"excel\",\n        *,\n        delimiter: str = \",\",\n        quotechar: str | None = '\"',\n        escapechar: str | None = None,\n        doublequote: bool = True,\n        skipinitialspace: bool = False,\n        lineterminator: str = \"\\r\\n\",\n        quoting: _QuotingType = 0,\n        strict: bool = False,\n    ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def writeheader(self) -> Any: ...\n    else:\n        def writeheader(self) -> None: ...\n\n    def writerow(self, rowdict: Mapping[_T, Any]) -> Any: ...\n    def writerows(self, rowdicts: Iterable[Mapping[_T, Any]]) -> None: ...\n    if sys.version_info >= (3, 12):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Sniffer:\n    preferred: list[str]\n    def sniff(self, sample: str, delimiters: str | None = None) -> type[Dialect]: ...\n    def has_header(self, sample: str) -> bool: ...\n",
  "/typeshed/stdlib/dataclasses.pyi": "import enum\nimport sys\nimport types\nfrom _typeshed import DataclassInstance\nfrom builtins import type as Type  # alias to avoid name clashes with fields named \"type\"\nfrom collections.abc import Callable, Iterable, Mapping\nfrom typing import Any, Generic, Protocol, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias, TypeGuard\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n\n__all__ = [\n    \"dataclass\",\n    \"field\",\n    \"Field\",\n    \"FrozenInstanceError\",\n    \"InitVar\",\n    \"MISSING\",\n    \"fields\",\n    \"asdict\",\n    \"astuple\",\n    \"make_dataclass\",\n    \"replace\",\n    \"is_dataclass\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"KW_ONLY\"]\n\n_DataclassT = TypeVar(\"_DataclassT\", bound=DataclassInstance)\n\n# define _MISSING_TYPE as an enum within the type stubs,\n# even though that is not really its type at runtime\n# this allows us to use Literal[_MISSING_TYPE.MISSING]\n# for background, see:\n#   https://github.com/python/typeshed/pull/5900#issuecomment-895513797\nclass _MISSING_TYPE(enum.Enum):\n    MISSING = enum.auto()\n\nMISSING = _MISSING_TYPE.MISSING\n\nif sys.version_info >= (3, 10):\n    class KW_ONLY: ...\n\n@overload\ndef asdict(obj: DataclassInstance) -> dict[str, Any]: ...\n@overload\ndef asdict(obj: DataclassInstance, *, dict_factory: Callable[[list[tuple[str, Any]]], _T]) -> _T: ...\n@overload\ndef astuple(obj: DataclassInstance) -> tuple[Any, ...]: ...\n@overload\ndef astuple(obj: DataclassInstance, *, tuple_factory: Callable[[list[Any]], _T]) -> _T: ...\n\nif sys.version_info >= (3, 8):\n    # cls argument is now positional-only\n    @overload\n    def dataclass(__cls: None) -> Callable[[type[_T]], type[_T]]: ...\n    @overload\n    def dataclass(__cls: type[_T]) -> type[_T]: ...\n\nelse:\n    @overload\n    def dataclass(_cls: None) -> Callable[[type[_T]], type[_T]]: ...\n    @overload\n    def dataclass(_cls: type[_T]) -> type[_T]: ...\n\nif sys.version_info >= (3, 11):\n    @overload\n    def dataclass(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\nelif sys.version_info >= (3, 10):\n    @overload\n    def dataclass(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\nelse:\n    @overload\n    def dataclass(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\n# See https://github.com/python/mypy/issues/10750\nclass _DefaultFactory(Protocol[_T_co]):\n    def __call__(self) -> _T_co: ...\n\nclass Field(Generic[_T]):\n    name: str\n    type: Type[_T]\n    default: _T | Literal[_MISSING_TYPE.MISSING]\n    default_factory: _DefaultFactory[_T] | Literal[_MISSING_TYPE.MISSING]\n    repr: bool\n    hash: bool | None\n    init: bool\n    compare: bool\n    metadata: types.MappingProxyType[Any, Any]\n    if sys.version_info >= (3, 10):\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING]\n        def __init__(\n            self,\n            default: _T,\n            default_factory: Callable[[], _T],\n            init: bool,\n            repr: bool,\n            hash: bool | None,\n            compare: bool,\n            metadata: Mapping[Any, Any],\n            kw_only: bool,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            default: _T,\n            default_factory: Callable[[], _T],\n            init: bool,\n            repr: bool,\n            hash: bool | None,\n            compare: bool,\n            metadata: Mapping[Any, Any],\n        ) -> None: ...\n\n    def __set_name__(self, owner: Type[Any], name: str) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# NOTE: Actual return type is 'Field[_T]', but we want to help type checkers\n# to understand the magic that happens at runtime.\nif sys.version_info >= (3, 10):\n    @overload  # `default` and `default_factory` are optional and mutually exclusive.\n    def field(\n        *,\n        default: _T,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool = ...,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default_factory: Callable[[], _T],\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool = ...,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool = ...,\n    ) -> Any: ...\n\nelse:\n    @overload  # `default` and `default_factory` are optional and mutually exclusive.\n    def field(\n        *,\n        default: _T,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default_factory: Callable[[], _T],\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> Any: ...\n\ndef fields(class_or_instance: DataclassInstance | type[DataclassInstance]) -> tuple[Field[Any], ...]: ...\n@overload\ndef is_dataclass(obj: DataclassInstance) -> Literal[True]: ...\n@overload\ndef is_dataclass(obj: type) -> TypeGuard[type[DataclassInstance]]: ...\n@overload\ndef is_dataclass(obj: object) -> TypeGuard[DataclassInstance | type[DataclassInstance]]: ...\n\nclass FrozenInstanceError(AttributeError): ...\n\nif sys.version_info >= (3, 9):\n    _InitVarMeta: TypeAlias = type\nelse:\n    class _InitVarMeta(type):\n        # Not used, instead `InitVar.__class_getitem__` is called.\n        def __getitem__(self, params: Any) -> InitVar[Any]: ...\n\nclass InitVar(Generic[_T], metaclass=_InitVarMeta):\n    type: Type[_T]\n    def __init__(self, type: Type[_T]) -> None: ...\n    if sys.version_info >= (3, 9):\n        @overload\n        def __class_getitem__(cls, type: Type[_T]) -> InitVar[_T]: ...\n        @overload\n        def __class_getitem__(cls, type: Any) -> InitVar[Any]: ...\n\nif sys.version_info >= (3, 12):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n        module: str | None = None,\n    ) -> type: ...\n\nelif sys.version_info >= (3, 11):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> type: ...\n\nelif sys.version_info >= (3, 10):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n    ) -> type: ...\n\nelse:\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, type] | tuple[str, type, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n    ) -> type: ...\n\ndef replace(__obj: _DataclassT, **changes: Any) -> _DataclassT: ...\n",
  "/typeshed/stdlib/datetime.pyi": "import sys\nfrom abc import abstractmethod\nfrom time import struct_time\nfrom typing import ClassVar, NamedTuple, NoReturn, TypeVar, overload\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias, final\n\nif sys.version_info >= (3, 11):\n    __all__ = (\"date\", \"datetime\", \"time\", \"timedelta\", \"timezone\", \"tzinfo\", \"MINYEAR\", \"MAXYEAR\", \"UTC\")\nelif sys.version_info >= (3, 9):\n    __all__ = (\"date\", \"datetime\", \"time\", \"timedelta\", \"timezone\", \"tzinfo\", \"MINYEAR\", \"MAXYEAR\")\n\n_D = TypeVar(\"_D\", bound=date)\n\nMINYEAR: Literal[1]\nMAXYEAR: Literal[9999]\n\nclass tzinfo:\n    @abstractmethod\n    def tzname(self, __dt: datetime | None) -> str | None: ...\n    @abstractmethod\n    def utcoffset(self, __dt: datetime | None) -> timedelta | None: ...\n    @abstractmethod\n    def dst(self, __dt: datetime | None) -> timedelta | None: ...\n    def fromutc(self, __dt: datetime) -> datetime: ...\n\n# Alias required to avoid name conflicts with date(time).tzinfo.\n_TzInfo: TypeAlias = tzinfo\n\n@final\nclass timezone(tzinfo):\n    utc: ClassVar[timezone]\n    min: ClassVar[timezone]\n    max: ClassVar[timezone]\n    def __init__(self, offset: timedelta, name: str = ...) -> None: ...\n    def tzname(self, __dt: datetime | None) -> str: ...\n    def utcoffset(self, __dt: datetime | None) -> timedelta: ...\n    def dst(self, __dt: datetime | None) -> None: ...\n\nif sys.version_info >= (3, 11):\n    UTC: timezone\n\nif sys.version_info >= (3, 9):\n    class _IsoCalendarDate(NamedTuple):\n        year: int\n        week: int\n        weekday: int\n\nclass date:\n    min: ClassVar[date]\n    max: ClassVar[date]\n    resolution: ClassVar[timedelta]\n    def __new__(cls, year: SupportsIndex, month: SupportsIndex, day: SupportsIndex) -> Self: ...\n    @classmethod\n    def fromtimestamp(cls, __timestamp: float) -> Self: ...\n    @classmethod\n    def today(cls) -> Self: ...\n    @classmethod\n    def fromordinal(cls, __n: int) -> Self: ...\n    @classmethod\n    def fromisoformat(cls, __date_string: str) -> Self: ...\n    if sys.version_info >= (3, 8):\n        @classmethod\n        def fromisocalendar(cls, year: int, week: int, day: int) -> Self: ...\n\n    @property\n    def year(self) -> int: ...\n    @property\n    def month(self) -> int: ...\n    @property\n    def day(self) -> int: ...\n    def ctime(self) -> str: ...\n    # On <3.12, the name of the parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        def strftime(self, format: str) -> str: ...\n    else:\n        def strftime(self, __format: str) -> str: ...\n\n    def __format__(self, __fmt: str) -> str: ...\n    def isoformat(self) -> str: ...\n    def timetuple(self) -> struct_time: ...\n    def toordinal(self) -> int: ...\n    def replace(self, year: SupportsIndex = ..., month: SupportsIndex = ..., day: SupportsIndex = ...) -> Self: ...\n    def __le__(self, __value: date) -> bool: ...\n    def __lt__(self, __value: date) -> bool: ...\n    def __ge__(self, __value: date) -> bool: ...\n    def __gt__(self, __value: date) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def __add__(self, __value: timedelta) -> Self: ...\n        def __radd__(self, __value: timedelta) -> Self: ...\n        @overload\n        def __sub__(self, __value: timedelta) -> Self: ...\n        @overload\n        def __sub__(self, __value: datetime) -> NoReturn: ...\n        @overload\n        def __sub__(self: _D, __value: _D) -> timedelta: ...\n    else:\n        # Prior to Python 3.8, arithmetic operations always returned `date`, even in subclasses\n        def __add__(self, __value: timedelta) -> date: ...\n        def __radd__(self, __value: timedelta) -> date: ...\n        @overload\n        def __sub__(self, __value: timedelta) -> date: ...\n        @overload\n        def __sub__(self, __value: datetime) -> NoReturn: ...\n        @overload\n        def __sub__(self, __value: date) -> timedelta: ...\n\n    def weekday(self) -> int: ...\n    def isoweekday(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def isocalendar(self) -> _IsoCalendarDate: ...\n    else:\n        def isocalendar(self) -> tuple[int, int, int]: ...\n\nclass time:\n    min: ClassVar[time]\n    max: ClassVar[time]\n    resolution: ClassVar[timedelta]\n    def __new__(\n        cls,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n    @property\n    def hour(self) -> int: ...\n    @property\n    def minute(self) -> int: ...\n    @property\n    def second(self) -> int: ...\n    @property\n    def microsecond(self) -> int: ...\n    @property\n    def tzinfo(self) -> _TzInfo | None: ...\n    @property\n    def fold(self) -> int: ...\n    def __le__(self, __value: time) -> bool: ...\n    def __lt__(self, __value: time) -> bool: ...\n    def __ge__(self, __value: time) -> bool: ...\n    def __gt__(self, __value: time) -> bool: ...\n    def isoformat(self, timespec: str = ...) -> str: ...\n    @classmethod\n    def fromisoformat(cls, __time_string: str) -> Self: ...\n    # On <3.12, the name of the parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        def strftime(self, format: str) -> str: ...\n    else:\n        def strftime(self, __format: str) -> str: ...\n\n    def __format__(self, __fmt: str) -> str: ...\n    def utcoffset(self) -> timedelta | None: ...\n    def tzname(self) -> str | None: ...\n    def dst(self) -> timedelta | None: ...\n    def replace(\n        self,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n\n_Date: TypeAlias = date\n_Time: TypeAlias = time\n\nclass timedelta:\n    min: ClassVar[timedelta]\n    max: ClassVar[timedelta]\n    resolution: ClassVar[timedelta]\n    def __new__(\n        cls,\n        days: float = ...,\n        seconds: float = ...,\n        microseconds: float = ...,\n        milliseconds: float = ...,\n        minutes: float = ...,\n        hours: float = ...,\n        weeks: float = ...,\n    ) -> Self: ...\n    @property\n    def days(self) -> int: ...\n    @property\n    def seconds(self) -> int: ...\n    @property\n    def microseconds(self) -> int: ...\n    def total_seconds(self) -> float: ...\n    def __add__(self, __value: timedelta) -> timedelta: ...\n    def __radd__(self, __value: timedelta) -> timedelta: ...\n    def __sub__(self, __value: timedelta) -> timedelta: ...\n    def __rsub__(self, __value: timedelta) -> timedelta: ...\n    def __neg__(self) -> timedelta: ...\n    def __pos__(self) -> timedelta: ...\n    def __abs__(self) -> timedelta: ...\n    def __mul__(self, __value: float) -> timedelta: ...\n    def __rmul__(self, __value: float) -> timedelta: ...\n    @overload\n    def __floordiv__(self, __value: timedelta) -> int: ...\n    @overload\n    def __floordiv__(self, __value: int) -> timedelta: ...\n    @overload\n    def __truediv__(self, __value: timedelta) -> float: ...\n    @overload\n    def __truediv__(self, __value: float) -> timedelta: ...\n    def __mod__(self, __value: timedelta) -> timedelta: ...\n    def __divmod__(self, __value: timedelta) -> tuple[int, timedelta]: ...\n    def __le__(self, __value: timedelta) -> bool: ...\n    def __lt__(self, __value: timedelta) -> bool: ...\n    def __ge__(self, __value: timedelta) -> bool: ...\n    def __gt__(self, __value: timedelta) -> bool: ...\n    def __bool__(self) -> bool: ...\n\nclass datetime(date):\n    min: ClassVar[datetime]\n    max: ClassVar[datetime]\n    def __new__(\n        cls,\n        year: SupportsIndex,\n        month: SupportsIndex,\n        day: SupportsIndex,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n    @property\n    def hour(self) -> int: ...\n    @property\n    def minute(self) -> int: ...\n    @property\n    def second(self) -> int: ...\n    @property\n    def microsecond(self) -> int: ...\n    @property\n    def tzinfo(self) -> _TzInfo | None: ...\n    @property\n    def fold(self) -> int: ...\n    # On <3.12, the name of the first parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        @classmethod\n        def fromtimestamp(cls, timestamp: float, tz: _TzInfo | None = ...) -> Self: ...\n    else:\n        @classmethod\n        def fromtimestamp(cls, __timestamp: float, tz: _TzInfo | None = ...) -> Self: ...\n\n    @classmethod\n    def utcfromtimestamp(cls, __t: float) -> Self: ...\n    if sys.version_info >= (3, 8):\n        @classmethod\n        def now(cls, tz: _TzInfo | None = None) -> Self: ...\n    else:\n        @overload\n        @classmethod\n        def now(cls, tz: None = None) -> Self: ...\n        @overload\n        @classmethod\n        def now(cls, tz: _TzInfo) -> datetime: ...\n\n    @classmethod\n    def utcnow(cls) -> Self: ...\n    @classmethod\n    def combine(cls, date: _Date, time: _Time, tzinfo: _TzInfo | None = ...) -> Self: ...\n    def timestamp(self) -> float: ...\n    def utctimetuple(self) -> struct_time: ...\n    def date(self) -> _Date: ...\n    def time(self) -> _Time: ...\n    def timetz(self) -> _Time: ...\n    def replace(\n        self,\n        year: SupportsIndex = ...,\n        month: SupportsIndex = ...,\n        day: SupportsIndex = ...,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n    if sys.version_info >= (3, 8):\n        def astimezone(self, tz: _TzInfo | None = ...) -> Self: ...\n    else:\n        def astimezone(self, tz: _TzInfo | None = ...) -> datetime: ...\n\n    def isoformat(self, sep: str = ..., timespec: str = ...) -> str: ...\n    @classmethod\n    def strptime(cls, __date_string: str, __format: str) -> Self: ...\n    def utcoffset(self) -> timedelta | None: ...\n    def tzname(self) -> str | None: ...\n    def dst(self) -> timedelta | None: ...\n    def __le__(self, __value: datetime) -> bool: ...  # type: ignore[override]\n    def __lt__(self, __value: datetime) -> bool: ...  # type: ignore[override]\n    def __ge__(self, __value: datetime) -> bool: ...  # type: ignore[override]\n    def __gt__(self, __value: datetime) -> bool: ...  # type: ignore[override]\n    if sys.version_info >= (3, 8):\n        @overload  # type: ignore[override]\n        def __sub__(self, __value: timedelta) -> Self: ...\n        @overload\n        def __sub__(self: _D, __value: _D) -> timedelta: ...\n    else:\n        # Prior to Python 3.8, arithmetic operations always returned `datetime`, even in subclasses\n        def __add__(self, __value: timedelta) -> datetime: ...\n        def __radd__(self, __value: timedelta) -> datetime: ...\n        @overload  # type: ignore[override]\n        def __sub__(self, __value: datetime) -> timedelta: ...\n        @overload\n        def __sub__(self, __value: timedelta) -> datetime: ...\n",
  "/typeshed/stdlib/decimal.pyi": "from _decimal import *\nfrom _decimal import __libmpdec_version__ as __libmpdec_version__, __version__ as __version__\n",
  "/typeshed/stdlib/difflib.pyi": "import sys\nfrom collections.abc import Callable, Iterable, Iterator, Sequence\nfrom typing import Any, AnyStr, Generic, NamedTuple, TypeVar, overload\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"get_close_matches\",\n    \"ndiff\",\n    \"restore\",\n    \"SequenceMatcher\",\n    \"Differ\",\n    \"IS_CHARACTER_JUNK\",\n    \"IS_LINE_JUNK\",\n    \"context_diff\",\n    \"unified_diff\",\n    \"diff_bytes\",\n    \"HtmlDiff\",\n    \"Match\",\n]\n\n_T = TypeVar(\"_T\")\n\nclass Match(NamedTuple):\n    a: int\n    b: int\n    size: int\n\nclass SequenceMatcher(Generic[_T]):\n    @overload\n    def __init__(self, isjunk: Callable[[_T], bool] | None, a: Sequence[_T], b: Sequence[_T], autojunk: bool = True) -> None: ...\n    @overload\n    def __init__(self, *, a: Sequence[_T], b: Sequence[_T], autojunk: bool = True) -> None: ...\n    @overload\n    def __init__(\n        self: SequenceMatcher[str],\n        isjunk: Callable[[str], bool] | None = None,\n        a: Sequence[str] = \"\",\n        b: Sequence[str] = \"\",\n        autojunk: bool = True,\n    ) -> None: ...\n    def set_seqs(self, a: Sequence[_T], b: Sequence[_T]) -> None: ...\n    def set_seq1(self, a: Sequence[_T]) -> None: ...\n    def set_seq2(self, b: Sequence[_T]) -> None: ...\n    if sys.version_info >= (3, 9):\n        def find_longest_match(self, alo: int = 0, ahi: int | None = None, blo: int = 0, bhi: int | None = None) -> Match: ...\n    else:\n        def find_longest_match(self, alo: int, ahi: int, blo: int, bhi: int) -> Match: ...\n\n    def get_matching_blocks(self) -> list[Match]: ...\n    def get_opcodes(self) -> list[tuple[str, int, int, int, int]]: ...\n    def get_grouped_opcodes(self, n: int = 3) -> Iterable[list[tuple[str, int, int, int, int]]]: ...\n    def ratio(self) -> float: ...\n    def quick_ratio(self) -> float: ...\n    def real_quick_ratio(self) -> float: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n@overload\ndef get_close_matches(word: AnyStr, possibilities: Iterable[AnyStr], n: int = 3, cutoff: float = 0.6) -> list[AnyStr]: ...\n@overload\ndef get_close_matches(\n    word: Sequence[_T], possibilities: Iterable[Sequence[_T]], n: int = 3, cutoff: float = 0.6\n) -> list[Sequence[_T]]: ...\n\nclass Differ:\n    def __init__(self, linejunk: Callable[[str], bool] | None = None, charjunk: Callable[[str], bool] | None = None) -> None: ...\n    def compare(self, a: Sequence[str], b: Sequence[str]) -> Iterator[str]: ...\n\ndef IS_LINE_JUNK(line: str, pat: Any = ...) -> bool: ...  # pat is undocumented\ndef IS_CHARACTER_JUNK(ch: str, ws: str = \" \\t\") -> bool: ...  # ws is undocumented\ndef unified_diff(\n    a: Sequence[str],\n    b: Sequence[str],\n    fromfile: str = \"\",\n    tofile: str = \"\",\n    fromfiledate: str = \"\",\n    tofiledate: str = \"\",\n    n: int = 3,\n    lineterm: str = \"\\n\",\n) -> Iterator[str]: ...\ndef context_diff(\n    a: Sequence[str],\n    b: Sequence[str],\n    fromfile: str = \"\",\n    tofile: str = \"\",\n    fromfiledate: str = \"\",\n    tofiledate: str = \"\",\n    n: int = 3,\n    lineterm: str = \"\\n\",\n) -> Iterator[str]: ...\ndef ndiff(\n    a: Sequence[str],\n    b: Sequence[str],\n    linejunk: Callable[[str], bool] | None = None,\n    charjunk: Callable[[str], bool] | None = ...,\n) -> Iterator[str]: ...\n\nclass HtmlDiff:\n    def __init__(\n        self,\n        tabsize: int = 8,\n        wrapcolumn: int | None = None,\n        linejunk: Callable[[str], bool] | None = None,\n        charjunk: Callable[[str], bool] | None = ...,\n    ) -> None: ...\n    def make_file(\n        self,\n        fromlines: Sequence[str],\n        tolines: Sequence[str],\n        fromdesc: str = \"\",\n        todesc: str = \"\",\n        context: bool = False,\n        numlines: int = 5,\n        *,\n        charset: str = \"utf-8\",\n    ) -> str: ...\n    def make_table(\n        self,\n        fromlines: Sequence[str],\n        tolines: Sequence[str],\n        fromdesc: str = \"\",\n        todesc: str = \"\",\n        context: bool = False,\n        numlines: int = 5,\n    ) -> str: ...\n\ndef restore(delta: Iterable[str], which: int) -> Iterator[str]: ...\ndef diff_bytes(\n    dfunc: Callable[[Sequence[str], Sequence[str], str, str, str, str, int, str], Iterator[str]],\n    a: Iterable[bytes | bytearray],\n    b: Iterable[bytes | bytearray],\n    fromfile: bytes | bytearray = b\"\",\n    tofile: bytes | bytearray = b\"\",\n    fromfiledate: bytes | bytearray = b\"\",\n    tofiledate: bytes | bytearray = b\"\",\n    n: int = 3,\n    lineterm: bytes | bytearray = b\"\\n\",\n) -> Iterator[bytes]: ...\n",
  "/typeshed/stdlib/dis.pyi": "import sys\nimport types\nfrom collections.abc import Callable, Iterator\nfrom opcode import *  # `dis` re-exports it as a part of public API\nfrom typing import IO, Any, NamedTuple\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\n    \"code_info\",\n    \"dis\",\n    \"disassemble\",\n    \"distb\",\n    \"disco\",\n    \"findlinestarts\",\n    \"findlabels\",\n    \"show_code\",\n    \"get_instructions\",\n    \"Instruction\",\n    \"Bytecode\",\n    \"cmp_op\",\n    \"hasconst\",\n    \"hasname\",\n    \"hasjrel\",\n    \"hasjabs\",\n    \"haslocal\",\n    \"hascompare\",\n    \"hasfree\",\n    \"opname\",\n    \"opmap\",\n    \"HAVE_ARGUMENT\",\n    \"EXTENDED_ARG\",\n    \"hasnargs\",\n    \"stack_effect\",\n]\n\n# Strictly this should not have to include Callable, but mypy doesn't use FunctionType\n# for functions (python/mypy#3171)\n_HaveCodeType: TypeAlias = types.MethodType | types.FunctionType | types.CodeType | type | Callable[..., Any]\n\nif sys.version_info >= (3, 11):\n    class Positions(NamedTuple):\n        lineno: int | None = None\n        end_lineno: int | None = None\n        col_offset: int | None = None\n        end_col_offset: int | None = None\n\nif sys.version_info >= (3, 11):\n    class Instruction(NamedTuple):\n        opname: str\n        opcode: int\n        arg: int | None\n        argval: Any\n        argrepr: str\n        offset: int\n        starts_line: int | None\n        is_jump_target: bool\n        positions: Positions | None = None\n\nelse:\n    class Instruction(NamedTuple):\n        opname: str\n        opcode: int\n        arg: int | None\n        argval: Any\n        argrepr: str\n        offset: int\n        starts_line: int | None\n        is_jump_target: bool\n\nclass Bytecode:\n    codeobj: types.CodeType\n    first_line: int\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            x: _HaveCodeType | str,\n            *,\n            first_line: int | None = None,\n            current_offset: int | None = None,\n            show_caches: bool = False,\n            adaptive: bool = False,\n        ) -> None: ...\n        @classmethod\n        def from_traceback(cls, tb: types.TracebackType, *, show_caches: bool = False, adaptive: bool = False) -> Self: ...\n    else:\n        def __init__(\n            self, x: _HaveCodeType | str, *, first_line: int | None = None, current_offset: int | None = None\n        ) -> None: ...\n        @classmethod\n        def from_traceback(cls, tb: types.TracebackType) -> Self: ...\n\n    def __iter__(self) -> Iterator[Instruction]: ...\n    def info(self) -> str: ...\n    def dis(self) -> str: ...\n\nCOMPILER_FLAG_NAMES: dict[int, str]\n\ndef findlabels(code: _HaveCodeType) -> list[int]: ...\ndef findlinestarts(code: _HaveCodeType) -> Iterator[tuple[int, int]]: ...\ndef pretty_flags(flags: int) -> str: ...\ndef code_info(x: _HaveCodeType | str) -> str: ...\n\nif sys.version_info >= (3, 11):\n    def dis(\n        x: _HaveCodeType | str | bytes | bytearray | None = None,\n        *,\n        file: IO[str] | None = None,\n        depth: int | None = None,\n        show_caches: bool = False,\n        adaptive: bool = False,\n    ) -> None: ...\n\nelse:\n    def dis(\n        x: _HaveCodeType | str | bytes | bytearray | None = None, *, file: IO[str] | None = None, depth: int | None = None\n    ) -> None: ...\n\nif sys.version_info >= (3, 11):\n    def disassemble(\n        co: _HaveCodeType, lasti: int = -1, *, file: IO[str] | None = None, show_caches: bool = False, adaptive: bool = False\n    ) -> None: ...\n    def disco(\n        co: _HaveCodeType, lasti: int = -1, *, file: IO[str] | None = None, show_caches: bool = False, adaptive: bool = False\n    ) -> None: ...\n    def distb(\n        tb: types.TracebackType | None = None, *, file: IO[str] | None = None, show_caches: bool = False, adaptive: bool = False\n    ) -> None: ...\n    def get_instructions(\n        x: _HaveCodeType, *, first_line: int | None = None, show_caches: bool = False, adaptive: bool = False\n    ) -> Iterator[Instruction]: ...\n\nelse:\n    def disassemble(co: _HaveCodeType, lasti: int = -1, *, file: IO[str] | None = None) -> None: ...\n    def disco(co: _HaveCodeType, lasti: int = -1, *, file: IO[str] | None = None) -> None: ...\n    def distb(tb: types.TracebackType | None = None, *, file: IO[str] | None = None) -> None: ...\n    def get_instructions(x: _HaveCodeType, *, first_line: int | None = None) -> Iterator[Instruction]: ...\n\ndef show_code(co: _HaveCodeType, *, file: IO[str] | None = None) -> None: ...\n",
  "/typeshed/stdlib/doctest.pyi": "import types\nimport unittest\nfrom _typeshed import ExcInfo\nfrom collections.abc import Callable\nfrom typing import Any, NamedTuple\nfrom typing_extensions import TypeAlias\n\n__all__ = [\n    \"register_optionflag\",\n    \"DONT_ACCEPT_TRUE_FOR_1\",\n    \"DONT_ACCEPT_BLANKLINE\",\n    \"NORMALIZE_WHITESPACE\",\n    \"ELLIPSIS\",\n    \"SKIP\",\n    \"IGNORE_EXCEPTION_DETAIL\",\n    \"COMPARISON_FLAGS\",\n    \"REPORT_UDIFF\",\n    \"REPORT_CDIFF\",\n    \"REPORT_NDIFF\",\n    \"REPORT_ONLY_FIRST_FAILURE\",\n    \"REPORTING_FLAGS\",\n    \"FAIL_FAST\",\n    \"Example\",\n    \"DocTest\",\n    \"DocTestParser\",\n    \"DocTestFinder\",\n    \"DocTestRunner\",\n    \"OutputChecker\",\n    \"DocTestFailure\",\n    \"UnexpectedException\",\n    \"DebugRunner\",\n    \"testmod\",\n    \"testfile\",\n    \"run_docstring_examples\",\n    \"DocTestSuite\",\n    \"DocFileSuite\",\n    \"set_unittest_reportflags\",\n    \"script_from_examples\",\n    \"testsource\",\n    \"debug_src\",\n    \"debug\",\n]\n\nclass TestResults(NamedTuple):\n    failed: int\n    attempted: int\n\nOPTIONFLAGS_BY_NAME: dict[str, int]\n\ndef register_optionflag(name: str) -> int: ...\n\nDONT_ACCEPT_TRUE_FOR_1: int\nDONT_ACCEPT_BLANKLINE: int\nNORMALIZE_WHITESPACE: int\nELLIPSIS: int\nSKIP: int\nIGNORE_EXCEPTION_DETAIL: int\n\nCOMPARISON_FLAGS: int\n\nREPORT_UDIFF: int\nREPORT_CDIFF: int\nREPORT_NDIFF: int\nREPORT_ONLY_FIRST_FAILURE: int\nFAIL_FAST: int\n\nREPORTING_FLAGS: int\n\nBLANKLINE_MARKER: str\nELLIPSIS_MARKER: str\n\nclass Example:\n    source: str\n    want: str\n    exc_msg: str | None\n    lineno: int\n    indent: int\n    options: dict[int, bool]\n    def __init__(\n        self,\n        source: str,\n        want: str,\n        exc_msg: str | None = None,\n        lineno: int = 0,\n        indent: int = 0,\n        options: dict[int, bool] | None = None,\n    ) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass DocTest:\n    examples: list[Example]\n    globs: dict[str, Any]\n    name: str\n    filename: str | None\n    lineno: int | None\n    docstring: str | None\n    def __init__(\n        self,\n        examples: list[Example],\n        globs: dict[str, Any],\n        name: str,\n        filename: str | None,\n        lineno: int | None,\n        docstring: str | None,\n    ) -> None: ...\n    def __lt__(self, other: DocTest) -> bool: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass DocTestParser:\n    def parse(self, string: str, name: str = \"<string>\") -> list[str | Example]: ...\n    def get_doctest(self, string: str, globs: dict[str, Any], name: str, filename: str | None, lineno: int | None) -> DocTest: ...\n    def get_examples(self, string: str, name: str = \"<string>\") -> list[Example]: ...\n\nclass DocTestFinder:\n    def __init__(\n        self, verbose: bool = False, parser: DocTestParser = ..., recurse: bool = True, exclude_empty: bool = True\n    ) -> None: ...\n    def find(\n        self,\n        obj: object,\n        name: str | None = None,\n        module: None | bool | types.ModuleType = None,\n        globs: dict[str, Any] | None = None,\n        extraglobs: dict[str, Any] | None = None,\n    ) -> list[DocTest]: ...\n\n_Out: TypeAlias = Callable[[str], object]\n\nclass DocTestRunner:\n    DIVIDER: str\n    optionflags: int\n    original_optionflags: int\n    tries: int\n    failures: int\n    test: DocTest\n    def __init__(self, checker: OutputChecker | None = None, verbose: bool | None = None, optionflags: int = 0) -> None: ...\n    def report_start(self, out: _Out, test: DocTest, example: Example) -> None: ...\n    def report_success(self, out: _Out, test: DocTest, example: Example, got: str) -> None: ...\n    def report_failure(self, out: _Out, test: DocTest, example: Example, got: str) -> None: ...\n    def report_unexpected_exception(self, out: _Out, test: DocTest, example: Example, exc_info: ExcInfo) -> None: ...\n    def run(\n        self, test: DocTest, compileflags: int | None = None, out: _Out | None = None, clear_globs: bool = True\n    ) -> TestResults: ...\n    def summarize(self, verbose: bool | None = None) -> TestResults: ...\n    def merge(self, other: DocTestRunner) -> None: ...\n\nclass OutputChecker:\n    def check_output(self, want: str, got: str, optionflags: int) -> bool: ...\n    def output_difference(self, example: Example, got: str, optionflags: int) -> str: ...\n\nclass DocTestFailure(Exception):\n    test: DocTest\n    example: Example\n    got: str\n    def __init__(self, test: DocTest, example: Example, got: str) -> None: ...\n\nclass UnexpectedException(Exception):\n    test: DocTest\n    example: Example\n    exc_info: ExcInfo\n    def __init__(self, test: DocTest, example: Example, exc_info: ExcInfo) -> None: ...\n\nclass DebugRunner(DocTestRunner): ...\n\nmaster: DocTestRunner | None\n\ndef testmod(\n    m: types.ModuleType | None = None,\n    name: str | None = None,\n    globs: dict[str, Any] | None = None,\n    verbose: bool | None = None,\n    report: bool = True,\n    optionflags: int = 0,\n    extraglobs: dict[str, Any] | None = None,\n    raise_on_error: bool = False,\n    exclude_empty: bool = False,\n) -> TestResults: ...\ndef testfile(\n    filename: str,\n    module_relative: bool = True,\n    name: str | None = None,\n    package: None | str | types.ModuleType = None,\n    globs: dict[str, Any] | None = None,\n    verbose: bool | None = None,\n    report: bool = True,\n    optionflags: int = 0,\n    extraglobs: dict[str, Any] | None = None,\n    raise_on_error: bool = False,\n    parser: DocTestParser = ...,\n    encoding: str | None = None,\n) -> TestResults: ...\ndef run_docstring_examples(\n    f: object,\n    globs: dict[str, Any],\n    verbose: bool = False,\n    name: str = \"NoName\",\n    compileflags: int | None = None,\n    optionflags: int = 0,\n) -> None: ...\ndef set_unittest_reportflags(flags: int) -> int: ...\n\nclass DocTestCase(unittest.TestCase):\n    def __init__(\n        self,\n        test: DocTest,\n        optionflags: int = 0,\n        setUp: Callable[[DocTest], Any] | None = None,\n        tearDown: Callable[[DocTest], Any] | None = None,\n        checker: OutputChecker | None = None,\n    ) -> None: ...\n    def runTest(self) -> None: ...\n    def format_failure(self, err: str) -> str: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass SkipDocTestCase(DocTestCase):\n    def __init__(self, module: types.ModuleType) -> None: ...\n    def test_skip(self) -> None: ...\n\nclass _DocTestSuite(unittest.TestSuite): ...\n\ndef DocTestSuite(\n    module: None | str | types.ModuleType = None,\n    globs: dict[str, Any] | None = None,\n    extraglobs: dict[str, Any] | None = None,\n    test_finder: DocTestFinder | None = None,\n    **options: Any,\n) -> _DocTestSuite: ...\n\nclass DocFileCase(DocTestCase): ...\n\ndef DocFileTest(\n    path: str,\n    module_relative: bool = True,\n    package: None | str | types.ModuleType = None,\n    globs: dict[str, Any] | None = None,\n    parser: DocTestParser = ...,\n    encoding: str | None = None,\n    **options: Any,\n) -> DocFileCase: ...\ndef DocFileSuite(*paths: str, **kw: Any) -> _DocTestSuite: ...\ndef script_from_examples(s: str) -> str: ...\ndef testsource(module: None | str | types.ModuleType, name: str) -> str: ...\ndef debug_src(src: str, pm: bool = False, globs: dict[str, Any] | None = None) -> None: ...\ndef debug_script(src: str, pm: bool = False, globs: dict[str, Any] | None = None) -> None: ...\ndef debug(module: None | str | types.ModuleType, name: str, pm: bool = False) -> None: ...\n",
  "/typeshed/stdlib/dummy_threading.pyi": "from _dummy_threading import *\nfrom _dummy_threading import __all__ as __all__\n",
  "/typeshed/stdlib/enum.pyi": "import _typeshed\nimport sys\nimport types\nfrom _typeshed import SupportsKeysAndGetItem, Unused\nfrom abc import ABCMeta\nfrom builtins import property as _builtins_property\nfrom collections.abc import Iterable, Iterator, Mapping\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\"EnumMeta\", \"Enum\", \"IntEnum\", \"Flag\", \"IntFlag\", \"auto\", \"unique\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\n        \"CONFORM\",\n        \"CONTINUOUS\",\n        \"EJECT\",\n        \"EnumCheck\",\n        \"EnumType\",\n        \"FlagBoundary\",\n        \"KEEP\",\n        \"NAMED_FLAGS\",\n        \"ReprEnum\",\n        \"STRICT\",\n        \"StrEnum\",\n        \"UNIQUE\",\n        \"global_enum\",\n        \"global_enum_repr\",\n        \"global_flag_repr\",\n        \"global_str\",\n        \"member\",\n        \"nonmember\",\n        \"property\",\n        \"verify\",\n    ]\n\n_EnumMemberT = TypeVar(\"_EnumMemberT\")\n_EnumerationT = TypeVar(\"_EnumerationT\", bound=type[Enum])\n\n# The following all work:\n# >>> from enum import Enum\n# >>> from string import ascii_lowercase\n# >>> Enum('Foo', names='RED YELLOW GREEN')\n# <enum 'Foo'>\n# >>> Enum('Foo', names=[('RED', 1), ('YELLOW, 2)])\n# <enum 'Foo'>\n# >>> Enum('Foo', names=((x for x in (ascii_lowercase[i], i)) for i in range(5)))\n# <enum 'Foo'>\n# >>> Enum('Foo', names={'RED': 1, 'YELLOW': 2})\n# <enum 'Foo'>\n_EnumNames: TypeAlias = str | Iterable[str] | Iterable[Iterable[str | Any]] | Mapping[str, Any]\n\nif sys.version_info >= (3, 11):\n    class nonmember(Generic[_EnumMemberT]):\n        value: _EnumMemberT\n        def __init__(self, value: _EnumMemberT) -> None: ...\n\n    class member(Generic[_EnumMemberT]):\n        value: _EnumMemberT\n        def __init__(self, value: _EnumMemberT) -> None: ...\n\nclass _EnumDict(dict[str, Any]):\n    def __init__(self) -> None: ...\n    def __setitem__(self, key: str, value: Any) -> None: ...\n    if sys.version_info >= (3, 11):\n        # See comment above `typing.MutableMapping.update`\n        # for why overloads are preferable to a Union here\n        #\n        # Unlike with MutableMapping.update(), the first argument is required,\n        # hence the type: ignore\n        @overload  # type: ignore[override]\n        def update(self, members: SupportsKeysAndGetItem[str, Any], **more_members: Any) -> None: ...\n        @overload\n        def update(self, members: Iterable[tuple[str, Any]], **more_members: Any) -> None: ...\n\n# Note: EnumMeta actually subclasses type directly, not ABCMeta.\n# This is a temporary workaround to allow multiple creation of enums with builtins\n# such as str as mixins, which due to the handling of ABCs of builtin types, cause\n# spurious inconsistent metaclass structure. See #1595.\n# Structurally: Iterable[T], Reversible[T], Container[T] where T is the enum itself\nclass EnumMeta(ABCMeta):\n    if sys.version_info >= (3, 11):\n        def __new__(\n            metacls: type[_typeshed.Self],\n            cls: str,\n            bases: tuple[type, ...],\n            classdict: _EnumDict,\n            *,\n            boundary: FlagBoundary | None = None,\n            _simple: bool = False,\n            **kwds: Any,\n        ) -> _typeshed.Self: ...\n    elif sys.version_info >= (3, 9):\n        def __new__(\n            metacls: type[_typeshed.Self], cls: str, bases: tuple[type, ...], classdict: _EnumDict, **kwds: Any\n        ) -> _typeshed.Self: ...\n    else:\n        def __new__(metacls: type[_typeshed.Self], cls: str, bases: tuple[type, ...], classdict: _EnumDict) -> _typeshed.Self: ...\n\n    if sys.version_info >= (3, 9):\n        @classmethod\n        def __prepare__(metacls, cls: str, bases: tuple[type, ...], **kwds: Any) -> _EnumDict: ...  # type: ignore[override]\n    else:\n        @classmethod\n        def __prepare__(metacls, cls: str, bases: tuple[type, ...]) -> _EnumDict: ...  # type: ignore[override]\n\n    def __iter__(self: type[_EnumMemberT]) -> Iterator[_EnumMemberT]: ...\n    def __reversed__(self: type[_EnumMemberT]) -> Iterator[_EnumMemberT]: ...\n    if sys.version_info >= (3, 12):\n        def __contains__(self: type[Any], value: object) -> bool: ...\n    elif sys.version_info >= (3, 11):\n        def __contains__(self: type[Any], member: object) -> bool: ...\n    elif sys.version_info >= (3, 10):\n        def __contains__(self: type[Any], obj: object) -> bool: ...\n    else:\n        def __contains__(self: type[Any], member: object) -> bool: ...\n\n    def __getitem__(self: type[_EnumMemberT], name: str) -> _EnumMemberT: ...\n    @_builtins_property\n    def __members__(self: type[_EnumMemberT]) -> types.MappingProxyType[str, _EnumMemberT]: ...\n    def __len__(self) -> int: ...\n    def __bool__(self) -> Literal[True]: ...\n    def __dir__(self) -> list[str]: ...\n    # Simple value lookup\n    @overload\n    def __call__(cls: type[_EnumMemberT], value: Any, names: None = None) -> _EnumMemberT: ...\n    # Functional Enum API\n    if sys.version_info >= (3, 11):\n        @overload\n        def __call__(\n            cls,\n            value: str,\n            names: _EnumNames,\n            *,\n            module: str | None = None,\n            qualname: str | None = None,\n            type: type | None = None,\n            start: int = 1,\n            boundary: FlagBoundary | None = None,\n        ) -> type[Enum]: ...\n    else:\n        @overload\n        def __call__(\n            cls,\n            value: str,\n            names: _EnumNames,\n            *,\n            module: str | None = None,\n            qualname: str | None = None,\n            type: type | None = None,\n            start: int = 1,\n        ) -> type[Enum]: ...\n    _member_names_: list[str]  # undocumented\n    _member_map_: dict[str, Enum]  # undocumented\n    _value2member_map_: dict[Any, Enum]  # undocumented\n\nif sys.version_info >= (3, 11):\n    # In 3.11 `EnumMeta` metaclass is renamed to `EnumType`, but old name also exists.\n    EnumType = EnumMeta\n\n    class property(types.DynamicClassAttribute):\n        def __set_name__(self, ownerclass: type[Enum], name: str) -> None: ...\n        name: str\n        clsname: str\n    _magic_enum_attr = property\nelse:\n    _magic_enum_attr = types.DynamicClassAttribute\n\nclass Enum(metaclass=EnumMeta):\n    @_magic_enum_attr\n    def name(self) -> str: ...\n    @_magic_enum_attr\n    def value(self) -> Any: ...\n    _name_: str\n    _value_: Any\n    _ignore_: str | list[str]\n    _order_: str\n    __order__: str\n    @classmethod\n    def _missing_(cls, value: object) -> Any: ...\n    @staticmethod\n    def _generate_next_value_(name: str, start: int, count: int, last_values: list[Any]) -> Any: ...\n    # It's not true that `__new__` will accept any argument type,\n    # so ideally we'd use `Any` to indicate that the argument type is inexpressible.\n    # However, using `Any` causes too many false-positives for those using mypy's `--disallow-any-expr`\n    # (see #7752, #2539, mypy/#5788),\n    # and in practice using `object` here has the same effect as using `Any`.\n    def __new__(cls, value: object) -> Self: ...\n    def __dir__(self) -> list[str]: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __reduce_ex__(self, proto: Unused) -> tuple[Any, ...]: ...\n\nif sys.version_info >= (3, 11):\n    class ReprEnum(Enum): ...\n\nif sys.version_info >= (3, 11):\n    _IntEnumBase = ReprEnum\nelse:\n    _IntEnumBase = Enum\n\nclass IntEnum(int, _IntEnumBase):\n    _value_: int\n    @_magic_enum_attr\n    def value(self) -> int: ...\n    def __new__(cls, value: int) -> Self: ...\n\ndef unique(enumeration: _EnumerationT) -> _EnumerationT: ...\n\n_auto_null: Any\n\n# subclassing IntFlag so it picks up all implemented base functions, best modeling behavior of enum.auto()\nclass auto(IntFlag):\n    _value_: Any\n    @_magic_enum_attr\n    def value(self) -> Any: ...\n    def __new__(cls) -> Self: ...\n\nclass Flag(Enum):\n    _name_: str | None  # type: ignore[assignment]\n    _value_: int\n    @_magic_enum_attr\n    def name(self) -> str | None: ...  # type: ignore[override]\n    @_magic_enum_attr\n    def value(self) -> int: ...\n    def __contains__(self, other: Self) -> bool: ...\n    def __bool__(self) -> bool: ...\n    def __or__(self, other: Self) -> Self: ...\n    def __and__(self, other: Self) -> Self: ...\n    def __xor__(self, other: Self) -> Self: ...\n    def __invert__(self) -> Self: ...\n    if sys.version_info >= (3, 11):\n        def __iter__(self) -> Iterator[Self]: ...\n        def __len__(self) -> int: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nif sys.version_info >= (3, 11):\n    # The body of the class is the same, but the base classes are different.\n    class IntFlag(int, ReprEnum, Flag, boundary=KEEP):  # type: ignore[misc]  # complaints about incompatible bases\n        def __new__(cls, value: int) -> Self: ...\n        def __or__(self, other: int) -> Self: ...\n        def __and__(self, other: int) -> Self: ...\n        def __xor__(self, other: int) -> Self: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nelse:\n    class IntFlag(int, Flag):  # type: ignore[misc]  # complaints about incompatible bases\n        def __new__(cls, value: int) -> Self: ...\n        def __or__(self, other: int) -> Self: ...\n        def __and__(self, other: int) -> Self: ...\n        def __xor__(self, other: int) -> Self: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nif sys.version_info >= (3, 11):\n    class StrEnum(str, ReprEnum):\n        def __new__(cls, value: str) -> Self: ...\n        _value_: str\n        @_magic_enum_attr\n        def value(self) -> str: ...\n\n    class EnumCheck(StrEnum):\n        CONTINUOUS: str\n        NAMED_FLAGS: str\n        UNIQUE: str\n    CONTINUOUS = EnumCheck.CONTINUOUS\n    NAMED_FLAGS = EnumCheck.NAMED_FLAGS\n    UNIQUE = EnumCheck.UNIQUE\n\n    class verify:\n        def __init__(self, *checks: EnumCheck) -> None: ...\n        def __call__(self, enumeration: _EnumerationT) -> _EnumerationT: ...\n\n    class FlagBoundary(StrEnum):\n        STRICT: str\n        CONFORM: str\n        EJECT: str\n        KEEP: str\n    STRICT = FlagBoundary.STRICT\n    CONFORM = FlagBoundary.CONFORM\n    EJECT = FlagBoundary.EJECT\n    KEEP = FlagBoundary.KEEP\n\n    def global_str(self: Enum) -> str: ...\n    def global_enum(cls: _EnumerationT, update_str: bool = False) -> _EnumerationT: ...\n    def global_enum_repr(self: Enum) -> str: ...\n    def global_flag_repr(self: Flag) -> str: ...\n",
  "/typeshed/stdlib/errno.pyi": "import sys\nfrom collections.abc import Mapping\n\nerrorcode: Mapping[int, str]\n\nEPERM: int\nENOENT: int\nESRCH: int\nEINTR: int\nEIO: int\nENXIO: int\nE2BIG: int\nENOEXEC: int\nEBADF: int\nECHILD: int\nEAGAIN: int\nENOMEM: int\nEACCES: int\nEFAULT: int\nEBUSY: int\nEEXIST: int\nEXDEV: int\nENODEV: int\nENOTDIR: int\nEISDIR: int\nEINVAL: int\nENFILE: int\nEMFILE: int\nENOTTY: int\nETXTBSY: int\nEFBIG: int\nENOSPC: int\nESPIPE: int\nEROFS: int\nEMLINK: int\nEPIPE: int\nEDOM: int\nERANGE: int\nEDEADLK: int\nENAMETOOLONG: int\nENOLCK: int\nENOSYS: int\nENOTEMPTY: int\nELOOP: int\nEWOULDBLOCK: int\nENOMSG: int\nEIDRM: int\nENOSTR: int\nENODATA: int\nETIME: int\nENOSR: int\nEREMOTE: int\nENOLINK: int\nEPROTO: int\nEBADMSG: int\nEOVERFLOW: int\nEILSEQ: int\nEUSERS: int\nENOTSOCK: int\nEDESTADDRREQ: int\nEMSGSIZE: int\nEPROTOTYPE: int\nENOPROTOOPT: int\nEPROTONOSUPPORT: int\nESOCKTNOSUPPORT: int\nENOTSUP: int\nEOPNOTSUPP: int\nEPFNOSUPPORT: int\nEAFNOSUPPORT: int\nEADDRINUSE: int\nEADDRNOTAVAIL: int\nENETDOWN: int\nENETUNREACH: int\nENETRESET: int\nECONNABORTED: int\nECONNRESET: int\nENOBUFS: int\nEISCONN: int\nENOTCONN: int\nESHUTDOWN: int\nETOOMANYREFS: int\nETIMEDOUT: int\nECONNREFUSED: int\nEHOSTDOWN: int\nEHOSTUNREACH: int\nEALREADY: int\nEINPROGRESS: int\nESTALE: int\nEDQUOT: int\nECANCELED: int  # undocumented\nENOTRECOVERABLE: int  # undocumented\nEOWNERDEAD: int  # undocumented\n\nif sys.platform != \"win32\":\n    ENOTBLK: int\n    EMULTIHOP: int\n    # All of the below are undocumented\n    EAUTH: int\n    EBADARCH: int\n    EBADEXEC: int\n    EBADMACHO: int\n    EBADRPC: int\n    EDEVERR: int\n    EFTYPE: int\n    ENEEDAUTH: int\n    ENOATTR: int\n    ENOPOLICY: int\n    EPROCLIM: int\n    EPROCUNAVAIL: int\n    EPROGMISMATCH: int\n    EPROGUNAVAIL: int\n    EPWROFF: int\n    ERPCMISMATCH: int\n    ESHLIBVERS: int\n\n    if sys.platform != \"darwin\" or sys.version_info >= (3, 11):\n        EQFULL: int  # undocumented\n\nif sys.platform != \"darwin\":\n    EDEADLOCK: int\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    ECHRNG: int\n    EL2NSYNC: int\n    EL3HLT: int\n    EL3RST: int\n    ELNRNG: int\n    EUNATCH: int\n    ENOCSI: int\n    EL2HLT: int\n    EBADE: int\n    EBADR: int\n    EXFULL: int\n    ENOANO: int\n    EBADRQC: int\n    EBADSLT: int\n    EBFONT: int\n    ENONET: int\n    ENOPKG: int\n    EADV: int\n    ESRMNT: int\n    ECOMM: int\n    EDOTDOT: int\n    ENOTUNIQ: int\n    EBADFD: int\n    EREMCHG: int\n    ELIBACC: int\n    ELIBBAD: int\n    ELIBSCN: int\n    ELIBMAX: int\n    ELIBEXEC: int\n    ERESTART: int\n    ESTRPIPE: int\n    EUCLEAN: int\n    ENOTNAM: int\n    ENAVAIL: int\n    EISNAM: int\n    EREMOTEIO: int\n    # All of the below are undocumented\n    EKEYEXPIRED: int\n    EKEYREJECTED: int\n    EKEYREVOKED: int\n    EMEDIUMTYPE: int\n    ENOKEY: int\n    ENOMEDIUM: int\n    ERFKILL: int\n    EL: int\n    ELOCKUNMAPPED: int\n    ENOTACTIVE: int\n\nif sys.platform == \"win32\":\n    # All of these are undocumented\n    WSABASEERR: int\n    WSAEACCES: int\n    WSAEADDRINUSE: int\n    WSAEADDRNOTAVAIL: int\n    WSAEAFNOSUPPORT: int\n    WSAEALREADY: int\n    WSAEBADF: int\n    WSAECONNABORTED: int\n    WSAECONNREFUSED: int\n    WSAECONNRESET: int\n    WSAEDESTADDRREQ: int\n    WSAEDISCON: int\n    WSAEDQUOT: int\n    WSAEFAULT: int\n    WSAEHOSTDOWN: int\n    WSAEHOSTUNREACH: int\n    WSAEINPROGRESS: int\n    WSAEINTR: int\n    WSAEINVAL: int\n    WSAEISCONN: int\n    WSAELOOP: int\n    WSAEMFILE: int\n    WSAEMSGSIZE: int\n    WSAENAMETOOLONG: int\n    WSAENETDOWN: int\n    WSAENETRESET: int\n    WSAENETUNREACH: int\n    WSAENOBUFS: int\n    WSAENOPROTOOPT: int\n    WSAENOTCONN: int\n    WSAENOTEMPTY: int\n    WSAENOTSOCK: int\n    WSAEOPNOTSUPP: int\n    WSAEPFNOSUPPORT: int\n    WSAEPROCLIM: int\n    WSAEPROTONOSUPPORT: int\n    WSAEPROTOTYPE: int\n    WSAEREMOTE: int\n    WSAESHUTDOWN: int\n    WSAESOCKTNOSUPPORT: int\n    WSAESTALE: int\n    WSAETIMEDOUT: int\n    WSAETOOMANYREFS: int\n    WSAEUSERS: int\n    WSAEWOULDBLOCK: int\n    WSANOTINITIALISED: int\n    WSASYSNOTREADY: int\n    WSAVERNOTSUPPORTED: int\n",
  "/typeshed/stdlib/faulthandler.pyi": "import sys\nfrom _typeshed import FileDescriptorLike\n\ndef cancel_dump_traceback_later() -> None: ...\ndef disable() -> None: ...\ndef dump_traceback(file: FileDescriptorLike = ..., all_threads: bool = ...) -> None: ...\ndef dump_traceback_later(timeout: float, repeat: bool = ..., file: FileDescriptorLike = ..., exit: bool = ...) -> None: ...\ndef enable(file: FileDescriptorLike = ..., all_threads: bool = ...) -> None: ...\ndef is_enabled() -> bool: ...\n\nif sys.platform != \"win32\":\n    def register(signum: int, file: FileDescriptorLike = ..., all_threads: bool = ..., chain: bool = ...) -> None: ...\n    def unregister(signum: int) -> None: ...\n",
  "/typeshed/stdlib/fcntl.pyi": "import sys\nfrom _typeshed import FileDescriptorLike, ReadOnlyBuffer, WriteableBuffer\nfrom typing import Any, overload\nfrom typing_extensions import Literal\n\nif sys.platform != \"win32\":\n    FASYNC: int\n    FD_CLOEXEC: int\n    F_DUPFD: int\n    F_DUPFD_CLOEXEC: int\n    F_GETFD: int\n    F_GETFL: int\n    F_GETLK: int\n    F_GETOWN: int\n    F_RDLCK: int\n    F_SETFD: int\n    F_SETFL: int\n    F_SETLK: int\n    F_SETLKW: int\n    F_SETOWN: int\n    F_UNLCK: int\n    F_WRLCK: int\n    if sys.platform == \"darwin\":\n        F_FULLFSYNC: int\n        F_NOCACHE: int\n        if sys.version_info >= (3, 9):\n            F_GETPATH: int\n    if sys.platform == \"linux\":\n        F_SETLKW64: int\n        F_SETSIG: int\n        F_SHLCK: int\n        F_SETLK64: int\n        F_SETLEASE: int\n        F_GETSIG: int\n        F_NOTIFY: int\n        F_EXLCK: int\n        F_GETLEASE: int\n        F_GETLK64: int\n        if sys.version_info >= (3, 8):\n            F_ADD_SEALS: int\n            F_GET_SEALS: int\n            F_SEAL_GROW: int\n            F_SEAL_SEAL: int\n            F_SEAL_SHRINK: int\n            F_SEAL_WRITE: int\n        if sys.version_info >= (3, 9):\n            F_OFD_GETLK: int\n            F_OFD_SETLK: int\n            F_OFD_SETLKW: int\n        if sys.version_info >= (3, 10):\n            F_GETPIPE_SZ: int\n            F_SETPIPE_SZ: int\n\n        DN_ACCESS: int\n        DN_ATTRIB: int\n        DN_CREATE: int\n        DN_DELETE: int\n        DN_MODIFY: int\n        DN_MULTISHOT: int\n        DN_RENAME: int\n\n    LOCK_EX: int\n    LOCK_NB: int\n    LOCK_SH: int\n    LOCK_UN: int\n    if sys.platform == \"linux\":\n        LOCK_MAND: int\n        LOCK_READ: int\n        LOCK_RW: int\n        LOCK_WRITE: int\n\n    # These are highly problematic, they might be present or not, depends on the specific OS.\n    if sys.platform == \"linux\":\n        I_ATMARK: int\n        I_CANPUT: int\n        I_CKBAND: int\n        I_FDINSERT: int\n        I_FIND: int\n        I_FLUSH: int\n        I_FLUSHBAND: int\n        I_GETBAND: int\n        I_GETCLTIME: int\n        I_GETSIG: int\n        I_GRDOPT: int\n        I_GWROPT: int\n        I_LINK: int\n        I_LIST: int\n        I_LOOK: int\n        I_NREAD: int\n        I_PEEK: int\n        I_PLINK: int\n        I_POP: int\n        I_PUNLINK: int\n        I_PUSH: int\n        I_RECVFD: int\n        I_SENDFD: int\n        I_SETCLTIME: int\n        I_SETSIG: int\n        I_SRDOPT: int\n        I_STR: int\n        I_SWROPT: int\n        I_UNLINK: int\n    @overload\n    def fcntl(__fd: FileDescriptorLike, __cmd: int, __arg: int = 0) -> int: ...\n    @overload\n    def fcntl(__fd: FileDescriptorLike, __cmd: int, __arg: str | ReadOnlyBuffer) -> bytes: ...\n    @overload\n    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: int = 0, __mutate_flag: bool = True) -> int: ...\n    @overload\n    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: WriteableBuffer, __mutate_flag: Literal[True] = True) -> int: ...\n    @overload\n    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: WriteableBuffer, __mutate_flag: Literal[False]) -> bytes: ...\n    @overload\n    def ioctl(__fd: FileDescriptorLike, __request: int, __arg: ReadOnlyBuffer, __mutate_flag: bool = True) -> bytes: ...\n    def flock(__fd: FileDescriptorLike, __operation: int) -> None: ...\n    def lockf(__fd: FileDescriptorLike, __cmd: int, __len: int = 0, __start: int = 0, __whence: int = 0) -> Any: ...\n",
  "/typeshed/stdlib/filecmp.pyi": "import sys\nfrom _typeshed import GenericPath, StrOrBytesPath\nfrom collections.abc import Callable, Iterable, Sequence\nfrom typing import Any, AnyStr, Generic\nfrom typing_extensions import Literal\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\"clear_cache\", \"cmp\", \"dircmp\", \"cmpfiles\", \"DEFAULT_IGNORES\"]\n\nDEFAULT_IGNORES: list[str]\nBUFSIZE: Literal[8192]\n\ndef cmp(f1: StrOrBytesPath, f2: StrOrBytesPath, shallow: bool | Literal[0, 1] = True) -> bool: ...\ndef cmpfiles(\n    a: GenericPath[AnyStr], b: GenericPath[AnyStr], common: Iterable[GenericPath[AnyStr]], shallow: bool | Literal[0, 1] = True\n) -> tuple[list[AnyStr], list[AnyStr], list[AnyStr]]: ...\n\nclass dircmp(Generic[AnyStr]):\n    def __init__(\n        self,\n        a: GenericPath[AnyStr],\n        b: GenericPath[AnyStr],\n        ignore: Sequence[AnyStr] | None = None,\n        hide: Sequence[AnyStr] | None = None,\n    ) -> None: ...\n    left: AnyStr\n    right: AnyStr\n    hide: Sequence[AnyStr]\n    ignore: Sequence[AnyStr]\n    # These properties are created at runtime by __getattr__\n    subdirs: dict[AnyStr, dircmp[AnyStr]]\n    same_files: list[AnyStr]\n    diff_files: list[AnyStr]\n    funny_files: list[AnyStr]\n    common_dirs: list[AnyStr]\n    common_files: list[AnyStr]\n    common_funny: list[AnyStr]\n    common: list[AnyStr]\n    left_only: list[AnyStr]\n    right_only: list[AnyStr]\n    left_list: list[AnyStr]\n    right_list: list[AnyStr]\n    def report(self) -> None: ...\n    def report_partial_closure(self) -> None: ...\n    def report_full_closure(self) -> None: ...\n    methodmap: dict[str, Callable[[], None]]\n    def phase0(self) -> None: ...\n    def phase1(self) -> None: ...\n    def phase2(self) -> None: ...\n    def phase3(self) -> None: ...\n    def phase4(self) -> None: ...\n    def phase4_closure(self) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef clear_cache() -> None: ...\n",
  "/typeshed/stdlib/fileinput.pyi": "import sys\nfrom _typeshed import AnyStr_co, StrOrBytesPath\nfrom collections.abc import Callable, Iterable, Iterator\nfrom types import TracebackType\nfrom typing import IO, Any, AnyStr, Generic, Protocol, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"input\",\n    \"close\",\n    \"nextfile\",\n    \"filename\",\n    \"lineno\",\n    \"filelineno\",\n    \"fileno\",\n    \"isfirstline\",\n    \"isstdin\",\n    \"FileInput\",\n    \"hook_compressed\",\n    \"hook_encoded\",\n]\n\nif sys.version_info >= (3, 11):\n    _TextMode: TypeAlias = Literal[\"r\"]\nelse:\n    _TextMode: TypeAlias = Literal[\"r\", \"rU\", \"U\"]\n\nclass _HasReadlineAndFileno(Protocol[AnyStr_co]):\n    def readline(self) -> AnyStr_co: ...\n    def fileno(self) -> int: ...\n\nif sys.version_info >= (3, 10):\n    # encoding and errors are added\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: _TextMode = \"r\",\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n        encoding: str | None = None,\n        errors: str | None = None,\n    ) -> FileInput[str]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: Literal[\"rb\"],\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n        encoding: None = None,\n        errors: None = None,\n    ) -> FileInput[bytes]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: str,\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n        encoding: str | None = None,\n        errors: str | None = None,\n    ) -> FileInput[Any]: ...\n\nelif sys.version_info >= (3, 8):\n    # bufsize is dropped and mode and openhook become keyword-only\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: _TextMode = \"r\",\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n    ) -> FileInput[str]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: Literal[\"rb\"],\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n    ) -> FileInput[bytes]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        *,\n        mode: str,\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n    ) -> FileInput[Any]: ...\n\nelse:\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        bufsize: int = 0,\n        mode: _TextMode = \"r\",\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n    ) -> FileInput[str]: ...\n    # Because mode isn't keyword-only here yet, we need two overloads each for\n    # the bytes case and the fallback case.\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        bufsize: int = 0,\n        *,\n        mode: Literal[\"rb\"],\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n    ) -> FileInput[bytes]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None,\n        inplace: bool,\n        backup: str,\n        bufsize: int,\n        mode: Literal[\"rb\"],\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n    ) -> FileInput[bytes]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n        inplace: bool = False,\n        backup: str = \"\",\n        bufsize: int = 0,\n        *,\n        mode: str,\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n    ) -> FileInput[Any]: ...\n    @overload\n    def input(\n        files: StrOrBytesPath | Iterable[StrOrBytesPath] | None,\n        inplace: bool,\n        backup: str,\n        bufsize: int,\n        mode: str,\n        openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n    ) -> FileInput[Any]: ...\n\ndef close() -> None: ...\ndef nextfile() -> None: ...\ndef filename() -> str: ...\ndef lineno() -> int: ...\ndef filelineno() -> int: ...\ndef fileno() -> int: ...\ndef isfirstline() -> bool: ...\ndef isstdin() -> bool: ...\n\nclass FileInput(Iterator[AnyStr], Generic[AnyStr]):\n    if sys.version_info >= (3, 10):\n        # encoding and errors are added\n        @overload\n        def __init__(\n            self: FileInput[str],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: _TextMode = \"r\",\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n            encoding: str | None = None,\n            errors: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[bytes],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: Literal[\"rb\"],\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n            encoding: None = None,\n            errors: None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[Any],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: str,\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n            encoding: str | None = None,\n            errors: str | None = None,\n        ) -> None: ...\n\n    elif sys.version_info >= (3, 8):\n        # bufsize is dropped and mode and openhook become keyword-only\n        @overload\n        def __init__(\n            self: FileInput[str],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: _TextMode = \"r\",\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[bytes],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: Literal[\"rb\"],\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[Any],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            *,\n            mode: str,\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n        ) -> None: ...\n\n    else:\n        @overload\n        def __init__(\n            self: FileInput[str],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            bufsize: int = 0,\n            mode: _TextMode = \"r\",\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[str]] | None = None,\n        ) -> None: ...\n        # Because mode isn't keyword-only here yet, we need two overloads each for\n        # the bytes case and the fallback case.\n        @overload\n        def __init__(\n            self: FileInput[bytes],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            bufsize: int = 0,\n            *,\n            mode: Literal[\"rb\"],\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[bytes],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None,\n            inplace: bool,\n            backup: str,\n            bufsize: int,\n            mode: Literal[\"rb\"],\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[bytes]] | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[Any],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None = None,\n            inplace: bool = False,\n            backup: str = \"\",\n            bufsize: int = 0,\n            *,\n            mode: str,\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: FileInput[Any],\n            files: StrOrBytesPath | Iterable[StrOrBytesPath] | None,\n            inplace: bool,\n            backup: str,\n            bufsize: int,\n            mode: str,\n            openhook: Callable[[StrOrBytesPath, str], _HasReadlineAndFileno[Any]] | None = None,\n        ) -> None: ...\n\n    def __del__(self) -> None: ...\n    def close(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> AnyStr: ...\n    if sys.version_info < (3, 11):\n        def __getitem__(self, i: int) -> AnyStr: ...\n\n    def nextfile(self) -> None: ...\n    def readline(self) -> AnyStr: ...\n    def filename(self) -> str: ...\n    def lineno(self) -> int: ...\n    def filelineno(self) -> int: ...\n    def fileno(self) -> int: ...\n    def isfirstline(self) -> bool: ...\n    def isstdin(self) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nif sys.version_info >= (3, 10):\n    def hook_compressed(\n        filename: StrOrBytesPath, mode: str, *, encoding: str | None = None, errors: str | None = None\n    ) -> IO[Any]: ...\n\nelse:\n    def hook_compressed(filename: StrOrBytesPath, mode: str) -> IO[Any]: ...\n\ndef hook_encoded(encoding: str, errors: str | None = None) -> Callable[[StrOrBytesPath, str], IO[Any]]: ...\n",
  "/typeshed/stdlib/fnmatch.pyi": "from collections.abc import Iterable\nfrom typing import AnyStr\n\n__all__ = [\"filter\", \"fnmatch\", \"fnmatchcase\", \"translate\"]\n\ndef fnmatch(name: AnyStr, pat: AnyStr) -> bool: ...\ndef fnmatchcase(name: AnyStr, pat: AnyStr) -> bool: ...\ndef filter(names: Iterable[AnyStr], pat: AnyStr) -> list[AnyStr]: ...\ndef translate(pat: str) -> str: ...\n",
  "/typeshed/stdlib/formatter.pyi": "from collections.abc import Iterable\nfrom typing import IO, Any\nfrom typing_extensions import TypeAlias\n\nAS_IS: None\n_FontType: TypeAlias = tuple[str, bool, bool, bool]\n_StylesType: TypeAlias = tuple[Any, ...]\n\nclass NullFormatter:\n    writer: NullWriter | None\n    def __init__(self, writer: NullWriter | None = None) -> None: ...\n    def end_paragraph(self, blankline: int) -> None: ...\n    def add_line_break(self) -> None: ...\n    def add_hor_rule(self, *args: Any, **kw: Any) -> None: ...\n    def add_label_data(self, format: str, counter: int, blankline: int | None = None) -> None: ...\n    def add_flowing_data(self, data: str) -> None: ...\n    def add_literal_data(self, data: str) -> None: ...\n    def flush_softspace(self) -> None: ...\n    def push_alignment(self, align: str | None) -> None: ...\n    def pop_alignment(self) -> None: ...\n    def push_font(self, x: _FontType) -> None: ...\n    def pop_font(self) -> None: ...\n    def push_margin(self, margin: int) -> None: ...\n    def pop_margin(self) -> None: ...\n    def set_spacing(self, spacing: str | None) -> None: ...\n    def push_style(self, *styles: _StylesType) -> None: ...\n    def pop_style(self, n: int = 1) -> None: ...\n    def assert_line_data(self, flag: int = 1) -> None: ...\n\nclass AbstractFormatter:\n    writer: NullWriter\n    align: str | None\n    align_stack: list[str | None]\n    font_stack: list[_FontType]\n    margin_stack: list[int]\n    spacing: str | None\n    style_stack: Any\n    nospace: int\n    softspace: int\n    para_end: int\n    parskip: int\n    hard_break: int\n    have_label: int\n    def __init__(self, writer: NullWriter) -> None: ...\n    def end_paragraph(self, blankline: int) -> None: ...\n    def add_line_break(self) -> None: ...\n    def add_hor_rule(self, *args: Any, **kw: Any) -> None: ...\n    def add_label_data(self, format: str, counter: int, blankline: int | None = None) -> None: ...\n    def format_counter(self, format: Iterable[str], counter: int) -> str: ...\n    def format_letter(self, case: str, counter: int) -> str: ...\n    def format_roman(self, case: str, counter: int) -> str: ...\n    def add_flowing_data(self, data: str) -> None: ...\n    def add_literal_data(self, data: str) -> None: ...\n    def flush_softspace(self) -> None: ...\n    def push_alignment(self, align: str | None) -> None: ...\n    def pop_alignment(self) -> None: ...\n    def push_font(self, font: _FontType) -> None: ...\n    def pop_font(self) -> None: ...\n    def push_margin(self, margin: int) -> None: ...\n    def pop_margin(self) -> None: ...\n    def set_spacing(self, spacing: str | None) -> None: ...\n    def push_style(self, *styles: _StylesType) -> None: ...\n    def pop_style(self, n: int = 1) -> None: ...\n    def assert_line_data(self, flag: int = 1) -> None: ...\n\nclass NullWriter:\n    def flush(self) -> None: ...\n    def new_alignment(self, align: str | None) -> None: ...\n    def new_font(self, font: _FontType) -> None: ...\n    def new_margin(self, margin: int, level: int) -> None: ...\n    def new_spacing(self, spacing: str | None) -> None: ...\n    def new_styles(self, styles: tuple[Any, ...]) -> None: ...\n    def send_paragraph(self, blankline: int) -> None: ...\n    def send_line_break(self) -> None: ...\n    def send_hor_rule(self, *args: Any, **kw: Any) -> None: ...\n    def send_label_data(self, data: str) -> None: ...\n    def send_flowing_data(self, data: str) -> None: ...\n    def send_literal_data(self, data: str) -> None: ...\n\nclass AbstractWriter(NullWriter): ...\n\nclass DumbWriter(NullWriter):\n    file: IO[str]\n    maxcol: int\n    def __init__(self, file: IO[str] | None = None, maxcol: int = 72) -> None: ...\n    def reset(self) -> None: ...\n\ndef test(file: str | None = None) -> None: ...\n",
  "/typeshed/stdlib/fractions.pyi": "import sys\nfrom collections.abc import Callable\nfrom decimal import Decimal\nfrom numbers import Integral, Rational, Real\nfrom typing import Any, overload\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias\n\n_ComparableNum: TypeAlias = int | float | Decimal | Real\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"Fraction\"]\nelse:\n    __all__ = [\"Fraction\", \"gcd\"]\n    @overload\n    def gcd(a: int, b: int) -> int: ...\n    @overload\n    def gcd(a: Integral, b: int) -> Integral: ...\n    @overload\n    def gcd(a: int, b: Integral) -> Integral: ...\n    @overload\n    def gcd(a: Integral, b: Integral) -> Integral: ...\n\nclass Fraction(Rational):\n    @overload\n    def __new__(\n        cls, numerator: int | Rational = 0, denominator: int | Rational | None = None, *, _normalize: bool = True\n    ) -> Self: ...\n    @overload\n    def __new__(cls, __value: float | Decimal | str, *, _normalize: bool = True) -> Self: ...\n    @classmethod\n    def from_float(cls, f: float) -> Self: ...\n    @classmethod\n    def from_decimal(cls, dec: Decimal) -> Self: ...\n    def limit_denominator(self, max_denominator: int = 1000000) -> Fraction: ...\n    if sys.version_info >= (3, 8):\n        def as_integer_ratio(self) -> tuple[int, int]: ...\n\n    @property\n    def numerator(a) -> int: ...\n    @property\n    def denominator(a) -> int: ...\n    @overload\n    def __add__(a, b: int | Fraction) -> Fraction: ...\n    @overload\n    def __add__(a, b: float) -> float: ...\n    @overload\n    def __add__(a, b: complex) -> complex: ...\n    @overload\n    def __radd__(b, a: int | Fraction) -> Fraction: ...\n    @overload\n    def __radd__(b, a: float) -> float: ...\n    @overload\n    def __radd__(b, a: complex) -> complex: ...\n    @overload\n    def __sub__(a, b: int | Fraction) -> Fraction: ...\n    @overload\n    def __sub__(a, b: float) -> float: ...\n    @overload\n    def __sub__(a, b: complex) -> complex: ...\n    @overload\n    def __rsub__(b, a: int | Fraction) -> Fraction: ...\n    @overload\n    def __rsub__(b, a: float) -> float: ...\n    @overload\n    def __rsub__(b, a: complex) -> complex: ...\n    @overload\n    def __mul__(a, b: int | Fraction) -> Fraction: ...\n    @overload\n    def __mul__(a, b: float) -> float: ...\n    @overload\n    def __mul__(a, b: complex) -> complex: ...\n    @overload\n    def __rmul__(b, a: int | Fraction) -> Fraction: ...\n    @overload\n    def __rmul__(b, a: float) -> float: ...\n    @overload\n    def __rmul__(b, a: complex) -> complex: ...\n    @overload\n    def __truediv__(a, b: int | Fraction) -> Fraction: ...\n    @overload\n    def __truediv__(a, b: float) -> float: ...\n    @overload\n    def __truediv__(a, b: complex) -> complex: ...\n    @overload\n    def __rtruediv__(b, a: int | Fraction) -> Fraction: ...\n    @overload\n    def __rtruediv__(b, a: float) -> float: ...\n    @overload\n    def __rtruediv__(b, a: complex) -> complex: ...\n    @overload\n    def __floordiv__(a, b: int | Fraction) -> int: ...\n    @overload\n    def __floordiv__(a, b: float) -> float: ...\n    @overload\n    def __rfloordiv__(b, a: int | Fraction) -> int: ...\n    @overload\n    def __rfloordiv__(b, a: float) -> float: ...\n    @overload\n    def __mod__(a, b: int | Fraction) -> Fraction: ...\n    @overload\n    def __mod__(a, b: float) -> float: ...\n    @overload\n    def __rmod__(b, a: int | Fraction) -> Fraction: ...\n    @overload\n    def __rmod__(b, a: float) -> float: ...\n    if sys.version_info >= (3, 8):\n        @overload\n        def __divmod__(a, b: int | Fraction) -> tuple[int, Fraction]: ...\n        @overload\n        def __divmod__(a, b: float) -> tuple[float, Fraction]: ...\n        @overload\n        def __rdivmod__(a, b: int | Fraction) -> tuple[int, Fraction]: ...\n        @overload\n        def __rdivmod__(a, b: float) -> tuple[float, Fraction]: ...\n    else:\n        @overload\n        def __divmod__(self, other: int | Fraction) -> tuple[int, Fraction]: ...\n        @overload\n        def __divmod__(self, other: float) -> tuple[float, Fraction]: ...\n        @overload\n        def __rdivmod__(self, other: int | Fraction) -> tuple[int, Fraction]: ...\n        @overload\n        def __rdivmod__(self, other: float) -> tuple[float, Fraction]: ...\n\n    @overload\n    def __pow__(a, b: int) -> Fraction: ...\n    @overload\n    def __pow__(a, b: float | Fraction) -> float: ...\n    @overload\n    def __pow__(a, b: complex) -> complex: ...\n    @overload\n    def __rpow__(b, a: float | Fraction) -> float: ...\n    @overload\n    def __rpow__(b, a: complex) -> complex: ...\n    def __pos__(a) -> Fraction: ...\n    def __neg__(a) -> Fraction: ...\n    def __abs__(a) -> Fraction: ...\n    def __trunc__(a) -> int: ...\n    def __floor__(a) -> int: ...\n    def __ceil__(a) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = None) -> int: ...\n    @overload\n    def __round__(self, ndigits: int) -> Fraction: ...\n    def __hash__(self) -> int: ...\n    def __eq__(a, b: object) -> bool: ...\n    def __lt__(a, b: _ComparableNum) -> bool: ...\n    def __gt__(a, b: _ComparableNum) -> bool: ...\n    def __le__(a, b: _ComparableNum) -> bool: ...\n    def __ge__(a, b: _ComparableNum) -> bool: ...\n    def __bool__(a) -> bool: ...\n    def __copy__(self) -> Self: ...\n    def __deepcopy__(self, memo: Any) -> Self: ...\n    if sys.version_info >= (3, 11):\n        def __int__(a, _index: Callable[[SupportsIndex], int] = ...) -> int: ...\n    # Not actually defined within fractions.py, but provides more useful\n    # overrides\n    @property\n    def real(self) -> Fraction: ...\n    @property\n    def imag(self) -> Literal[0]: ...\n    def conjugate(self) -> Fraction: ...\n",
  "/typeshed/stdlib/ftplib.pyi": "import sys\nfrom _typeshed import SupportsRead, SupportsReadline\nfrom collections.abc import Callable, Iterable, Iterator\nfrom socket import socket\nfrom ssl import SSLContext\nfrom types import TracebackType\nfrom typing import Any, TextIO\nfrom typing_extensions import Literal, Self\n\n__all__ = [\"FTP\", \"error_reply\", \"error_temp\", \"error_perm\", \"error_proto\", \"all_errors\", \"FTP_TLS\"]\n\nMSG_OOB: Literal[1]\nFTP_PORT: Literal[21]\nMAXLINE: Literal[8192]\nCRLF: Literal[\"\\r\\n\"]\nB_CRLF: Literal[b\"\\r\\n\"]\n\nclass Error(Exception): ...\nclass error_reply(Error): ...\nclass error_temp(Error): ...\nclass error_perm(Error): ...\nclass error_proto(Error): ...\n\nall_errors: tuple[type[Exception], ...]\n\nclass FTP:\n    debugging: int\n    host: str\n    port: int\n    maxline: int\n    sock: socket | None\n    welcome: str | None\n    passiveserver: int\n    timeout: int\n    af: int\n    lastresp: str\n    file: TextIO | None\n    encoding: str\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    source_address: tuple[str, int] | None\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            host: str = \"\",\n            user: str = \"\",\n            passwd: str = \"\",\n            acct: str = \"\",\n            timeout: float = ...,\n            source_address: tuple[str, int] | None = None,\n            *,\n            encoding: str = \"utf-8\",\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            host: str = \"\",\n            user: str = \"\",\n            passwd: str = \"\",\n            acct: str = \"\",\n            timeout: float = ...,\n            source_address: tuple[str, int] | None = None,\n        ) -> None: ...\n\n    def connect(\n        self, host: str = \"\", port: int = 0, timeout: float = -999, source_address: tuple[str, int] | None = None\n    ) -> str: ...\n    def getwelcome(self) -> str: ...\n    def set_debuglevel(self, level: int) -> None: ...\n    def debug(self, level: int) -> None: ...\n    def set_pasv(self, val: bool | Literal[0, 1]) -> None: ...\n    def sanitize(self, s: str) -> str: ...\n    def putline(self, line: str) -> None: ...\n    def putcmd(self, line: str) -> None: ...\n    def getline(self) -> str: ...\n    def getmultiline(self) -> str: ...\n    def getresp(self) -> str: ...\n    def voidresp(self) -> str: ...\n    def abort(self) -> str: ...\n    def sendcmd(self, cmd: str) -> str: ...\n    def voidcmd(self, cmd: str) -> str: ...\n    def sendport(self, host: str, port: int) -> str: ...\n    def sendeprt(self, host: str, port: int) -> str: ...\n    def makeport(self) -> socket: ...\n    def makepasv(self) -> tuple[str, int]: ...\n    def login(self, user: str = \"\", passwd: str = \"\", acct: str = \"\") -> str: ...\n    # In practice, `rest` rest can actually be anything whose str() is an integer sequence, so to make it simple we allow integers.\n    def ntransfercmd(self, cmd: str, rest: int | str | None = None) -> tuple[socket, int]: ...\n    def transfercmd(self, cmd: str, rest: int | str | None = None) -> socket: ...\n    def retrbinary(\n        self, cmd: str, callback: Callable[[bytes], object], blocksize: int = 8192, rest: int | str | None = None\n    ) -> str: ...\n    def storbinary(\n        self,\n        cmd: str,\n        fp: SupportsRead[bytes],\n        blocksize: int = 8192,\n        callback: Callable[[bytes], object] | None = None,\n        rest: int | str | None = None,\n    ) -> str: ...\n    def retrlines(self, cmd: str, callback: Callable[[str], object] | None = None) -> str: ...\n    def storlines(self, cmd: str, fp: SupportsReadline[bytes], callback: Callable[[bytes], object] | None = None) -> str: ...\n    def acct(self, password: str) -> str: ...\n    def nlst(self, *args: str) -> list[str]: ...\n    # Technically only the last arg can be a Callable but ...\n    def dir(self, *args: str | Callable[[str], object]) -> None: ...\n    def mlsd(self, path: str = \"\", facts: Iterable[str] = []) -> Iterator[tuple[str, dict[str, str]]]: ...\n    def rename(self, fromname: str, toname: str) -> str: ...\n    def delete(self, filename: str) -> str: ...\n    def cwd(self, dirname: str) -> str: ...\n    def size(self, filename: str) -> int | None: ...\n    def mkd(self, dirname: str) -> str: ...\n    def rmd(self, dirname: str) -> str: ...\n    def pwd(self) -> str: ...\n    def quit(self) -> str: ...\n    def close(self) -> None: ...\n\nclass FTP_TLS(FTP):\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            host: str = \"\",\n            user: str = \"\",\n            passwd: str = \"\",\n            acct: str = \"\",\n            keyfile: str | None = None,\n            certfile: str | None = None,\n            context: SSLContext | None = None,\n            timeout: float = ...,\n            source_address: tuple[str, int] | None = None,\n            *,\n            encoding: str = \"utf-8\",\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            host: str = \"\",\n            user: str = \"\",\n            passwd: str = \"\",\n            acct: str = \"\",\n            keyfile: str | None = None,\n            certfile: str | None = None,\n            context: SSLContext | None = None,\n            timeout: float = ...,\n            source_address: tuple[str, int] | None = None,\n        ) -> None: ...\n    ssl_version: int\n    keyfile: str | None\n    certfile: str | None\n    context: SSLContext\n    def login(self, user: str = \"\", passwd: str = \"\", acct: str = \"\", secure: bool = True) -> str: ...\n    def auth(self) -> str: ...\n    def prot_p(self) -> str: ...\n    def prot_c(self) -> str: ...\n    def ccc(self) -> str: ...\n\ndef parse150(resp: str) -> int | None: ...  # undocumented\ndef parse227(resp: str) -> tuple[str, int]: ...  # undocumented\ndef parse229(resp: str, peer: Any) -> tuple[str, int]: ...  # undocumented\ndef parse257(resp: str) -> str: ...  # undocumented\ndef ftpcp(\n    source: FTP, sourcename: str, target: FTP, targetname: str = \"\", type: Literal[\"A\", \"I\"] = \"I\"\n) -> None: ...  # undocumented\n",
  "/typeshed/stdlib/functools.pyi": "import sys\nimport types\nfrom _typeshed import SupportsAllComparisons, SupportsItems\nfrom collections.abc import Callable, Hashable, Iterable, Sequence, Sized\nfrom typing import Any, Generic, NamedTuple, TypeVar, overload\nfrom typing_extensions import Literal, ParamSpec, Self, TypeAlias, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"update_wrapper\",\n    \"wraps\",\n    \"WRAPPER_ASSIGNMENTS\",\n    \"WRAPPER_UPDATES\",\n    \"total_ordering\",\n    \"cmp_to_key\",\n    \"lru_cache\",\n    \"reduce\",\n    \"partial\",\n    \"partialmethod\",\n    \"singledispatch\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"cached_property\", \"singledispatchmethod\"]\n\nif sys.version_info >= (3, 9):\n    __all__ += [\"cache\"]\n\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_PWrapped = ParamSpec(\"_PWrapped\")\n_RWrapped = TypeVar(\"_RWrapped\")\n_PWrapper = ParamSpec(\"_PWrapper\")\n_RWapper = TypeVar(\"_RWapper\")\n\n@overload\ndef reduce(function: Callable[[_T, _S], _T], sequence: Iterable[_S], initial: _T) -> _T: ...\n@overload\ndef reduce(function: Callable[[_T, _T], _T], sequence: Iterable[_T]) -> _T: ...\n\nclass _CacheInfo(NamedTuple):\n    hits: int\n    misses: int\n    maxsize: int | None\n    currsize: int\n\n@final\nclass _lru_cache_wrapper(Generic[_T]):\n    __wrapped__: Callable[..., _T]\n    def __call__(self, *args: Hashable, **kwargs: Hashable) -> _T: ...\n    def cache_info(self) -> _CacheInfo: ...\n    def cache_clear(self) -> None: ...\n    def __copy__(self) -> _lru_cache_wrapper[_T]: ...\n    def __deepcopy__(self, __memo: Any) -> _lru_cache_wrapper[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def lru_cache(maxsize: int | None = 128, typed: bool = False) -> Callable[[Callable[..., _T]], _lru_cache_wrapper[_T]]: ...\n    @overload\n    def lru_cache(maxsize: Callable[..., _T], typed: bool = False) -> _lru_cache_wrapper[_T]: ...\n\nelse:\n    def lru_cache(maxsize: int | None = 128, typed: bool = False) -> Callable[[Callable[..., _T]], _lru_cache_wrapper[_T]]: ...\n\nWRAPPER_ASSIGNMENTS: tuple[\n    Literal[\"__module__\"], Literal[\"__name__\"], Literal[\"__qualname__\"], Literal[\"__doc__\"], Literal[\"__annotations__\"]\n]\nWRAPPER_UPDATES: tuple[Literal[\"__dict__\"]]\n\nclass _Wrapped(Generic[_PWrapped, _RWrapped, _PWrapper, _RWapper]):\n    __wrapped__: Callable[_PWrapped, _RWrapped]\n    def __call__(self, *args: _PWrapper.args, **kwargs: _PWrapper.kwargs) -> _RWapper: ...\n    # as with ``Callable``, we'll assume that these attributes exist\n    __name__: str\n    __qualname__: str\n\nclass _Wrapper(Generic[_PWrapped, _RWrapped]):\n    def __call__(self, f: Callable[_PWrapper, _RWapper]) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWapper]: ...\n\ndef update_wrapper(\n    wrapper: Callable[_PWrapper, _RWapper],\n    wrapped: Callable[_PWrapped, _RWrapped],\n    assigned: Sequence[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\"),\n    updated: Sequence[str] = (\"__dict__\",),\n) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWapper]: ...\ndef wraps(\n    wrapped: Callable[_PWrapped, _RWrapped],\n    assigned: Sequence[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\"),\n    updated: Sequence[str] = (\"__dict__\",),\n) -> _Wrapper[_PWrapped, _RWrapped]: ...\ndef total_ordering(cls: type[_T]) -> type[_T]: ...\ndef cmp_to_key(mycmp: Callable[[_T, _T], int]) -> Callable[[_T], SupportsAllComparisons]: ...\n\nclass partial(Generic[_T]):\n    @property\n    def func(self) -> Callable[..., _T]: ...\n    @property\n    def args(self) -> tuple[Any, ...]: ...\n    @property\n    def keywords(self) -> dict[str, Any]: ...\n    def __new__(cls, __func: Callable[..., _T], *args: Any, **kwargs: Any) -> Self: ...\n    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# With protocols, this could change into a generic protocol that defines __get__ and returns _T\n_Descriptor: TypeAlias = Any\n\nclass partialmethod(Generic[_T]):\n    func: Callable[..., _T] | _Descriptor\n    args: tuple[Any, ...]\n    keywords: dict[str, Any]\n    @overload\n    def __init__(self, __func: Callable[..., _T], *args: Any, **keywords: Any) -> None: ...\n    @overload\n    def __init__(self, __func: _Descriptor, *args: Any, **keywords: Any) -> None: ...\n    if sys.version_info >= (3, 8):\n        def __get__(self, obj: Any, cls: type[Any] | None = None) -> Callable[..., _T]: ...\n    else:\n        def __get__(self, obj: Any, cls: type[Any] | None) -> Callable[..., _T]: ...\n\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass _SingleDispatchCallable(Generic[_T]):\n    registry: types.MappingProxyType[Any, Callable[..., _T]]\n    def dispatch(self, cls: Any) -> Callable[..., _T]: ...\n    # @fun.register(complex)\n    # def _(arg, verbose=False): ...\n    @overload\n    def register(self, cls: type[Any], func: None = None) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...\n    # @fun.register\n    # def _(arg: int, verbose=False):\n    @overload\n    def register(self, cls: Callable[..., _T], func: None = None) -> Callable[..., _T]: ...\n    # fun.register(int, lambda x: x)\n    @overload\n    def register(self, cls: type[Any], func: Callable[..., _T]) -> Callable[..., _T]: ...\n    def _clear_cache(self) -> None: ...\n    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...\n\ndef singledispatch(func: Callable[..., _T]) -> _SingleDispatchCallable[_T]: ...\n\nif sys.version_info >= (3, 8):\n    class singledispatchmethod(Generic[_T]):\n        dispatcher: _SingleDispatchCallable[_T]\n        func: Callable[..., _T]\n        def __init__(self, func: Callable[..., _T]) -> None: ...\n        @property\n        def __isabstractmethod__(self) -> bool: ...\n        @overload\n        def register(self, cls: type[Any], method: None = None) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...\n        @overload\n        def register(self, cls: Callable[..., _T], method: None = None) -> Callable[..., _T]: ...\n        @overload\n        def register(self, cls: type[Any], method: Callable[..., _T]) -> Callable[..., _T]: ...\n        def __get__(self, obj: _S, cls: type[_S] | None = None) -> Callable[..., _T]: ...\n\n    class cached_property(Generic[_T]):\n        func: Callable[[Any], _T]\n        attrname: str | None\n        def __init__(self, func: Callable[[Any], _T]) -> None: ...\n        @overload\n        def __get__(self, instance: None, owner: type[Any] | None = None) -> Self: ...\n        @overload\n        def __get__(self, instance: object, owner: type[Any] | None = None) -> _T: ...\n        def __set_name__(self, owner: type[Any], name: str) -> None: ...\n        # __set__ is not defined at runtime, but @cached_property is designed to be settable\n        def __set__(self, instance: object, value: _T) -> None: ...\n        if sys.version_info >= (3, 9):\n            def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nif sys.version_info >= (3, 9):\n    def cache(__user_function: Callable[..., _T]) -> _lru_cache_wrapper[_T]: ...\n\ndef _make_key(\n    args: tuple[Hashable, ...],\n    kwds: SupportsItems[Any, Any],\n    typed: bool,\n    kwd_mark: tuple[object, ...] = ...,\n    fasttypes: set[type] = ...,\n    tuple: type = ...,\n    type: Any = ...,\n    len: Callable[[Sized], int] = ...,\n) -> Hashable: ...\n",
  "/typeshed/stdlib/gc.pyi": "import sys\nfrom collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import Literal, TypeAlias\n\nDEBUG_COLLECTABLE: Literal[2]\nDEBUG_LEAK: Literal[38]\nDEBUG_SAVEALL: Literal[32]\nDEBUG_STATS: Literal[1]\nDEBUG_UNCOLLECTABLE: Literal[4]\n\n_CallbackType: TypeAlias = Callable[[Literal[\"start\", \"stop\"], dict[str, int]], object]\n\ncallbacks: list[_CallbackType]\ngarbage: list[Any]\n\ndef collect(generation: int = 2) -> int: ...\ndef disable() -> None: ...\ndef enable() -> None: ...\ndef get_count() -> tuple[int, int, int]: ...\ndef get_debug() -> int: ...\n\nif sys.version_info >= (3, 8):\n    def get_objects(generation: int | None = None) -> list[Any]: ...\n\nelse:\n    def get_objects() -> list[Any]: ...\n\ndef freeze() -> None: ...\ndef unfreeze() -> None: ...\ndef get_freeze_count() -> int: ...\ndef get_referents(*objs: Any) -> list[Any]: ...\ndef get_referrers(*objs: Any) -> list[Any]: ...\ndef get_stats() -> list[dict[str, Any]]: ...\ndef get_threshold() -> tuple[int, int, int]: ...\ndef is_tracked(__obj: Any) -> bool: ...\n\nif sys.version_info >= (3, 9):\n    def is_finalized(__obj: Any) -> bool: ...\n\ndef isenabled() -> bool: ...\ndef set_debug(__flags: int) -> None: ...\ndef set_threshold(threshold0: int, threshold1: int = ..., threshold2: int = ...) -> None: ...\n",
  "/typeshed/stdlib/genericpath.pyi": "import os\nfrom _typeshed import BytesPath, FileDescriptorOrPath, StrPath, SupportsRichComparisonT\nfrom collections.abc import Sequence\nfrom typing import overload\nfrom typing_extensions import Literal, LiteralString\n\n__all__ = [\n    \"commonprefix\",\n    \"exists\",\n    \"getatime\",\n    \"getctime\",\n    \"getmtime\",\n    \"getsize\",\n    \"isdir\",\n    \"isfile\",\n    \"samefile\",\n    \"sameopenfile\",\n    \"samestat\",\n]\n\n# All overloads can return empty string. Ideally, Literal[\"\"] would be a valid\n# Iterable[T], so that list[T] | Literal[\"\"] could be used as a return\n# type. But because this only works when T is str, we need Sequence[T] instead.\n@overload\ndef commonprefix(m: Sequence[LiteralString]) -> LiteralString: ...\n@overload\ndef commonprefix(m: Sequence[StrPath]) -> str: ...\n@overload\ndef commonprefix(m: Sequence[BytesPath]) -> bytes | Literal[\"\"]: ...\n@overload\ndef commonprefix(m: Sequence[list[SupportsRichComparisonT]]) -> Sequence[SupportsRichComparisonT]: ...\n@overload\ndef commonprefix(m: Sequence[tuple[SupportsRichComparisonT, ...]]) -> Sequence[SupportsRichComparisonT]: ...\ndef exists(path: FileDescriptorOrPath) -> bool: ...\ndef getsize(filename: FileDescriptorOrPath) -> int: ...\ndef isfile(path: FileDescriptorOrPath) -> bool: ...\ndef isdir(s: FileDescriptorOrPath) -> bool: ...\n\n# These return float if os.stat_float_times() == True,\n# but int is a subclass of float.\ndef getatime(filename: FileDescriptorOrPath) -> float: ...\ndef getmtime(filename: FileDescriptorOrPath) -> float: ...\ndef getctime(filename: FileDescriptorOrPath) -> float: ...\ndef samefile(f1: FileDescriptorOrPath, f2: FileDescriptorOrPath) -> bool: ...\ndef sameopenfile(fp1: int, fp2: int) -> bool: ...\ndef samestat(s1: os.stat_result, s2: os.stat_result) -> bool: ...\n",
  "/typeshed/stdlib/getopt.pyi": "__all__ = [\"GetoptError\", \"error\", \"getopt\", \"gnu_getopt\"]\n\ndef getopt(args: list[str], shortopts: str, longopts: list[str] = []) -> tuple[list[tuple[str, str]], list[str]]: ...\ndef gnu_getopt(args: list[str], shortopts: str, longopts: list[str] = []) -> tuple[list[tuple[str, str]], list[str]]: ...\n\nclass GetoptError(Exception):\n    msg: str\n    opt: str\n    def __init__(self, msg: str, opt: str = \"\") -> None: ...\n\nerror = GetoptError\n",
  "/typeshed/stdlib/getpass.pyi": "from typing import TextIO\n\n__all__ = [\"getpass\", \"getuser\", \"GetPassWarning\"]\n\ndef getpass(prompt: str = \"Password: \", stream: TextIO | None = None) -> str: ...\ndef getuser() -> str: ...\n\nclass GetPassWarning(UserWarning): ...\n",
  "/typeshed/stdlib/gettext.pyi": "import io\nimport sys\nfrom _typeshed import StrPath\nfrom collections.abc import Callable, Container, Iterable, Sequence\nfrom typing import Any, Protocol, TypeVar, overload\nfrom typing_extensions import Final, Literal\n\n__all__ = [\n    \"NullTranslations\",\n    \"GNUTranslations\",\n    \"Catalog\",\n    \"find\",\n    \"translation\",\n    \"install\",\n    \"textdomain\",\n    \"bindtextdomain\",\n    \"dgettext\",\n    \"dngettext\",\n    \"gettext\",\n    \"ngettext\",\n]\n\nif sys.version_info < (3, 11):\n    __all__ += [\"bind_textdomain_codeset\", \"ldgettext\", \"ldngettext\", \"lgettext\", \"lngettext\"]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"dnpgettext\", \"dpgettext\", \"npgettext\", \"pgettext\"]\n\nclass _TranslationsReader(Protocol):\n    def read(self) -> bytes: ...\n    # optional:\n    # name: str\n\nclass NullTranslations:\n    def __init__(self, fp: _TranslationsReader | None = None) -> None: ...\n    def _parse(self, fp: _TranslationsReader) -> None: ...\n    def add_fallback(self, fallback: NullTranslations) -> None: ...\n    def gettext(self, message: str) -> str: ...\n    def ngettext(self, msgid1: str, msgid2: str, n: int) -> str: ...\n    if sys.version_info >= (3, 8):\n        def pgettext(self, context: str, message: str) -> str: ...\n        def npgettext(self, context: str, msgid1: str, msgid2: str, n: int) -> str: ...\n\n    def info(self) -> dict[str, str]: ...\n    def charset(self) -> str | None: ...\n    if sys.version_info < (3, 11):\n        def output_charset(self) -> str | None: ...\n        def set_output_charset(self, charset: str) -> None: ...\n        def lgettext(self, message: str) -> str: ...\n        def lngettext(self, msgid1: str, msgid2: str, n: int) -> str: ...\n\n    def install(self, names: Container[str] | None = None) -> None: ...\n\nclass GNUTranslations(NullTranslations):\n    LE_MAGIC: Final[int]\n    BE_MAGIC: Final[int]\n    CONTEXT: str\n    VERSIONS: Sequence[int]\n\n@overload\ndef find(\n    domain: str, localedir: StrPath | None = None, languages: Iterable[str] | None = None, all: Literal[False] = False\n) -> str | None: ...\n@overload\ndef find(\n    domain: str, localedir: StrPath | None = None, languages: Iterable[str] | None = None, *, all: Literal[True]\n) -> list[str]: ...\n@overload\ndef find(domain: str, localedir: StrPath | None, languages: Iterable[str] | None, all: Literal[True]) -> list[str]: ...\n@overload\ndef find(domain: str, localedir: StrPath | None = None, languages: Iterable[str] | None = None, all: bool = False) -> Any: ...\n\n_NullTranslationsT = TypeVar(\"_NullTranslationsT\", bound=NullTranslations)\n\nif sys.version_info >= (3, 11):\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        class_: None = None,\n        fallback: Literal[False] = False,\n    ) -> GNUTranslations: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        *,\n        class_: Callable[[io.BufferedReader], _NullTranslationsT],\n        fallback: Literal[False] = False,\n    ) -> _NullTranslationsT: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None,\n        languages: Iterable[str] | None,\n        class_: Callable[[io.BufferedReader], _NullTranslationsT],\n        fallback: Literal[False] = False,\n    ) -> _NullTranslationsT: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        class_: Callable[[io.BufferedReader], NullTranslations] | None = None,\n        fallback: bool = False,\n    ) -> NullTranslations: ...\n    def install(domain: str, localedir: StrPath | None = None, *, names: Container[str] | None = None) -> None: ...\n\nelse:\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        class_: None = None,\n        fallback: Literal[False] = False,\n        codeset: str | None = None,\n    ) -> GNUTranslations: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        *,\n        class_: Callable[[io.BufferedReader], _NullTranslationsT],\n        fallback: Literal[False] = False,\n        codeset: str | None = None,\n    ) -> _NullTranslationsT: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None,\n        languages: Iterable[str] | None,\n        class_: Callable[[io.BufferedReader], _NullTranslationsT],\n        fallback: Literal[False] = False,\n        codeset: str | None = None,\n    ) -> _NullTranslationsT: ...\n    @overload\n    def translation(\n        domain: str,\n        localedir: StrPath | None = None,\n        languages: Iterable[str] | None = None,\n        class_: Callable[[io.BufferedReader], NullTranslations] | None = None,\n        fallback: bool = False,\n        codeset: str | None = None,\n    ) -> NullTranslations: ...\n    def install(\n        domain: str, localedir: StrPath | None = None, codeset: str | None = None, names: Container[str] | None = None\n    ) -> None: ...\n\ndef textdomain(domain: str | None = None) -> str: ...\ndef bindtextdomain(domain: str, localedir: StrPath | None = None) -> str: ...\ndef dgettext(domain: str, message: str) -> str: ...\ndef dngettext(domain: str, msgid1: str, msgid2: str, n: int) -> str: ...\ndef gettext(message: str) -> str: ...\ndef ngettext(msgid1: str, msgid2: str, n: int) -> str: ...\n\nif sys.version_info >= (3, 8):\n    def pgettext(context: str, message: str) -> str: ...\n    def dpgettext(domain: str, context: str, message: str) -> str: ...\n    def npgettext(context: str, msgid1: str, msgid2: str, n: int) -> str: ...\n    def dnpgettext(domain: str, context: str, msgid1: str, msgid2: str, n: int) -> str: ...\n\nif sys.version_info < (3, 11):\n    def lgettext(message: str) -> str: ...\n    def ldgettext(domain: str, message: str) -> str: ...\n    def lngettext(msgid1: str, msgid2: str, n: int) -> str: ...\n    def ldngettext(domain: str, msgid1: str, msgid2: str, n: int) -> str: ...\n    def bind_textdomain_codeset(domain: str, codeset: str | None = None) -> str: ...\n\nCatalog = translation\n",
  "/typeshed/stdlib/glob.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Iterator\nfrom typing import AnyStr\n\n__all__ = [\"escape\", \"glob\", \"iglob\"]\n\ndef glob0(dirname: AnyStr, pattern: AnyStr) -> list[AnyStr]: ...\ndef glob1(dirname: AnyStr, pattern: AnyStr) -> list[AnyStr]: ...\n\nif sys.version_info >= (3, 11):\n    def glob(\n        pathname: AnyStr,\n        *,\n        root_dir: StrOrBytesPath | None = None,\n        dir_fd: int | None = None,\n        recursive: bool = False,\n        include_hidden: bool = False,\n    ) -> list[AnyStr]: ...\n    def iglob(\n        pathname: AnyStr,\n        *,\n        root_dir: StrOrBytesPath | None = None,\n        dir_fd: int | None = None,\n        recursive: bool = False,\n        include_hidden: bool = False,\n    ) -> Iterator[AnyStr]: ...\n\nelif sys.version_info >= (3, 10):\n    def glob(\n        pathname: AnyStr, *, root_dir: StrOrBytesPath | None = None, dir_fd: int | None = None, recursive: bool = False\n    ) -> list[AnyStr]: ...\n    def iglob(\n        pathname: AnyStr, *, root_dir: StrOrBytesPath | None = None, dir_fd: int | None = None, recursive: bool = False\n    ) -> Iterator[AnyStr]: ...\n\nelse:\n    def glob(pathname: AnyStr, *, recursive: bool = False) -> list[AnyStr]: ...\n    def iglob(pathname: AnyStr, *, recursive: bool = False) -> Iterator[AnyStr]: ...\n\ndef escape(pathname: AnyStr) -> AnyStr: ...\ndef has_magic(s: str | bytes) -> bool: ...  # undocumented\n",
  "/typeshed/stdlib/graphlib.pyi": "import sys\nfrom _typeshed import SupportsItems\nfrom collections.abc import Iterable\nfrom typing import Any, Generic, TypeVar, overload\n\n__all__ = [\"TopologicalSorter\", \"CycleError\"]\n\n_T = TypeVar(\"_T\")\n\nif sys.version_info >= (3, 11):\n    from types import GenericAlias\n\nclass TopologicalSorter(Generic[_T]):\n    @overload\n    def __init__(self, graph: None = None) -> None: ...\n    @overload\n    def __init__(self, graph: SupportsItems[_T, Iterable[_T]]) -> None: ...\n    def add(self, node: _T, *predecessors: _T) -> None: ...\n    def prepare(self) -> None: ...\n    def is_active(self) -> bool: ...\n    def __bool__(self) -> bool: ...\n    def done(self, *nodes: _T) -> None: ...\n    def get_ready(self) -> tuple[_T, ...]: ...\n    def static_order(self) -> Iterable[_T]: ...\n    if sys.version_info >= (3, 11):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass CycleError(ValueError): ...\n",
  "/typeshed/stdlib/grp.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import Any\nfrom typing_extensions import Final, final\n\nif sys.platform != \"win32\":\n    @final\n    class struct_group(structseq[Any], tuple[str, str | None, int, list[str]]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\"gr_name\", \"gr_passwd\", \"gr_gid\", \"gr_mem\")\n        @property\n        def gr_name(self) -> str: ...\n        @property\n        def gr_passwd(self) -> str | None: ...\n        @property\n        def gr_gid(self) -> int: ...\n        @property\n        def gr_mem(self) -> list[str]: ...\n\n    def getgrall() -> list[struct_group]: ...\n    def getgrgid(id: int) -> struct_group: ...\n    def getgrnam(name: str) -> struct_group: ...\n",
  "/typeshed/stdlib/gzip.pyi": "import _compression\nimport sys\nimport zlib\nfrom _typeshed import ReadableBuffer, StrOrBytesPath, _BufferWithLen\nfrom io import FileIO\nfrom typing import Protocol, TextIO, overload\nfrom typing_extensions import Literal, TypeAlias\n\nif sys.version_info >= (3, 8):\n    __all__ = [\"BadGzipFile\", \"GzipFile\", \"open\", \"compress\", \"decompress\"]\nelse:\n    __all__ = [\"GzipFile\", \"open\", \"compress\", \"decompress\"]\n\n_ReadBinaryMode: TypeAlias = Literal[\"r\", \"rb\"]\n_WriteBinaryMode: TypeAlias = Literal[\"a\", \"ab\", \"w\", \"wb\", \"x\", \"xb\"]\n_OpenTextMode: TypeAlias = Literal[\"rt\", \"at\", \"wt\", \"xt\"]\n\nREAD: Literal[1]  # undocumented\nWRITE: Literal[2]  # undocumented\n\nFTEXT: int  # actually Literal[1] # undocumented\nFHCRC: int  # actually Literal[2] # undocumented\nFEXTRA: int  # actually Literal[4] # undocumented\nFNAME: int  # actually Literal[8] # undocumented\nFCOMMENT: int  # actually Literal[16] # undocumented\n\nclass _ReadableFileobj(Protocol):\n    def read(self, __n: int) -> bytes: ...\n    def seek(self, __n: int) -> object: ...\n    # The following attributes and methods are optional:\n    # name: str\n    # mode: str\n    # def fileno() -> int: ...\n\nclass _WritableFileobj(Protocol):\n    def write(self, __b: bytes) -> object: ...\n    def flush(self) -> object: ...\n    # The following attributes and methods are optional:\n    # name: str\n    # mode: str\n    # def fileno() -> int: ...\n\n@overload\ndef open(\n    filename: StrOrBytesPath | _ReadableFileobj,\n    mode: _ReadBinaryMode = \"rb\",\n    compresslevel: int = 9,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> GzipFile: ...\n@overload\ndef open(\n    filename: StrOrBytesPath | _WritableFileobj,\n    mode: _WriteBinaryMode,\n    compresslevel: int = 9,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> GzipFile: ...\n@overload\ndef open(\n    filename: StrOrBytesPath,\n    mode: _OpenTextMode,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: StrOrBytesPath | _ReadableFileobj | _WritableFileobj,\n    mode: str,\n    compresslevel: int = 9,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> GzipFile | TextIO: ...\n\nclass _PaddedFile:\n    file: _ReadableFileobj\n    def __init__(self, f: _ReadableFileobj, prepend: bytes = b\"\") -> None: ...\n    def read(self, size: int) -> bytes: ...\n    def prepend(self, prepend: bytes = b\"\") -> None: ...\n    def seek(self, off: int) -> int: ...\n    def seekable(self) -> bool: ...\n\nif sys.version_info >= (3, 8):\n    class BadGzipFile(OSError): ...\n\nclass GzipFile(_compression.BaseStream):\n    myfileobj: FileIO | None\n    mode: Literal[1, 2]\n    name: str\n    compress: zlib._Compress\n    fileobj: _ReadableFileobj | _WritableFileobj\n    @overload\n    def __init__(\n        self,\n        filename: StrOrBytesPath | None,\n        mode: _ReadBinaryMode,\n        compresslevel: int = 9,\n        fileobj: _ReadableFileobj | None = None,\n        mtime: float | None = None,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        *,\n        mode: _ReadBinaryMode,\n        compresslevel: int = 9,\n        fileobj: _ReadableFileobj | None = None,\n        mtime: float | None = None,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        filename: StrOrBytesPath | None,\n        mode: _WriteBinaryMode,\n        compresslevel: int = 9,\n        fileobj: _WritableFileobj | None = None,\n        mtime: float | None = None,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        *,\n        mode: _WriteBinaryMode,\n        compresslevel: int = 9,\n        fileobj: _WritableFileobj | None = None,\n        mtime: float | None = None,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        filename: StrOrBytesPath | None = None,\n        mode: str | None = None,\n        compresslevel: int = 9,\n        fileobj: _ReadableFileobj | _WritableFileobj | None = None,\n        mtime: float | None = None,\n    ) -> None: ...\n    @property\n    def filename(self) -> str: ...\n    @property\n    def mtime(self) -> int | None: ...\n    crc: int\n    def write(self, data: ReadableBuffer) -> int: ...\n    def read(self, size: int | None = -1) -> bytes: ...\n    def read1(self, size: int = -1) -> bytes: ...\n    def peek(self, n: int) -> bytes: ...\n    def close(self) -> None: ...\n    def flush(self, zlib_mode: int = 2) -> None: ...\n    def fileno(self) -> int: ...\n    def rewind(self) -> None: ...\n    def seek(self, offset: int, whence: int = 0) -> int: ...\n    def readline(self, size: int | None = -1) -> bytes: ...\n\nclass _GzipReader(_compression.DecompressReader):\n    def __init__(self, fp: _ReadableFileobj) -> None: ...\n\nif sys.version_info >= (3, 8):\n    def compress(data: _BufferWithLen, compresslevel: int = 9, *, mtime: float | None = None) -> bytes: ...\n\nelse:\n    def compress(data: _BufferWithLen, compresslevel: int = 9) -> bytes: ...\n\ndef decompress(data: ReadableBuffer) -> bytes: ...\n",
  "/typeshed/stdlib/hashlib.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable, Set as AbstractSet\nfrom typing import Protocol\nfrom typing_extensions import Self, final\n\nif sys.version_info >= (3, 11):\n    __all__ = (\n        \"md5\",\n        \"sha1\",\n        \"sha224\",\n        \"sha256\",\n        \"sha384\",\n        \"sha512\",\n        \"blake2b\",\n        \"blake2s\",\n        \"sha3_224\",\n        \"sha3_256\",\n        \"sha3_384\",\n        \"sha3_512\",\n        \"shake_128\",\n        \"shake_256\",\n        \"new\",\n        \"algorithms_guaranteed\",\n        \"algorithms_available\",\n        \"pbkdf2_hmac\",\n        \"file_digest\",\n    )\nelse:\n    __all__ = (\n        \"md5\",\n        \"sha1\",\n        \"sha224\",\n        \"sha256\",\n        \"sha384\",\n        \"sha512\",\n        \"blake2b\",\n        \"blake2s\",\n        \"sha3_224\",\n        \"sha3_256\",\n        \"sha3_384\",\n        \"sha3_512\",\n        \"shake_128\",\n        \"shake_256\",\n        \"new\",\n        \"algorithms_guaranteed\",\n        \"algorithms_available\",\n        \"pbkdf2_hmac\",\n    )\n\nclass _Hash:\n    @property\n    def digest_size(self) -> int: ...\n    @property\n    def block_size(self) -> int: ...\n    @property\n    def name(self) -> str: ...\n    def __init__(self, data: ReadableBuffer = ...) -> None: ...\n    def copy(self) -> Self: ...\n    def digest(self) -> bytes: ...\n    def hexdigest(self) -> str: ...\n    def update(self, __data: ReadableBuffer) -> None: ...\n\nif sys.version_info >= (3, 9):\n    def new(name: str, data: ReadableBuffer = b\"\", *, usedforsecurity: bool = ...) -> _Hash: ...\n    def md5(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n    def sha1(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n    def sha224(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n    def sha256(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n    def sha384(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n    def sha512(string: ReadableBuffer = b\"\", *, usedforsecurity: bool = True) -> _Hash: ...\n\nelif sys.version_info >= (3, 8):\n    def new(name: str, data: ReadableBuffer = b\"\") -> _Hash: ...\n    def md5(string: ReadableBuffer = b\"\") -> _Hash: ...\n    def sha1(string: ReadableBuffer = b\"\") -> _Hash: ...\n    def sha224(string: ReadableBuffer = b\"\") -> _Hash: ...\n    def sha256(string: ReadableBuffer = b\"\") -> _Hash: ...\n    def sha384(string: ReadableBuffer = b\"\") -> _Hash: ...\n    def sha512(string: ReadableBuffer = b\"\") -> _Hash: ...\n\nelse:\n    def new(name: str, data: ReadableBuffer = b\"\") -> _Hash: ...\n    def md5(__string: ReadableBuffer = ...) -> _Hash: ...\n    def sha1(__string: ReadableBuffer = ...) -> _Hash: ...\n    def sha224(__string: ReadableBuffer = ...) -> _Hash: ...\n    def sha256(__string: ReadableBuffer = ...) -> _Hash: ...\n    def sha384(__string: ReadableBuffer = ...) -> _Hash: ...\n    def sha512(__string: ReadableBuffer = ...) -> _Hash: ...\n\nalgorithms_guaranteed: AbstractSet[str]\nalgorithms_available: AbstractSet[str]\n\ndef pbkdf2_hmac(\n    hash_name: str, password: ReadableBuffer, salt: ReadableBuffer, iterations: int, dklen: int | None = None\n) -> bytes: ...\n\nclass _VarLenHash:\n    digest_size: int\n    block_size: int\n    name: str\n    def __init__(self, data: ReadableBuffer = ...) -> None: ...\n    def copy(self) -> _VarLenHash: ...\n    def digest(self, __length: int) -> bytes: ...\n    def hexdigest(self, __length: int) -> str: ...\n    def update(self, __data: ReadableBuffer) -> None: ...\n\nsha3_224 = _Hash\nsha3_256 = _Hash\nsha3_384 = _Hash\nsha3_512 = _Hash\nshake_128 = _VarLenHash\nshake_256 = _VarLenHash\n\ndef scrypt(\n    password: ReadableBuffer,\n    *,\n    salt: ReadableBuffer | None = None,\n    n: int | None = None,\n    r: int | None = None,\n    p: int | None = None,\n    maxmem: int = 0,\n    dklen: int = 64,\n) -> bytes: ...\n@final\nclass _BlakeHash(_Hash):\n    MAX_DIGEST_SIZE: int\n    MAX_KEY_SIZE: int\n    PERSON_SIZE: int\n    SALT_SIZE: int\n\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            __data: ReadableBuffer = ...,\n            *,\n            digest_size: int = ...,\n            key: ReadableBuffer = ...,\n            salt: ReadableBuffer = ...,\n            person: ReadableBuffer = ...,\n            fanout: int = ...,\n            depth: int = ...,\n            leaf_size: int = ...,\n            node_offset: int = ...,\n            node_depth: int = ...,\n            inner_size: int = ...,\n            last_node: bool = ...,\n            usedforsecurity: bool = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            __data: ReadableBuffer = ...,\n            *,\n            digest_size: int = ...,\n            key: ReadableBuffer = ...,\n            salt: ReadableBuffer = ...,\n            person: ReadableBuffer = ...,\n            fanout: int = ...,\n            depth: int = ...,\n            leaf_size: int = ...,\n            node_offset: int = ...,\n            node_depth: int = ...,\n            inner_size: int = ...,\n            last_node: bool = ...,\n        ) -> None: ...\n\nblake2b = _BlakeHash\nblake2s = _BlakeHash\n\nif sys.version_info >= (3, 11):\n    class _BytesIOLike(Protocol):\n        def getbuffer(self) -> ReadableBuffer: ...\n\n    class _FileDigestFileObj(Protocol):\n        def readinto(self, __buf: bytearray) -> int: ...\n        def readable(self) -> bool: ...\n\n    def file_digest(\n        __fileobj: _BytesIOLike | _FileDigestFileObj, __digest: str | Callable[[], _Hash], *, _bufsize: int = 262144\n    ) -> _Hash: ...\n",
  "/typeshed/stdlib/heapq.pyi": "from _heapq import *\nfrom _typeshed import SupportsRichComparison\nfrom collections.abc import Callable, Iterable\nfrom typing import Any, TypeVar\nfrom typing_extensions import Final\n\n__all__ = [\"heappush\", \"heappop\", \"heapify\", \"heapreplace\", \"merge\", \"nlargest\", \"nsmallest\", \"heappushpop\"]\n\n_S = TypeVar(\"_S\")\n\n__about__: Final[str]\n\ndef merge(\n    *iterables: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None, reverse: bool = False\n) -> Iterable[_S]: ...\ndef nlargest(n: int, iterable: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None) -> list[_S]: ...\ndef nsmallest(n: int, iterable: Iterable[_S], key: Callable[[_S], SupportsRichComparison] | None = None) -> list[_S]: ...\ndef _heapify_max(__heap: list[Any]) -> None: ...  # undocumented\n",
  "/typeshed/stdlib/hmac.pyi": "import sys\nfrom _typeshed import ReadableBuffer, _BufferWithLen\nfrom collections.abc import Callable\nfrom types import ModuleType\nfrom typing import Any, AnyStr, overload\nfrom typing_extensions import TypeAlias\n\n# TODO more precise type for object of hashlib\n_Hash: TypeAlias = Any\n_DigestMod: TypeAlias = str | Callable[[], _Hash] | ModuleType\n\ntrans_5C: bytes\ntrans_36: bytes\n\ndigest_size: None\n\nif sys.version_info >= (3, 8):\n    # In reality digestmod has a default value, but the function always throws an error\n    # if the argument is not given, so we pretend it is a required argument.\n    @overload\n    def new(key: bytes | bytearray, msg: ReadableBuffer | None, digestmod: _DigestMod) -> HMAC: ...\n    @overload\n    def new(key: bytes | bytearray, *, digestmod: _DigestMod) -> HMAC: ...\n\nelse:\n    def new(key: bytes | bytearray, msg: ReadableBuffer | None = None, digestmod: _DigestMod | None = None) -> HMAC: ...\n\nclass HMAC:\n    digest_size: int\n    block_size: int\n    @property\n    def name(self) -> str: ...\n    if sys.version_info >= (3, 8):\n        def __init__(self, key: bytes | bytearray, msg: ReadableBuffer | None = None, digestmod: _DigestMod = \"\") -> None: ...\n    else:\n        def __init__(\n            self, key: bytes | bytearray, msg: ReadableBuffer | None = None, digestmod: _DigestMod | None = None\n        ) -> None: ...\n\n    def update(self, msg: ReadableBuffer) -> None: ...\n    def digest(self) -> bytes: ...\n    def hexdigest(self) -> str: ...\n    def copy(self) -> HMAC: ...\n\n@overload\ndef compare_digest(__a: ReadableBuffer, __b: ReadableBuffer) -> bool: ...\n@overload\ndef compare_digest(__a: AnyStr, __b: AnyStr) -> bool: ...\ndef digest(key: _BufferWithLen, msg: ReadableBuffer, digest: _DigestMod) -> bytes: ...\n",
  "/typeshed/stdlib/imaplib.pyi": "import subprocess\nimport sys\nimport time\nfrom _typeshed import ReadableBuffer, _BufferWithLen\nfrom builtins import list as _list  # conflicts with a method named \"list\"\nfrom collections.abc import Callable\nfrom datetime import datetime\nfrom re import Pattern\nfrom socket import socket as _socket\nfrom ssl import SSLContext, SSLSocket\nfrom types import TracebackType\nfrom typing import IO, Any, SupportsAbs, SupportsInt\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\"IMAP4\", \"IMAP4_stream\", \"Internaldate2tuple\", \"Int2AP\", \"ParseFlags\", \"Time2Internaldate\", \"IMAP4_SSL\"]\n\n# TODO: Commands should use their actual return types, not this type alias.\n#       E.g. Tuple[Literal[\"OK\"], List[bytes]]\n_CommandResults: TypeAlias = tuple[str, list[Any]]\n\n_AnyResponseData: TypeAlias = list[None] | list[bytes | tuple[bytes, bytes]]\n\nCommands: dict[str, tuple[str, ...]]\n\nclass IMAP4:\n    class error(Exception): ...\n    class abort(error): ...\n    class readonly(abort): ...\n    mustquote: Pattern[str]\n    debug: int\n    state: str\n    literal: str | None\n    tagged_commands: dict[bytes, _list[bytes] | None]\n    untagged_responses: dict[str, _list[bytes | tuple[bytes, bytes]]]\n    continuation_response: str\n    is_readonly: bool\n    tagnum: int\n    tagpre: str\n    tagre: Pattern[str]\n    welcome: bytes\n    capabilities: tuple[str, ...]\n    PROTOCOL_VERSION: str\n    if sys.version_info >= (3, 9):\n        def __init__(self, host: str = \"\", port: int = 143, timeout: float | None = None) -> None: ...\n        def open(self, host: str = \"\", port: int = 143, timeout: float | None = None) -> None: ...\n    else:\n        def __init__(self, host: str = \"\", port: int = 143) -> None: ...\n        def open(self, host: str = \"\", port: int = 143) -> None: ...\n\n    def __getattr__(self, attr: str) -> Any: ...\n    host: str\n    port: int\n    sock: _socket\n    file: IO[str] | IO[bytes]\n    def read(self, size: int) -> bytes: ...\n    def readline(self) -> bytes: ...\n    def send(self, data: ReadableBuffer) -> None: ...\n    def shutdown(self) -> None: ...\n    def socket(self) -> _socket: ...\n    def recent(self) -> _CommandResults: ...\n    def response(self, code: str) -> _CommandResults: ...\n    def append(self, mailbox: str, flags: str, date_time: str, message: ReadableBuffer) -> str: ...\n    def authenticate(self, mechanism: str, authobject: Callable[[bytes], bytes | None]) -> tuple[str, str]: ...\n    def capability(self) -> _CommandResults: ...\n    def check(self) -> _CommandResults: ...\n    def close(self) -> _CommandResults: ...\n    def copy(self, message_set: str, new_mailbox: str) -> _CommandResults: ...\n    def create(self, mailbox: str) -> _CommandResults: ...\n    def delete(self, mailbox: str) -> _CommandResults: ...\n    def deleteacl(self, mailbox: str, who: str) -> _CommandResults: ...\n    def enable(self, capability: str) -> _CommandResults: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n    def expunge(self) -> _CommandResults: ...\n    def fetch(self, message_set: str, message_parts: str) -> tuple[str, _AnyResponseData]: ...\n    def getacl(self, mailbox: str) -> _CommandResults: ...\n    def getannotation(self, mailbox: str, entry: str, attribute: str) -> _CommandResults: ...\n    def getquota(self, root: str) -> _CommandResults: ...\n    def getquotaroot(self, mailbox: str) -> _CommandResults: ...\n    def list(self, directory: str = '\"\"', pattern: str = \"*\") -> tuple[str, _AnyResponseData]: ...\n    def login(self, user: str, password: str) -> tuple[Literal[\"OK\"], _list[bytes]]: ...\n    def login_cram_md5(self, user: str, password: str) -> _CommandResults: ...\n    def logout(self) -> tuple[str, _AnyResponseData]: ...\n    def lsub(self, directory: str = '\"\"', pattern: str = \"*\") -> _CommandResults: ...\n    def myrights(self, mailbox: str) -> _CommandResults: ...\n    def namespace(self) -> _CommandResults: ...\n    def noop(self) -> tuple[str, _list[bytes]]: ...\n    def partial(self, message_num: str, message_part: str, start: str, length: str) -> _CommandResults: ...\n    def proxyauth(self, user: str) -> _CommandResults: ...\n    def rename(self, oldmailbox: str, newmailbox: str) -> _CommandResults: ...\n    def search(self, charset: str | None, *criteria: str) -> _CommandResults: ...\n    def select(self, mailbox: str = \"INBOX\", readonly: bool = False) -> tuple[str, _list[bytes | None]]: ...\n    def setacl(self, mailbox: str, who: str, what: str) -> _CommandResults: ...\n    def setannotation(self, *args: str) -> _CommandResults: ...\n    def setquota(self, root: str, limits: str) -> _CommandResults: ...\n    def sort(self, sort_criteria: str, charset: str, *search_criteria: str) -> _CommandResults: ...\n    def starttls(self, ssl_context: Any | None = None) -> tuple[Literal[\"OK\"], _list[None]]: ...\n    def status(self, mailbox: str, names: str) -> _CommandResults: ...\n    def store(self, message_set: str, command: str, flags: str) -> _CommandResults: ...\n    def subscribe(self, mailbox: str) -> _CommandResults: ...\n    def thread(self, threading_algorithm: str, charset: str, *search_criteria: str) -> _CommandResults: ...\n    def uid(self, command: str, *args: str) -> _CommandResults: ...\n    def unsubscribe(self, mailbox: str) -> _CommandResults: ...\n    if sys.version_info >= (3, 9):\n        def unselect(self) -> _CommandResults: ...\n\n    def xatom(self, name: str, *args: str) -> _CommandResults: ...\n    def print_log(self) -> None: ...\n\nclass IMAP4_SSL(IMAP4):\n    keyfile: str\n    certfile: str\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            host: str = \"\",\n            port: int = 993,\n            keyfile: str | None = None,\n            certfile: str | None = None,\n            ssl_context: SSLContext | None = None,\n            timeout: float | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            host: str = \"\",\n            port: int = 993,\n            keyfile: str | None = None,\n            certfile: str | None = None,\n            ssl_context: SSLContext | None = None,\n        ) -> None: ...\n    sslobj: SSLSocket\n    file: IO[Any]\n    if sys.version_info >= (3, 9):\n        def open(self, host: str = \"\", port: int | None = 993, timeout: float | None = None) -> None: ...\n    else:\n        def open(self, host: str = \"\", port: int | None = 993) -> None: ...\n\n    def ssl(self) -> SSLSocket: ...\n\nclass IMAP4_stream(IMAP4):\n    command: str\n    def __init__(self, command: str) -> None: ...\n    file: IO[Any]\n    process: subprocess.Popen[bytes]\n    writefile: IO[Any]\n    readfile: IO[Any]\n    if sys.version_info >= (3, 9):\n        def open(self, host: str | None = None, port: int | None = None, timeout: float | None = None) -> None: ...\n    else:\n        def open(self, host: str | None = None, port: int | None = None) -> None: ...\n\nclass _Authenticator:\n    mech: Callable[[bytes], bytes | bytearray | memoryview | str | None]\n    def __init__(self, mechinst: Callable[[bytes], bytes | bytearray | memoryview | str | None]) -> None: ...\n    def process(self, data: str) -> str: ...\n    def encode(self, inp: bytes | bytearray | memoryview) -> str: ...\n    def decode(self, inp: str | _BufferWithLen) -> bytes: ...\n\ndef Internaldate2tuple(resp: ReadableBuffer) -> time.struct_time | None: ...\ndef Int2AP(num: SupportsAbs[SupportsInt]) -> bytes: ...\ndef ParseFlags(resp: ReadableBuffer) -> tuple[bytes, ...]: ...\ndef Time2Internaldate(date_time: float | time.struct_time | time._TimeTuple | datetime | str) -> str: ...\n",
  "/typeshed/stdlib/imghdr.pyi": "from _typeshed import StrPath\nfrom collections.abc import Callable\nfrom typing import Any, BinaryIO, Protocol, overload\n\n__all__ = [\"what\"]\n\nclass _ReadableBinary(Protocol):\n    def tell(self) -> int: ...\n    def read(self, size: int) -> bytes: ...\n    def seek(self, offset: int) -> Any: ...\n\n@overload\ndef what(file: StrPath | _ReadableBinary, h: None = None) -> str | None: ...\n@overload\ndef what(file: Any, h: bytes) -> str | None: ...\n\ntests: list[Callable[[bytes, BinaryIO | None], str | None]]\n",
  "/typeshed/stdlib/imp.pyi": "import types\nfrom _imp import (\n    acquire_lock as acquire_lock,\n    create_dynamic as create_dynamic,\n    get_frozen_object as get_frozen_object,\n    init_frozen as init_frozen,\n    is_builtin as is_builtin,\n    is_frozen as is_frozen,\n    is_frozen_package as is_frozen_package,\n    lock_held as lock_held,\n    release_lock as release_lock,\n)\nfrom _typeshed import StrPath\nfrom os import PathLike\nfrom types import TracebackType\nfrom typing import IO, Any, Protocol\n\nSEARCH_ERROR: int\nPY_SOURCE: int\nPY_COMPILED: int\nC_EXTENSION: int\nPY_RESOURCE: int\nPKG_DIRECTORY: int\nC_BUILTIN: int\nPY_FROZEN: int\nPY_CODERESOURCE: int\nIMP_HOOK: int\n\ndef new_module(name: str) -> types.ModuleType: ...\ndef get_magic() -> bytes: ...\ndef get_tag() -> str: ...\ndef cache_from_source(path: StrPath, debug_override: bool | None = None) -> str: ...\ndef source_from_cache(path: StrPath) -> str: ...\ndef get_suffixes() -> list[tuple[str, str, int]]: ...\n\nclass NullImporter:\n    def __init__(self, path: StrPath) -> None: ...\n    def find_module(self, fullname: Any) -> None: ...\n\n# Technically, a text file has to support a slightly different set of operations than a binary file,\n# but we ignore that here.\nclass _FileLike(Protocol):\n    closed: bool\n    mode: str\n    def read(self) -> str | bytes: ...\n    def close(self) -> Any: ...\n    def __enter__(self) -> Any: ...\n    def __exit__(self, typ: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None) -> Any: ...\n\n# PathLike doesn't work for the pathname argument here\ndef load_source(name: str, pathname: str, file: _FileLike | None = None) -> types.ModuleType: ...\ndef load_compiled(name: str, pathname: str, file: _FileLike | None = None) -> types.ModuleType: ...\ndef load_package(name: str, path: StrPath) -> types.ModuleType: ...\ndef load_module(name: str, file: _FileLike | None, filename: str, details: tuple[str, str, int]) -> types.ModuleType: ...\n\n# IO[Any] is a TextIOWrapper if name is a .py file, and a FileIO otherwise.\ndef find_module(\n    name: str, path: None | list[str] | list[PathLike[str]] | list[StrPath] = None\n) -> tuple[IO[Any], str, tuple[str, str, int]]: ...\ndef reload(module: types.ModuleType) -> types.ModuleType: ...\ndef init_builtin(name: str) -> types.ModuleType | None: ...\ndef load_dynamic(name: str, path: str, file: Any = None) -> types.ModuleType: ...  # file argument is ignored\n",
  "/typeshed/stdlib/inspect.pyi": "import dis\nimport enum\nimport sys\nimport types\nfrom collections import OrderedDict\nfrom collections.abc import AsyncGenerator, Awaitable, Callable, Coroutine, Generator, Mapping, Sequence, Set as AbstractSet\nfrom types import (\n    AsyncGeneratorType,\n    BuiltinFunctionType,\n    BuiltinMethodType,\n    ClassMethodDescriptorType,\n    CodeType,\n    CoroutineType,\n    FrameType,\n    FunctionType,\n    GeneratorType,\n    GetSetDescriptorType,\n    LambdaType,\n    MemberDescriptorType,\n    MethodDescriptorType,\n    MethodType,\n    MethodWrapperType,\n    ModuleType,\n    TracebackType,\n    WrapperDescriptorType,\n)\nfrom typing import Any, ClassVar, NamedTuple, Protocol, TypeVar, overload\nfrom typing_extensions import Literal, ParamSpec, Self, TypeAlias, TypeGuard\n\nif sys.version_info >= (3, 11):\n    __all__ = [\n        \"ArgInfo\",\n        \"Arguments\",\n        \"Attribute\",\n        \"BlockFinder\",\n        \"BoundArguments\",\n        \"CORO_CLOSED\",\n        \"CORO_CREATED\",\n        \"CORO_RUNNING\",\n        \"CORO_SUSPENDED\",\n        \"CO_ASYNC_GENERATOR\",\n        \"CO_COROUTINE\",\n        \"CO_GENERATOR\",\n        \"CO_ITERABLE_COROUTINE\",\n        \"CO_NESTED\",\n        \"CO_NEWLOCALS\",\n        \"CO_NOFREE\",\n        \"CO_OPTIMIZED\",\n        \"CO_VARARGS\",\n        \"CO_VARKEYWORDS\",\n        \"ClassFoundException\",\n        \"ClosureVars\",\n        \"EndOfBlock\",\n        \"FrameInfo\",\n        \"FullArgSpec\",\n        \"GEN_CLOSED\",\n        \"GEN_CREATED\",\n        \"GEN_RUNNING\",\n        \"GEN_SUSPENDED\",\n        \"Parameter\",\n        \"Signature\",\n        \"TPFLAGS_IS_ABSTRACT\",\n        \"Traceback\",\n        \"classify_class_attrs\",\n        \"cleandoc\",\n        \"currentframe\",\n        \"findsource\",\n        \"formatannotation\",\n        \"formatannotationrelativeto\",\n        \"formatargvalues\",\n        \"get_annotations\",\n        \"getabsfile\",\n        \"getargs\",\n        \"getargvalues\",\n        \"getattr_static\",\n        \"getblock\",\n        \"getcallargs\",\n        \"getclasstree\",\n        \"getclosurevars\",\n        \"getcomments\",\n        \"getcoroutinelocals\",\n        \"getcoroutinestate\",\n        \"getdoc\",\n        \"getfile\",\n        \"getframeinfo\",\n        \"getfullargspec\",\n        \"getgeneratorlocals\",\n        \"getgeneratorstate\",\n        \"getinnerframes\",\n        \"getlineno\",\n        \"getmembers\",\n        \"getmembers_static\",\n        \"getmodule\",\n        \"getmodulename\",\n        \"getmro\",\n        \"getouterframes\",\n        \"getsource\",\n        \"getsourcefile\",\n        \"getsourcelines\",\n        \"indentsize\",\n        \"isabstract\",\n        \"isasyncgen\",\n        \"isasyncgenfunction\",\n        \"isawaitable\",\n        \"isbuiltin\",\n        \"isclass\",\n        \"iscode\",\n        \"iscoroutine\",\n        \"iscoroutinefunction\",\n        \"isdatadescriptor\",\n        \"isframe\",\n        \"isfunction\",\n        \"isgenerator\",\n        \"isgeneratorfunction\",\n        \"isgetsetdescriptor\",\n        \"ismemberdescriptor\",\n        \"ismethod\",\n        \"ismethoddescriptor\",\n        \"ismethodwrapper\",\n        \"ismodule\",\n        \"isroutine\",\n        \"istraceback\",\n        \"signature\",\n        \"stack\",\n        \"trace\",\n        \"unwrap\",\n        \"walktree\",\n    ]\n\n_P = ParamSpec(\"_P\")\n_T = TypeVar(\"_T\")\n_T_cont = TypeVar(\"_T_cont\", contravariant=True)\n_V_cont = TypeVar(\"_V_cont\", contravariant=True)\n\n#\n# Types and members\n#\nclass EndOfBlock(Exception): ...\n\nclass BlockFinder:\n    indent: int\n    islambda: bool\n    started: bool\n    passline: bool\n    indecorator: bool\n    decoratorhasargs: bool\n    last: int\n    def tokeneater(self, type: int, token: str, srowcol: tuple[int, int], erowcol: tuple[int, int], line: str) -> None: ...\n\nCO_OPTIMIZED: Literal[1]\nCO_NEWLOCALS: Literal[2]\nCO_VARARGS: Literal[4]\nCO_VARKEYWORDS: Literal[8]\nCO_NESTED: Literal[16]\nCO_GENERATOR: Literal[32]\nCO_NOFREE: Literal[64]\nCO_COROUTINE: Literal[128]\nCO_ITERABLE_COROUTINE: Literal[256]\nCO_ASYNC_GENERATOR: Literal[512]\nTPFLAGS_IS_ABSTRACT: Literal[1048576]\n\nmodulesbyfile: dict[str, Any]\n\n_GetMembersPredicateTypeGuard: TypeAlias = Callable[[Any], TypeGuard[_T]]\n_GetMembersPredicate: TypeAlias = Callable[[Any], bool]\n_GetMembersReturnTypeGuard: TypeAlias = list[tuple[str, _T]]\n_GetMembersReturn: TypeAlias = list[tuple[str, Any]]\n\n@overload\ndef getmembers(object: object, predicate: _GetMembersPredicateTypeGuard[_T]) -> _GetMembersReturnTypeGuard[_T]: ...\n@overload\ndef getmembers(object: object, predicate: _GetMembersPredicate | None = None) -> _GetMembersReturn: ...\n\nif sys.version_info >= (3, 11):\n    @overload\n    def getmembers_static(object: object, predicate: _GetMembersPredicateTypeGuard[_T]) -> _GetMembersReturnTypeGuard[_T]: ...\n    @overload\n    def getmembers_static(object: object, predicate: _GetMembersPredicate | None = None) -> _GetMembersReturn: ...\n\ndef getmodulename(path: str) -> str | None: ...\ndef ismodule(object: object) -> TypeGuard[ModuleType]: ...\ndef isclass(object: object) -> TypeGuard[type[Any]]: ...\ndef ismethod(object: object) -> TypeGuard[MethodType]: ...\ndef isfunction(object: object) -> TypeGuard[FunctionType]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def isgeneratorfunction(obj: Callable[..., Generator[Any, Any, Any]]) -> bool: ...\n    @overload\n    def isgeneratorfunction(obj: Callable[_P, Any]) -> TypeGuard[Callable[_P, GeneratorType[Any, Any, Any]]]: ...\n    @overload\n    def isgeneratorfunction(obj: object) -> TypeGuard[Callable[..., GeneratorType[Any, Any, Any]]]: ...\n    @overload\n    def iscoroutinefunction(obj: Callable[..., Coroutine[Any, Any, Any]]) -> bool: ...\n    @overload\n    def iscoroutinefunction(obj: Callable[_P, Awaitable[_T]]) -> TypeGuard[Callable[_P, CoroutineType[Any, Any, _T]]]: ...\n    @overload\n    def iscoroutinefunction(obj: Callable[_P, object]) -> TypeGuard[Callable[_P, CoroutineType[Any, Any, Any]]]: ...\n    @overload\n    def iscoroutinefunction(obj: object) -> TypeGuard[Callable[..., CoroutineType[Any, Any, Any]]]: ...\n\nelse:\n    @overload\n    def isgeneratorfunction(object: Callable[..., Generator[Any, Any, Any]]) -> bool: ...\n    @overload\n    def isgeneratorfunction(object: Callable[_P, Any]) -> TypeGuard[Callable[_P, GeneratorType[Any, Any, Any]]]: ...\n    @overload\n    def isgeneratorfunction(object: object) -> TypeGuard[Callable[..., GeneratorType[Any, Any, Any]]]: ...\n    @overload\n    def iscoroutinefunction(object: Callable[..., Coroutine[Any, Any, Any]]) -> bool: ...\n    @overload\n    def iscoroutinefunction(object: Callable[_P, Awaitable[_T]]) -> TypeGuard[Callable[_P, CoroutineType[Any, Any, _T]]]: ...\n    @overload\n    def iscoroutinefunction(object: Callable[_P, Any]) -> TypeGuard[Callable[_P, CoroutineType[Any, Any, Any]]]: ...\n    @overload\n    def iscoroutinefunction(object: object) -> TypeGuard[Callable[..., CoroutineType[Any, Any, Any]]]: ...\n\ndef isgenerator(object: object) -> TypeGuard[GeneratorType[Any, Any, Any]]: ...\ndef iscoroutine(object: object) -> TypeGuard[CoroutineType[Any, Any, Any]]: ...\ndef isawaitable(object: object) -> TypeGuard[Awaitable[Any]]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def isasyncgenfunction(obj: Callable[..., AsyncGenerator[Any, Any]]) -> bool: ...\n    @overload\n    def isasyncgenfunction(obj: Callable[_P, Any]) -> TypeGuard[Callable[_P, AsyncGeneratorType[Any, Any]]]: ...\n    @overload\n    def isasyncgenfunction(obj: object) -> TypeGuard[Callable[..., AsyncGeneratorType[Any, Any]]]: ...\n\nelse:\n    @overload\n    def isasyncgenfunction(object: Callable[..., AsyncGenerator[Any, Any]]) -> bool: ...\n    @overload\n    def isasyncgenfunction(object: Callable[_P, Any]) -> TypeGuard[Callable[_P, AsyncGeneratorType[Any, Any]]]: ...\n    @overload\n    def isasyncgenfunction(object: object) -> TypeGuard[Callable[..., AsyncGeneratorType[Any, Any]]]: ...\n\nclass _SupportsSet(Protocol[_T_cont, _V_cont]):\n    def __set__(self, __instance: _T_cont, __value: _V_cont) -> None: ...\n\nclass _SupportsDelete(Protocol[_T_cont]):\n    def __delete__(self, __instance: _T_cont) -> None: ...\n\ndef isasyncgen(object: object) -> TypeGuard[AsyncGeneratorType[Any, Any]]: ...\ndef istraceback(object: object) -> TypeGuard[TracebackType]: ...\ndef isframe(object: object) -> TypeGuard[FrameType]: ...\ndef iscode(object: object) -> TypeGuard[CodeType]: ...\ndef isbuiltin(object: object) -> TypeGuard[BuiltinFunctionType]: ...\n\nif sys.version_info >= (3, 11):\n    def ismethodwrapper(object: object) -> TypeGuard[MethodWrapperType]: ...\n\ndef isroutine(\n    object: object,\n) -> TypeGuard[\n    FunctionType\n    | LambdaType\n    | MethodType\n    | BuiltinFunctionType\n    | BuiltinMethodType\n    | WrapperDescriptorType\n    | MethodDescriptorType\n    | ClassMethodDescriptorType\n]: ...\ndef ismethoddescriptor(object: object) -> TypeGuard[MethodDescriptorType]: ...\ndef ismemberdescriptor(object: object) -> TypeGuard[MemberDescriptorType]: ...\ndef isabstract(object: object) -> bool: ...\ndef isgetsetdescriptor(object: object) -> TypeGuard[GetSetDescriptorType]: ...\ndef isdatadescriptor(object: object) -> TypeGuard[_SupportsSet[Any, Any] | _SupportsDelete[Any]]: ...\n\n#\n# Retrieving source code\n#\n_SourceObjectType: TypeAlias = (\n    ModuleType | type[Any] | MethodType | FunctionType | TracebackType | FrameType | CodeType | Callable[..., Any]\n)\n\ndef findsource(object: _SourceObjectType) -> tuple[list[str], int]: ...\ndef getabsfile(object: _SourceObjectType, _filename: str | None = None) -> str: ...\ndef getblock(lines: Sequence[str]) -> Sequence[str]: ...\ndef getdoc(object: object) -> str | None: ...\ndef getcomments(object: object) -> str | None: ...\ndef getfile(object: _SourceObjectType) -> str: ...\ndef getmodule(object: object, _filename: str | None = None) -> ModuleType | None: ...\ndef getsourcefile(object: _SourceObjectType) -> str | None: ...\ndef getsourcelines(object: _SourceObjectType) -> tuple[list[str], int]: ...\ndef getsource(object: _SourceObjectType) -> str: ...\ndef cleandoc(doc: str) -> str: ...\ndef indentsize(line: str) -> int: ...\n\n_IntrospectableCallable: TypeAlias = Callable[..., Any]\n\n#\n# Introspecting callables with the Signature object\n#\nif sys.version_info >= (3, 10):\n    def signature(\n        obj: _IntrospectableCallable,\n        *,\n        follow_wrapped: bool = True,\n        globals: Mapping[str, Any] | None = None,\n        locals: Mapping[str, Any] | None = None,\n        eval_str: bool = False,\n    ) -> Signature: ...\n\nelse:\n    def signature(obj: _IntrospectableCallable, *, follow_wrapped: bool = True) -> Signature: ...\n\nclass _void: ...\nclass _empty: ...\n\nclass Signature:\n    def __init__(\n        self, parameters: Sequence[Parameter] | None = None, *, return_annotation: Any = ..., __validate_parameters__: bool = True\n    ) -> None: ...\n    empty = _empty\n    @property\n    def parameters(self) -> types.MappingProxyType[str, Parameter]: ...\n    @property\n    def return_annotation(self) -> Any: ...\n    def bind(self, *args: Any, **kwargs: Any) -> BoundArguments: ...\n    def bind_partial(self, *args: Any, **kwargs: Any) -> BoundArguments: ...\n    def replace(self, *, parameters: Sequence[Parameter] | type[_void] | None = ..., return_annotation: Any = ...) -> Self: ...\n    if sys.version_info >= (3, 10):\n        @classmethod\n        def from_callable(\n            cls,\n            obj: _IntrospectableCallable,\n            *,\n            follow_wrapped: bool = True,\n            globals: Mapping[str, Any] | None = None,\n            locals: Mapping[str, Any] | None = None,\n            eval_str: bool = False,\n        ) -> Self: ...\n    else:\n        @classmethod\n        def from_callable(cls, obj: _IntrospectableCallable, *, follow_wrapped: bool = True) -> Self: ...\n\n    def __eq__(self, other: object) -> bool: ...\n\nif sys.version_info >= (3, 10):\n    def get_annotations(\n        obj: Callable[..., object] | type[Any] | ModuleType,\n        *,\n        globals: Mapping[str, Any] | None = None,\n        locals: Mapping[str, Any] | None = None,\n        eval_str: bool = False,\n    ) -> dict[str, Any]: ...\n\n# The name is the same as the enum's name in CPython\nclass _ParameterKind(enum.IntEnum):\n    POSITIONAL_ONLY: int\n    POSITIONAL_OR_KEYWORD: int\n    VAR_POSITIONAL: int\n    KEYWORD_ONLY: int\n    VAR_KEYWORD: int\n\n    if sys.version_info >= (3, 8):\n        @property\n        def description(self) -> str: ...\n\nclass Parameter:\n    def __init__(self, name: str, kind: _ParameterKind, *, default: Any = ..., annotation: Any = ...) -> None: ...\n    empty = _empty\n\n    POSITIONAL_ONLY: ClassVar[Literal[_ParameterKind.POSITIONAL_ONLY]]\n    POSITIONAL_OR_KEYWORD: ClassVar[Literal[_ParameterKind.POSITIONAL_OR_KEYWORD]]\n    VAR_POSITIONAL: ClassVar[Literal[_ParameterKind.VAR_POSITIONAL]]\n    KEYWORD_ONLY: ClassVar[Literal[_ParameterKind.KEYWORD_ONLY]]\n    VAR_KEYWORD: ClassVar[Literal[_ParameterKind.VAR_KEYWORD]]\n    @property\n    def name(self) -> str: ...\n    @property\n    def default(self) -> Any: ...\n    @property\n    def kind(self) -> _ParameterKind: ...\n    @property\n    def annotation(self) -> Any: ...\n    def replace(\n        self,\n        *,\n        name: str | type[_void] = ...,\n        kind: _ParameterKind | type[_void] = ...,\n        default: Any = ...,\n        annotation: Any = ...,\n    ) -> Self: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass BoundArguments:\n    arguments: OrderedDict[str, Any]\n    @property\n    def args(self) -> tuple[Any, ...]: ...\n    @property\n    def kwargs(self) -> dict[str, Any]: ...\n    @property\n    def signature(self) -> Signature: ...\n    def __init__(self, signature: Signature, arguments: OrderedDict[str, Any]) -> None: ...\n    def apply_defaults(self) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\n#\n# Classes and functions\n#\n\n# TODO: The actual return type should be list[_ClassTreeItem] but mypy doesn't\n# seem to be supporting this at the moment:\n# _ClassTreeItem = list[_ClassTreeItem] | Tuple[type, Tuple[type, ...]]\ndef getclasstree(classes: list[type], unique: bool = False) -> list[Any]: ...\ndef walktree(classes: list[type], children: Mapping[type[Any], list[type]], parent: type[Any] | None) -> list[Any]: ...\n\nclass Arguments(NamedTuple):\n    args: list[str]\n    varargs: str | None\n    varkw: str | None\n\ndef getargs(co: CodeType) -> Arguments: ...\n\nif sys.version_info < (3, 11):\n    class ArgSpec(NamedTuple):\n        args: list[str]\n        varargs: str | None\n        keywords: str | None\n        defaults: tuple[Any, ...]\n    def getargspec(func: object) -> ArgSpec: ...\n\nclass FullArgSpec(NamedTuple):\n    args: list[str]\n    varargs: str | None\n    varkw: str | None\n    defaults: tuple[Any, ...] | None\n    kwonlyargs: list[str]\n    kwonlydefaults: dict[str, Any] | None\n    annotations: dict[str, Any]\n\ndef getfullargspec(func: object) -> FullArgSpec: ...\n\nclass ArgInfo(NamedTuple):\n    args: list[str]\n    varargs: str | None\n    keywords: str | None\n    locals: dict[str, Any]\n\ndef getargvalues(frame: FrameType) -> ArgInfo: ...\ndef formatannotation(annotation: object, base_module: str | None = None) -> str: ...\ndef formatannotationrelativeto(object: object) -> Callable[[object], str]: ...\n\nif sys.version_info < (3, 11):\n    def formatargspec(\n        args: list[str],\n        varargs: str | None = None,\n        varkw: str | None = None,\n        defaults: tuple[Any, ...] | None = None,\n        kwonlyargs: Sequence[str] | None = (),\n        kwonlydefaults: Mapping[str, Any] | None = {},\n        annotations: Mapping[str, Any] = {},\n        formatarg: Callable[[str], str] = ...,\n        formatvarargs: Callable[[str], str] = ...,\n        formatvarkw: Callable[[str], str] = ...,\n        formatvalue: Callable[[Any], str] = ...,\n        formatreturns: Callable[[Any], str] = ...,\n        formatannotation: Callable[[Any], str] = ...,\n    ) -> str: ...\n\ndef formatargvalues(\n    args: list[str],\n    varargs: str | None,\n    varkw: str | None,\n    locals: Mapping[str, Any] | None,\n    formatarg: Callable[[str], str] | None = ...,\n    formatvarargs: Callable[[str], str] | None = ...,\n    formatvarkw: Callable[[str], str] | None = ...,\n    formatvalue: Callable[[Any], str] | None = ...,\n) -> str: ...\ndef getmro(cls: type) -> tuple[type, ...]: ...\ndef getcallargs(__func: Callable[_P, Any], *args: _P.args, **kwds: _P.kwargs) -> dict[str, Any]: ...\n\nclass ClosureVars(NamedTuple):\n    nonlocals: Mapping[str, Any]\n    globals: Mapping[str, Any]\n    builtins: Mapping[str, Any]\n    unbound: AbstractSet[str]\n\ndef getclosurevars(func: _IntrospectableCallable) -> ClosureVars: ...\ndef unwrap(func: Callable[..., Any], *, stop: Callable[[Callable[..., Any]], Any] | None = None) -> Any: ...\n\n#\n# The interpreter stack\n#\n\nif sys.version_info >= (3, 11):\n    class _Traceback(NamedTuple):\n        filename: str\n        lineno: int\n        function: str\n        code_context: list[str] | None\n        index: int | None  # type: ignore[assignment]\n\n    class Traceback(_Traceback):\n        positions: dis.Positions | None\n        def __new__(\n            cls,\n            filename: str,\n            lineno: int,\n            function: str,\n            code_context: list[str] | None,\n            index: int | None,\n            *,\n            positions: dis.Positions | None = None,\n        ) -> Self: ...\n\n    class _FrameInfo(NamedTuple):\n        frame: FrameType\n        filename: str\n        lineno: int\n        function: str\n        code_context: list[str] | None\n        index: int | None  # type: ignore[assignment]\n\n    class FrameInfo(_FrameInfo):\n        positions: dis.Positions | None\n        def __new__(\n            cls,\n            frame: FrameType,\n            filename: str,\n            lineno: int,\n            function: str,\n            code_context: list[str] | None,\n            index: int | None,\n            *,\n            positions: dis.Positions | None = None,\n        ) -> Self: ...\n\nelse:\n    class Traceback(NamedTuple):\n        filename: str\n        lineno: int\n        function: str\n        code_context: list[str] | None\n        index: int | None  # type: ignore[assignment]\n\n    class FrameInfo(NamedTuple):\n        frame: FrameType\n        filename: str\n        lineno: int\n        function: str\n        code_context: list[str] | None\n        index: int | None  # type: ignore[assignment]\n\ndef getframeinfo(frame: FrameType | TracebackType, context: int = 1) -> Traceback: ...\ndef getouterframes(frame: Any, context: int = 1) -> list[FrameInfo]: ...\ndef getinnerframes(tb: TracebackType, context: int = 1) -> list[FrameInfo]: ...\ndef getlineno(frame: FrameType) -> int: ...\ndef currentframe() -> FrameType | None: ...\ndef stack(context: int = 1) -> list[FrameInfo]: ...\ndef trace(context: int = 1) -> list[FrameInfo]: ...\n\n#\n# Fetching attributes statically\n#\n\ndef getattr_static(obj: object, attr: str, default: Any | None = ...) -> Any: ...\n\n#\n# Current State of Generators and Coroutines\n#\n\nGEN_CREATED: Literal[\"GEN_CREATED\"]\nGEN_RUNNING: Literal[\"GEN_RUNNING\"]\nGEN_SUSPENDED: Literal[\"GEN_SUSPENDED\"]\nGEN_CLOSED: Literal[\"GEN_CLOSED\"]\n\ndef getgeneratorstate(\n    generator: Generator[Any, Any, Any]\n) -> Literal[\"GEN_CREATED\", \"GEN_RUNNING\", \"GEN_SUSPENDED\", \"GEN_CLOSED\"]: ...\n\nCORO_CREATED: Literal[\"CORO_CREATED\"]\nCORO_RUNNING: Literal[\"CORO_RUNNING\"]\nCORO_SUSPENDED: Literal[\"CORO_SUSPENDED\"]\nCORO_CLOSED: Literal[\"CORO_CLOSED\"]\n\ndef getcoroutinestate(\n    coroutine: Coroutine[Any, Any, Any]\n) -> Literal[\"CORO_CREATED\", \"CORO_RUNNING\", \"CORO_SUSPENDED\", \"CORO_CLOSED\"]: ...\ndef getgeneratorlocals(generator: Generator[Any, Any, Any]) -> dict[str, Any]: ...\ndef getcoroutinelocals(coroutine: Coroutine[Any, Any, Any]) -> dict[str, Any]: ...\n\n# Create private type alias to avoid conflict with symbol of same\n# name created in Attribute class.\n_Object: TypeAlias = object\n\nclass Attribute(NamedTuple):\n    name: str\n    kind: Literal[\"class method\", \"static method\", \"property\", \"method\", \"data\"]\n    defining_class: type\n    object: _Object\n\ndef classify_class_attrs(cls: type) -> list[Attribute]: ...\n\nif sys.version_info >= (3, 9):\n    class ClassFoundException(Exception): ...\n",
  "/typeshed/stdlib/io.pyi": "import abc\nimport builtins\nimport codecs\nimport sys\nfrom _typeshed import FileDescriptorOrPath, ReadableBuffer, WriteableBuffer\nfrom collections.abc import Callable, Iterable, Iterator\nfrom os import _Opener\nfrom types import TracebackType\nfrom typing import IO, Any, BinaryIO, TextIO\nfrom typing_extensions import Literal, Self\n\n__all__ = [\n    \"BlockingIOError\",\n    \"open\",\n    \"IOBase\",\n    \"RawIOBase\",\n    \"FileIO\",\n    \"BytesIO\",\n    \"StringIO\",\n    \"BufferedIOBase\",\n    \"BufferedReader\",\n    \"BufferedWriter\",\n    \"BufferedRWPair\",\n    \"BufferedRandom\",\n    \"TextIOBase\",\n    \"TextIOWrapper\",\n    \"UnsupportedOperation\",\n    \"SEEK_SET\",\n    \"SEEK_CUR\",\n    \"SEEK_END\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"open_code\"]\n\nDEFAULT_BUFFER_SIZE: Literal[8192]\n\nSEEK_SET: Literal[0]\nSEEK_CUR: Literal[1]\nSEEK_END: Literal[2]\n\nopen = builtins.open\n\nif sys.version_info >= (3, 8):\n    def open_code(path: str) -> IO[bytes]: ...\n\nBlockingIOError = builtins.BlockingIOError\n\nclass UnsupportedOperation(OSError, ValueError): ...\n\nclass IOBase(metaclass=abc.ABCMeta):\n    def __iter__(self) -> Iterator[bytes]: ...\n    def __next__(self) -> bytes: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def close(self) -> None: ...\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def readable(self) -> bool: ...\n    read: Callable[..., Any]\n    def readlines(self, __hint: int = -1) -> list[bytes]: ...\n    def seek(self, __offset: int, __whence: int = ...) -> int: ...\n    def seekable(self) -> bool: ...\n    def tell(self) -> int: ...\n    def truncate(self, __size: int | None = ...) -> int: ...\n    def writable(self) -> bool: ...\n    write: Callable[..., Any]\n    def writelines(self, __lines: Iterable[ReadableBuffer]) -> None: ...\n    def readline(self, __size: int | None = -1) -> bytes: ...\n    def __del__(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    def _checkClosed(self, msg: str | None = ...) -> None: ...  # undocumented\n\nclass RawIOBase(IOBase):\n    def readall(self) -> bytes: ...\n    def readinto(self, __buffer: WriteableBuffer) -> int | None: ...\n    def write(self, __b: ReadableBuffer) -> int | None: ...\n    def read(self, __size: int = -1) -> bytes | None: ...\n\nclass BufferedIOBase(IOBase):\n    raw: RawIOBase  # This is not part of the BufferedIOBase API and may not exist on some implementations.\n    def detach(self) -> RawIOBase: ...\n    def readinto(self, __buffer: WriteableBuffer) -> int: ...\n    def write(self, __buffer: ReadableBuffer) -> int: ...\n    def readinto1(self, __buffer: WriteableBuffer) -> int: ...\n    def read(self, __size: int | None = ...) -> bytes: ...\n    def read1(self, __size: int = ...) -> bytes: ...\n\nclass FileIO(RawIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes\n    mode: str\n    name: FileDescriptorOrPath  # type: ignore[assignment]\n    def __init__(\n        self, file: FileDescriptorOrPath, mode: str = ..., closefd: bool = ..., opener: _Opener | None = ...\n    ) -> None: ...\n    @property\n    def closefd(self) -> bool: ...\n    def write(self, __b: ReadableBuffer) -> int: ...\n    def read(self, __size: int = -1) -> bytes: ...\n    def __enter__(self) -> Self: ...\n\nclass BytesIO(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes\n    def __init__(self, initial_bytes: ReadableBuffer = ...) -> None: ...\n    # BytesIO does not contain a \"name\" field. This workaround is necessary\n    # to allow BytesIO sub-classes to add this field, as it is defined\n    # as a read-only property on IO[].\n    name: Any\n    def __enter__(self) -> Self: ...\n    def getvalue(self) -> bytes: ...\n    def getbuffer(self) -> memoryview: ...\n    def read1(self, __size: int | None = -1) -> bytes: ...\n\nclass BufferedReader(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of methods in the base classes\n    def __enter__(self) -> Self: ...\n    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...\n    def peek(self, __size: int = 0) -> bytes: ...\n\nclass BufferedWriter(BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes\n    def __enter__(self) -> Self: ...\n    def __init__(self, raw: RawIOBase, buffer_size: int = ...) -> None: ...\n    def write(self, __buffer: ReadableBuffer) -> int: ...\n\nclass BufferedRandom(BufferedReader, BufferedWriter):  # type: ignore[misc]  # incompatible definitions of methods in the base classes\n    def __enter__(self) -> Self: ...\n    def seek(self, __target: int, __whence: int = 0) -> int: ...  # stubtest needs this\n\nclass BufferedRWPair(BufferedIOBase):\n    def __init__(self, reader: RawIOBase, writer: RawIOBase, buffer_size: int = ...) -> None: ...\n    def peek(self, __size: int = ...) -> bytes: ...\n\nclass TextIOBase(IOBase):\n    encoding: str\n    errors: str | None\n    newlines: str | tuple[str, ...] | None\n    def __iter__(self) -> Iterator[str]: ...  # type: ignore[override]\n    def __next__(self) -> str: ...  # type: ignore[override]\n    def detach(self) -> BinaryIO: ...\n    def write(self, __s: str) -> int: ...\n    def writelines(self, __lines: Iterable[str]) -> None: ...  # type: ignore[override]\n    def readline(self, __size: int = ...) -> str: ...  # type: ignore[override]\n    def readlines(self, __hint: int = -1) -> list[str]: ...  # type: ignore[override]\n    def read(self, __size: int | None = ...) -> str: ...\n\nclass TextIOWrapper(TextIOBase, TextIO):  # type: ignore[misc]  # incompatible definitions of write in the base classes\n    def __init__(\n        self,\n        buffer: IO[bytes],\n        encoding: str | None = ...,\n        errors: str | None = ...,\n        newline: str | None = ...,\n        line_buffering: bool = ...,\n        write_through: bool = ...,\n    ) -> None: ...\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def closed(self) -> bool: ...\n    @property\n    def line_buffering(self) -> bool: ...\n    @property\n    def write_through(self) -> bool: ...\n    def reconfigure(\n        self,\n        *,\n        encoding: str | None = None,\n        errors: str | None = None,\n        newline: str | None = None,\n        line_buffering: bool | None = None,\n        write_through: bool | None = None,\n    ) -> None: ...\n    # These are inherited from TextIOBase, but must exist in the stub to satisfy mypy.\n    def __enter__(self) -> Self: ...\n    def __iter__(self) -> Iterator[str]: ...  # type: ignore[override]\n    def __next__(self) -> str: ...  # type: ignore[override]\n    def writelines(self, __lines: Iterable[str]) -> None: ...  # type: ignore[override]\n    def readline(self, __size: int = -1) -> str: ...  # type: ignore[override]\n    def readlines(self, __hint: int = -1) -> list[str]: ...  # type: ignore[override]\n    def seek(self, __cookie: int, __whence: int = 0) -> int: ...  # stubtest needs this\n\nclass StringIO(TextIOWrapper):\n    def __init__(self, initial_value: str | None = ..., newline: str | None = ...) -> None: ...\n    # StringIO does not contain a \"name\" field. This workaround is necessary\n    # to allow StringIO sub-classes to add this field, as it is defined\n    # as a read-only property on IO[].\n    name: Any\n    def getvalue(self) -> str: ...\n\nclass IncrementalNewlineDecoder(codecs.IncrementalDecoder):\n    def __init__(self, decoder: codecs.IncrementalDecoder | None, translate: bool, errors: str = ...) -> None: ...\n    def decode(self, input: ReadableBuffer | str, final: bool = False) -> str: ...\n    @property\n    def newlines(self) -> str | tuple[str, ...] | None: ...\n    def setstate(self, __state: tuple[bytes, int]) -> None: ...\n",
  "/typeshed/stdlib/ipaddress.pyi": "import sys\nfrom collections.abc import Container, Iterable, Iterator\nfrom typing import Any, Generic, SupportsInt, TypeVar, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\n# Undocumented length constants\nIPV4LENGTH: Literal[32]\nIPV6LENGTH: Literal[128]\n\n_A = TypeVar(\"_A\", IPv4Address, IPv6Address)\n_N = TypeVar(\"_N\", IPv4Network, IPv6Network)\n\n_RawIPAddress: TypeAlias = int | str | bytes | IPv4Address | IPv6Address\n_RawNetworkPart: TypeAlias = IPv4Network | IPv6Network | IPv4Interface | IPv6Interface\n\ndef ip_address(address: _RawIPAddress) -> IPv4Address | IPv6Address: ...\ndef ip_network(\n    address: _RawIPAddress | _RawNetworkPart | tuple[_RawIPAddress] | tuple[_RawIPAddress, int], strict: bool = True\n) -> IPv4Network | IPv6Network: ...\ndef ip_interface(\n    address: _RawIPAddress | _RawNetworkPart | tuple[_RawIPAddress] | tuple[_RawIPAddress, int]\n) -> IPv4Interface | IPv6Interface: ...\n\nclass _IPAddressBase:\n    @property\n    def compressed(self) -> str: ...\n    @property\n    def exploded(self) -> str: ...\n    @property\n    def reverse_pointer(self) -> str: ...\n    @property\n    def version(self) -> int: ...\n\nclass _BaseAddress(_IPAddressBase, SupportsInt):\n    def __init__(self, address: object) -> None: ...\n    def __add__(self, other: int) -> Self: ...\n    def __int__(self) -> int: ...\n    def __sub__(self, other: int) -> Self: ...\n    if sys.version_info >= (3, 9):\n        def __format__(self, fmt: str) -> str: ...\n\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: Self) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __ge__(self, other: Self) -> bool: ...\n        def __gt__(self, other: Self) -> bool: ...\n        def __le__(self, other: Self) -> bool: ...\n    else:\n        def __ge__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n        def __gt__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n        def __le__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n\n    @property\n    def is_global(self) -> bool: ...\n    @property\n    def is_link_local(self) -> bool: ...\n    @property\n    def is_loopback(self) -> bool: ...\n    @property\n    def is_multicast(self) -> bool: ...\n    @property\n    def is_private(self) -> bool: ...\n    @property\n    def is_reserved(self) -> bool: ...\n    @property\n    def is_unspecified(self) -> bool: ...\n    @property\n    def max_prefixlen(self) -> int: ...\n    @property\n    def packed(self) -> bytes: ...\n\nclass _BaseNetwork(_IPAddressBase, Container[_A], Iterable[_A], Generic[_A]):\n    network_address: _A\n    netmask: _A\n    def __init__(self, address: object, strict: bool = ...) -> None: ...\n    def __contains__(self, other: Any) -> bool: ...\n    def __getitem__(self, n: int) -> _A: ...\n    def __iter__(self) -> Iterator[_A]: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: Self) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __ge__(self, other: Self) -> bool: ...\n        def __gt__(self, other: Self) -> bool: ...\n        def __le__(self, other: Self) -> bool: ...\n    else:\n        def __ge__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n        def __gt__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n        def __le__(self, other: Self, NotImplemented: Any = ...) -> bool: ...\n\n    def address_exclude(self, other: Self) -> Iterator[Self]: ...\n    @property\n    def broadcast_address(self) -> _A: ...\n    def compare_networks(self, other: Self) -> int: ...\n    def hosts(self) -> Iterator[_A]: ...\n    @property\n    def is_global(self) -> bool: ...\n    @property\n    def is_link_local(self) -> bool: ...\n    @property\n    def is_loopback(self) -> bool: ...\n    @property\n    def is_multicast(self) -> bool: ...\n    @property\n    def is_private(self) -> bool: ...\n    @property\n    def is_reserved(self) -> bool: ...\n    @property\n    def is_unspecified(self) -> bool: ...\n    @property\n    def max_prefixlen(self) -> int: ...\n    @property\n    def num_addresses(self) -> int: ...\n    def overlaps(self, other: _BaseNetwork[IPv4Address] | _BaseNetwork[IPv6Address]) -> bool: ...\n    @property\n    def prefixlen(self) -> int: ...\n    def subnet_of(self, other: Self) -> bool: ...\n    def supernet_of(self, other: Self) -> bool: ...\n    def subnets(self, prefixlen_diff: int = 1, new_prefix: int | None = None) -> Iterator[Self]: ...\n    def supernet(self, prefixlen_diff: int = 1, new_prefix: int | None = None) -> Self: ...\n    @property\n    def with_hostmask(self) -> str: ...\n    @property\n    def with_netmask(self) -> str: ...\n    @property\n    def with_prefixlen(self) -> str: ...\n    @property\n    def hostmask(self) -> _A: ...\n\nclass _BaseInterface(_BaseAddress, Generic[_A, _N]):\n    hostmask: _A\n    netmask: _A\n    network: _N\n    @property\n    def ip(self) -> _A: ...\n    @property\n    def with_hostmask(self) -> str: ...\n    @property\n    def with_netmask(self) -> str: ...\n    @property\n    def with_prefixlen(self) -> str: ...\n\nclass _BaseV4:\n    @property\n    def version(self) -> Literal[4]: ...\n    @property\n    def max_prefixlen(self) -> Literal[32]: ...\n\nclass IPv4Address(_BaseV4, _BaseAddress): ...\nclass IPv4Network(_BaseV4, _BaseNetwork[IPv4Address]): ...\nclass IPv4Interface(IPv4Address, _BaseInterface[IPv4Address, IPv4Network]): ...\n\nclass _BaseV6:\n    @property\n    def version(self) -> Literal[6]: ...\n    @property\n    def max_prefixlen(self) -> Literal[128]: ...\n\nclass IPv6Address(_BaseV6, _BaseAddress):\n    @property\n    def ipv4_mapped(self) -> IPv4Address | None: ...\n    @property\n    def is_site_local(self) -> bool: ...\n    @property\n    def sixtofour(self) -> IPv4Address | None: ...\n    @property\n    def teredo(self) -> tuple[IPv4Address, IPv4Address] | None: ...\n    if sys.version_info >= (3, 9):\n        @property\n        def scope_id(self) -> str | None: ...\n\nclass IPv6Network(_BaseV6, _BaseNetwork[IPv6Address]):\n    @property\n    def is_site_local(self) -> bool: ...\n\nclass IPv6Interface(IPv6Address, _BaseInterface[IPv6Address, IPv6Network]): ...\n\ndef v4_int_to_packed(address: int) -> bytes: ...\ndef v6_int_to_packed(address: int) -> bytes: ...\n\n# Third overload is technically incorrect, but convenient when first and last are return values of ip_address()\n@overload\ndef summarize_address_range(first: IPv4Address, last: IPv4Address) -> Iterator[IPv4Network]: ...\n@overload\ndef summarize_address_range(first: IPv6Address, last: IPv6Address) -> Iterator[IPv6Network]: ...\n@overload\ndef summarize_address_range(\n    first: IPv4Address | IPv6Address, last: IPv4Address | IPv6Address\n) -> Iterator[IPv4Network] | Iterator[IPv6Network]: ...\ndef collapse_addresses(addresses: Iterable[_N]) -> Iterator[_N]: ...\n@overload\ndef get_mixed_type_key(obj: _A) -> tuple[int, _A]: ...\n@overload\ndef get_mixed_type_key(obj: IPv4Network) -> tuple[int, IPv4Address, IPv4Address]: ...\n@overload\ndef get_mixed_type_key(obj: IPv6Network) -> tuple[int, IPv6Address, IPv6Address]: ...\n\nclass AddressValueError(ValueError): ...\nclass NetmaskValueError(ValueError): ...\n",
  "/typeshed/stdlib/itertools.pyi": "import sys\nfrom collections.abc import Callable, Iterable, Iterator\nfrom typing import Any, Generic, SupportsComplex, SupportsFloat, SupportsInt, TypeVar, overload\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_N = TypeVar(\"_N\", int, float, SupportsFloat, SupportsInt, SupportsIndex, SupportsComplex)\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_T6 = TypeVar(\"_T6\")\n\n_Step: TypeAlias = SupportsFloat | SupportsInt | SupportsIndex | SupportsComplex\n\n_Predicate: TypeAlias = Callable[[_T], object]\n\n# Technically count can take anything that implements a number protocol and has an add method\n# but we can't enforce the add method\nclass count(Iterator[_N], Generic[_N]):\n    @overload\n    def __new__(cls) -> count[int]: ...\n    @overload\n    def __new__(cls, start: _N, step: _Step = ...) -> count[_N]: ...\n    @overload\n    def __new__(cls, *, step: _N) -> count[_N]: ...\n    def __next__(self) -> _N: ...\n    def __iter__(self) -> Self: ...\n\nclass cycle(Iterator[_T], Generic[_T]):\n    def __init__(self, __iterable: Iterable[_T]) -> None: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n\nclass repeat(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, object: _T) -> None: ...\n    @overload\n    def __init__(self, object: _T, times: int) -> None: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n    def __length_hint__(self) -> int: ...\n\nclass accumulate(Iterator[_T], Generic[_T]):\n    if sys.version_info >= (3, 8):\n        @overload\n        def __init__(self, iterable: Iterable[_T], func: None = None, *, initial: _T | None = ...) -> None: ...\n        @overload\n        def __init__(self, iterable: Iterable[_S], func: Callable[[_T, _S], _T], *, initial: _T | None = ...) -> None: ...\n    else:\n        def __init__(self, iterable: Iterable[_T], func: Callable[[_T, _T], _T] | None = ...) -> None: ...\n\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass chain(Iterator[_T], Generic[_T]):\n    def __init__(self, *iterables: Iterable[_T]) -> None: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n    @classmethod\n    # We use type[Any] and not type[_S] to not lose the type inference from __iterable\n    def from_iterable(cls: type[Any], __iterable: Iterable[Iterable[_S]]) -> chain[_S]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\nclass compress(Iterator[_T], Generic[_T]):\n    def __init__(self, data: Iterable[_T], selectors: Iterable[Any]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass dropwhile(Iterator[_T], Generic[_T]):\n    def __init__(self, __predicate: _Predicate[_T], __iterable: Iterable[_T]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass filterfalse(Iterator[_T], Generic[_T]):\n    def __init__(self, __predicate: _Predicate[_T] | None, __iterable: Iterable[_T]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass groupby(Iterator[tuple[_T, Iterator[_S]]], Generic[_T, _S]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T1], key: None = None) -> groupby[_T1, _T1]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T1], key: Callable[[_T1], _T2]) -> groupby[_T2, _T1]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[_T, Iterator[_S]]: ...\n\nclass islice(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __iterable: Iterable[_T], __stop: int | None) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[_T], __start: int | None, __stop: int | None, __step: int | None = ...) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass starmap(Iterator[_T], Generic[_T]):\n    def __init__(self, __function: Callable[..., _T], __iterable: Iterable[Iterable[Any]]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\nclass takewhile(Iterator[_T], Generic[_T]):\n    def __init__(self, __predicate: _Predicate[_T], __iterable: Iterable[_T]) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\ndef tee(__iterable: Iterable[_T], __n: int = 2) -> tuple[Iterator[_T], ...]: ...\n\nclass zip_longest(Iterator[_T_co], Generic[_T_co]):\n    # one iterable (fillvalue doesn't matter)\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1], *, fillvalue: object = ...) -> zip_longest[tuple[_T1]]: ...\n    # two iterables\n    @overload\n    # In the overloads without fillvalue, all of the tuple members could theoretically be None,\n    # but we return Any instead to avoid false positives for code where we know one of the iterables\n    # is longer.\n    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> zip_longest[tuple[_T1 | Any, _T2 | Any]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T]]: ...\n    # three iterables\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T]]: ...\n    # four iterables\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]\n    ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any, _T4 | Any]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4], *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T]]: ...\n    # five iterables\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip_longest[tuple[_T1 | Any, _T2 | Any, _T3 | Any, _T4 | Any, _T5 | Any]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n        *,\n        fillvalue: _T,\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T, _T5 | _T]]: ...\n    # six or more iterables\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T],\n        __iter2: Iterable[_T],\n        __iter3: Iterable[_T],\n        __iter4: Iterable[_T],\n        __iter5: Iterable[_T],\n        __iter6: Iterable[_T],\n        *iterables: Iterable[_T],\n    ) -> zip_longest[tuple[_T | Any, ...]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T],\n        __iter2: Iterable[_T],\n        __iter3: Iterable[_T],\n        __iter4: Iterable[_T],\n        __iter5: Iterable[_T],\n        __iter6: Iterable[_T],\n        *iterables: Iterable[_T],\n        fillvalue: _T,\n    ) -> zip_longest[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\nclass product(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> product[tuple[_T1]]: ...\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]) -> product[tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]) -> product[tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3], __iter4: Iterable[_T4]\n    ) -> product[tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n        __iter6: Iterable[_T6],\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        __iter7: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> product[tuple[Any, ...]]: ...\n    @overload\n    def __new__(cls, *iterables: Iterable[_T1], repeat: int) -> product[tuple[_T1, ...]]: ...\n    @overload\n    def __new__(cls, *iterables: Iterable[Any], repeat: int = ...) -> product[tuple[Any, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\nclass permutations(Iterator[tuple[_T, ...]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], r: int | None = ...) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[_T, ...]: ...\n\nclass combinations(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[2]) -> combinations[tuple[_T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[3]) -> combinations[tuple[_T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[4]) -> combinations[tuple[_T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[5]) -> combinations[tuple[_T, _T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: int) -> combinations[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\nclass combinations_with_replacement(Iterator[tuple[_T, ...]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], r: int) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[_T, ...]: ...\n\nif sys.version_info >= (3, 10):\n    class pairwise(Iterator[_T_co], Generic[_T_co]):\n        def __new__(cls, __iterable: Iterable[_T]) -> pairwise[tuple[_T, _T]]: ...\n        def __iter__(self) -> Self: ...\n        def __next__(self) -> _T_co: ...\n\nif sys.version_info >= (3, 12):\n    class batched(Iterator[_T_co], Generic[_T_co]):\n        def __new__(cls, iterable: Iterable[_T_co], n: int) -> Self: ...\n        def __iter__(self) -> Self: ...\n        def __next__(self) -> tuple[_T_co, ...]: ...\n",
  "/typeshed/stdlib/keyword.pyi": "import sys\nfrom collections.abc import Sequence\nfrom typing_extensions import Final\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"iskeyword\", \"issoftkeyword\", \"kwlist\", \"softkwlist\"]\nelse:\n    __all__ = [\"iskeyword\", \"kwlist\"]\n\ndef iskeyword(s: str) -> bool: ...\n\n# a list at runtime, but you're not meant to mutate it;\n# type it as a sequence\nkwlist: Final[Sequence[str]]\n\nif sys.version_info >= (3, 9):\n    def issoftkeyword(s: str) -> bool: ...\n\n    # a list at runtime, but you're not meant to mutate it;\n    # type it as a sequence\n    softkwlist: Final[Sequence[str]]\n",
  "/typeshed/stdlib/linecache.pyi": "import sys\nfrom typing import Any, Protocol\nfrom typing_extensions import TypeAlias\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"getline\", \"clearcache\", \"checkcache\", \"lazycache\"]\nelse:\n    __all__ = [\"getline\", \"clearcache\", \"checkcache\"]\n\n_ModuleGlobals: TypeAlias = dict[str, Any]\n_ModuleMetadata: TypeAlias = tuple[int, float | None, list[str], str]\n\nclass _SourceLoader(Protocol):\n    def __call__(self) -> str | None: ...\n\ncache: dict[str, _SourceLoader | _ModuleMetadata]  # undocumented\n\ndef getline(filename: str, lineno: int, module_globals: _ModuleGlobals | None = None) -> str: ...\ndef clearcache() -> None: ...\ndef getlines(filename: str, module_globals: _ModuleGlobals | None = None) -> list[str]: ...\ndef checkcache(filename: str | None = None) -> None: ...\ndef updatecache(filename: str, module_globals: _ModuleGlobals | None = None) -> list[str]: ...\ndef lazycache(filename: str, module_globals: _ModuleGlobals) -> bool: ...\n",
  "/typeshed/stdlib/locale.pyi": "import sys\nfrom _typeshed import StrPath\nfrom collections.abc import Callable, Iterable, Mapping\n\n__all__ = [\n    \"getlocale\",\n    \"getdefaultlocale\",\n    \"getpreferredencoding\",\n    \"Error\",\n    \"setlocale\",\n    \"resetlocale\",\n    \"localeconv\",\n    \"strcoll\",\n    \"strxfrm\",\n    \"str\",\n    \"atof\",\n    \"atoi\",\n    \"format\",\n    \"format_string\",\n    \"currency\",\n    \"normalize\",\n    \"LC_CTYPE\",\n    \"LC_COLLATE\",\n    \"LC_MESSAGES\",\n    \"LC_TIME\",\n    \"LC_MONETARY\",\n    \"LC_NUMERIC\",\n    \"LC_ALL\",\n    \"CHAR_MAX\",\n]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"getencoding\"]\n\n# This module defines a function \"str()\", which is why \"str\" can't be used\n# as a type annotation or type alias.\nfrom builtins import str as _str\nfrom decimal import Decimal\nfrom typing import Any\n\nCODESET: int\nD_T_FMT: int\nD_FMT: int\nT_FMT: int\nT_FMT_AMPM: int\nAM_STR: int\nPM_STR: int\n\nDAY_1: int\nDAY_2: int\nDAY_3: int\nDAY_4: int\nDAY_5: int\nDAY_6: int\nDAY_7: int\nABDAY_1: int\nABDAY_2: int\nABDAY_3: int\nABDAY_4: int\nABDAY_5: int\nABDAY_6: int\nABDAY_7: int\n\nMON_1: int\nMON_2: int\nMON_3: int\nMON_4: int\nMON_5: int\nMON_6: int\nMON_7: int\nMON_8: int\nMON_9: int\nMON_10: int\nMON_11: int\nMON_12: int\nABMON_1: int\nABMON_2: int\nABMON_3: int\nABMON_4: int\nABMON_5: int\nABMON_6: int\nABMON_7: int\nABMON_8: int\nABMON_9: int\nABMON_10: int\nABMON_11: int\nABMON_12: int\n\nRADIXCHAR: int\nTHOUSEP: int\nYESEXPR: int\nNOEXPR: int\nCRNCYSTR: int\n\nERA: int\nERA_D_T_FMT: int\nERA_D_FMT: int\nERA_T_FMT: int\n\nALT_DIGITS: int\n\nLC_CTYPE: int\nLC_COLLATE: int\nLC_TIME: int\nLC_MONETARY: int\nLC_MESSAGES: int\nLC_NUMERIC: int\nLC_ALL: int\n\nCHAR_MAX: int\n\nclass Error(Exception): ...\n\ndef setlocale(category: int, locale: _str | Iterable[_str | None] | None = None) -> _str: ...\ndef localeconv() -> Mapping[_str, int | _str | list[int]]: ...\ndef nl_langinfo(__key: int) -> _str: ...\ndef getdefaultlocale(\n    envvars: tuple[_str, ...] = (\"LC_ALL\", \"LC_CTYPE\", \"LANG\", \"LANGUAGE\")\n) -> tuple[_str | None, _str | None]: ...\ndef getlocale(category: int = ...) -> tuple[_str | None, _str | None]: ...\ndef getpreferredencoding(do_setlocale: bool = True) -> _str: ...\ndef normalize(localename: _str) -> _str: ...\ndef resetlocale(category: int = ...) -> None: ...\ndef strcoll(__os1: _str, __os2: _str) -> int: ...\ndef strxfrm(__string: _str) -> _str: ...\ndef format(percent: _str, value: float | Decimal, grouping: bool = False, monetary: bool = False, *additional: Any) -> _str: ...\ndef format_string(f: _str, val: Any, grouping: bool = False, monetary: bool = False) -> _str: ...\ndef currency(val: float | Decimal, symbol: bool = True, grouping: bool = False, international: bool = False) -> _str: ...\ndef delocalize(string: _str) -> _str: ...\ndef atof(string: _str, func: Callable[[_str], float] = ...) -> float: ...\ndef atoi(string: _str) -> int: ...\ndef str(val: float) -> _str: ...\n\n# native gettext functions\n# https://docs.python.org/3/library/locale.html#access-to-message-catalogs\n# https://github.com/python/cpython/blob/f4c03484da59049eb62a9bf7777b963e2267d187/Modules/_localemodule.c#L626\nif sys.platform == \"linux\" or sys.platform == \"darwin\":\n    def gettext(__msg: _str) -> _str: ...\n    def dgettext(__domain: _str | None, __msg: _str) -> _str: ...\n    def dcgettext(__domain: _str | None, __msg: _str, __category: int) -> _str: ...\n    def textdomain(__domain: _str | None) -> _str: ...\n    def bindtextdomain(__domain: _str, __dir: StrPath | None) -> _str: ...\n    def bind_textdomain_codeset(__domain: _str, __codeset: _str | None) -> _str | None: ...\n\nif sys.version_info >= (3, 11):\n    def getencoding() -> _str: ...\n\nlocale_alias: dict[_str, _str]  # undocumented\nlocale_encoding_alias: dict[_str, _str]  # undocumented\nwindows_locale: dict[int, _str]  # undocumented\n",
  "/typeshed/stdlib/lzma.pyi": "import io\nfrom _typeshed import ReadableBuffer, StrOrBytesPath\nfrom collections.abc import Mapping, Sequence\nfrom typing import IO, Any, TextIO, overload\nfrom typing_extensions import Literal, Self, TypeAlias, final\n\n__all__ = [\n    \"CHECK_NONE\",\n    \"CHECK_CRC32\",\n    \"CHECK_CRC64\",\n    \"CHECK_SHA256\",\n    \"CHECK_ID_MAX\",\n    \"CHECK_UNKNOWN\",\n    \"FILTER_LZMA1\",\n    \"FILTER_LZMA2\",\n    \"FILTER_DELTA\",\n    \"FILTER_X86\",\n    \"FILTER_IA64\",\n    \"FILTER_ARM\",\n    \"FILTER_ARMTHUMB\",\n    \"FILTER_POWERPC\",\n    \"FILTER_SPARC\",\n    \"FORMAT_AUTO\",\n    \"FORMAT_XZ\",\n    \"FORMAT_ALONE\",\n    \"FORMAT_RAW\",\n    \"MF_HC3\",\n    \"MF_HC4\",\n    \"MF_BT2\",\n    \"MF_BT3\",\n    \"MF_BT4\",\n    \"MODE_FAST\",\n    \"MODE_NORMAL\",\n    \"PRESET_DEFAULT\",\n    \"PRESET_EXTREME\",\n    \"LZMACompressor\",\n    \"LZMADecompressor\",\n    \"LZMAFile\",\n    \"LZMAError\",\n    \"open\",\n    \"compress\",\n    \"decompress\",\n    \"is_check_supported\",\n]\n\n_OpenBinaryWritingMode: TypeAlias = Literal[\"w\", \"wb\", \"x\", \"xb\", \"a\", \"ab\"]\n_OpenTextWritingMode: TypeAlias = Literal[\"wt\", \"xt\", \"at\"]\n\n_PathOrFile: TypeAlias = StrOrBytesPath | IO[bytes]\n\n_FilterChain: TypeAlias = Sequence[Mapping[str, Any]]\n\nFORMAT_AUTO: Literal[0]\nFORMAT_XZ: Literal[1]\nFORMAT_ALONE: Literal[2]\nFORMAT_RAW: Literal[3]\nCHECK_NONE: Literal[0]\nCHECK_CRC32: Literal[1]\nCHECK_CRC64: Literal[4]\nCHECK_SHA256: Literal[10]\nCHECK_ID_MAX: Literal[15]\nCHECK_UNKNOWN: Literal[16]\nFILTER_LZMA1: int  # v big number\nFILTER_LZMA2: Literal[33]\nFILTER_DELTA: Literal[3]\nFILTER_X86: Literal[4]\nFILTER_IA64: Literal[6]\nFILTER_ARM: Literal[7]\nFILTER_ARMTHUMB: Literal[8]\nFILTER_SPARC: Literal[9]\nFILTER_POWERPC: Literal[5]\nMF_HC3: Literal[3]\nMF_HC4: Literal[4]\nMF_BT2: Literal[18]\nMF_BT3: Literal[19]\nMF_BT4: Literal[20]\nMODE_FAST: Literal[1]\nMODE_NORMAL: Literal[2]\nPRESET_DEFAULT: Literal[6]\nPRESET_EXTREME: int  # v big number\n\n# from _lzma.c\n@final\nclass LZMADecompressor:\n    def __init__(self, format: int | None = ..., memlimit: int | None = ..., filters: _FilterChain | None = ...) -> None: ...\n    def decompress(self, data: ReadableBuffer, max_length: int = -1) -> bytes: ...\n    @property\n    def check(self) -> int: ...\n    @property\n    def eof(self) -> bool: ...\n    @property\n    def unused_data(self) -> bytes: ...\n    @property\n    def needs_input(self) -> bool: ...\n\n# from _lzma.c\n@final\nclass LZMACompressor:\n    def __init__(\n        self, format: int | None = ..., check: int = ..., preset: int | None = ..., filters: _FilterChain | None = ...\n    ) -> None: ...\n    def compress(self, __data: ReadableBuffer) -> bytes: ...\n    def flush(self) -> bytes: ...\n\nclass LZMAError(Exception): ...\n\nclass LZMAFile(io.BufferedIOBase, IO[bytes]):  # type: ignore[misc]  # incompatible definitions of writelines in the base classes\n    def __init__(\n        self,\n        filename: _PathOrFile | None = None,\n        mode: str = \"r\",\n        *,\n        format: int | None = None,\n        check: int = -1,\n        preset: int | None = None,\n        filters: _FilterChain | None = None,\n    ) -> None: ...\n    def __enter__(self) -> Self: ...\n    def peek(self, size: int = -1) -> bytes: ...\n    def read(self, size: int | None = -1) -> bytes: ...\n    def read1(self, size: int = -1) -> bytes: ...\n    def readline(self, size: int | None = -1) -> bytes: ...\n    def write(self, data: ReadableBuffer) -> int: ...\n    def seek(self, offset: int, whence: int = 0) -> int: ...\n\n@overload\ndef open(\n    filename: _PathOrFile,\n    mode: Literal[\"r\", \"rb\"] = \"rb\",\n    *,\n    format: int | None = None,\n    check: Literal[-1] = -1,\n    preset: None = None,\n    filters: _FilterChain | None = None,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> LZMAFile: ...\n@overload\ndef open(\n    filename: _PathOrFile,\n    mode: _OpenBinaryWritingMode,\n    *,\n    format: int | None = None,\n    check: int = -1,\n    preset: int | None = None,\n    filters: _FilterChain | None = None,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n) -> LZMAFile: ...\n@overload\ndef open(\n    filename: StrOrBytesPath,\n    mode: Literal[\"rt\"],\n    *,\n    format: int | None = None,\n    check: Literal[-1] = -1,\n    preset: None = None,\n    filters: _FilterChain | None = None,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: StrOrBytesPath,\n    mode: _OpenTextWritingMode,\n    *,\n    format: int | None = None,\n    check: int = -1,\n    preset: int | None = None,\n    filters: _FilterChain | None = None,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> TextIO: ...\n@overload\ndef open(\n    filename: _PathOrFile,\n    mode: str,\n    *,\n    format: int | None = None,\n    check: int = -1,\n    preset: int | None = None,\n    filters: _FilterChain | None = None,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n) -> LZMAFile | TextIO: ...\ndef compress(\n    data: ReadableBuffer, format: int = 1, check: int = -1, preset: int | None = None, filters: _FilterChain | None = None\n) -> bytes: ...\ndef decompress(\n    data: ReadableBuffer, format: int = 0, memlimit: int | None = None, filters: _FilterChain | None = None\n) -> bytes: ...\ndef is_check_supported(__check_id: int) -> bool: ...\n",
  "/typeshed/stdlib/mailbox.pyi": "import email.message\nimport io\nimport sys\nfrom _typeshed import StrPath, SupportsNoArgReadline, SupportsRead\nfrom abc import ABCMeta, abstractmethod\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, Sequence\nfrom types import TracebackType\nfrom typing import IO, Any, AnyStr, Generic, Protocol, TypeVar, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"Mailbox\",\n    \"Maildir\",\n    \"mbox\",\n    \"MH\",\n    \"Babyl\",\n    \"MMDF\",\n    \"Message\",\n    \"MaildirMessage\",\n    \"mboxMessage\",\n    \"MHMessage\",\n    \"BabylMessage\",\n    \"MMDFMessage\",\n    \"Error\",\n    \"NoSuchMailboxError\",\n    \"NotEmptyError\",\n    \"ExternalClashError\",\n    \"FormatError\",\n]\n\n_T = TypeVar(\"_T\")\n_MessageT = TypeVar(\"_MessageT\", bound=Message)\n\nclass _SupportsReadAndReadline(SupportsRead[bytes], SupportsNoArgReadline[bytes], Protocol): ...\n\n_MessageData: TypeAlias = email.message.Message | bytes | str | io.StringIO | _SupportsReadAndReadline\n\nclass _HasIteritems(Protocol):\n    def iteritems(self) -> Iterator[tuple[str, _MessageData]]: ...\n\nclass _HasItems(Protocol):\n    def items(self) -> Iterator[tuple[str, _MessageData]]: ...\n\nlinesep: bytes\n\nclass Mailbox(Generic[_MessageT]):\n    _path: str  # undocumented\n    _factory: Callable[[IO[Any]], _MessageT] | None  # undocumented\n    @overload\n    def __init__(self, path: StrPath, factory: Callable[[IO[Any]], _MessageT], create: bool = True) -> None: ...\n    @overload\n    def __init__(self, path: StrPath, factory: None = None, create: bool = True) -> None: ...\n    @abstractmethod\n    def add(self, message: _MessageData) -> str: ...\n    @abstractmethod\n    def remove(self, key: str) -> None: ...\n    def __delitem__(self, key: str) -> None: ...\n    def discard(self, key: str) -> None: ...\n    @abstractmethod\n    def __setitem__(self, key: str, message: _MessageData) -> None: ...\n    @overload\n    def get(self, key: str, default: None = None) -> _MessageT | None: ...\n    @overload\n    def get(self, key: str, default: _T) -> _MessageT | _T: ...\n    def __getitem__(self, key: str) -> _MessageT: ...\n    @abstractmethod\n    def get_message(self, key: str) -> _MessageT: ...\n    def get_string(self, key: str) -> str: ...\n    @abstractmethod\n    def get_bytes(self, key: str) -> bytes: ...\n    # As '_ProxyFile' doesn't implement the full IO spec, and BytesIO is incompatible with it, get_file return is Any here\n    @abstractmethod\n    def get_file(self, key: str) -> Any: ...\n    @abstractmethod\n    def iterkeys(self) -> Iterator[str]: ...\n    def keys(self) -> list[str]: ...\n    def itervalues(self) -> Iterator[_MessageT]: ...\n    def __iter__(self) -> Iterator[_MessageT]: ...\n    def values(self) -> list[_MessageT]: ...\n    def iteritems(self) -> Iterator[tuple[str, _MessageT]]: ...\n    def items(self) -> list[tuple[str, _MessageT]]: ...\n    @abstractmethod\n    def __contains__(self, key: str) -> bool: ...\n    @abstractmethod\n    def __len__(self) -> int: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: str, default: None = None) -> _MessageT | None: ...\n    @overload\n    def pop(self, key: str, default: _T) -> _MessageT | _T: ...\n    def popitem(self) -> tuple[str, _MessageT]: ...\n    def update(self, arg: _HasIteritems | _HasItems | Iterable[tuple[str, _MessageData]] | None = None) -> None: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def lock(self) -> None: ...\n    @abstractmethod\n    def unlock(self) -> None: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Maildir(Mailbox[MaildirMessage]):\n    colon: str\n    def __init__(\n        self, dirname: StrPath, factory: Callable[[IO[Any]], MaildirMessage] | None = None, create: bool = True\n    ) -> None: ...\n    def add(self, message: _MessageData) -> str: ...\n    def remove(self, key: str) -> None: ...\n    def __setitem__(self, key: str, message: _MessageData) -> None: ...\n    def get_message(self, key: str) -> MaildirMessage: ...\n    def get_bytes(self, key: str) -> bytes: ...\n    def get_file(self, key: str) -> _ProxyFile[bytes]: ...\n    def iterkeys(self) -> Iterator[str]: ...\n    def __contains__(self, key: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def flush(self) -> None: ...\n    def lock(self) -> None: ...\n    def unlock(self) -> None: ...\n    def close(self) -> None: ...\n    def list_folders(self) -> list[str]: ...\n    def get_folder(self, folder: str) -> Maildir: ...\n    def add_folder(self, folder: str) -> Maildir: ...\n    def remove_folder(self, folder: str) -> None: ...\n    def clean(self) -> None: ...\n    def next(self) -> str | None: ...\n\nclass _singlefileMailbox(Mailbox[_MessageT], metaclass=ABCMeta):\n    def add(self, message: _MessageData) -> str: ...\n    def remove(self, key: str) -> None: ...\n    def __setitem__(self, key: str, message: _MessageData) -> None: ...\n    def iterkeys(self) -> Iterator[str]: ...\n    def __contains__(self, key: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def lock(self) -> None: ...\n    def unlock(self) -> None: ...\n    def flush(self) -> None: ...\n    def close(self) -> None: ...\n\nclass _mboxMMDF(_singlefileMailbox[_MessageT]):\n    def get_message(self, key: str) -> _MessageT: ...\n    def get_file(self, key: str, from_: bool = False) -> _PartialFile[bytes]: ...\n    def get_bytes(self, key: str, from_: bool = False) -> bytes: ...\n    def get_string(self, key: str, from_: bool = False) -> str: ...\n\nclass mbox(_mboxMMDF[mboxMessage]):\n    def __init__(self, path: StrPath, factory: Callable[[IO[Any]], mboxMessage] | None = None, create: bool = True) -> None: ...\n\nclass MMDF(_mboxMMDF[MMDFMessage]):\n    def __init__(self, path: StrPath, factory: Callable[[IO[Any]], MMDFMessage] | None = None, create: bool = True) -> None: ...\n\nclass MH(Mailbox[MHMessage]):\n    def __init__(self, path: StrPath, factory: Callable[[IO[Any]], MHMessage] | None = None, create: bool = True) -> None: ...\n    def add(self, message: _MessageData) -> str: ...\n    def remove(self, key: str) -> None: ...\n    def __setitem__(self, key: str, message: _MessageData) -> None: ...\n    def get_message(self, key: str) -> MHMessage: ...\n    def get_bytes(self, key: str) -> bytes: ...\n    def get_file(self, key: str) -> _ProxyFile[bytes]: ...\n    def iterkeys(self) -> Iterator[str]: ...\n    def __contains__(self, key: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def flush(self) -> None: ...\n    def lock(self) -> None: ...\n    def unlock(self) -> None: ...\n    def close(self) -> None: ...\n    def list_folders(self) -> list[str]: ...\n    def get_folder(self, folder: StrPath) -> MH: ...\n    def add_folder(self, folder: StrPath) -> MH: ...\n    def remove_folder(self, folder: StrPath) -> None: ...\n    def get_sequences(self) -> dict[str, list[int]]: ...\n    def set_sequences(self, sequences: Mapping[str, Sequence[int]]) -> None: ...\n    def pack(self) -> None: ...\n\nclass Babyl(_singlefileMailbox[BabylMessage]):\n    def __init__(self, path: StrPath, factory: Callable[[IO[Any]], BabylMessage] | None = None, create: bool = True) -> None: ...\n    def get_message(self, key: str) -> BabylMessage: ...\n    def get_bytes(self, key: str) -> bytes: ...\n    def get_file(self, key: str) -> IO[bytes]: ...\n    def get_labels(self) -> list[str]: ...\n\nclass Message(email.message.Message):\n    def __init__(self, message: _MessageData | None = None) -> None: ...\n\nclass MaildirMessage(Message):\n    def get_subdir(self) -> str: ...\n    def set_subdir(self, subdir: Literal[\"new\", \"cur\"]) -> None: ...\n    def get_flags(self) -> str: ...\n    def set_flags(self, flags: Iterable[str]) -> None: ...\n    def add_flag(self, flag: str) -> None: ...\n    def remove_flag(self, flag: str) -> None: ...\n    def get_date(self) -> int: ...\n    def set_date(self, date: float) -> None: ...\n    def get_info(self) -> str: ...\n    def set_info(self, info: str) -> None: ...\n\nclass _mboxMMDFMessage(Message):\n    def get_from(self) -> str: ...\n    def set_from(self, from_: str, time_: bool | tuple[int, int, int, int, int, int, int, int, int] | None = None) -> None: ...\n    def get_flags(self) -> str: ...\n    def set_flags(self, flags: Iterable[str]) -> None: ...\n    def add_flag(self, flag: str) -> None: ...\n    def remove_flag(self, flag: str) -> None: ...\n\nclass mboxMessage(_mboxMMDFMessage): ...\n\nclass MHMessage(Message):\n    def get_sequences(self) -> list[str]: ...\n    def set_sequences(self, sequences: Iterable[str]) -> None: ...\n    def add_sequence(self, sequence: str) -> None: ...\n    def remove_sequence(self, sequence: str) -> None: ...\n\nclass BabylMessage(Message):\n    def get_labels(self) -> list[str]: ...\n    def set_labels(self, labels: Iterable[str]) -> None: ...\n    def add_label(self, label: str) -> None: ...\n    def remove_label(self, label: str) -> None: ...\n    def get_visible(self) -> Message: ...\n    def set_visible(self, visible: _MessageData) -> None: ...\n    def update_visible(self) -> None: ...\n\nclass MMDFMessage(_mboxMMDFMessage): ...\n\nclass _ProxyFile(Generic[AnyStr]):\n    def __init__(self, f: IO[AnyStr], pos: int | None = None) -> None: ...\n    def read(self, size: int | None = None) -> AnyStr: ...\n    def read1(self, size: int | None = None) -> AnyStr: ...\n    def readline(self, size: int | None = None) -> AnyStr: ...\n    def readlines(self, sizehint: int | None = None) -> list[AnyStr]: ...\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    def tell(self) -> int: ...\n    def seek(self, offset: int, whence: int = 0) -> None: ...\n    def close(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None) -> None: ...\n    def readable(self) -> bool: ...\n    def writable(self) -> bool: ...\n    def seekable(self) -> bool: ...\n    def flush(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass _PartialFile(_ProxyFile[AnyStr]):\n    def __init__(self, f: IO[AnyStr], start: int | None = None, stop: int | None = None) -> None: ...\n\nclass Error(Exception): ...\nclass NoSuchMailboxError(Error): ...\nclass NotEmptyError(Error): ...\nclass ExternalClashError(Error): ...\nclass FormatError(Error): ...\n",
  "/typeshed/stdlib/mailcap.pyi": "from collections.abc import Mapping, Sequence\nfrom typing_extensions import TypeAlias\n\n_Cap: TypeAlias = dict[str, str | int]\n\n__all__ = [\"getcaps\", \"findmatch\"]\n\ndef findmatch(\n    caps: Mapping[str, list[_Cap]], MIMEtype: str, key: str = \"view\", filename: str = \"/dev/null\", plist: Sequence[str] = []\n) -> tuple[str | None, _Cap | None]: ...\ndef getcaps() -> dict[str, list[_Cap]]: ...\n",
  "/typeshed/stdlib/marshal.pyi": "import builtins\nimport types\nfrom _typeshed import ReadableBuffer, SupportsRead, SupportsWrite\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\nversion: int\n\n_Marshallable: TypeAlias = (\n    # handled in w_object() in marshal.c\n    None\n    | type[StopIteration]\n    | builtins.ellipsis\n    | bool\n    # handled in w_complex_object() in marshal.c\n    | int\n    | float\n    | complex\n    | bytes\n    | str\n    | tuple[_Marshallable, ...]\n    | list[Any]\n    | dict[Any, Any]\n    | set[Any]\n    | frozenset[_Marshallable]\n    | types.CodeType\n    | ReadableBuffer\n)\n\ndef dump(__value: _Marshallable, __file: SupportsWrite[bytes], __version: int = 4) -> None: ...\ndef load(__file: SupportsRead[bytes]) -> Any: ...\ndef dumps(__value: _Marshallable, __version: int = 4) -> bytes: ...\ndef loads(__bytes: ReadableBuffer) -> Any: ...\n",
  "/typeshed/stdlib/math.pyi": "import sys\nfrom collections.abc import Iterable\nfrom typing import Protocol, SupportsFloat, TypeVar, overload\nfrom typing_extensions import SupportsIndex, TypeAlias\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n\nif sys.version_info >= (3, 8):\n    _SupportsFloatOrIndex: TypeAlias = SupportsFloat | SupportsIndex\nelse:\n    _SupportsFloatOrIndex: TypeAlias = SupportsFloat\n\ne: float\npi: float\ninf: float\nnan: float\ntau: float\n\ndef acos(__x: _SupportsFloatOrIndex) -> float: ...\ndef acosh(__x: _SupportsFloatOrIndex) -> float: ...\ndef asin(__x: _SupportsFloatOrIndex) -> float: ...\ndef asinh(__x: _SupportsFloatOrIndex) -> float: ...\ndef atan(__x: _SupportsFloatOrIndex) -> float: ...\ndef atan2(__y: _SupportsFloatOrIndex, __x: _SupportsFloatOrIndex) -> float: ...\ndef atanh(__x: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 11):\n    def cbrt(__x: _SupportsFloatOrIndex) -> float: ...\n\nclass _SupportsCeil(Protocol[_T_co]):\n    def __ceil__(self) -> _T_co: ...\n\n@overload\ndef ceil(__x: _SupportsCeil[_T]) -> _T: ...\n@overload\ndef ceil(__x: _SupportsFloatOrIndex) -> int: ...\n\nif sys.version_info >= (3, 8):\n    def comb(__n: SupportsIndex, __k: SupportsIndex) -> int: ...\n\ndef copysign(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\ndef cos(__x: _SupportsFloatOrIndex) -> float: ...\ndef cosh(__x: _SupportsFloatOrIndex) -> float: ...\ndef degrees(__x: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 8):\n    def dist(__p: Iterable[_SupportsFloatOrIndex], __q: Iterable[_SupportsFloatOrIndex]) -> float: ...\n\ndef erf(__x: _SupportsFloatOrIndex) -> float: ...\ndef erfc(__x: _SupportsFloatOrIndex) -> float: ...\ndef exp(__x: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 11):\n    def exp2(__x: _SupportsFloatOrIndex) -> float: ...\n\ndef expm1(__x: _SupportsFloatOrIndex) -> float: ...\ndef fabs(__x: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 8):\n    def factorial(__x: SupportsIndex) -> int: ...\n\nelse:\n    def factorial(__x: int) -> int: ...\n\nclass _SupportsFloor(Protocol[_T_co]):\n    def __floor__(self) -> _T_co: ...\n\n@overload\ndef floor(__x: _SupportsFloor[_T]) -> _T: ...\n@overload\ndef floor(__x: _SupportsFloatOrIndex) -> int: ...\ndef fmod(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\ndef frexp(__x: _SupportsFloatOrIndex) -> tuple[float, int]: ...\ndef fsum(__seq: Iterable[_SupportsFloatOrIndex]) -> float: ...\ndef gamma(__x: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 9):\n    def gcd(*integers: SupportsIndex) -> int: ...\n\nelse:\n    def gcd(__x: SupportsIndex, __y: SupportsIndex) -> int: ...\n\nif sys.version_info >= (3, 8):\n    def hypot(*coordinates: _SupportsFloatOrIndex) -> float: ...\n\nelse:\n    def hypot(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\n\ndef isclose(\n    a: _SupportsFloatOrIndex,\n    b: _SupportsFloatOrIndex,\n    *,\n    rel_tol: _SupportsFloatOrIndex = 1e-09,\n    abs_tol: _SupportsFloatOrIndex = 0.0,\n) -> bool: ...\ndef isinf(__x: _SupportsFloatOrIndex) -> bool: ...\ndef isfinite(__x: _SupportsFloatOrIndex) -> bool: ...\ndef isnan(__x: _SupportsFloatOrIndex) -> bool: ...\n\nif sys.version_info >= (3, 8):\n    def isqrt(__n: SupportsIndex) -> int: ...\n\nif sys.version_info >= (3, 9):\n    def lcm(*integers: SupportsIndex) -> int: ...\n\ndef ldexp(__x: _SupportsFloatOrIndex, __i: int) -> float: ...\ndef lgamma(__x: _SupportsFloatOrIndex) -> float: ...\ndef log(x: _SupportsFloatOrIndex, base: _SupportsFloatOrIndex = ...) -> float: ...\ndef log10(__x: _SupportsFloatOrIndex) -> float: ...\ndef log1p(__x: _SupportsFloatOrIndex) -> float: ...\ndef log2(__x: _SupportsFloatOrIndex) -> float: ...\ndef modf(__x: _SupportsFloatOrIndex) -> tuple[float, float]: ...\n\nif sys.version_info >= (3, 9):\n    def nextafter(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 8):\n    def perm(__n: SupportsIndex, __k: SupportsIndex | None = None) -> int: ...\n\ndef pow(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def prod(__iterable: Iterable[SupportsIndex], *, start: SupportsIndex = 1) -> int: ...  # type: ignore[misc]\n    @overload\n    def prod(__iterable: Iterable[_SupportsFloatOrIndex], *, start: _SupportsFloatOrIndex = 1) -> float: ...\n\ndef radians(__x: _SupportsFloatOrIndex) -> float: ...\ndef remainder(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...\ndef sin(__x: _SupportsFloatOrIndex) -> float: ...\ndef sinh(__x: _SupportsFloatOrIndex) -> float: ...\ndef sqrt(__x: _SupportsFloatOrIndex) -> float: ...\ndef tan(__x: _SupportsFloatOrIndex) -> float: ...\ndef tanh(__x: _SupportsFloatOrIndex) -> float: ...\n\n# Is different from `_typeshed.SupportsTrunc`, which is not generic\nclass _SupportsTrunc(Protocol[_T_co]):\n    def __trunc__(self) -> _T_co: ...\n\ndef trunc(__x: _SupportsTrunc[_T]) -> _T: ...\n\nif sys.version_info >= (3, 9):\n    def ulp(__x: _SupportsFloatOrIndex) -> float: ...\n",
  "/typeshed/stdlib/mimetypes.pyi": "import sys\nfrom _typeshed import StrPath\nfrom collections.abc import Sequence\nfrom typing import IO\n\n__all__ = [\n    \"knownfiles\",\n    \"inited\",\n    \"MimeTypes\",\n    \"guess_type\",\n    \"guess_all_extensions\",\n    \"guess_extension\",\n    \"add_type\",\n    \"init\",\n    \"read_mime_types\",\n    \"suffix_map\",\n    \"encodings_map\",\n    \"types_map\",\n    \"common_types\",\n]\n\nif sys.version_info >= (3, 8):\n    def guess_type(url: StrPath, strict: bool = True) -> tuple[str | None, str | None]: ...\n\nelse:\n    def guess_type(url: str, strict: bool = True) -> tuple[str | None, str | None]: ...\n\ndef guess_all_extensions(type: str, strict: bool = True) -> list[str]: ...\ndef guess_extension(type: str, strict: bool = True) -> str | None: ...\ndef init(files: Sequence[str] | None = None) -> None: ...\ndef read_mime_types(file: str) -> dict[str, str] | None: ...\ndef add_type(type: str, ext: str, strict: bool = True) -> None: ...\n\ninited: bool\nknownfiles: list[str]\nsuffix_map: dict[str, str]\nencodings_map: dict[str, str]\ntypes_map: dict[str, str]\ncommon_types: dict[str, str]\n\nclass MimeTypes:\n    suffix_map: dict[str, str]\n    encodings_map: dict[str, str]\n    types_map: tuple[dict[str, str], dict[str, str]]\n    types_map_inv: tuple[dict[str, str], dict[str, str]]\n    def __init__(self, filenames: tuple[str, ...] = (), strict: bool = True) -> None: ...\n    def guess_extension(self, type: str, strict: bool = True) -> str | None: ...\n    if sys.version_info >= (3, 8):\n        def guess_type(self, url: StrPath, strict: bool = True) -> tuple[str | None, str | None]: ...\n    else:\n        def guess_type(self, url: str, strict: bool = True) -> tuple[str | None, str | None]: ...\n\n    def guess_all_extensions(self, type: str, strict: bool = True) -> list[str]: ...\n    def read(self, filename: str, strict: bool = True) -> None: ...\n    def readfp(self, fp: IO[str], strict: bool = True) -> None: ...\n    if sys.platform == \"win32\":\n        def read_windows_registry(self, strict: bool = True) -> None: ...\n",
  "/typeshed/stdlib/mmap.pyi": "import sys\nfrom _typeshed import ReadableBuffer, Unused\nfrom collections.abc import Iterable, Iterator, Sized\nfrom typing import NoReturn, overload\nfrom typing_extensions import Self\n\nACCESS_DEFAULT: int\nACCESS_READ: int\nACCESS_WRITE: int\nACCESS_COPY: int\n\nALLOCATIONGRANULARITY: int\n\nif sys.platform == \"linux\":\n    MAP_DENYWRITE: int\n    MAP_EXECUTABLE: int\n    if sys.version_info >= (3, 10):\n        MAP_POPULATE: int\n\nif sys.platform != \"win32\":\n    MAP_ANON: int\n    MAP_ANONYMOUS: int\n    MAP_PRIVATE: int\n    MAP_SHARED: int\n    PROT_EXEC: int\n    PROT_READ: int\n    PROT_WRITE: int\n\n    PAGESIZE: int\n\nclass mmap(Iterable[int], Sized):\n    if sys.platform == \"win32\":\n        def __init__(self, fileno: int, length: int, tagname: str | None = ..., access: int = ..., offset: int = ...) -> None: ...\n    else:\n        def __init__(\n            self, fileno: int, length: int, flags: int = ..., prot: int = ..., access: int = ..., offset: int = ...\n        ) -> None: ...\n\n    def close(self) -> None: ...\n    if sys.version_info >= (3, 8):\n        def flush(self, offset: int = ..., size: int = ...) -> None: ...\n    else:\n        def flush(self, offset: int = ..., size: int = ...) -> int: ...\n\n    def move(self, dest: int, src: int, count: int) -> None: ...\n    def read_byte(self) -> int: ...\n    def readline(self) -> bytes: ...\n    def resize(self, newsize: int) -> None: ...\n    def seek(self, pos: int, whence: int = ...) -> None: ...\n    def size(self) -> int: ...\n    def tell(self) -> int: ...\n    def write_byte(self, byte: int) -> None: ...\n    def __len__(self) -> int: ...\n    closed: bool\n    if sys.version_info >= (3, 8) and sys.platform != \"win32\":\n        def madvise(self, option: int, start: int = ..., length: int = ...) -> None: ...\n\n    def find(self, sub: ReadableBuffer, start: int = ..., stop: int = ...) -> int: ...\n    def rfind(self, sub: ReadableBuffer, start: int = ..., stop: int = ...) -> int: ...\n    def read(self, n: int | None = ...) -> bytes: ...\n    def write(self, bytes: ReadableBuffer) -> int: ...\n    @overload\n    def __getitem__(self, __key: int) -> int: ...\n    @overload\n    def __getitem__(self, __key: slice) -> bytes: ...\n    def __delitem__(self, __key: int | slice) -> NoReturn: ...\n    @overload\n    def __setitem__(self, __key: int, __value: int) -> None: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: ReadableBuffer) -> None: ...\n    # Doesn't actually exist, but the object actually supports \"in\" because it has __getitem__,\n    # so we claim that there is also a __contains__ to help type checkers.\n    def __contains__(self, __o: object) -> bool: ...\n    # Doesn't actually exist, but the object is actually iterable because it has __getitem__ and __len__,\n    # so we claim that there is also an __iter__ to help type checkers.\n    def __iter__(self) -> Iterator[int]: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n\nif sys.version_info >= (3, 8) and sys.platform != \"win32\":\n    MADV_NORMAL: int\n    MADV_RANDOM: int\n    MADV_SEQUENTIAL: int\n    MADV_WILLNEED: int\n    MADV_DONTNEED: int\n    MADV_FREE: int\n\n    if sys.platform == \"linux\":\n        MADV_REMOVE: int\n        MADV_DONTFORK: int\n        MADV_DOFORK: int\n        MADV_HWPOISON: int\n        MADV_MERGEABLE: int\n        MADV_UNMERGEABLE: int\n        # Seems like this constant is not defined in glibc.\n        # See https://github.com/python/typeshed/pull/5360 for details\n        # MADV_SOFT_OFFLINE: int\n        MADV_HUGEPAGE: int\n        MADV_NOHUGEPAGE: int\n        MADV_DONTDUMP: int\n        MADV_DODUMP: int\n\n    # This Values are defined for FreeBSD but type checkers do not support conditions for these\n    if sys.platform != \"linux\" and sys.platform != \"darwin\":\n        MADV_NOSYNC: int\n        MADV_AUTOSYNC: int\n        MADV_NOCORE: int\n        MADV_CORE: int\n        MADV_PROTECT: int\n\nif sys.version_info >= (3, 10) and sys.platform == \"darwin\":\n    MADV_FREE_REUSABLE: int\n    MADV_FREE_REUSE: int\n",
  "/typeshed/stdlib/modulefinder.pyi": "import sys\nfrom collections.abc import Container, Iterable, Iterator, Sequence\nfrom types import CodeType\nfrom typing import IO, Any\n\nif sys.version_info < (3, 11):\n    LOAD_CONST: int  # undocumented\n    IMPORT_NAME: int  # undocumented\n    STORE_NAME: int  # undocumented\n    STORE_GLOBAL: int  # undocumented\n    STORE_OPS: tuple[int, int]  # undocumented\n    EXTENDED_ARG: int  # undocumented\n\npackagePathMap: dict[str, list[str]]  # undocumented\n\ndef AddPackagePath(packagename: str, path: str) -> None: ...\n\nreplacePackageMap: dict[str, str]  # undocumented\n\ndef ReplacePackage(oldname: str, newname: str) -> None: ...\n\nclass Module:  # undocumented\n    def __init__(self, name: str, file: str | None = None, path: str | None = None) -> None: ...\n\nclass ModuleFinder:\n    modules: dict[str, Module]\n    path: list[str]  # undocumented\n    badmodules: dict[str, dict[str, int]]  # undocumented\n    debug: int  # undocumented\n    indent: int  # undocumented\n    excludes: Container[str]  # undocumented\n    replace_paths: Sequence[tuple[str, str]]  # undocumented\n\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            path: list[str] | None = None,\n            debug: int = 0,\n            excludes: Container[str] | None = None,\n            replace_paths: Sequence[tuple[str, str]] | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            path: list[str] | None = None,\n            debug: int = 0,\n            excludes: Container[str] = [],\n            replace_paths: Sequence[tuple[str, str]] = [],\n        ) -> None: ...\n\n    def msg(self, level: int, str: str, *args: Any) -> None: ...  # undocumented\n    def msgin(self, *args: Any) -> None: ...  # undocumented\n    def msgout(self, *args: Any) -> None: ...  # undocumented\n    def run_script(self, pathname: str) -> None: ...\n    def load_file(self, pathname: str) -> None: ...  # undocumented\n    def import_hook(\n        self, name: str, caller: Module | None = None, fromlist: list[str] | None = None, level: int = -1\n    ) -> Module | None: ...  # undocumented\n    def determine_parent(self, caller: Module | None, level: int = -1) -> Module | None: ...  # undocumented\n    def find_head_package(self, parent: Module, name: str) -> tuple[Module, str]: ...  # undocumented\n    def load_tail(self, q: Module, tail: str) -> Module: ...  # undocumented\n    def ensure_fromlist(self, m: Module, fromlist: Iterable[str], recursive: int = 0) -> None: ...  # undocumented\n    def find_all_submodules(self, m: Module) -> Iterable[str]: ...  # undocumented\n    def import_module(self, partname: str, fqname: str, parent: Module) -> Module | None: ...  # undocumented\n    def load_module(self, fqname: str, fp: IO[str], pathname: str, file_info: tuple[str, str, str]) -> Module: ...  # undocumented\n    def scan_opcodes(self, co: CodeType) -> Iterator[tuple[str, tuple[Any, ...]]]: ...  # undocumented\n    def scan_code(self, co: CodeType, m: Module) -> None: ...  # undocumented\n    def load_package(self, fqname: str, pathname: str) -> Module: ...  # undocumented\n    def add_module(self, fqname: str) -> Module: ...  # undocumented\n    def find_module(\n        self, name: str, path: str | None, parent: Module | None = None\n    ) -> tuple[IO[Any] | None, str | None, tuple[str, str, int]]: ...  # undocumented\n    def report(self) -> None: ...\n    def any_missing(self) -> list[str]: ...  # undocumented\n    def any_missing_maybe(self) -> tuple[list[str], list[str]]: ...  # undocumented\n    def replace_paths_in_code(self, co: CodeType) -> CodeType: ...  # undocumented\n",
  "/typeshed/stdlib/msvcrt.pyi": "import sys\nfrom typing_extensions import Literal\n\n# This module is only available on Windows\nif sys.platform == \"win32\":\n    LK_UNLCK: Literal[0]\n    LK_LOCK: Literal[1]\n    LK_NBLCK: Literal[2]\n    LK_RLCK: Literal[3]\n    LK_NBRLCK: Literal[4]\n    SEM_FAILCRITICALERRORS: int\n    SEM_NOALIGNMENTFAULTEXCEPT: int\n    SEM_NOGPFAULTERRORBOX: int\n    SEM_NOOPENFILEERRORBOX: int\n    def locking(__fd: int, __mode: int, __nbytes: int) -> None: ...\n    def setmode(__fd: int, __mode: int) -> int: ...\n    def open_osfhandle(__handle: int, __flags: int) -> int: ...\n    def get_osfhandle(__fd: int) -> int: ...\n    def kbhit() -> bool: ...\n    def getch() -> bytes: ...\n    def getwch() -> str: ...\n    def getche() -> bytes: ...\n    def getwche() -> str: ...\n    def putch(__char: bytes | bytearray) -> None: ...\n    def putwch(__unicode_char: str) -> None: ...\n    def ungetch(__char: bytes | bytearray) -> None: ...\n    def ungetwch(__unicode_char: str) -> None: ...\n    def heapmin() -> None: ...\n",
  "/typeshed/stdlib/netrc.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"netrc\", \"NetrcParseError\"]\n\nclass NetrcParseError(Exception):\n    filename: str | None\n    lineno: int | None\n    msg: str\n    def __init__(self, msg: str, filename: StrOrBytesPath | None = None, lineno: int | None = None) -> None: ...\n\n# (login, account, password) tuple\nif sys.version_info >= (3, 11):\n    _NetrcTuple: TypeAlias = tuple[str, str, str]\nelse:\n    _NetrcTuple: TypeAlias = tuple[str, str | None, str | None]\n\nclass netrc:\n    hosts: dict[str, _NetrcTuple]\n    macros: dict[str, list[str]]\n    def __init__(self, file: StrOrBytesPath | None = None) -> None: ...\n    def authenticators(self, host: str) -> _NetrcTuple | None: ...\n",
  "/typeshed/stdlib/nis.pyi": "import sys\n\nif sys.platform != \"win32\":\n    def cat(map: str, domain: str = ...) -> dict[str, str]: ...\n    def get_default_domain() -> str: ...\n    def maps(domain: str = ...) -> list[str]: ...\n    def match(key: str, map: str, domain: str = ...) -> str: ...\n\n    class error(Exception): ...\n",
  "/typeshed/stdlib/nntplib.pyi": "import datetime\nimport socket\nimport ssl\nimport sys\nfrom _typeshed import Unused\nfrom builtins import list as _list  # conflicts with a method named \"list\"\nfrom collections.abc import Iterable\nfrom typing import IO, Any, NamedTuple\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\n    \"NNTP\",\n    \"NNTPError\",\n    \"NNTPReplyError\",\n    \"NNTPTemporaryError\",\n    \"NNTPPermanentError\",\n    \"NNTPProtocolError\",\n    \"NNTPDataError\",\n    \"decode_header\",\n    \"NNTP_SSL\",\n]\n\n_File: TypeAlias = IO[bytes] | bytes | str | None\n\nclass NNTPError(Exception):\n    response: str\n\nclass NNTPReplyError(NNTPError): ...\nclass NNTPTemporaryError(NNTPError): ...\nclass NNTPPermanentError(NNTPError): ...\nclass NNTPProtocolError(NNTPError): ...\nclass NNTPDataError(NNTPError): ...\n\nNNTP_PORT: Literal[119]\nNNTP_SSL_PORT: Literal[563]\n\nclass GroupInfo(NamedTuple):\n    group: str\n    last: str\n    first: str\n    flag: str\n\nclass ArticleInfo(NamedTuple):\n    number: int\n    message_id: str\n    lines: list[bytes]\n\ndef decode_header(header_str: str) -> str: ...\n\nclass NNTP:\n    encoding: str\n    errors: str\n\n    host: str\n    port: int\n    sock: socket.socket\n    file: IO[bytes]\n    debugging: int\n    welcome: str\n    readermode_afterauth: bool\n    tls_on: bool\n    authenticated: bool\n    nntp_implementation: str\n    nntp_version: int\n    def __init__(\n        self,\n        host: str,\n        port: int = 119,\n        user: str | None = None,\n        password: str | None = None,\n        readermode: bool | None = None,\n        usenetrc: bool = False,\n        timeout: float = ...,\n    ) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def getwelcome(self) -> str: ...\n    def getcapabilities(self) -> dict[str, _list[str]]: ...\n    def set_debuglevel(self, level: int) -> None: ...\n    def debug(self, level: int) -> None: ...\n    def capabilities(self) -> tuple[str, dict[str, _list[str]]]: ...\n    def newgroups(self, date: datetime.date | datetime.datetime, *, file: _File = None) -> tuple[str, _list[str]]: ...\n    def newnews(self, group: str, date: datetime.date | datetime.datetime, *, file: _File = None) -> tuple[str, _list[str]]: ...\n    def list(self, group_pattern: str | None = None, *, file: _File = None) -> tuple[str, _list[str]]: ...\n    def description(self, group: str) -> str: ...\n    def descriptions(self, group_pattern: str) -> tuple[str, dict[str, str]]: ...\n    def group(self, name: str) -> tuple[str, int, int, int, str]: ...\n    def help(self, *, file: _File = None) -> tuple[str, _list[str]]: ...\n    def stat(self, message_spec: Any = None) -> tuple[str, int, str]: ...\n    def next(self) -> tuple[str, int, str]: ...\n    def last(self) -> tuple[str, int, str]: ...\n    def head(self, message_spec: Any = None, *, file: _File = None) -> tuple[str, ArticleInfo]: ...\n    def body(self, message_spec: Any = None, *, file: _File = None) -> tuple[str, ArticleInfo]: ...\n    def article(self, message_spec: Any = None, *, file: _File = None) -> tuple[str, ArticleInfo]: ...\n    def slave(self) -> str: ...\n    def xhdr(self, hdr: str, str: Any, *, file: _File = None) -> tuple[str, _list[str]]: ...\n    def xover(self, start: int, end: int, *, file: _File = None) -> tuple[str, _list[tuple[int, dict[str, str]]]]: ...\n    def over(\n        self, message_spec: None | str | _list[Any] | tuple[Any, ...], *, file: _File = None\n    ) -> tuple[str, _list[tuple[int, dict[str, str]]]]: ...\n    if sys.version_info < (3, 9):\n        def xgtitle(self, group: str, *, file: _File = None) -> tuple[str, _list[tuple[str, str]]]: ...\n        def xpath(self, id: Any) -> tuple[str, str]: ...\n\n    def date(self) -> tuple[str, datetime.datetime]: ...\n    def post(self, data: bytes | Iterable[bytes]) -> str: ...\n    def ihave(self, message_id: Any, data: bytes | Iterable[bytes]) -> str: ...\n    def quit(self) -> str: ...\n    def login(self, user: str | None = None, password: str | None = None, usenetrc: bool = True) -> None: ...\n    def starttls(self, context: ssl.SSLContext | None = None) -> None: ...\n\nclass NNTP_SSL(NNTP):\n    ssl_context: ssl.SSLContext | None\n    sock: ssl.SSLSocket\n    def __init__(\n        self,\n        host: str,\n        port: int = 563,\n        user: str | None = None,\n        password: str | None = None,\n        ssl_context: ssl.SSLContext | None = None,\n        readermode: bool | None = None,\n        usenetrc: bool = False,\n        timeout: float = ...,\n    ) -> None: ...\n",
  "/typeshed/stdlib/ntpath.pyi": "import sys\nfrom _typeshed import BytesPath, StrPath\nfrom genericpath import (\n    commonprefix as commonprefix,\n    exists as exists,\n    getatime as getatime,\n    getctime as getctime,\n    getmtime as getmtime,\n    getsize as getsize,\n    isdir as isdir,\n    isfile as isfile,\n    samefile as samefile,\n    sameopenfile as sameopenfile,\n    samestat as samestat,\n)\nfrom os import PathLike\n\n# Re-export common definitions from posixpath to reduce duplication\nfrom posixpath import (\n    abspath as abspath,\n    basename as basename,\n    commonpath as commonpath,\n    curdir as curdir,\n    defpath as defpath,\n    devnull as devnull,\n    dirname as dirname,\n    expanduser as expanduser,\n    expandvars as expandvars,\n    extsep as extsep,\n    isabs as isabs,\n    islink as islink,\n    ismount as ismount,\n    lexists as lexists,\n    normcase as normcase,\n    normpath as normpath,\n    pardir as pardir,\n    pathsep as pathsep,\n    relpath as relpath,\n    sep as sep,\n    split as split,\n    splitdrive as splitdrive,\n    splitext as splitext,\n    supports_unicode_filenames as supports_unicode_filenames,\n)\nfrom typing import AnyStr, overload\nfrom typing_extensions import LiteralString\n\n__all__ = [\n    \"normcase\",\n    \"isabs\",\n    \"join\",\n    \"splitdrive\",\n    \"split\",\n    \"splitext\",\n    \"basename\",\n    \"dirname\",\n    \"commonprefix\",\n    \"getsize\",\n    \"getmtime\",\n    \"getatime\",\n    \"getctime\",\n    \"islink\",\n    \"exists\",\n    \"lexists\",\n    \"isdir\",\n    \"isfile\",\n    \"ismount\",\n    \"expanduser\",\n    \"expandvars\",\n    \"normpath\",\n    \"abspath\",\n    \"curdir\",\n    \"pardir\",\n    \"sep\",\n    \"pathsep\",\n    \"defpath\",\n    \"altsep\",\n    \"extsep\",\n    \"devnull\",\n    \"realpath\",\n    \"supports_unicode_filenames\",\n    \"relpath\",\n    \"samefile\",\n    \"sameopenfile\",\n    \"samestat\",\n    \"commonpath\",\n]\n\naltsep: LiteralString\n\n# First parameter is not actually pos-only,\n# but must be defined as pos-only in the stub or cross-platform code doesn't type-check,\n# as the parameter name is different in posixpath.join()\n@overload\ndef join(__path: LiteralString, *paths: LiteralString) -> LiteralString: ...\n@overload\ndef join(__path: StrPath, *paths: StrPath) -> str: ...\n@overload\ndef join(__path: BytesPath, *paths: BytesPath) -> bytes: ...\n\nif sys.platform == \"win32\":\n    if sys.version_info >= (3, 10):\n        @overload\n        def realpath(path: PathLike[AnyStr], *, strict: bool = False) -> AnyStr: ...\n        @overload\n        def realpath(path: AnyStr, *, strict: bool = False) -> AnyStr: ...\n    else:\n        @overload\n        def realpath(path: PathLike[AnyStr]) -> AnyStr: ...\n        @overload\n        def realpath(path: AnyStr) -> AnyStr: ...\n\nelse:\n    realpath = abspath\n",
  "/typeshed/stdlib/nturl2path.pyi": "def url2pathname(url: str) -> str: ...\ndef pathname2url(p: str) -> str: ...\n",
  "/typeshed/stdlib/numbers.pyi": "# Note: these stubs are incomplete. The more complex type\n# signatures are currently omitted.\n\nfrom abc import ABCMeta, abstractmethod\nfrom typing import Any, SupportsFloat, overload\n\n__all__ = [\"Number\", \"Complex\", \"Real\", \"Rational\", \"Integral\"]\n\nclass Number(metaclass=ABCMeta):\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\nclass Complex(Number):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n    def __bool__(self) -> bool: ...\n    @property\n    @abstractmethod\n    def real(self) -> Any: ...\n    @property\n    @abstractmethod\n    def imag(self) -> Any: ...\n    @abstractmethod\n    def __add__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __radd__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __neg__(self) -> Any: ...\n    @abstractmethod\n    def __pos__(self) -> Any: ...\n    def __sub__(self, other: Any) -> Any: ...\n    def __rsub__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __mul__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rmul__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __truediv__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rtruediv__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __pow__(self, exponent: Any) -> Any: ...\n    @abstractmethod\n    def __rpow__(self, base: Any) -> Any: ...\n    @abstractmethod\n    def __abs__(self) -> Real: ...\n    @abstractmethod\n    def conjugate(self) -> Any: ...\n    @abstractmethod\n    def __eq__(self, other: object) -> bool: ...\n\nclass Real(Complex, SupportsFloat):\n    @abstractmethod\n    def __float__(self) -> float: ...\n    @abstractmethod\n    def __trunc__(self) -> int: ...\n    @abstractmethod\n    def __floor__(self) -> int: ...\n    @abstractmethod\n    def __ceil__(self) -> int: ...\n    @abstractmethod\n    @overload\n    def __round__(self, ndigits: None = None) -> int: ...\n    @abstractmethod\n    @overload\n    def __round__(self, ndigits: int) -> Any: ...\n    def __divmod__(self, other: Any) -> Any: ...\n    def __rdivmod__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __floordiv__(self, other: Any) -> int: ...\n    @abstractmethod\n    def __rfloordiv__(self, other: Any) -> int: ...\n    @abstractmethod\n    def __mod__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rmod__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __lt__(self, other: Any) -> bool: ...\n    @abstractmethod\n    def __le__(self, other: Any) -> bool: ...\n    def __complex__(self) -> complex: ...\n    @property\n    def real(self) -> Any: ...\n    @property\n    def imag(self) -> Any: ...\n    def conjugate(self) -> Any: ...\n\nclass Rational(Real):\n    @property\n    @abstractmethod\n    def numerator(self) -> int: ...\n    @property\n    @abstractmethod\n    def denominator(self) -> int: ...\n    def __float__(self) -> float: ...\n\nclass Integral(Rational):\n    @abstractmethod\n    def __int__(self) -> int: ...\n    def __index__(self) -> int: ...\n    @abstractmethod\n    def __pow__(self, exponent: Any, modulus: Any | None = None) -> Any: ...\n    @abstractmethod\n    def __lshift__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rlshift__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rshift__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rrshift__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __and__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rand__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __xor__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __rxor__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __or__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __ror__(self, other: Any) -> Any: ...\n    @abstractmethod\n    def __invert__(self) -> Any: ...\n    def __float__(self) -> float: ...\n    @property\n    def numerator(self) -> int: ...\n    @property\n    def denominator(self) -> int: ...\n",
  "/typeshed/stdlib/opcode.pyi": "import sys\nfrom typing_extensions import Literal\n\n__all__ = [\n    \"cmp_op\",\n    \"hasconst\",\n    \"hasname\",\n    \"hasjrel\",\n    \"hasjabs\",\n    \"haslocal\",\n    \"hascompare\",\n    \"hasfree\",\n    \"opname\",\n    \"opmap\",\n    \"HAVE_ARGUMENT\",\n    \"EXTENDED_ARG\",\n    \"hasnargs\",\n    \"stack_effect\",\n]\n\nif sys.version_info >= (3, 9):\n    cmp_op: tuple[Literal[\"<\"], Literal[\"<=\"], Literal[\"==\"], Literal[\"!=\"], Literal[\">\"], Literal[\">=\"]]\nelse:\n    cmp_op: tuple[\n        Literal[\"<\"],\n        Literal[\"<=\"],\n        Literal[\"==\"],\n        Literal[\"!=\"],\n        Literal[\">\"],\n        Literal[\">=\"],\n        Literal[\"in\"],\n        Literal[\"not in\"],\n        Literal[\"is\"],\n        Literal[\"is not\"],\n        Literal[\"exception match\"],\n        Literal[\"BAD\"],\n    ]\nhasconst: list[int]\nhasname: list[int]\nhasjrel: list[int]\nhasjabs: list[int]\nhaslocal: list[int]\nhascompare: list[int]\nhasfree: list[int]\nopname: list[str]\n\nopmap: dict[str, int]\nHAVE_ARGUMENT: Literal[90]\nEXTENDED_ARG: Literal[144]\n\nif sys.version_info >= (3, 8):\n    def stack_effect(__opcode: int, __oparg: int | None = None, *, jump: bool | None = None) -> int: ...\n\nelse:\n    def stack_effect(__opcode: int, __oparg: int | None = None) -> int: ...\n\nhasnargs: list[int]\n",
  "/typeshed/stdlib/operator.pyi": "import sys\nfrom _operator import *\n\n__all__ = [\n    \"abs\",\n    \"add\",\n    \"and_\",\n    \"attrgetter\",\n    \"concat\",\n    \"contains\",\n    \"countOf\",\n    \"delitem\",\n    \"eq\",\n    \"floordiv\",\n    \"ge\",\n    \"getitem\",\n    \"gt\",\n    \"iadd\",\n    \"iand\",\n    \"iconcat\",\n    \"ifloordiv\",\n    \"ilshift\",\n    \"imatmul\",\n    \"imod\",\n    \"imul\",\n    \"index\",\n    \"indexOf\",\n    \"inv\",\n    \"invert\",\n    \"ior\",\n    \"ipow\",\n    \"irshift\",\n    \"is_\",\n    \"is_not\",\n    \"isub\",\n    \"itemgetter\",\n    \"itruediv\",\n    \"ixor\",\n    \"le\",\n    \"length_hint\",\n    \"lshift\",\n    \"lt\",\n    \"matmul\",\n    \"methodcaller\",\n    \"mod\",\n    \"mul\",\n    \"ne\",\n    \"neg\",\n    \"not_\",\n    \"or_\",\n    \"pos\",\n    \"pow\",\n    \"rshift\",\n    \"setitem\",\n    \"sub\",\n    \"truediv\",\n    \"truth\",\n    \"xor\",\n]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"call\"]\n\n__lt__ = lt\n__le__ = le\n__eq__ = eq\n__ne__ = ne\n__ge__ = ge\n__gt__ = gt\n__not__ = not_\n__abs__ = abs\n__add__ = add\n__and__ = and_\n__floordiv__ = floordiv\n__index__ = index\n__inv__ = inv\n__invert__ = invert\n__lshift__ = lshift\n__mod__ = mod\n__mul__ = mul\n__matmul__ = matmul\n__neg__ = neg\n__or__ = or_\n__pos__ = pos\n__pow__ = pow\n__rshift__ = rshift\n__sub__ = sub\n__truediv__ = truediv\n__xor__ = xor\n__concat__ = concat\n__contains__ = contains\n__delitem__ = delitem\n__getitem__ = getitem\n__setitem__ = setitem\n__iadd__ = iadd\n__iand__ = iand\n__iconcat__ = iconcat\n__ifloordiv__ = ifloordiv\n__ilshift__ = ilshift\n__imod__ = imod\n__imul__ = imul\n__imatmul__ = imatmul\n__ior__ = ior\n__ipow__ = ipow\n__irshift__ = irshift\n__isub__ = isub\n__itruediv__ = itruediv\n__ixor__ = ixor\nif sys.version_info >= (3, 11):\n    __call__ = call\n",
  "/typeshed/stdlib/optparse.pyi": "from abc import abstractmethod\nfrom collections.abc import Callable, Iterable, Mapping, Sequence\nfrom typing import IO, Any, AnyStr, overload\n\n__all__ = [\n    \"Option\",\n    \"make_option\",\n    \"SUPPRESS_HELP\",\n    \"SUPPRESS_USAGE\",\n    \"Values\",\n    \"OptionContainer\",\n    \"OptionGroup\",\n    \"OptionParser\",\n    \"HelpFormatter\",\n    \"IndentedHelpFormatter\",\n    \"TitledHelpFormatter\",\n    \"OptParseError\",\n    \"OptionError\",\n    \"OptionConflictError\",\n    \"OptionValueError\",\n    \"BadOptionError\",\n    \"check_choice\",\n]\n\nNO_DEFAULT: tuple[str, ...]\nSUPPRESS_HELP: str\nSUPPRESS_USAGE: str\n\ndef check_builtin(option: Option, opt: Any, value: str) -> Any: ...\ndef check_choice(option: Option, opt: Any, value: str) -> str: ...\n\nclass OptParseError(Exception):\n    msg: str\n    def __init__(self, msg: str) -> None: ...\n\nclass BadOptionError(OptParseError):\n    opt_str: str\n    def __init__(self, opt_str: str) -> None: ...\n\nclass AmbiguousOptionError(BadOptionError):\n    possibilities: Iterable[str]\n    def __init__(self, opt_str: str, possibilities: Sequence[str]) -> None: ...\n\nclass OptionError(OptParseError):\n    option_id: str\n    def __init__(self, msg: str, option: Option) -> None: ...\n\nclass OptionConflictError(OptionError): ...\nclass OptionValueError(OptParseError): ...\n\nclass HelpFormatter:\n    NO_DEFAULT_VALUE: str\n    _long_opt_fmt: str\n    _short_opt_fmt: str\n    current_indent: int\n    default_tag: str\n    help_position: Any\n    help_width: Any\n    indent_increment: int\n    level: int\n    max_help_position: int\n    option_strings: dict[Option, str]\n    parser: OptionParser\n    short_first: Any\n    width: int\n    def __init__(self, indent_increment: int, max_help_position: int, width: int | None, short_first: int) -> None: ...\n    def dedent(self) -> None: ...\n    def expand_default(self, option: Option) -> str: ...\n    def format_description(self, description: str) -> str: ...\n    def format_epilog(self, epilog: str) -> str: ...\n    @abstractmethod\n    def format_heading(self, heading: Any) -> str: ...\n    def format_option(self, option: Option) -> str: ...\n    def format_option_strings(self, option: Option) -> str: ...\n    @abstractmethod\n    def format_usage(self, usage: Any) -> str: ...\n    def indent(self) -> None: ...\n    def set_long_opt_delimiter(self, delim: str) -> None: ...\n    def set_parser(self, parser: OptionParser) -> None: ...\n    def set_short_opt_delimiter(self, delim: str) -> None: ...\n    def store_option_strings(self, parser: OptionParser) -> None: ...\n\nclass IndentedHelpFormatter(HelpFormatter):\n    def __init__(\n        self, indent_increment: int = 2, max_help_position: int = 24, width: int | None = None, short_first: int = 1\n    ) -> None: ...\n    def format_heading(self, heading: str) -> str: ...\n    def format_usage(self, usage: str) -> str: ...\n\nclass TitledHelpFormatter(HelpFormatter):\n    def __init__(\n        self, indent_increment: int = 0, max_help_position: int = 24, width: int | None = None, short_first: int = 0\n    ) -> None: ...\n    def format_heading(self, heading: str) -> str: ...\n    def format_usage(self, usage: str) -> str: ...\n\nclass Option:\n    ACTIONS: tuple[str, ...]\n    ALWAYS_TYPED_ACTIONS: tuple[str, ...]\n    ATTRS: list[str]\n    CHECK_METHODS: list[Callable[..., Any]] | None\n    CONST_ACTIONS: tuple[str, ...]\n    STORE_ACTIONS: tuple[str, ...]\n    TYPED_ACTIONS: tuple[str, ...]\n    TYPES: tuple[str, ...]\n    TYPE_CHECKER: dict[str, Callable[..., Any]]\n    _long_opts: list[str]\n    _short_opts: list[str]\n    action: str\n    dest: str | None\n    default: Any\n    nargs: int\n    type: Any\n    callback: Callable[..., Any] | None\n    callback_args: tuple[Any, ...] | None\n    callback_kwargs: dict[str, Any] | None\n    help: str | None\n    metavar: str | None\n    def __init__(self, *opts: str | None, **attrs: Any) -> None: ...\n    def _check_action(self) -> None: ...\n    def _check_callback(self) -> None: ...\n    def _check_choice(self) -> None: ...\n    def _check_const(self) -> None: ...\n    def _check_dest(self) -> None: ...\n    def _check_nargs(self) -> None: ...\n    def _check_opt_strings(self, opts: Iterable[str | None]) -> list[str]: ...\n    def _check_type(self) -> None: ...\n    def _set_attrs(self, attrs: dict[str, Any]) -> None: ...\n    def _set_opt_strings(self, opts: Iterable[str]) -> None: ...\n    def check_value(self, opt: str, value: Any) -> Any: ...\n    def convert_value(self, opt: str, value: Any) -> Any: ...\n    def get_opt_string(self) -> str: ...\n    def process(self, opt: Any, value: Any, values: Any, parser: OptionParser) -> int: ...\n    def take_action(self, action: str, dest: str, opt: Any, value: Any, values: Any, parser: OptionParser) -> int: ...\n    def takes_value(self) -> bool: ...\n\nmake_option = Option\n\nclass OptionContainer:\n    _long_opt: dict[str, Option]\n    _short_opt: dict[str, Option]\n    conflict_handler: str\n    defaults: dict[str, Any]\n    description: Any\n    option_class: type[Option]\n    def __init__(self, option_class: type[Option], conflict_handler: Any, description: Any) -> None: ...\n    def _check_conflict(self, option: Any) -> None: ...\n    def _create_option_mappings(self) -> None: ...\n    def _share_option_mappings(self, parser: OptionParser) -> None: ...\n    @overload\n    def add_option(self, opt: Option) -> Option: ...\n    @overload\n    def add_option(self, *args: str | None, **kwargs: Any) -> Any: ...\n    def add_options(self, option_list: Iterable[Option]) -> None: ...\n    def destroy(self) -> None: ...\n    def format_description(self, formatter: HelpFormatter | None) -> Any: ...\n    def format_help(self, formatter: HelpFormatter | None) -> str: ...\n    def format_option_help(self, formatter: HelpFormatter | None) -> str: ...\n    def get_description(self) -> Any: ...\n    def get_option(self, opt_str: str) -> Option | None: ...\n    def has_option(self, opt_str: str) -> bool: ...\n    def remove_option(self, opt_str: str) -> None: ...\n    def set_conflict_handler(self, handler: Any) -> None: ...\n    def set_description(self, description: Any) -> None: ...\n\nclass OptionGroup(OptionContainer):\n    option_list: list[Option]\n    parser: OptionParser\n    title: str\n    def __init__(self, parser: OptionParser, title: str, description: str | None = None) -> None: ...\n    def _create_option_list(self) -> None: ...\n    def set_title(self, title: str) -> None: ...\n\nclass Values:\n    def __init__(self, defaults: Mapping[str, Any] | None = None) -> None: ...\n    def _update(self, dict: Mapping[str, Any], mode: Any) -> None: ...\n    def _update_careful(self, dict: Mapping[str, Any]) -> None: ...\n    def _update_loose(self, dict: Mapping[str, Any]) -> None: ...\n    def ensure_value(self, attr: str, value: Any) -> Any: ...\n    def read_file(self, filename: str, mode: str = \"careful\") -> None: ...\n    def read_module(self, modname: str, mode: str = \"careful\") -> None: ...\n    def __getattr__(self, name: str) -> Any: ...\n    def __setattr__(self, __name: str, __value: Any) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass OptionParser(OptionContainer):\n    allow_interspersed_args: bool\n    epilog: str | None\n    formatter: HelpFormatter\n    largs: list[str] | None\n    option_groups: list[OptionGroup]\n    option_list: list[Option]\n    process_default_values: Any\n    prog: str | None\n    rargs: list[Any] | None\n    standard_option_list: list[Option]\n    usage: str | None\n    values: Values | None\n    version: str\n    def __init__(\n        self,\n        usage: str | None = None,\n        option_list: Iterable[Option] | None = None,\n        option_class: type[Option] = ...,\n        version: str | None = None,\n        conflict_handler: str = \"error\",\n        description: str | None = None,\n        formatter: HelpFormatter | None = None,\n        add_help_option: bool = True,\n        prog: str | None = None,\n        epilog: str | None = None,\n    ) -> None: ...\n    def _add_help_option(self) -> None: ...\n    def _add_version_option(self) -> None: ...\n    def _create_option_list(self) -> None: ...\n    def _get_all_options(self) -> list[Option]: ...\n    def _get_args(self, args: Iterable[Any]) -> list[Any]: ...\n    def _init_parsing_state(self) -> None: ...\n    def _match_long_opt(self, opt: str) -> str: ...\n    def _populate_option_list(self, option_list: Iterable[Option], add_help: bool = True) -> None: ...\n    def _process_args(self, largs: list[Any], rargs: list[Any], values: Values) -> None: ...\n    def _process_long_opt(self, rargs: list[Any], values: Any) -> None: ...\n    def _process_short_opts(self, rargs: list[Any], values: Any) -> None: ...\n    @overload\n    def add_option_group(self, __opt_group: OptionGroup) -> OptionGroup: ...\n    @overload\n    def add_option_group(self, *args: Any, **kwargs: Any) -> OptionGroup: ...\n    def check_values(self, values: Values, args: list[str]) -> tuple[Values, list[str]]: ...\n    def disable_interspersed_args(self) -> None: ...\n    def enable_interspersed_args(self) -> None: ...\n    def error(self, msg: str) -> None: ...\n    def exit(self, status: int = 0, msg: str | None = None) -> None: ...\n    def expand_prog_name(self, s: str | None) -> Any: ...\n    def format_epilog(self, formatter: HelpFormatter) -> Any: ...\n    def format_help(self, formatter: HelpFormatter | None = None) -> str: ...\n    def format_option_help(self, formatter: HelpFormatter | None = None) -> str: ...\n    def get_default_values(self) -> Values: ...\n    def get_option_group(self, opt_str: str) -> Any: ...\n    def get_prog_name(self) -> str: ...\n    def get_usage(self) -> str: ...\n    def get_version(self) -> str: ...\n    @overload\n    def parse_args(self, args: None = None, values: Values | None = None) -> tuple[Values, list[str]]: ...\n    @overload\n    def parse_args(self, args: Sequence[AnyStr], values: Values | None = None) -> tuple[Values, list[AnyStr]]: ...\n    def print_usage(self, file: IO[str] | None = None) -> None: ...\n    def print_help(self, file: IO[str] | None = None) -> None: ...\n    def print_version(self, file: IO[str] | None = None) -> None: ...\n    def set_default(self, dest: Any, value: Any) -> None: ...\n    def set_defaults(self, **kwargs: Any) -> None: ...\n    def set_process_default_values(self, process: Any) -> None: ...\n    def set_usage(self, usage: str) -> None: ...\n",
  "/typeshed/stdlib/ossaudiodev.pyi": "import sys\nfrom typing import Any, overload\nfrom typing_extensions import Literal\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    AFMT_AC3: int\n    AFMT_A_LAW: int\n    AFMT_IMA_ADPCM: int\n    AFMT_MPEG: int\n    AFMT_MU_LAW: int\n    AFMT_QUERY: int\n    AFMT_S16_BE: int\n    AFMT_S16_LE: int\n    AFMT_S16_NE: int\n    AFMT_S8: int\n    AFMT_U16_BE: int\n    AFMT_U16_LE: int\n    AFMT_U8: int\n    SNDCTL_COPR_HALT: int\n    SNDCTL_COPR_LOAD: int\n    SNDCTL_COPR_RCODE: int\n    SNDCTL_COPR_RCVMSG: int\n    SNDCTL_COPR_RDATA: int\n    SNDCTL_COPR_RESET: int\n    SNDCTL_COPR_RUN: int\n    SNDCTL_COPR_SENDMSG: int\n    SNDCTL_COPR_WCODE: int\n    SNDCTL_COPR_WDATA: int\n    SNDCTL_DSP_BIND_CHANNEL: int\n    SNDCTL_DSP_CHANNELS: int\n    SNDCTL_DSP_GETBLKSIZE: int\n    SNDCTL_DSP_GETCAPS: int\n    SNDCTL_DSP_GETCHANNELMASK: int\n    SNDCTL_DSP_GETFMTS: int\n    SNDCTL_DSP_GETIPTR: int\n    SNDCTL_DSP_GETISPACE: int\n    SNDCTL_DSP_GETODELAY: int\n    SNDCTL_DSP_GETOPTR: int\n    SNDCTL_DSP_GETOSPACE: int\n    SNDCTL_DSP_GETSPDIF: int\n    SNDCTL_DSP_GETTRIGGER: int\n    SNDCTL_DSP_MAPINBUF: int\n    SNDCTL_DSP_MAPOUTBUF: int\n    SNDCTL_DSP_NONBLOCK: int\n    SNDCTL_DSP_POST: int\n    SNDCTL_DSP_PROFILE: int\n    SNDCTL_DSP_RESET: int\n    SNDCTL_DSP_SAMPLESIZE: int\n    SNDCTL_DSP_SETDUPLEX: int\n    SNDCTL_DSP_SETFMT: int\n    SNDCTL_DSP_SETFRAGMENT: int\n    SNDCTL_DSP_SETSPDIF: int\n    SNDCTL_DSP_SETSYNCRO: int\n    SNDCTL_DSP_SETTRIGGER: int\n    SNDCTL_DSP_SPEED: int\n    SNDCTL_DSP_STEREO: int\n    SNDCTL_DSP_SUBDIVIDE: int\n    SNDCTL_DSP_SYNC: int\n    SNDCTL_FM_4OP_ENABLE: int\n    SNDCTL_FM_LOAD_INSTR: int\n    SNDCTL_MIDI_INFO: int\n    SNDCTL_MIDI_MPUCMD: int\n    SNDCTL_MIDI_MPUMODE: int\n    SNDCTL_MIDI_PRETIME: int\n    SNDCTL_SEQ_CTRLRATE: int\n    SNDCTL_SEQ_GETINCOUNT: int\n    SNDCTL_SEQ_GETOUTCOUNT: int\n    SNDCTL_SEQ_GETTIME: int\n    SNDCTL_SEQ_NRMIDIS: int\n    SNDCTL_SEQ_NRSYNTHS: int\n    SNDCTL_SEQ_OUTOFBAND: int\n    SNDCTL_SEQ_PANIC: int\n    SNDCTL_SEQ_PERCMODE: int\n    SNDCTL_SEQ_RESET: int\n    SNDCTL_SEQ_RESETSAMPLES: int\n    SNDCTL_SEQ_SYNC: int\n    SNDCTL_SEQ_TESTMIDI: int\n    SNDCTL_SEQ_THRESHOLD: int\n    SNDCTL_SYNTH_CONTROL: int\n    SNDCTL_SYNTH_ID: int\n    SNDCTL_SYNTH_INFO: int\n    SNDCTL_SYNTH_MEMAVL: int\n    SNDCTL_SYNTH_REMOVESAMPLE: int\n    SNDCTL_TMR_CONTINUE: int\n    SNDCTL_TMR_METRONOME: int\n    SNDCTL_TMR_SELECT: int\n    SNDCTL_TMR_SOURCE: int\n    SNDCTL_TMR_START: int\n    SNDCTL_TMR_STOP: int\n    SNDCTL_TMR_TEMPO: int\n    SNDCTL_TMR_TIMEBASE: int\n    SOUND_MIXER_ALTPCM: int\n    SOUND_MIXER_BASS: int\n    SOUND_MIXER_CD: int\n    SOUND_MIXER_DIGITAL1: int\n    SOUND_MIXER_DIGITAL2: int\n    SOUND_MIXER_DIGITAL3: int\n    SOUND_MIXER_IGAIN: int\n    SOUND_MIXER_IMIX: int\n    SOUND_MIXER_LINE: int\n    SOUND_MIXER_LINE1: int\n    SOUND_MIXER_LINE2: int\n    SOUND_MIXER_LINE3: int\n    SOUND_MIXER_MIC: int\n    SOUND_MIXER_MONITOR: int\n    SOUND_MIXER_NRDEVICES: int\n    SOUND_MIXER_OGAIN: int\n    SOUND_MIXER_PCM: int\n    SOUND_MIXER_PHONEIN: int\n    SOUND_MIXER_PHONEOUT: int\n    SOUND_MIXER_RADIO: int\n    SOUND_MIXER_RECLEV: int\n    SOUND_MIXER_SPEAKER: int\n    SOUND_MIXER_SYNTH: int\n    SOUND_MIXER_TREBLE: int\n    SOUND_MIXER_VIDEO: int\n    SOUND_MIXER_VOLUME: int\n\n    control_labels: list[str]\n    control_names: list[str]\n\n    # TODO: oss_audio_device return type\n    @overload\n    def open(mode: Literal[\"r\", \"w\", \"rw\"]) -> Any: ...\n    @overload\n    def open(device: str, mode: Literal[\"r\", \"w\", \"rw\"]) -> Any: ...\n\n    # TODO: oss_mixer_device return type\n    def openmixer(device: str = ...) -> Any: ...\n\n    class OSSAudioError(Exception): ...\n    error = OSSAudioError\n",
  "/typeshed/stdlib/parser.pyi": "from _typeshed import StrOrBytesPath\nfrom collections.abc import Sequence\nfrom types import CodeType\nfrom typing import Any\nfrom typing_extensions import final\n\ndef expr(source: str) -> STType: ...\ndef suite(source: str) -> STType: ...\ndef sequence2st(sequence: Sequence[Any]) -> STType: ...\ndef tuple2st(sequence: Sequence[Any]) -> STType: ...\ndef st2list(st: STType, line_info: bool = ..., col_info: bool = ...) -> list[Any]: ...\ndef st2tuple(st: STType, line_info: bool = ..., col_info: bool = ...) -> tuple[Any, ...]: ...\ndef compilest(st: STType, filename: StrOrBytesPath = ...) -> CodeType: ...\ndef isexpr(st: STType) -> bool: ...\ndef issuite(st: STType) -> bool: ...\n\nclass ParserError(Exception): ...\n\n@final\nclass STType:\n    def compile(self, filename: StrOrBytesPath = ...) -> CodeType: ...\n    def isexpr(self) -> bool: ...\n    def issuite(self) -> bool: ...\n    def tolist(self, line_info: bool = ..., col_info: bool = ...) -> list[Any]: ...\n    def totuple(self, line_info: bool = ..., col_info: bool = ...) -> tuple[Any, ...]: ...\n",
  "/typeshed/stdlib/pathlib.pyi": "import sys\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    StrOrBytesPath,\n    StrPath,\n)\nfrom collections.abc import Callable, Generator, Iterator, Sequence\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom os import PathLike, stat_result\nfrom types import TracebackType\nfrom typing import IO, Any, BinaryIO, overload\nfrom typing_extensions import Literal, Self\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\"PurePath\", \"PurePosixPath\", \"PureWindowsPath\", \"Path\", \"PosixPath\", \"WindowsPath\"]\n\nclass PurePath(PathLike[str]):\n    @property\n    def parts(self) -> tuple[str, ...]: ...\n    @property\n    def drive(self) -> str: ...\n    @property\n    def root(self) -> str: ...\n    @property\n    def anchor(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @property\n    def suffix(self) -> str: ...\n    @property\n    def suffixes(self) -> list[str]: ...\n    @property\n    def stem(self) -> str: ...\n    def __new__(cls, *args: StrPath) -> Self: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __fspath__(self) -> str: ...\n    def __lt__(self, other: PurePath) -> bool: ...\n    def __le__(self, other: PurePath) -> bool: ...\n    def __gt__(self, other: PurePath) -> bool: ...\n    def __ge__(self, other: PurePath) -> bool: ...\n    def __truediv__(self, key: StrPath) -> Self: ...\n    def __rtruediv__(self, key: StrPath) -> Self: ...\n    def __bytes__(self) -> bytes: ...\n    def as_posix(self) -> str: ...\n    def as_uri(self) -> str: ...\n    def is_absolute(self) -> bool: ...\n    def is_reserved(self) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def is_relative_to(self, *other: StrPath) -> bool: ...\n\n    def match(self, path_pattern: str) -> bool: ...\n    def relative_to(self, *other: StrPath) -> Self: ...\n    def with_name(self, name: str) -> Self: ...\n    if sys.version_info >= (3, 9):\n        def with_stem(self, stem: str) -> Self: ...\n\n    def with_suffix(self, suffix: str) -> Self: ...\n    def joinpath(self, *other: StrPath) -> Self: ...\n    @property\n    def parents(self) -> Sequence[Self]: ...\n    @property\n    def parent(self) -> Self: ...\n    if sys.version_info >= (3, 9) and sys.version_info < (3, 11):\n        def __class_getitem__(cls, type: Any) -> GenericAlias: ...\n\nclass PurePosixPath(PurePath): ...\nclass PureWindowsPath(PurePath): ...\n\nclass Path(PurePath):\n    def __new__(cls, *args: StrPath, **kwargs: Any) -> Self: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n    @classmethod\n    def cwd(cls) -> Self: ...\n    if sys.version_info >= (3, 10):\n        def stat(self, *, follow_symlinks: bool = True) -> stat_result: ...\n        def chmod(self, mode: int, *, follow_symlinks: bool = True) -> None: ...\n    else:\n        def stat(self) -> stat_result: ...\n        def chmod(self, mode: int) -> None: ...\n\n    def exists(self) -> bool: ...\n    def glob(self, pattern: str) -> Generator[Self, None, None]: ...\n    def is_dir(self) -> bool: ...\n    def is_file(self) -> bool: ...\n    def is_symlink(self) -> bool: ...\n    def is_socket(self) -> bool: ...\n    def is_fifo(self) -> bool: ...\n    def is_block_device(self) -> bool: ...\n    def is_char_device(self) -> bool: ...\n    def iterdir(self) -> Generator[Self, None, None]: ...\n    def lchmod(self, mode: int) -> None: ...\n    def lstat(self) -> stat_result: ...\n    def mkdir(self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False) -> None: ...\n    # Adapted from builtins.open\n    # Text mode: always returns a TextIOWrapper\n    # The Traversable .open in stdlib/importlib/abc.pyi should be kept in sync with this.\n    @overload\n    def open(\n        self,\n        mode: OpenTextMode = \"r\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        errors: str | None = None,\n        newline: str | None = None,\n    ) -> TextIOWrapper: ...\n    # Unbuffered binary mode: returns a FileIO\n    @overload\n    def open(\n        self, mode: OpenBinaryMode, buffering: Literal[0], encoding: None = None, errors: None = None, newline: None = None\n    ) -> FileIO: ...\n    # Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeUpdating,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedRandom: ...\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeWriting,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedWriter: ...\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeReading,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedReader: ...\n    # Buffering cannot be determined: fall back to BinaryIO\n    @overload\n    def open(\n        self, mode: OpenBinaryMode, buffering: int = -1, encoding: None = None, errors: None = None, newline: None = None\n    ) -> BinaryIO: ...\n    # Fallback if mode is not specified\n    @overload\n    def open(\n        self, mode: str, buffering: int = -1, encoding: str | None = None, errors: str | None = None, newline: str | None = None\n    ) -> IO[Any]: ...\n    if sys.platform != \"win32\":\n        # These methods do \"exist\" on Windows, but they always raise NotImplementedError,\n        # so it's safer to pretend they don't exist\n        def owner(self) -> str: ...\n        def group(self) -> str: ...\n        def is_mount(self) -> bool: ...\n\n    if sys.version_info >= (3, 9):\n        def readlink(self) -> Self: ...\n    if sys.version_info >= (3, 8):\n        def rename(self, target: str | PurePath) -> Self: ...\n        def replace(self, target: str | PurePath) -> Self: ...\n    else:\n        def rename(self, target: str | PurePath) -> None: ...\n        def replace(self, target: str | PurePath) -> None: ...\n\n    def resolve(self, strict: bool = False) -> Self: ...\n    def rglob(self, pattern: str) -> Generator[Self, None, None]: ...\n    def rmdir(self) -> None: ...\n    def symlink_to(self, target: StrOrBytesPath, target_is_directory: bool = False) -> None: ...\n    if sys.version_info >= (3, 10):\n        def hardlink_to(self, target: StrOrBytesPath) -> None: ...\n\n    def touch(self, mode: int = 0o666, exist_ok: bool = True) -> None: ...\n    if sys.version_info >= (3, 8):\n        def unlink(self, missing_ok: bool = False) -> None: ...\n    else:\n        def unlink(self) -> None: ...\n\n    @classmethod\n    def home(cls) -> Self: ...\n    def absolute(self) -> Self: ...\n    def expanduser(self) -> Self: ...\n    def read_bytes(self) -> bytes: ...\n    def read_text(self, encoding: str | None = None, errors: str | None = None) -> str: ...\n    def samefile(self, other_path: StrPath) -> bool: ...\n    def write_bytes(self, data: ReadableBuffer) -> int: ...\n    if sys.version_info >= (3, 10):\n        def write_text(\n            self, data: str, encoding: str | None = None, errors: str | None = None, newline: str | None = None\n        ) -> int: ...\n    else:\n        def write_text(self, data: str, encoding: str | None = None, errors: str | None = None) -> int: ...\n    if sys.version_info >= (3, 8) and sys.version_info < (3, 12):\n        def link_to(self, target: StrOrBytesPath) -> None: ...\n    if sys.version_info >= (3, 12):\n        def walk(\n            self, top_down: bool = ..., on_error: Callable[[OSError], object] | None = ..., follow_symlinks: bool = ...\n        ) -> Iterator[tuple[Self, list[str], list[str]]]: ...\n\nclass PosixPath(Path, PurePosixPath): ...\nclass WindowsPath(Path, PureWindowsPath): ...\n",
  "/typeshed/stdlib/pdb.pyi": "import signal\nimport sys\nfrom bdb import Bdb\nfrom cmd import Cmd\nfrom collections.abc import Callable, Iterable, Mapping, Sequence\nfrom inspect import _SourceObjectType\nfrom types import CodeType, FrameType, TracebackType\nfrom typing import IO, Any, ClassVar, TypeVar\nfrom typing_extensions import ParamSpec, Self\n\n__all__ = [\"run\", \"pm\", \"Pdb\", \"runeval\", \"runctx\", \"runcall\", \"set_trace\", \"post_mortem\", \"help\"]\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n\nline_prefix: str  # undocumented\n\nclass Restart(Exception): ...\n\ndef run(statement: str, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None) -> None: ...\ndef runeval(expression: str, globals: dict[str, Any] | None = None, locals: Mapping[str, Any] | None = None) -> Any: ...\ndef runctx(statement: str, globals: dict[str, Any], locals: Mapping[str, Any]) -> None: ...\ndef runcall(func: Callable[_P, _T], *args: _P.args, **kwds: _P.kwargs) -> _T | None: ...\ndef set_trace(*, header: str | None = None) -> None: ...\ndef post_mortem(t: TracebackType | None = None) -> None: ...\ndef pm() -> None: ...\n\nclass Pdb(Bdb, Cmd):\n    # Everything here is undocumented, except for __init__\n\n    commands_resuming: ClassVar[list[str]]\n\n    aliases: dict[str, str]\n    mainpyfile: str\n    _wait_for_mainpyfile: bool\n    rcLines: list[str]\n    commands: dict[int, list[str]]\n    commands_doprompt: dict[int, bool]\n    commands_silent: dict[int, bool]\n    commands_defining: bool\n    commands_bnum: int | None\n    lineno: int | None\n    stack: list[tuple[FrameType, int]]\n    curindex: int\n    curframe: FrameType | None\n    curframe_locals: Mapping[str, Any]\n    def __init__(\n        self,\n        completekey: str = \"tab\",\n        stdin: IO[str] | None = None,\n        stdout: IO[str] | None = None,\n        skip: Iterable[str] | None = None,\n        nosigint: bool = False,\n        readrc: bool = True,\n    ) -> None: ...\n    def forget(self) -> None: ...\n    def setup(self, f: FrameType | None, tb: TracebackType | None) -> None: ...\n    def execRcLines(self) -> None: ...\n    def bp_commands(self, frame: FrameType) -> bool: ...\n    def interaction(self, frame: FrameType | None, traceback: TracebackType | None) -> None: ...\n    def displayhook(self, obj: object) -> None: ...\n    def handle_command_def(self, line: str) -> bool: ...\n    def defaultFile(self) -> str: ...\n    def lineinfo(self, identifier: str) -> tuple[None, None, None] | tuple[str, str, int]: ...\n    def checkline(self, filename: str, lineno: int) -> int: ...\n    def _getval(self, arg: str) -> object: ...\n    def print_stack_trace(self) -> None: ...\n    def print_stack_entry(self, frame_lineno: tuple[FrameType, int], prompt_prefix: str = \"\\n-> \") -> None: ...\n    def lookupmodule(self, filename: str) -> str | None: ...\n    if sys.version_info < (3, 11):\n        def _runscript(self, filename: str) -> None: ...\n\n    def do_commands(self, arg: str) -> bool | None: ...\n    def do_break(self, arg: str, temporary: bool = ...) -> bool | None: ...\n    def do_tbreak(self, arg: str) -> bool | None: ...\n    def do_enable(self, arg: str) -> bool | None: ...\n    def do_disable(self, arg: str) -> bool | None: ...\n    def do_condition(self, arg: str) -> bool | None: ...\n    def do_ignore(self, arg: str) -> bool | None: ...\n    def do_clear(self, arg: str) -> bool | None: ...\n    def do_where(self, arg: str) -> bool | None: ...\n    def do_up(self, arg: str) -> bool | None: ...\n    def do_down(self, arg: str) -> bool | None: ...\n    def do_until(self, arg: str) -> bool | None: ...\n    def do_step(self, arg: str) -> bool | None: ...\n    def do_next(self, arg: str) -> bool | None: ...\n    def do_run(self, arg: str) -> bool | None: ...\n    def do_return(self, arg: str) -> bool | None: ...\n    def do_continue(self, arg: str) -> bool | None: ...\n    def do_jump(self, arg: str) -> bool | None: ...\n    def do_debug(self, arg: str) -> bool | None: ...\n    def do_quit(self, arg: str) -> bool | None: ...\n    def do_EOF(self, arg: str) -> bool | None: ...\n    def do_args(self, arg: str) -> bool | None: ...\n    def do_retval(self, arg: str) -> bool | None: ...\n    def do_p(self, arg: str) -> bool | None: ...\n    def do_pp(self, arg: str) -> bool | None: ...\n    def do_list(self, arg: str) -> bool | None: ...\n    def do_whatis(self, arg: str) -> bool | None: ...\n    def do_alias(self, arg: str) -> bool | None: ...\n    def do_unalias(self, arg: str) -> bool | None: ...\n    def do_help(self, arg: str) -> bool | None: ...\n    do_b = do_break\n    do_cl = do_clear\n    do_w = do_where\n    do_bt = do_where\n    do_u = do_up\n    do_d = do_down\n    do_unt = do_until\n    do_s = do_step\n    do_n = do_next\n    do_restart = do_run\n    do_r = do_return\n    do_c = do_continue\n    do_cont = do_continue\n    do_j = do_jump\n    do_q = do_quit\n    do_exit = do_quit\n    do_a = do_args\n    do_rv = do_retval\n    do_l = do_list\n    do_h = do_help\n    def help_exec(self) -> None: ...\n    def help_pdb(self) -> None: ...\n    def sigint_handler(self, signum: signal.Signals, frame: FrameType) -> None: ...\n    def message(self, msg: str) -> None: ...\n    def error(self, msg: str) -> None: ...\n    def _select_frame(self, number: int) -> None: ...\n    def _getval_except(self, arg: str, frame: FrameType | None = None) -> object: ...\n    def _print_lines(\n        self, lines: Sequence[str], start: int, breaks: Sequence[int] = (), frame: FrameType | None = None\n    ) -> None: ...\n    def _cmdloop(self) -> None: ...\n    def do_display(self, arg: str) -> bool | None: ...\n    def do_interact(self, arg: str) -> bool | None: ...\n    def do_longlist(self, arg: str) -> bool | None: ...\n    def do_source(self, arg: str) -> bool | None: ...\n    def do_undisplay(self, arg: str) -> bool | None: ...\n    do_ll = do_longlist\n    def _complete_location(self, text: str, line: str, begidx: int, endidx: int) -> list[str]: ...\n    def _complete_bpnumber(self, text: str, line: str, begidx: int, endidx: int) -> list[str]: ...\n    def _complete_expression(self, text: str, line: str, begidx: int, endidx: int) -> list[str]: ...\n    def complete_undisplay(self, text: str, line: str, begidx: int, endidx: int) -> list[str]: ...\n    def complete_unalias(self, text: str, line: str, begidx: int, endidx: int) -> list[str]: ...\n    complete_commands = _complete_bpnumber\n    complete_break = _complete_location\n    complete_b = _complete_location\n    complete_tbreak = _complete_location\n    complete_enable = _complete_bpnumber\n    complete_disable = _complete_bpnumber\n    complete_condition = _complete_bpnumber\n    complete_ignore = _complete_bpnumber\n    complete_clear = _complete_location\n    complete_cl = _complete_location\n    complete_debug = _complete_expression\n    complete_print = _complete_expression\n    complete_p = _complete_expression\n    complete_pp = _complete_expression\n    complete_source = _complete_expression\n    complete_whatis = _complete_expression\n    complete_display = _complete_expression\n\n    if sys.version_info < (3, 11):\n        def _runmodule(self, module_name: str) -> None: ...\n\n# undocumented\n\ndef find_function(funcname: str, filename: str) -> tuple[str, str, int] | None: ...\ndef main() -> None: ...\ndef help() -> None: ...\ndef getsourcelines(obj: _SourceObjectType) -> tuple[list[str], int]: ...\ndef lasti2lineno(code: CodeType, lasti: int) -> int: ...\n\nclass _rstr(str):\n    def __repr__(self) -> Self: ...\n",
  "/typeshed/stdlib/pickle.pyi": "import sys\nfrom _typeshed import ReadableBuffer, SupportsWrite\nfrom collections.abc import Callable, Iterable, Iterator, Mapping\nfrom typing import Any, ClassVar, Protocol, SupportsBytes\nfrom typing_extensions import SupportsIndex, TypeAlias, final\n\n__all__ = [\n    \"PickleError\",\n    \"PicklingError\",\n    \"UnpicklingError\",\n    \"Pickler\",\n    \"Unpickler\",\n    \"dump\",\n    \"dumps\",\n    \"load\",\n    \"loads\",\n    \"ADDITEMS\",\n    \"APPEND\",\n    \"APPENDS\",\n    \"BINBYTES\",\n    \"BINBYTES8\",\n    \"BINFLOAT\",\n    \"BINGET\",\n    \"BININT\",\n    \"BININT1\",\n    \"BININT2\",\n    \"BINPERSID\",\n    \"BINPUT\",\n    \"BINSTRING\",\n    \"BINUNICODE\",\n    \"BINUNICODE8\",\n    \"BUILD\",\n    \"DEFAULT_PROTOCOL\",\n    \"DICT\",\n    \"DUP\",\n    \"EMPTY_DICT\",\n    \"EMPTY_LIST\",\n    \"EMPTY_SET\",\n    \"EMPTY_TUPLE\",\n    \"EXT1\",\n    \"EXT2\",\n    \"EXT4\",\n    \"FALSE\",\n    \"FLOAT\",\n    \"FRAME\",\n    \"FROZENSET\",\n    \"GET\",\n    \"GLOBAL\",\n    \"HIGHEST_PROTOCOL\",\n    \"INST\",\n    \"INT\",\n    \"LIST\",\n    \"LONG\",\n    \"LONG1\",\n    \"LONG4\",\n    \"LONG_BINGET\",\n    \"LONG_BINPUT\",\n    \"MARK\",\n    \"MEMOIZE\",\n    \"NEWFALSE\",\n    \"NEWOBJ\",\n    \"NEWOBJ_EX\",\n    \"NEWTRUE\",\n    \"NONE\",\n    \"OBJ\",\n    \"PERSID\",\n    \"POP\",\n    \"POP_MARK\",\n    \"PROTO\",\n    \"PUT\",\n    \"REDUCE\",\n    \"SETITEM\",\n    \"SETITEMS\",\n    \"SHORT_BINBYTES\",\n    \"SHORT_BINSTRING\",\n    \"SHORT_BINUNICODE\",\n    \"STACK_GLOBAL\",\n    \"STOP\",\n    \"STRING\",\n    \"TRUE\",\n    \"TUPLE\",\n    \"TUPLE1\",\n    \"TUPLE2\",\n    \"TUPLE3\",\n    \"UNICODE\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"BYTEARRAY8\", \"NEXT_BUFFER\", \"PickleBuffer\", \"READONLY_BUFFER\"]\n\nHIGHEST_PROTOCOL: int\nDEFAULT_PROTOCOL: int\n\nbytes_types: tuple[type[Any], ...]  # undocumented\n\nclass _ReadableFileobj(Protocol):\n    def read(self, __n: int) -> bytes: ...\n    def readline(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @final\n    class PickleBuffer:\n        def __init__(self, buffer: ReadableBuffer) -> None: ...\n        def raw(self) -> memoryview: ...\n        def release(self) -> None: ...\n    _BufferCallback: TypeAlias = Callable[[PickleBuffer], Any] | None\n    def dump(\n        obj: Any,\n        file: SupportsWrite[bytes],\n        protocol: int | None = None,\n        *,\n        fix_imports: bool = True,\n        buffer_callback: _BufferCallback = None,\n    ) -> None: ...\n    def dumps(\n        obj: Any, protocol: int | None = None, *, fix_imports: bool = True, buffer_callback: _BufferCallback = None\n    ) -> bytes: ...\n    def load(\n        file: _ReadableFileobj,\n        *,\n        fix_imports: bool = True,\n        encoding: str = \"ASCII\",\n        errors: str = \"strict\",\n        buffers: Iterable[Any] | None = (),\n    ) -> Any: ...\n    def loads(\n        __data: ReadableBuffer,\n        *,\n        fix_imports: bool = True,\n        encoding: str = \"ASCII\",\n        errors: str = \"strict\",\n        buffers: Iterable[Any] | None = (),\n    ) -> Any: ...\n\nelse:\n    def dump(obj: Any, file: SupportsWrite[bytes], protocol: int | None = None, *, fix_imports: bool = True) -> None: ...\n    def dumps(obj: Any, protocol: int | None = None, *, fix_imports: bool = True) -> bytes: ...\n    def load(file: _ReadableFileobj, *, fix_imports: bool = True, encoding: str = \"ASCII\", errors: str = \"strict\") -> Any: ...\n    def loads(data: ReadableBuffer, *, fix_imports: bool = True, encoding: str = \"ASCII\", errors: str = \"strict\") -> Any: ...\n\nclass PickleError(Exception): ...\nclass PicklingError(PickleError): ...\nclass UnpicklingError(PickleError): ...\n\n_ReducedType: TypeAlias = (\n    str\n    | tuple[Callable[..., Any], tuple[Any, ...]]\n    | tuple[Callable[..., Any], tuple[Any, ...], Any]\n    | tuple[Callable[..., Any], tuple[Any, ...], Any, Iterator[Any] | None]\n    | tuple[Callable[..., Any], tuple[Any, ...], Any, Iterator[Any] | None, Iterator[Any] | None]\n)\n\nclass Pickler:\n    fast: bool\n    dispatch_table: Mapping[type, Callable[[Any], _ReducedType]]\n    bin: bool  # undocumented\n    dispatch: ClassVar[dict[type, Callable[[Unpickler, Any], None]]]  # undocumented, _Pickler only\n\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            file: SupportsWrite[bytes],\n            protocol: int | None = ...,\n            *,\n            fix_imports: bool = ...,\n            buffer_callback: _BufferCallback = ...,\n        ) -> None: ...\n        def reducer_override(self, obj: Any) -> Any: ...\n    else:\n        def __init__(self, file: SupportsWrite[bytes], protocol: int | None = ..., *, fix_imports: bool = ...) -> None: ...\n\n    def dump(self, __obj: Any) -> None: ...\n    def clear_memo(self) -> None: ...\n    def persistent_id(self, obj: Any) -> Any: ...\n\nclass Unpickler:\n    dispatch: ClassVar[dict[int, Callable[[Unpickler], None]]]  # undocumented, _Unpickler only\n\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            file: _ReadableFileobj,\n            *,\n            fix_imports: bool = ...,\n            encoding: str = ...,\n            errors: str = ...,\n            buffers: Iterable[Any] | None = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self, file: _ReadableFileobj, *, fix_imports: bool = ..., encoding: str = ..., errors: str = ...\n        ) -> None: ...\n\n    def load(self) -> Any: ...\n    def find_class(self, __module_name: str, __global_name: str) -> Any: ...\n    def persistent_load(self, pid: Any) -> Any: ...\n\nMARK: bytes\nSTOP: bytes\nPOP: bytes\nPOP_MARK: bytes\nDUP: bytes\nFLOAT: bytes\nINT: bytes\nBININT: bytes\nBININT1: bytes\nLONG: bytes\nBININT2: bytes\nNONE: bytes\nPERSID: bytes\nBINPERSID: bytes\nREDUCE: bytes\nSTRING: bytes\nBINSTRING: bytes\nSHORT_BINSTRING: bytes\nUNICODE: bytes\nBINUNICODE: bytes\nAPPEND: bytes\nBUILD: bytes\nGLOBAL: bytes\nDICT: bytes\nEMPTY_DICT: bytes\nAPPENDS: bytes\nGET: bytes\nBINGET: bytes\nINST: bytes\nLONG_BINGET: bytes\nLIST: bytes\nEMPTY_LIST: bytes\nOBJ: bytes\nPUT: bytes\nBINPUT: bytes\nLONG_BINPUT: bytes\nSETITEM: bytes\nTUPLE: bytes\nEMPTY_TUPLE: bytes\nSETITEMS: bytes\nBINFLOAT: bytes\n\nTRUE: bytes\nFALSE: bytes\n\n# protocol 2\nPROTO: bytes\nNEWOBJ: bytes\nEXT1: bytes\nEXT2: bytes\nEXT4: bytes\nTUPLE1: bytes\nTUPLE2: bytes\nTUPLE3: bytes\nNEWTRUE: bytes\nNEWFALSE: bytes\nLONG1: bytes\nLONG4: bytes\n\n# protocol 3\nBINBYTES: bytes\nSHORT_BINBYTES: bytes\n\n# protocol 4\nSHORT_BINUNICODE: bytes\nBINUNICODE8: bytes\nBINBYTES8: bytes\nEMPTY_SET: bytes\nADDITEMS: bytes\nFROZENSET: bytes\nNEWOBJ_EX: bytes\nSTACK_GLOBAL: bytes\nMEMOIZE: bytes\nFRAME: bytes\n\nif sys.version_info >= (3, 8):\n    # Protocol 5\n    BYTEARRAY8: bytes\n    NEXT_BUFFER: bytes\n    READONLY_BUFFER: bytes\n\ndef encode_long(x: int) -> bytes: ...  # undocumented\ndef decode_long(data: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer) -> int: ...  # undocumented\n\n# pure-Python implementations\n_Pickler = Pickler  # undocumented\n_Unpickler = Unpickler  # undocumented\n",
  "/typeshed/stdlib/pickletools.pyi": "from collections.abc import Callable, Iterator, MutableMapping\nfrom typing import IO, Any\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"dis\", \"genops\", \"optimize\"]\n\n_Reader: TypeAlias = Callable[[IO[bytes]], Any]\nbytes_types: tuple[type[Any], ...]\n\nUP_TO_NEWLINE: int\nTAKEN_FROM_ARGUMENT1: int\nTAKEN_FROM_ARGUMENT4: int\nTAKEN_FROM_ARGUMENT4U: int\nTAKEN_FROM_ARGUMENT8U: int\n\nclass ArgumentDescriptor:\n    name: str\n    n: int\n    reader: _Reader\n    doc: str\n    def __init__(self, name: str, n: int, reader: _Reader, doc: str) -> None: ...\n\ndef read_uint1(f: IO[bytes]) -> int: ...\n\nuint1: ArgumentDescriptor\n\ndef read_uint2(f: IO[bytes]) -> int: ...\n\nuint2: ArgumentDescriptor\n\ndef read_int4(f: IO[bytes]) -> int: ...\n\nint4: ArgumentDescriptor\n\ndef read_uint4(f: IO[bytes]) -> int: ...\n\nuint4: ArgumentDescriptor\n\ndef read_uint8(f: IO[bytes]) -> int: ...\n\nuint8: ArgumentDescriptor\n\ndef read_stringnl(f: IO[bytes], decode: bool = True, stripquotes: bool = True) -> bytes | str: ...\n\nstringnl: ArgumentDescriptor\n\ndef read_stringnl_noescape(f: IO[bytes]) -> str: ...\n\nstringnl_noescape: ArgumentDescriptor\n\ndef read_stringnl_noescape_pair(f: IO[bytes]) -> str: ...\n\nstringnl_noescape_pair: ArgumentDescriptor\n\ndef read_string1(f: IO[bytes]) -> str: ...\n\nstring1: ArgumentDescriptor\n\ndef read_string4(f: IO[bytes]) -> str: ...\n\nstring4: ArgumentDescriptor\n\ndef read_bytes1(f: IO[bytes]) -> bytes: ...\n\nbytes1: ArgumentDescriptor\n\ndef read_bytes4(f: IO[bytes]) -> bytes: ...\n\nbytes4: ArgumentDescriptor\n\ndef read_bytes8(f: IO[bytes]) -> bytes: ...\n\nbytes8: ArgumentDescriptor\n\ndef read_unicodestringnl(f: IO[bytes]) -> str: ...\n\nunicodestringnl: ArgumentDescriptor\n\ndef read_unicodestring1(f: IO[bytes]) -> str: ...\n\nunicodestring1: ArgumentDescriptor\n\ndef read_unicodestring4(f: IO[bytes]) -> str: ...\n\nunicodestring4: ArgumentDescriptor\n\ndef read_unicodestring8(f: IO[bytes]) -> str: ...\n\nunicodestring8: ArgumentDescriptor\n\ndef read_decimalnl_short(f: IO[bytes]) -> int: ...\ndef read_decimalnl_long(f: IO[bytes]) -> int: ...\n\ndecimalnl_short: ArgumentDescriptor\ndecimalnl_long: ArgumentDescriptor\n\ndef read_floatnl(f: IO[bytes]) -> float: ...\n\nfloatnl: ArgumentDescriptor\n\ndef read_float8(f: IO[bytes]) -> float: ...\n\nfloat8: ArgumentDescriptor\n\ndef read_long1(f: IO[bytes]) -> int: ...\n\nlong1: ArgumentDescriptor\n\ndef read_long4(f: IO[bytes]) -> int: ...\n\nlong4: ArgumentDescriptor\n\nclass StackObject:\n    name: str\n    obtype: type[Any] | tuple[type[Any], ...]\n    doc: str\n    def __init__(self, name: str, obtype: type[Any] | tuple[type[Any], ...], doc: str) -> None: ...\n\npyint: StackObject\npylong: StackObject\npyinteger_or_bool: StackObject\npybool: StackObject\npyfloat: StackObject\npybytes_or_str: StackObject\npystring: StackObject\npybytes: StackObject\npyunicode: StackObject\npynone: StackObject\npytuple: StackObject\npylist: StackObject\npydict: StackObject\npyset: StackObject\npyfrozenset: StackObject\nanyobject: StackObject\nmarkobject: StackObject\nstackslice: StackObject\n\nclass OpcodeInfo:\n    name: str\n    code: str\n    arg: ArgumentDescriptor | None\n    stack_before: list[StackObject]\n    stack_after: list[StackObject]\n    proto: int\n    doc: str\n    def __init__(\n        self,\n        name: str,\n        code: str,\n        arg: ArgumentDescriptor | None,\n        stack_before: list[StackObject],\n        stack_after: list[StackObject],\n        proto: int,\n        doc: str,\n    ) -> None: ...\n\nopcodes: list[OpcodeInfo]\n\ndef genops(pickle: bytes | bytearray | IO[bytes]) -> Iterator[tuple[OpcodeInfo, Any | None, int | None]]: ...\ndef optimize(p: bytes | bytearray | IO[bytes]) -> bytes: ...\ndef dis(\n    pickle: bytes | bytearray | IO[bytes],\n    out: IO[str] | None = None,\n    memo: MutableMapping[int, Any] | None = None,\n    indentlevel: int = 4,\n    annotate: int = 0,\n) -> None: ...\n",
  "/typeshed/stdlib/pipes.pyi": "import os\n\n__all__ = [\"Template\"]\n\nclass Template:\n    def reset(self) -> None: ...\n    def clone(self) -> Template: ...\n    def debug(self, flag: bool) -> None: ...\n    def append(self, cmd: str, kind: str) -> None: ...\n    def prepend(self, cmd: str, kind: str) -> None: ...\n    def open(self, file: str, rw: str) -> os._wrap_close: ...\n    def copy(self, infile: str, outfile: str) -> int: ...\n\n# Not documented, but widely used.\n# Documented as shlex.quote since 3.3.\ndef quote(s: str) -> str: ...\n",
  "/typeshed/stdlib/pkgutil.pyi": "import sys\nfrom _typeshed import SupportsRead\nfrom collections.abc import Callable, Iterable, Iterator\nfrom importlib.abc import Loader, MetaPathFinder, PathEntryFinder\nfrom typing import IO, Any, NamedTuple, TypeVar\n\n__all__ = [\n    \"get_importer\",\n    \"iter_importers\",\n    \"get_loader\",\n    \"find_loader\",\n    \"walk_packages\",\n    \"iter_modules\",\n    \"get_data\",\n    \"ImpImporter\",\n    \"ImpLoader\",\n    \"read_code\",\n    \"extend_path\",\n    \"ModuleInfo\",\n]\n\n_PathT = TypeVar(\"_PathT\", bound=Iterable[str])\n\nclass ModuleInfo(NamedTuple):\n    module_finder: MetaPathFinder | PathEntryFinder\n    name: str\n    ispkg: bool\n\ndef extend_path(path: _PathT, name: str) -> _PathT: ...\n\nclass ImpImporter:\n    def __init__(self, path: str | None = None) -> None: ...\n\nclass ImpLoader:\n    def __init__(self, fullname: str, file: IO[str], filename: str, etc: tuple[str, str, int]) -> None: ...\n\ndef find_loader(fullname: str) -> Loader | None: ...\ndef get_importer(path_item: str) -> PathEntryFinder | None: ...\ndef get_loader(module_or_name: str) -> Loader | None: ...\ndef iter_importers(fullname: str = \"\") -> Iterator[MetaPathFinder | PathEntryFinder]: ...\ndef iter_modules(path: Iterable[str] | None = None, prefix: str = \"\") -> Iterator[ModuleInfo]: ...\ndef read_code(stream: SupportsRead[bytes]) -> Any: ...  # undocumented\ndef walk_packages(\n    path: Iterable[str] | None = None, prefix: str = \"\", onerror: Callable[[str], object] | None = None\n) -> Iterator[ModuleInfo]: ...\ndef get_data(package: str, resource: str) -> bytes | None: ...\n\nif sys.version_info >= (3, 9):\n    def resolve_name(name: str) -> Any: ...\n",
  "/typeshed/stdlib/platform.pyi": "import sys\n\nif sys.version_info < (3, 8):\n    import os\n\n    DEV_NULL = os.devnull\nfrom typing import NamedTuple\n\nif sys.version_info >= (3, 8):\n    def libc_ver(executable: str | None = None, lib: str = \"\", version: str = \"\", chunksize: int = 16384) -> tuple[str, str]: ...\n\nelse:\n    def libc_ver(\n        executable: str = sys.executable, lib: str = \"\", version: str = \"\", chunksize: int = 16384\n    ) -> tuple[str, str]: ...\n\nif sys.version_info < (3, 8):\n    def linux_distribution(\n        distname: str = \"\",\n        version: str = \"\",\n        id: str = \"\",\n        supported_dists: tuple[str, ...] = ...,\n        full_distribution_name: bool = ...,\n    ) -> tuple[str, str, str]: ...\n    def dist(\n        distname: str = \"\", version: str = \"\", id: str = \"\", supported_dists: tuple[str, ...] = ...\n    ) -> tuple[str, str, str]: ...\n\ndef win32_ver(release: str = \"\", version: str = \"\", csd: str = \"\", ptype: str = \"\") -> tuple[str, str, str, str]: ...\n\nif sys.version_info >= (3, 8):\n    def win32_edition() -> str: ...\n    def win32_is_iot() -> bool: ...\n\ndef mac_ver(\n    release: str = \"\", versioninfo: tuple[str, str, str] = (\"\", \"\", \"\"), machine: str = \"\"\n) -> tuple[str, tuple[str, str, str], str]: ...\ndef java_ver(\n    release: str = \"\", vendor: str = \"\", vminfo: tuple[str, str, str] = (\"\", \"\", \"\"), osinfo: tuple[str, str, str] = (\"\", \"\", \"\")\n) -> tuple[str, str, tuple[str, str, str], tuple[str, str, str]]: ...\ndef system_alias(system: str, release: str, version: str) -> tuple[str, str, str]: ...\ndef architecture(executable: str = sys.executable, bits: str = \"\", linkage: str = \"\") -> tuple[str, str]: ...\n\nclass uname_result(NamedTuple):\n    system: str\n    node: str\n    release: str\n    version: str\n    machine: str\n    processor: str\n\ndef uname() -> uname_result: ...\ndef system() -> str: ...\ndef node() -> str: ...\ndef release() -> str: ...\ndef version() -> str: ...\ndef machine() -> str: ...\ndef processor() -> str: ...\ndef python_implementation() -> str: ...\ndef python_version() -> str: ...\ndef python_version_tuple() -> tuple[str, str, str]: ...\ndef python_branch() -> str: ...\ndef python_revision() -> str: ...\ndef python_build() -> tuple[str, str]: ...\ndef python_compiler() -> str: ...\ndef platform(aliased: bool = ..., terse: bool = ...) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def freedesktop_os_release() -> dict[str, str]: ...\n",
  "/typeshed/stdlib/plistlib.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Mapping, MutableMapping\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import IO, Any\nfrom typing_extensions import Self\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"InvalidFileException\", \"FMT_XML\", \"FMT_BINARY\", \"load\", \"dump\", \"loads\", \"dumps\", \"UID\"]\nelif sys.version_info >= (3, 8):\n    __all__ = [\n        \"readPlist\",\n        \"writePlist\",\n        \"readPlistFromBytes\",\n        \"writePlistToBytes\",\n        \"Data\",\n        \"InvalidFileException\",\n        \"FMT_XML\",\n        \"FMT_BINARY\",\n        \"load\",\n        \"dump\",\n        \"loads\",\n        \"dumps\",\n        \"UID\",\n    ]\nelse:\n    __all__ = [\n        \"readPlist\",\n        \"writePlist\",\n        \"readPlistFromBytes\",\n        \"writePlistToBytes\",\n        \"Data\",\n        \"InvalidFileException\",\n        \"FMT_XML\",\n        \"FMT_BINARY\",\n        \"load\",\n        \"dump\",\n        \"loads\",\n        \"dumps\",\n    ]\n\nclass PlistFormat(Enum):\n    FMT_XML: int\n    FMT_BINARY: int\n\nFMT_XML = PlistFormat.FMT_XML\nFMT_BINARY = PlistFormat.FMT_BINARY\n\nif sys.version_info >= (3, 9):\n    def load(fp: IO[bytes], *, fmt: PlistFormat | None = None, dict_type: type[MutableMapping[str, Any]] = ...) -> Any: ...\n    def loads(\n        value: ReadableBuffer, *, fmt: PlistFormat | None = None, dict_type: type[MutableMapping[str, Any]] = ...\n    ) -> Any: ...\n\nelse:\n    def load(\n        fp: IO[bytes],\n        *,\n        fmt: PlistFormat | None = None,\n        use_builtin_types: bool = True,\n        dict_type: type[MutableMapping[str, Any]] = ...,\n    ) -> Any: ...\n    def loads(\n        value: ReadableBuffer,\n        *,\n        fmt: PlistFormat | None = None,\n        use_builtin_types: bool = True,\n        dict_type: type[MutableMapping[str, Any]] = ...,\n    ) -> Any: ...\n\ndef dump(\n    value: Mapping[str, Any] | list[Any] | tuple[Any, ...] | str | bool | float | bytes | bytearray | datetime,\n    fp: IO[bytes],\n    *,\n    fmt: PlistFormat = ...,\n    sort_keys: bool = True,\n    skipkeys: bool = False,\n) -> None: ...\ndef dumps(\n    value: Mapping[str, Any] | list[Any] | tuple[Any, ...] | str | bool | float | bytes | bytearray | datetime,\n    *,\n    fmt: PlistFormat = ...,\n    skipkeys: bool = False,\n    sort_keys: bool = True,\n) -> bytes: ...\n\nif sys.version_info < (3, 9):\n    def readPlist(pathOrFile: str | IO[bytes]) -> Any: ...\n    def writePlist(value: Mapping[str, Any], pathOrFile: str | IO[bytes]) -> None: ...\n    def readPlistFromBytes(data: ReadableBuffer) -> Any: ...\n    def writePlistToBytes(value: Mapping[str, Any]) -> bytes: ...\n\nif sys.version_info < (3, 9):\n    class Data:\n        data: bytes\n        def __init__(self, data: bytes) -> None: ...\n\nif sys.version_info >= (3, 8):\n    class UID:\n        data: int\n        def __init__(self, data: int) -> None: ...\n        def __index__(self) -> int: ...\n        def __reduce__(self) -> tuple[type[Self], tuple[int]]: ...\n        def __eq__(self, other: object) -> bool: ...\n\nclass InvalidFileException(ValueError):\n    def __init__(self, message: str = \"Invalid file\") -> None: ...\n",
  "/typeshed/stdlib/poplib.pyi": "import socket\nimport ssl\nfrom builtins import list as _list  # conflicts with a method named \"list\"\nfrom re import Pattern\nfrom typing import Any, BinaryIO, NoReturn, overload\nfrom typing_extensions import Literal, TypeAlias\n\n__all__ = [\"POP3\", \"error_proto\", \"POP3_SSL\"]\n\n_LongResp: TypeAlias = tuple[bytes, list[bytes], int]\n\nclass error_proto(Exception): ...\n\nPOP3_PORT: Literal[110]\nPOP3_SSL_PORT: Literal[995]\nCR: Literal[b\"\\r\"]\nLF: Literal[b\"\\n\"]\nCRLF: Literal[b\"\\r\\n\"]\nHAVE_SSL: bool\n\nclass POP3:\n    encoding: str\n    host: str\n    port: int\n    sock: socket.socket\n    file: BinaryIO\n    welcome: bytes\n    def __init__(self, host: str, port: int = 110, timeout: float = ...) -> None: ...\n    def getwelcome(self) -> bytes: ...\n    def set_debuglevel(self, level: int) -> None: ...\n    def user(self, user: str) -> bytes: ...\n    def pass_(self, pswd: str) -> bytes: ...\n    def stat(self) -> tuple[int, int]: ...\n    def list(self, which: Any | None = None) -> _LongResp: ...\n    def retr(self, which: Any) -> _LongResp: ...\n    def dele(self, which: Any) -> bytes: ...\n    def noop(self) -> bytes: ...\n    def rset(self) -> bytes: ...\n    def quit(self) -> bytes: ...\n    def close(self) -> None: ...\n    def rpop(self, user: str) -> bytes: ...\n    timestamp: Pattern[str]\n    def apop(self, user: str, password: str) -> bytes: ...\n    def top(self, which: Any, howmuch: int) -> _LongResp: ...\n    @overload\n    def uidl(self) -> _LongResp: ...\n    @overload\n    def uidl(self, which: Any) -> bytes: ...\n    def utf8(self) -> bytes: ...\n    def capa(self) -> dict[str, _list[str]]: ...\n    def stls(self, context: ssl.SSLContext | None = None) -> bytes: ...\n\nclass POP3_SSL(POP3):\n    def __init__(\n        self,\n        host: str,\n        port: int = 995,\n        keyfile: str | None = None,\n        certfile: str | None = None,\n        timeout: float = ...,\n        context: ssl.SSLContext | None = None,\n    ) -> None: ...\n    # \"context\" is actually the last argument, but that breaks LSP and it doesn't really matter because all the arguments are ignored\n    def stls(self, context: Any = None, keyfile: Any = None, certfile: Any = None) -> NoReturn: ...\n",
  "/typeshed/stdlib/posix.pyi": "import sys\n\nif sys.platform != \"win32\":\n    # Actually defined here, but defining in os allows sharing code with windows\n    from os import (\n        CLD_CONTINUED as CLD_CONTINUED,\n        CLD_DUMPED as CLD_DUMPED,\n        CLD_EXITED as CLD_EXITED,\n        CLD_TRAPPED as CLD_TRAPPED,\n        EX_CANTCREAT as EX_CANTCREAT,\n        EX_CONFIG as EX_CONFIG,\n        EX_DATAERR as EX_DATAERR,\n        EX_IOERR as EX_IOERR,\n        EX_NOHOST as EX_NOHOST,\n        EX_NOINPUT as EX_NOINPUT,\n        EX_NOPERM as EX_NOPERM,\n        EX_NOTFOUND as EX_NOTFOUND,\n        EX_NOUSER as EX_NOUSER,\n        EX_OK as EX_OK,\n        EX_OSERR as EX_OSERR,\n        EX_OSFILE as EX_OSFILE,\n        EX_PROTOCOL as EX_PROTOCOL,\n        EX_SOFTWARE as EX_SOFTWARE,\n        EX_TEMPFAIL as EX_TEMPFAIL,\n        EX_UNAVAILABLE as EX_UNAVAILABLE,\n        EX_USAGE as EX_USAGE,\n        F_LOCK as F_LOCK,\n        F_OK as F_OK,\n        F_TEST as F_TEST,\n        F_TLOCK as F_TLOCK,\n        F_ULOCK as F_ULOCK,\n        O_APPEND as O_APPEND,\n        O_ASYNC as O_ASYNC,\n        O_CREAT as O_CREAT,\n        O_DIRECT as O_DIRECT,\n        O_DIRECTORY as O_DIRECTORY,\n        O_DSYNC as O_DSYNC,\n        O_EXCL as O_EXCL,\n        O_LARGEFILE as O_LARGEFILE,\n        O_NDELAY as O_NDELAY,\n        O_NOATIME as O_NOATIME,\n        O_NOCTTY as O_NOCTTY,\n        O_NOFOLLOW as O_NOFOLLOW,\n        O_NONBLOCK as O_NONBLOCK,\n        O_RDONLY as O_RDONLY,\n        O_RDWR as O_RDWR,\n        O_RSYNC as O_RSYNC,\n        O_SYNC as O_SYNC,\n        O_TRUNC as O_TRUNC,\n        O_WRONLY as O_WRONLY,\n        P_ALL as P_ALL,\n        P_PGID as P_PGID,\n        P_PID as P_PID,\n        PRIO_PGRP as PRIO_PGRP,\n        PRIO_PROCESS as PRIO_PROCESS,\n        PRIO_USER as PRIO_USER,\n        R_OK as R_OK,\n        RTLD_GLOBAL as RTLD_GLOBAL,\n        RTLD_LAZY as RTLD_LAZY,\n        RTLD_LOCAL as RTLD_LOCAL,\n        RTLD_NODELETE as RTLD_NODELETE,\n        RTLD_NOLOAD as RTLD_NOLOAD,\n        RTLD_NOW as RTLD_NOW,\n        SCHED_BATCH as SCHED_BATCH,\n        SCHED_FIFO as SCHED_FIFO,\n        SCHED_IDLE as SCHED_IDLE,\n        SCHED_OTHER as SCHED_OTHER,\n        SCHED_RESET_ON_FORK as SCHED_RESET_ON_FORK,\n        SCHED_RR as SCHED_RR,\n        SCHED_SPORADIC as SCHED_SPORADIC,\n        SEEK_DATA as SEEK_DATA,\n        SEEK_HOLE as SEEK_HOLE,\n        ST_NOSUID as ST_NOSUID,\n        ST_RDONLY as ST_RDONLY,\n        TMP_MAX as TMP_MAX,\n        W_OK as W_OK,\n        WCONTINUED as WCONTINUED,\n        WCOREDUMP as WCOREDUMP,\n        WEXITED as WEXITED,\n        WEXITSTATUS as WEXITSTATUS,\n        WIFCONTINUED as WIFCONTINUED,\n        WIFEXITED as WIFEXITED,\n        WIFSIGNALED as WIFSIGNALED,\n        WIFSTOPPED as WIFSTOPPED,\n        WNOHANG as WNOHANG,\n        WNOWAIT as WNOWAIT,\n        WSTOPPED as WSTOPPED,\n        WSTOPSIG as WSTOPSIG,\n        WTERMSIG as WTERMSIG,\n        WUNTRACED as WUNTRACED,\n        X_OK as X_OK,\n        DirEntry as DirEntry,\n        _exit as _exit,\n        abort as abort,\n        access as access,\n        chdir as chdir,\n        chmod as chmod,\n        chown as chown,\n        chroot as chroot,\n        close as close,\n        closerange as closerange,\n        confstr as confstr,\n        confstr_names as confstr_names,\n        cpu_count as cpu_count,\n        ctermid as ctermid,\n        device_encoding as device_encoding,\n        dup as dup,\n        dup2 as dup2,\n        error as error,\n        execv as execv,\n        execve as execve,\n        fchdir as fchdir,\n        fchmod as fchmod,\n        fchown as fchown,\n        fork as fork,\n        forkpty as forkpty,\n        fpathconf as fpathconf,\n        fspath as fspath,\n        fstat as fstat,\n        fstatvfs as fstatvfs,\n        fsync as fsync,\n        ftruncate as ftruncate,\n        get_blocking as get_blocking,\n        get_inheritable as get_inheritable,\n        get_terminal_size as get_terminal_size,\n        getcwd as getcwd,\n        getcwdb as getcwdb,\n        getegid as getegid,\n        geteuid as geteuid,\n        getgid as getgid,\n        getgrouplist as getgrouplist,\n        getgroups as getgroups,\n        getloadavg as getloadavg,\n        getlogin as getlogin,\n        getpgid as getpgid,\n        getpgrp as getpgrp,\n        getpid as getpid,\n        getppid as getppid,\n        getpriority as getpriority,\n        getsid as getsid,\n        getuid as getuid,\n        initgroups as initgroups,\n        isatty as isatty,\n        kill as kill,\n        killpg as killpg,\n        lchown as lchown,\n        link as link,\n        listdir as listdir,\n        lockf as lockf,\n        lseek as lseek,\n        lstat as lstat,\n        major as major,\n        makedev as makedev,\n        minor as minor,\n        mkdir as mkdir,\n        mkfifo as mkfifo,\n        mknod as mknod,\n        nice as nice,\n        open as open,\n        openpty as openpty,\n        pathconf as pathconf,\n        pathconf_names as pathconf_names,\n        pipe as pipe,\n        pread as pread,\n        putenv as putenv,\n        pwrite as pwrite,\n        read as read,\n        readlink as readlink,\n        readv as readv,\n        remove as remove,\n        rename as rename,\n        replace as replace,\n        rmdir as rmdir,\n        scandir as scandir,\n        sched_get_priority_max as sched_get_priority_max,\n        sched_get_priority_min as sched_get_priority_min,\n        sched_param as sched_param,\n        sched_yield as sched_yield,\n        sendfile as sendfile,\n        set_blocking as set_blocking,\n        set_inheritable as set_inheritable,\n        setegid as setegid,\n        seteuid as seteuid,\n        setgid as setgid,\n        setgroups as setgroups,\n        setpgid as setpgid,\n        setpgrp as setpgrp,\n        setpriority as setpriority,\n        setregid as setregid,\n        setreuid as setreuid,\n        setsid as setsid,\n        setuid as setuid,\n        stat as stat,\n        stat_result as stat_result,\n        statvfs as statvfs,\n        statvfs_result as statvfs_result,\n        strerror as strerror,\n        symlink as symlink,\n        sync as sync,\n        sysconf as sysconf,\n        sysconf_names as sysconf_names,\n        system as system,\n        tcgetpgrp as tcgetpgrp,\n        tcsetpgrp as tcsetpgrp,\n        terminal_size as terminal_size,\n        times as times,\n        times_result as times_result,\n        truncate as truncate,\n        ttyname as ttyname,\n        umask as umask,\n        uname as uname,\n        uname_result as uname_result,\n        unlink as unlink,\n        unsetenv as unsetenv,\n        urandom as urandom,\n        utime as utime,\n        wait as wait,\n        wait3 as wait3,\n        wait4 as wait4,\n        waitpid as waitpid,\n        write as write,\n        writev as writev,\n    )\n\n    if sys.platform == \"linux\":\n        from os import (\n            GRND_NONBLOCK as GRND_NONBLOCK,\n            GRND_RANDOM as GRND_RANDOM,\n            RTLD_DEEPBIND as RTLD_DEEPBIND,\n            XATTR_CREATE as XATTR_CREATE,\n            XATTR_REPLACE as XATTR_REPLACE,\n            XATTR_SIZE_MAX as XATTR_SIZE_MAX,\n            getrandom as getrandom,\n            getxattr as getxattr,\n            listxattr as listxattr,\n            removexattr as removexattr,\n            setxattr as setxattr,\n        )\n    else:\n        from os import chflags as chflags, lchflags as lchflags, lchmod as lchmod\n\n    if sys.platform != \"darwin\":\n        from os import (\n            POSIX_FADV_DONTNEED as POSIX_FADV_DONTNEED,\n            POSIX_FADV_NOREUSE as POSIX_FADV_NOREUSE,\n            POSIX_FADV_NORMAL as POSIX_FADV_NORMAL,\n            POSIX_FADV_RANDOM as POSIX_FADV_RANDOM,\n            POSIX_FADV_SEQUENTIAL as POSIX_FADV_SEQUENTIAL,\n            POSIX_FADV_WILLNEED as POSIX_FADV_WILLNEED,\n            fdatasync as fdatasync,\n            getresgid as getresgid,\n            getresuid as getresuid,\n            pipe2 as pipe2,\n            posix_fadvise as posix_fadvise,\n            posix_fallocate as posix_fallocate,\n            sched_getaffinity as sched_getaffinity,\n            sched_getparam as sched_getparam,\n            sched_getscheduler as sched_getscheduler,\n            sched_rr_get_interval as sched_rr_get_interval,\n            sched_setaffinity as sched_setaffinity,\n            sched_setparam as sched_setparam,\n            sched_setscheduler as sched_setscheduler,\n            setresgid as setresgid,\n            setresuid as setresuid,\n            waitid as waitid,\n            waitid_result as waitid_result,\n        )\n\n        if sys.version_info >= (3, 10):\n            from os import RWF_APPEND as RWF_APPEND\n\n    if sys.version_info >= (3, 11):\n        from os import login_tty as login_tty\n\n    if sys.version_info >= (3, 9):\n        from os import CLD_KILLED as CLD_KILLED, CLD_STOPPED as CLD_STOPPED, waitstatus_to_exitcode as waitstatus_to_exitcode\n\n        if sys.platform == \"linux\":\n            from os import P_PIDFD as P_PIDFD, pidfd_open as pidfd_open\n\n    if sys.version_info >= (3, 8):\n        from os import (\n            POSIX_SPAWN_CLOSE as POSIX_SPAWN_CLOSE,\n            POSIX_SPAWN_DUP2 as POSIX_SPAWN_DUP2,\n            POSIX_SPAWN_OPEN as POSIX_SPAWN_OPEN,\n            posix_spawn as posix_spawn,\n            posix_spawnp as posix_spawnp,\n        )\n\n        if sys.platform == \"linux\":\n            from os import (\n                MFD_ALLOW_SEALING as MFD_ALLOW_SEALING,\n                MFD_CLOEXEC as MFD_CLOEXEC,\n                MFD_HUGE_1GB as MFD_HUGE_1GB,\n                MFD_HUGE_1MB as MFD_HUGE_1MB,\n                MFD_HUGE_2GB as MFD_HUGE_2GB,\n                MFD_HUGE_2MB as MFD_HUGE_2MB,\n                MFD_HUGE_8MB as MFD_HUGE_8MB,\n                MFD_HUGE_16GB as MFD_HUGE_16GB,\n                MFD_HUGE_16MB as MFD_HUGE_16MB,\n                MFD_HUGE_32MB as MFD_HUGE_32MB,\n                MFD_HUGE_64KB as MFD_HUGE_64KB,\n                MFD_HUGE_256MB as MFD_HUGE_256MB,\n                MFD_HUGE_512KB as MFD_HUGE_512KB,\n                MFD_HUGE_512MB as MFD_HUGE_512MB,\n                MFD_HUGE_MASK as MFD_HUGE_MASK,\n                MFD_HUGE_SHIFT as MFD_HUGE_SHIFT,\n                MFD_HUGETLB as MFD_HUGETLB,\n                copy_file_range as copy_file_range,\n                memfd_create as memfd_create,\n            )\n    from os import preadv as preadv, pwritev as pwritev, register_at_fork as register_at_fork\n\n    if sys.platform != \"darwin\":\n        from os import RWF_DSYNC as RWF_DSYNC, RWF_HIPRI as RWF_HIPRI, RWF_NOWAIT as RWF_NOWAIT, RWF_SYNC as RWF_SYNC\n\n    # Not same as os.environ or os.environb\n    # Because of this variable, we can't do \"from posix import *\" in os/__init__.pyi\n    environ: dict[bytes, bytes]\n",
  "/typeshed/stdlib/posixpath.pyi": "import sys\nfrom _typeshed import AnyOrLiteralStr, BytesPath, FileDescriptorOrPath, StrOrBytesPath, StrPath\nfrom collections.abc import Sequence\nfrom genericpath import (\n    commonprefix as commonprefix,\n    exists as exists,\n    getatime as getatime,\n    getctime as getctime,\n    getmtime as getmtime,\n    getsize as getsize,\n    isdir as isdir,\n    isfile as isfile,\n    samefile as samefile,\n    sameopenfile as sameopenfile,\n    samestat as samestat,\n)\nfrom os import PathLike\nfrom typing import AnyStr, overload\nfrom typing_extensions import LiteralString\n\n__all__ = [\n    \"normcase\",\n    \"isabs\",\n    \"join\",\n    \"splitdrive\",\n    \"split\",\n    \"splitext\",\n    \"basename\",\n    \"dirname\",\n    \"commonprefix\",\n    \"getsize\",\n    \"getmtime\",\n    \"getatime\",\n    \"getctime\",\n    \"islink\",\n    \"exists\",\n    \"lexists\",\n    \"isdir\",\n    \"isfile\",\n    \"ismount\",\n    \"expanduser\",\n    \"expandvars\",\n    \"normpath\",\n    \"abspath\",\n    \"samefile\",\n    \"sameopenfile\",\n    \"samestat\",\n    \"curdir\",\n    \"pardir\",\n    \"sep\",\n    \"pathsep\",\n    \"defpath\",\n    \"altsep\",\n    \"extsep\",\n    \"devnull\",\n    \"realpath\",\n    \"supports_unicode_filenames\",\n    \"relpath\",\n    \"commonpath\",\n]\n\nsupports_unicode_filenames: bool\n# aliases (also in os)\ncurdir: LiteralString\npardir: LiteralString\nsep: LiteralString\naltsep: LiteralString | None\nextsep: LiteralString\npathsep: LiteralString\ndefpath: LiteralString\ndevnull: LiteralString\n\n# Overloads are necessary to work around python/mypy#3644.\n@overload\ndef abspath(path: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef abspath(path: AnyStr) -> AnyStr: ...\n@overload\ndef basename(p: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef basename(p: AnyOrLiteralStr) -> AnyOrLiteralStr: ...\n@overload\ndef dirname(p: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef dirname(p: AnyOrLiteralStr) -> AnyOrLiteralStr: ...\n@overload\ndef expanduser(path: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef expanduser(path: AnyStr) -> AnyStr: ...\n@overload\ndef expandvars(path: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef expandvars(path: AnyStr) -> AnyStr: ...\n@overload\ndef normcase(s: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef normcase(s: AnyOrLiteralStr) -> AnyOrLiteralStr: ...\n@overload\ndef normpath(path: PathLike[AnyStr]) -> AnyStr: ...\n@overload\ndef normpath(path: AnyOrLiteralStr) -> AnyOrLiteralStr: ...\n@overload\ndef commonpath(paths: Sequence[LiteralString]) -> LiteralString: ...\n@overload\ndef commonpath(paths: Sequence[StrPath]) -> str: ...\n@overload\ndef commonpath(paths: Sequence[BytesPath]) -> bytes: ...\n\n# First parameter is not actually pos-only,\n# but must be defined as pos-only in the stub or cross-platform code doesn't type-check,\n# as the parameter name is different in ntpath.join()\n@overload\ndef join(__a: LiteralString, *paths: LiteralString) -> LiteralString: ...\n@overload\ndef join(__a: StrPath, *paths: StrPath) -> str: ...\n@overload\ndef join(__a: BytesPath, *paths: BytesPath) -> bytes: ...\n\nif sys.version_info >= (3, 10):\n    @overload\n    def realpath(filename: PathLike[AnyStr], *, strict: bool = False) -> AnyStr: ...\n    @overload\n    def realpath(filename: AnyStr, *, strict: bool = False) -> AnyStr: ...\n\nelse:\n    @overload\n    def realpath(filename: PathLike[AnyStr]) -> AnyStr: ...\n    @overload\n    def realpath(filename: AnyStr) -> AnyStr: ...\n\n@overload\ndef relpath(path: LiteralString, start: LiteralString | None = None) -> LiteralString: ...\n@overload\ndef relpath(path: BytesPath, start: BytesPath | None = None) -> bytes: ...\n@overload\ndef relpath(path: StrPath, start: StrPath | None = None) -> str: ...\n@overload\ndef split(p: PathLike[AnyStr]) -> tuple[AnyStr, AnyStr]: ...\n@overload\ndef split(p: AnyOrLiteralStr) -> tuple[AnyOrLiteralStr, AnyOrLiteralStr]: ...\n@overload\ndef splitdrive(p: PathLike[AnyStr]) -> tuple[AnyStr, AnyStr]: ...\n@overload\ndef splitdrive(p: AnyOrLiteralStr) -> tuple[AnyOrLiteralStr, AnyOrLiteralStr]: ...\n@overload\ndef splitext(p: PathLike[AnyStr]) -> tuple[AnyStr, AnyStr]: ...\n@overload\ndef splitext(p: AnyOrLiteralStr) -> tuple[AnyOrLiteralStr, AnyOrLiteralStr]: ...\ndef isabs(s: StrOrBytesPath) -> bool: ...\ndef islink(path: FileDescriptorOrPath) -> bool: ...\ndef ismount(path: FileDescriptorOrPath) -> bool: ...\ndef lexists(path: FileDescriptorOrPath) -> bool: ...\n",
  "/typeshed/stdlib/pprint.pyi": "import sys\nfrom typing import IO\n\nif sys.version_info >= (3, 8):\n    __all__ = [\"pprint\", \"pformat\", \"isreadable\", \"isrecursive\", \"saferepr\", \"PrettyPrinter\", \"pp\"]\nelse:\n    __all__ = [\"pprint\", \"pformat\", \"isreadable\", \"isrecursive\", \"saferepr\", \"PrettyPrinter\"]\n\nif sys.version_info >= (3, 10):\n    def pformat(\n        object: object,\n        indent: int = 1,\n        width: int = 80,\n        depth: int | None = None,\n        *,\n        compact: bool = False,\n        sort_dicts: bool = True,\n        underscore_numbers: bool = False,\n    ) -> str: ...\n\nelif sys.version_info >= (3, 8):\n    def pformat(\n        object: object,\n        indent: int = 1,\n        width: int = 80,\n        depth: int | None = None,\n        *,\n        compact: bool = False,\n        sort_dicts: bool = True,\n    ) -> str: ...\n\nelse:\n    def pformat(object: object, indent: int = 1, width: int = 80, depth: int | None = None, *, compact: bool = False) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def pp(\n        object: object,\n        stream: IO[str] | None = ...,\n        indent: int = ...,\n        width: int = ...,\n        depth: int | None = ...,\n        *,\n        compact: bool = ...,\n        sort_dicts: bool = False,\n        underscore_numbers: bool = ...,\n    ) -> None: ...\n\nelif sys.version_info >= (3, 8):\n    def pp(\n        object: object,\n        stream: IO[str] | None = ...,\n        indent: int = ...,\n        width: int = ...,\n        depth: int | None = ...,\n        *,\n        compact: bool = ...,\n        sort_dicts: bool = False,\n    ) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def pprint(\n        object: object,\n        stream: IO[str] | None = None,\n        indent: int = 1,\n        width: int = 80,\n        depth: int | None = None,\n        *,\n        compact: bool = False,\n        sort_dicts: bool = True,\n        underscore_numbers: bool = False,\n    ) -> None: ...\n\nelif sys.version_info >= (3, 8):\n    def pprint(\n        object: object,\n        stream: IO[str] | None = None,\n        indent: int = 1,\n        width: int = 80,\n        depth: int | None = None,\n        *,\n        compact: bool = False,\n        sort_dicts: bool = True,\n    ) -> None: ...\n\nelse:\n    def pprint(\n        object: object,\n        stream: IO[str] | None = None,\n        indent: int = 1,\n        width: int = 80,\n        depth: int | None = None,\n        *,\n        compact: bool = False,\n    ) -> None: ...\n\ndef isreadable(object: object) -> bool: ...\ndef isrecursive(object: object) -> bool: ...\ndef saferepr(object: object) -> str: ...\n\nclass PrettyPrinter:\n    if sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            indent: int = 1,\n            width: int = 80,\n            depth: int | None = None,\n            stream: IO[str] | None = None,\n            *,\n            compact: bool = False,\n            sort_dicts: bool = True,\n            underscore_numbers: bool = False,\n        ) -> None: ...\n    elif sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            indent: int = 1,\n            width: int = 80,\n            depth: int | None = None,\n            stream: IO[str] | None = None,\n            *,\n            compact: bool = False,\n            sort_dicts: bool = True,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            indent: int = 1,\n            width: int = 80,\n            depth: int | None = None,\n            stream: IO[str] | None = None,\n            *,\n            compact: bool = False,\n        ) -> None: ...\n\n    def pformat(self, object: object) -> str: ...\n    def pprint(self, object: object) -> None: ...\n    def isreadable(self, object: object) -> bool: ...\n    def isrecursive(self, object: object) -> bool: ...\n    def format(self, object: object, context: dict[int, int], maxlevels: int, level: int) -> tuple[str, bool, bool]: ...\n",
  "/typeshed/stdlib/profile.pyi": "from _typeshed import StrOrBytesPath\nfrom collections.abc import Callable\nfrom typing import Any, TypeVar\nfrom typing_extensions import ParamSpec, Self, TypeAlias\n\n__all__ = [\"run\", \"runctx\", \"Profile\"]\n\ndef run(statement: str, filename: str | None = None, sort: str | int = -1) -> None: ...\ndef runctx(\n    statement: str, globals: dict[str, Any], locals: dict[str, Any], filename: str | None = None, sort: str | int = -1\n) -> None: ...\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n_Label: TypeAlias = tuple[str, int, str]\n\nclass Profile:\n    bias: int\n    stats: dict[_Label, tuple[int, int, int, int, dict[_Label, tuple[int, int, int, int]]]]  # undocumented\n    def __init__(self, timer: Callable[[], float] | None = None, bias: int | None = None) -> None: ...\n    def set_cmd(self, cmd: str) -> None: ...\n    def simulate_call(self, name: str) -> None: ...\n    def simulate_cmd_complete(self) -> None: ...\n    def print_stats(self, sort: str | int = -1) -> None: ...\n    def dump_stats(self, file: StrOrBytesPath) -> None: ...\n    def create_stats(self) -> None: ...\n    def snapshot_stats(self) -> None: ...\n    def run(self, cmd: str) -> Self: ...\n    def runctx(self, cmd: str, globals: dict[str, Any], locals: dict[str, Any]) -> Self: ...\n    def runcall(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...\n    def calibrate(self, m: int, verbose: int = 0) -> float: ...\n",
  "/typeshed/stdlib/pstats.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Iterable\nfrom cProfile import Profile as _cProfile\nfrom enum import Enum\nfrom profile import Profile\nfrom typing import IO, Any, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"Stats\", \"SortKey\", \"FunctionProfile\", \"StatsProfile\"]\nelse:\n    __all__ = [\"Stats\", \"SortKey\"]\n\n_Selector: TypeAlias = str | float | int\n\nclass SortKey(str, Enum):\n    CALLS: str\n    CUMULATIVE: str\n    FILENAME: str\n    LINE: str\n    NAME: str\n    NFL: str\n    PCALLS: str\n    STDNAME: str\n    TIME: str\n\nif sys.version_info >= (3, 9):\n    from dataclasses import dataclass\n\n    @dataclass(unsafe_hash=True)\n    class FunctionProfile:\n        ncalls: str\n        tottime: float\n        percall_tottime: float\n        cumtime: float\n        percall_cumtime: float\n        file_name: str\n        line_number: int\n    @dataclass(unsafe_hash=True)\n    class StatsProfile:\n        total_tt: float\n        func_profiles: dict[str, FunctionProfile]\n\n_SortArgDict: TypeAlias = dict[str, tuple[tuple[tuple[int, int], ...], str]]\n\nclass Stats:\n    sort_arg_dict_default: _SortArgDict\n    def __init__(\n        self,\n        __arg: None | str | Profile | _cProfile = ...,\n        *args: None | str | Profile | _cProfile | Self,\n        stream: IO[Any] | None = None,\n    ) -> None: ...\n    def init(self, arg: None | str | Profile | _cProfile) -> None: ...\n    def load_stats(self, arg: None | str | Profile | _cProfile) -> None: ...\n    def get_top_level_stats(self) -> None: ...\n    def add(self, *arg_list: None | str | Profile | _cProfile | Self) -> Self: ...\n    def dump_stats(self, filename: StrOrBytesPath) -> None: ...\n    def get_sort_arg_defs(self) -> _SortArgDict: ...\n    @overload\n    def sort_stats(self, field: Literal[-1, 0, 1, 2]) -> Self: ...\n    @overload\n    def sort_stats(self, *field: str) -> Self: ...\n    def reverse_order(self) -> Self: ...\n    def strip_dirs(self) -> Self: ...\n    def calc_callees(self) -> None: ...\n    def eval_print_amount(self, sel: _Selector, list: list[str], msg: str) -> tuple[list[str], str]: ...\n    if sys.version_info >= (3, 9):\n        def get_stats_profile(self) -> StatsProfile: ...\n\n    def get_print_list(self, sel_list: Iterable[_Selector]) -> tuple[int, list[str]]: ...\n    def print_stats(self, *amount: _Selector) -> Self: ...\n    def print_callees(self, *amount: _Selector) -> Self: ...\n    def print_callers(self, *amount: _Selector) -> Self: ...\n    def print_call_heading(self, name_size: int, column_title: str) -> None: ...\n    def print_call_line(self, name_size: int, source: str, call_dict: dict[str, Any], arrow: str = \"->\") -> None: ...\n    def print_title(self) -> None: ...\n    def print_line(self, func: str) -> None: ...\n",
  "/typeshed/stdlib/pty.pyi": "import sys\nfrom collections.abc import Callable, Iterable\nfrom typing_extensions import Literal, TypeAlias\n\nif sys.platform != \"win32\":\n    __all__ = [\"openpty\", \"fork\", \"spawn\"]\n    _Reader: TypeAlias = Callable[[int], bytes]\n\n    STDIN_FILENO: Literal[0]\n    STDOUT_FILENO: Literal[1]\n    STDERR_FILENO: Literal[2]\n\n    CHILD: Literal[0]\n    def openpty() -> tuple[int, int]: ...\n    def master_open() -> tuple[int, str]: ...  # deprecated, use openpty()\n    def slave_open(tty_name: str) -> int: ...  # deprecated, use openpty()\n    def fork() -> tuple[int, int]: ...\n    def spawn(argv: str | Iterable[str], master_read: _Reader = ..., stdin_read: _Reader = ...) -> int: ...\n",
  "/typeshed/stdlib/pwd.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import Any\nfrom typing_extensions import Final, final\n\nif sys.platform != \"win32\":\n    @final\n    class struct_passwd(structseq[Any], tuple[str, str, int, int, str, str, str]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\"pw_name\", \"pw_passwd\", \"pw_uid\", \"pw_gid\", \"pw_gecos\", \"pw_dir\", \"pw_shell\")\n        @property\n        def pw_name(self) -> str: ...\n        @property\n        def pw_passwd(self) -> str: ...\n        @property\n        def pw_uid(self) -> int: ...\n        @property\n        def pw_gid(self) -> int: ...\n        @property\n        def pw_gecos(self) -> str: ...\n        @property\n        def pw_dir(self) -> str: ...\n        @property\n        def pw_shell(self) -> str: ...\n\n    def getpwall() -> list[struct_passwd]: ...\n    def getpwuid(__uid: int) -> struct_passwd: ...\n    def getpwnam(__name: str) -> struct_passwd: ...\n",
  "/typeshed/stdlib/py_compile.pyi": "import enum\nimport sys\nfrom typing import AnyStr\n\n__all__ = [\"compile\", \"main\", \"PyCompileError\", \"PycInvalidationMode\"]\n\nclass PyCompileError(Exception):\n    exc_type_name: str\n    exc_value: BaseException\n    file: str\n    msg: str\n    def __init__(self, exc_type: type[BaseException], exc_value: BaseException, file: str, msg: str = \"\") -> None: ...\n\nclass PycInvalidationMode(enum.Enum):\n    TIMESTAMP: int\n    CHECKED_HASH: int\n    UNCHECKED_HASH: int\n\ndef _get_default_invalidation_mode() -> PycInvalidationMode: ...\n\nif sys.version_info >= (3, 8):\n    def compile(\n        file: AnyStr,\n        cfile: AnyStr | None = None,\n        dfile: AnyStr | None = None,\n        doraise: bool = False,\n        optimize: int = -1,\n        invalidation_mode: PycInvalidationMode | None = None,\n        quiet: int = 0,\n    ) -> AnyStr | None: ...\n\nelse:\n    def compile(\n        file: AnyStr,\n        cfile: AnyStr | None = None,\n        dfile: AnyStr | None = None,\n        doraise: bool = False,\n        optimize: int = -1,\n        invalidation_mode: PycInvalidationMode | None = None,\n    ) -> AnyStr | None: ...\n\nif sys.version_info >= (3, 10):\n    def main() -> None: ...\n\nelse:\n    def main(args: list[str] | None = None) -> int: ...\n",
  "/typeshed/stdlib/pyclbr.pyi": "import sys\nfrom collections.abc import Sequence\n\n__all__ = [\"readmodule\", \"readmodule_ex\", \"Class\", \"Function\"]\n\nclass Class:\n    module: str\n    name: str\n    super: list[Class | str] | None\n    methods: dict[str, int]\n    file: int\n    lineno: int\n\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n\n    parent: Class | None\n    children: dict[str, Class | Function]\n\n    if sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            module: str,\n            name: str,\n            super_: list[Class | str] | None,\n            file: str,\n            lineno: int,\n            parent: Class | None = None,\n            *,\n            end_lineno: int | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self, module: str, name: str, super: list[Class | str] | None, file: str, lineno: int, parent: Class | None = None\n        ) -> None: ...\n\nclass Function:\n    module: str\n    name: str\n    file: int\n    lineno: int\n\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        is_async: bool\n\n    parent: Function | Class | None\n    children: dict[str, Class | Function]\n\n    if sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            module: str,\n            name: str,\n            file: str,\n            lineno: int,\n            parent: Function | Class | None = None,\n            is_async: bool = False,\n            *,\n            end_lineno: int | None = None,\n        ) -> None: ...\n    else:\n        def __init__(self, module: str, name: str, file: str, lineno: int, parent: Function | Class | None = None) -> None: ...\n\ndef readmodule(module: str, path: Sequence[str] | None = None) -> dict[str, Class]: ...\ndef readmodule_ex(module: str, path: Sequence[str] | None = None) -> dict[str, Class | Function | list[str]]: ...\n",
  "/typeshed/stdlib/pydoc.pyi": "import sys\nfrom _typeshed import OptExcInfo, SupportsWrite\nfrom abc import abstractmethod\nfrom builtins import list as _list  # \"list\" conflicts with method name\nfrom collections.abc import Callable, Container, Mapping, MutableMapping\nfrom reprlib import Repr\nfrom types import MethodType, ModuleType, TracebackType\nfrom typing import IO, Any, AnyStr, NoReturn, TypeVar\nfrom typing_extensions import Final, TypeGuard\n\n__all__ = [\"help\"]\n\n_T = TypeVar(\"_T\")\n\n__author__: Final[str]\n__date__: Final[str]\n__version__: Final[str]\n__credits__: Final[str]\n\ndef pathdirs() -> list[str]: ...\ndef getdoc(object: object) -> str: ...\ndef splitdoc(doc: AnyStr) -> tuple[AnyStr, AnyStr]: ...\ndef classname(object: object, modname: str) -> str: ...\ndef isdata(object: object) -> bool: ...\ndef replace(text: AnyStr, *pairs: AnyStr) -> AnyStr: ...\ndef cram(text: str, maxlen: int) -> str: ...\ndef stripid(text: str) -> str: ...\ndef allmethods(cl: type) -> MutableMapping[str, MethodType]: ...\ndef visiblename(name: str, all: Container[str] | None = None, obj: object = None) -> bool: ...\ndef classify_class_attrs(object: object) -> list[tuple[str, str, type, str]]: ...\ndef ispackage(path: str) -> bool: ...\ndef source_synopsis(file: IO[AnyStr]) -> AnyStr | None: ...\ndef synopsis(filename: str, cache: MutableMapping[str, tuple[int, str]] = {}) -> str | None: ...\n\nclass ErrorDuringImport(Exception):\n    filename: str\n    exc: type[BaseException] | None\n    value: BaseException | None\n    tb: TracebackType | None\n    def __init__(self, filename: str, exc_info: OptExcInfo) -> None: ...\n\ndef importfile(path: str) -> ModuleType: ...\ndef safeimport(path: str, forceload: bool = ..., cache: MutableMapping[str, ModuleType] = {}) -> ModuleType | None: ...\n\nclass Doc:\n    PYTHONDOCS: str\n    def document(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    def fail(self, object: object, name: str | None = None, *args: Any) -> NoReturn: ...\n    @abstractmethod\n    def docmodule(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    @abstractmethod\n    def docclass(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    @abstractmethod\n    def docroutine(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    @abstractmethod\n    def docother(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    @abstractmethod\n    def docproperty(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    @abstractmethod\n    def docdata(self, object: object, name: str | None = None, *args: Any) -> str: ...\n    def getdocloc(self, object: object, basedir: str = ...) -> str | None: ...\n\nclass HTMLRepr(Repr):\n    def escape(self, text: str) -> str: ...\n    def repr(self, object: object) -> str: ...\n    def repr1(self, x: object, level: complex) -> str: ...\n    def repr_string(self, x: str, level: complex) -> str: ...\n    def repr_str(self, x: str, level: complex) -> str: ...\n    def repr_instance(self, x: object, level: complex) -> str: ...\n    def repr_unicode(self, x: AnyStr, level: complex) -> str: ...\n\nclass HTMLDoc(Doc):\n    _repr_instance: HTMLRepr\n    repr = _repr_instance.repr\n    escape = _repr_instance.escape\n    def page(self, title: str, contents: str) -> str: ...\n    if sys.version_info >= (3, 11):\n        def heading(self, title: str, extras: str = \"\") -> str: ...\n        def section(\n            self,\n            title: str,\n            cls: str,\n            contents: str,\n            width: int = 6,\n            prelude: str = \"\",\n            marginalia: str | None = None,\n            gap: str = \"&nbsp;\",\n        ) -> str: ...\n        def multicolumn(self, list: list[_T], format: Callable[[_T], str]) -> str: ...\n    else:\n        def heading(self, title: str, fgcol: str, bgcol: str, extras: str = \"\") -> str: ...\n        def section(\n            self,\n            title: str,\n            fgcol: str,\n            bgcol: str,\n            contents: str,\n            width: int = 6,\n            prelude: str = \"\",\n            marginalia: str | None = None,\n            gap: str = \"&nbsp;\",\n        ) -> str: ...\n        def multicolumn(self, list: list[_T], format: Callable[[_T], str], cols: int = 4) -> str: ...\n\n    def bigsection(self, title: str, *args: Any) -> str: ...\n    def preformat(self, text: str) -> str: ...\n    def grey(self, text: str) -> str: ...\n    def namelink(self, name: str, *dicts: MutableMapping[str, str]) -> str: ...\n    def classlink(self, object: object, modname: str) -> str: ...\n    def modulelink(self, object: object) -> str: ...\n    def modpkglink(self, modpkginfo: tuple[str, str, bool, bool]) -> str: ...\n    def markup(\n        self,\n        text: str,\n        escape: Callable[[str], str] | None = None,\n        funcs: Mapping[str, str] = {},\n        classes: Mapping[str, str] = {},\n        methods: Mapping[str, str] = {},\n    ) -> str: ...\n    def formattree(\n        self, tree: list[tuple[type, tuple[type, ...]] | list[Any]], modname: str, parent: type | None = None\n    ) -> str: ...\n    def docmodule(self, object: object, name: str | None = None, mod: str | None = None, *ignored: Any) -> str: ...\n    def docclass(\n        self,\n        object: object,\n        name: str | None = None,\n        mod: str | None = None,\n        funcs: Mapping[str, str] = {},\n        classes: Mapping[str, str] = {},\n        *ignored: Any,\n    ) -> str: ...\n    def formatvalue(self, object: object) -> str: ...\n    def docroutine(  # type: ignore[override]\n        self,\n        object: object,\n        name: str | None = None,\n        mod: str | None = None,\n        funcs: Mapping[str, str] = {},\n        classes: Mapping[str, str] = {},\n        methods: Mapping[str, str] = {},\n        cl: type | None = None,\n    ) -> str: ...\n    def docproperty(self, object: object, name: str | None = None, mod: str | None = None, cl: Any | None = None) -> str: ...  # type: ignore[override]\n    def docother(self, object: object, name: str | None = None, mod: Any | None = None, *ignored: Any) -> str: ...\n    def docdata(self, object: object, name: str | None = None, mod: Any | None = None, cl: Any | None = None) -> str: ...  # type: ignore[override]\n    def index(self, dir: str, shadowed: MutableMapping[str, bool] | None = None) -> str: ...\n    def filelink(self, url: str, path: str) -> str: ...\n\nclass TextRepr(Repr):\n    def repr1(self, x: object, level: complex) -> str: ...\n    def repr_string(self, x: str, level: complex) -> str: ...\n    def repr_str(self, x: str, level: complex) -> str: ...\n    def repr_instance(self, x: object, level: complex) -> str: ...\n\nclass TextDoc(Doc):\n    _repr_instance: TextRepr\n    repr = _repr_instance.repr\n    def bold(self, text: str) -> str: ...\n    def indent(self, text: str, prefix: str = \"    \") -> str: ...\n    def section(self, title: str, contents: str) -> str: ...\n    def formattree(\n        self, tree: list[tuple[type, tuple[type, ...]] | list[Any]], modname: str, parent: type | None = None, prefix: str = \"\"\n    ) -> str: ...\n    def docmodule(self, object: object, name: str | None = None, mod: Any | None = None) -> str: ...  # type: ignore[override]\n    def docclass(self, object: object, name: str | None = None, mod: str | None = None, *ignored: Any) -> str: ...\n    def formatvalue(self, object: object) -> str: ...\n    def docroutine(self, object: object, name: str | None = None, mod: str | None = None, cl: Any | None = None) -> str: ...  # type: ignore[override]\n    def docproperty(self, object: object, name: str | None = None, mod: Any | None = None, cl: Any | None = None) -> str: ...  # type: ignore[override]\n    def docdata(self, object: object, name: str | None = None, mod: str | None = None, cl: Any | None = None) -> str: ...  # type: ignore[override]\n    def docother(  # type: ignore[override]\n        self,\n        object: object,\n        name: str | None = None,\n        mod: str | None = None,\n        parent: str | None = None,\n        maxlen: int | None = None,\n        doc: Any | None = None,\n    ) -> str: ...\n\ndef pager(text: str) -> None: ...\ndef getpager() -> Callable[[str], None]: ...\ndef plain(text: str) -> str: ...\ndef pipepager(text: str, cmd: str) -> None: ...\ndef tempfilepager(text: str, cmd: str) -> None: ...\ndef ttypager(text: str) -> None: ...\ndef plainpager(text: str) -> None: ...\ndef describe(thing: Any) -> str: ...\ndef locate(path: str, forceload: bool = ...) -> object: ...\n\ntext: TextDoc\nhtml: HTMLDoc\n\ndef resolve(thing: str | object, forceload: bool = ...) -> tuple[object, str] | None: ...\ndef render_doc(\n    thing: str | object, title: str = \"Python Library Documentation: %s\", forceload: bool = ..., renderer: Doc | None = None\n) -> str: ...\ndef doc(\n    thing: str | object,\n    title: str = \"Python Library Documentation: %s\",\n    forceload: bool = ...,\n    output: SupportsWrite[str] | None = None,\n) -> None: ...\ndef writedoc(thing: str | object, forceload: bool = ...) -> None: ...\ndef writedocs(dir: str, pkgpath: str = \"\", done: Any | None = None) -> None: ...\n\nclass Helper:\n    keywords: dict[str, str | tuple[str, str]]\n    symbols: dict[str, str]\n    topics: dict[str, str | tuple[str, ...]]\n    def __init__(self, input: IO[str] | None = None, output: IO[str] | None = None) -> None: ...\n    @property\n    def input(self) -> IO[str]: ...\n    @property\n    def output(self) -> IO[str]: ...\n    def __call__(self, request: str | Helper | object = ...) -> None: ...\n    def interact(self) -> None: ...\n    def getline(self, prompt: str) -> str: ...\n    def help(self, request: Any) -> None: ...\n    def intro(self) -> None: ...\n    def list(self, items: _list[str], columns: int = 4, width: int = 80) -> None: ...\n    def listkeywords(self) -> None: ...\n    def listsymbols(self) -> None: ...\n    def listtopics(self) -> None: ...\n    def showtopic(self, topic: str, more_xrefs: str = \"\") -> None: ...\n    def showsymbol(self, symbol: str) -> None: ...\n    def listmodules(self, key: str = \"\") -> None: ...\n\nhelp: Helper\n\nclass ModuleScanner:\n    quit: bool\n    def run(\n        self,\n        callback: Callable[[str | None, str, str], object],\n        key: str | None = None,\n        completer: Callable[[], object] | None = None,\n        onerror: Callable[[str], object] | None = None,\n    ) -> None: ...\n\ndef apropos(key: str) -> None: ...\ndef ispath(x: object) -> TypeGuard[str]: ...\ndef cli() -> None: ...\n",
  "/typeshed/stdlib/queue.pyi": "import sys\nfrom threading import Condition, Lock\nfrom typing import Any, Generic, TypeVar\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\"Empty\", \"Full\", \"Queue\", \"PriorityQueue\", \"LifoQueue\", \"SimpleQueue\"]\n\n_T = TypeVar(\"_T\")\n\nclass Empty(Exception): ...\nclass Full(Exception): ...\n\nclass Queue(Generic[_T]):\n    maxsize: int\n\n    mutex: Lock  # undocumented\n    not_empty: Condition  # undocumented\n    not_full: Condition  # undocumented\n    all_tasks_done: Condition  # undocumented\n    unfinished_tasks: int  # undocumented\n    # Despite the fact that `queue` has `deque` type,\n    # we treat it as `Any` to allow different implementations in subtypes.\n    queue: Any  # undocumented\n    def __init__(self, maxsize: int = 0) -> None: ...\n    def _init(self, maxsize: int) -> None: ...\n    def empty(self) -> bool: ...\n    def full(self) -> bool: ...\n    def get(self, block: bool = True, timeout: float | None = None) -> _T: ...\n    def get_nowait(self) -> _T: ...\n    def _get(self) -> _T: ...\n    def put(self, item: _T, block: bool = True, timeout: float | None = None) -> None: ...\n    def put_nowait(self, item: _T) -> None: ...\n    def _put(self, item: _T) -> None: ...\n    def join(self) -> None: ...\n    def qsize(self) -> int: ...\n    def _qsize(self) -> int: ...\n    def task_done(self) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass PriorityQueue(Queue[_T]):\n    queue: list[_T]\n\nclass LifoQueue(Queue[_T]):\n    queue: list[_T]\n\nclass SimpleQueue(Generic[_T]):\n    def __init__(self) -> None: ...\n    def empty(self) -> bool: ...\n    def get(self, block: bool = True, timeout: float | None = None) -> _T: ...\n    def get_nowait(self) -> _T: ...\n    def put(self, item: _T, block: bool = True, timeout: float | None = None) -> None: ...\n    def put_nowait(self, item: _T) -> None: ...\n    def qsize(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n",
  "/typeshed/stdlib/quopri.pyi": "from _typeshed import ReadableBuffer, SupportsNoArgReadline, SupportsRead, SupportsWrite\nfrom typing import Protocol\n\n__all__ = [\"encode\", \"decode\", \"encodestring\", \"decodestring\"]\n\nclass _Input(SupportsRead[bytes], SupportsNoArgReadline[bytes], Protocol): ...\n\ndef encode(input: _Input, output: SupportsWrite[bytes], quotetabs: int, header: bool = False) -> None: ...\ndef encodestring(s: ReadableBuffer, quotetabs: bool = False, header: bool = False) -> bytes: ...\ndef decode(input: _Input, output: SupportsWrite[bytes], header: bool = False) -> None: ...\ndef decodestring(s: str | ReadableBuffer, header: bool = False) -> bytes: ...\n",
  "/typeshed/stdlib/random.pyi": "import _random\nimport sys\nfrom _typeshed import SupportsLenAndGetItem\nfrom collections.abc import Callable, Iterable, MutableSequence, Sequence, Set as AbstractSet\nfrom fractions import Fraction\nfrom typing import Any, ClassVar, NoReturn, TypeVar\n\n__all__ = [\n    \"Random\",\n    \"seed\",\n    \"random\",\n    \"uniform\",\n    \"randint\",\n    \"choice\",\n    \"sample\",\n    \"randrange\",\n    \"shuffle\",\n    \"normalvariate\",\n    \"lognormvariate\",\n    \"expovariate\",\n    \"vonmisesvariate\",\n    \"gammavariate\",\n    \"triangular\",\n    \"gauss\",\n    \"betavariate\",\n    \"paretovariate\",\n    \"weibullvariate\",\n    \"getstate\",\n    \"setstate\",\n    \"getrandbits\",\n    \"choices\",\n    \"SystemRandom\",\n]\n\nif sys.version_info >= (3, 9):\n    __all__ += [\"randbytes\"]\n\n_T = TypeVar(\"_T\")\n\nclass Random(_random.Random):\n    VERSION: ClassVar[int]\n    def __init__(self, x: Any = None) -> None: ...\n    # Using other `seed` types is deprecated since 3.9 and removed in 3.11\n    # Ignore Y041, since random.seed doesn't treat int like a float subtype. Having an explicit\n    # int better documents conventional usage of random.seed.\n    if sys.version_info >= (3, 9):\n        def seed(self, a: int | float | str | bytes | bytearray | None = None, version: int = 2) -> None: ...  # type: ignore[override]  # noqa: Y041\n    else:\n        def seed(self, a: Any = None, version: int = 2) -> None: ...\n\n    def getstate(self) -> tuple[Any, ...]: ...\n    def setstate(self, state: tuple[Any, ...]) -> None: ...\n    def randrange(self, start: int, stop: int | None = None, step: int = 1) -> int: ...\n    def randint(self, a: int, b: int) -> int: ...\n    if sys.version_info >= (3, 9):\n        def randbytes(self, n: int) -> bytes: ...\n\n    def choice(self, seq: SupportsLenAndGetItem[_T]) -> _T: ...\n    def choices(\n        self,\n        population: SupportsLenAndGetItem[_T],\n        weights: Sequence[float | Fraction] | None = None,\n        *,\n        cum_weights: Sequence[float | Fraction] | None = None,\n        k: int = 1,\n    ) -> list[_T]: ...\n    if sys.version_info >= (3, 11):\n        def shuffle(self, x: MutableSequence[Any]) -> None: ...\n    else:\n        def shuffle(self, x: MutableSequence[Any], random: Callable[[], float] | None = None) -> None: ...\n    if sys.version_info >= (3, 11):\n        def sample(self, population: Sequence[_T], k: int, *, counts: Iterable[int] | None = None) -> list[_T]: ...\n    elif sys.version_info >= (3, 9):\n        def sample(\n            self, population: Sequence[_T] | AbstractSet[_T], k: int, *, counts: Iterable[int] | None = None\n        ) -> list[_T]: ...\n    else:\n        def sample(self, population: Sequence[_T] | AbstractSet[_T], k: int) -> list[_T]: ...\n\n    def uniform(self, a: float, b: float) -> float: ...\n    def triangular(self, low: float = 0.0, high: float = 1.0, mode: float | None = None) -> float: ...\n    def betavariate(self, alpha: float, beta: float) -> float: ...\n    def expovariate(self, lambd: float) -> float: ...\n    def gammavariate(self, alpha: float, beta: float) -> float: ...\n    if sys.version_info >= (3, 11):\n        def gauss(self, mu: float = 0.0, sigma: float = 1.0) -> float: ...\n        def normalvariate(self, mu: float = 0.0, sigma: float = 1.0) -> float: ...\n    else:\n        def gauss(self, mu: float, sigma: float) -> float: ...\n        def normalvariate(self, mu: float, sigma: float) -> float: ...\n\n    def lognormvariate(self, mu: float, sigma: float) -> float: ...\n    def vonmisesvariate(self, mu: float, kappa: float) -> float: ...\n    def paretovariate(self, alpha: float) -> float: ...\n    def weibullvariate(self, alpha: float, beta: float) -> float: ...\n\n# SystemRandom is not implemented for all OS's; good on Windows & Linux\nclass SystemRandom(Random):\n    def getrandbits(self, k: int) -> int: ...  # k can be passed by keyword\n    def getstate(self, *args: Any, **kwds: Any) -> NoReturn: ...\n    def setstate(self, *args: Any, **kwds: Any) -> NoReturn: ...\n\n_inst: Random\nseed = _inst.seed\nrandom = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nchoices = _inst.choices\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\nif sys.version_info >= (3, 9):\n    randbytes = _inst.randbytes\n",
  "/typeshed/stdlib/re.pyi": "import enum\nimport sre_compile\nimport sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable, Iterator, Mapping\nfrom sre_constants import error as error\nfrom typing import Any, AnyStr, Generic, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"match\",\n    \"fullmatch\",\n    \"search\",\n    \"sub\",\n    \"subn\",\n    \"split\",\n    \"findall\",\n    \"finditer\",\n    \"compile\",\n    \"purge\",\n    \"template\",\n    \"escape\",\n    \"error\",\n    \"A\",\n    \"I\",\n    \"L\",\n    \"M\",\n    \"S\",\n    \"X\",\n    \"U\",\n    \"ASCII\",\n    \"IGNORECASE\",\n    \"LOCALE\",\n    \"MULTILINE\",\n    \"DOTALL\",\n    \"VERBOSE\",\n    \"UNICODE\",\n    \"Match\",\n    \"Pattern\",\n]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"NOFLAG\", \"RegexFlag\"]\n\n_T = TypeVar(\"_T\")\n\n@final\nclass Match(Generic[AnyStr]):\n    @property\n    def pos(self) -> int: ...\n    @property\n    def endpos(self) -> int: ...\n    @property\n    def lastindex(self) -> int | None: ...\n    @property\n    def lastgroup(self) -> str | None: ...\n    @property\n    def string(self) -> AnyStr: ...\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    @property\n    def re(self) -> Pattern[AnyStr]: ...\n    @overload\n    def expand(self: Match[str], template: str) -> str: ...\n    @overload\n    def expand(self: Match[bytes], template: ReadableBuffer) -> bytes: ...  # type: ignore[misc]\n    @overload\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: Literal[0] = 0) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: int | str = 0) -> int: ...\n    def end(self, __group: int | str = 0) -> int: ...\n    def span(self, __group: int | str = 0) -> tuple[int, int]: ...\n    @property\n    def regs(self) -> tuple[tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    def __copy__(self) -> Match[AnyStr]: ...\n    def __deepcopy__(self, __memo: Any) -> Match[AnyStr]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n@final\nclass Pattern(Generic[AnyStr]):\n    @property\n    def flags(self) -> int: ...\n    @property\n    def groupindex(self) -> Mapping[str, int]: ...\n    @property\n    def groups(self) -> int: ...\n    @property\n    def pattern(self) -> AnyStr: ...\n    @overload\n    def search(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def search(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Match[bytes] | None: ...  # type: ignore[misc]\n    @overload\n    def search(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def match(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def match(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Match[bytes] | None: ...  # type: ignore[misc]\n    @overload\n    def match(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def fullmatch(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def fullmatch(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Match[bytes] | None: ...  # type: ignore[misc]\n    @overload\n    def fullmatch(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def split(self: Pattern[str], string: str, maxsplit: int = 0) -> list[str | Any]: ...\n    @overload\n    def split(self: Pattern[bytes], string: ReadableBuffer, maxsplit: int = 0) -> list[bytes | Any]: ...\n    @overload\n    def split(self, string: AnyStr, maxsplit: int = 0) -> list[AnyStr | Any]: ...\n    # return type depends on the number of groups in the pattern\n    @overload\n    def findall(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> list[Any]: ...\n    @overload\n    def findall(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> list[Any]: ...\n    @overload\n    def findall(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> list[AnyStr]: ...\n    @overload\n    def finditer(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Iterator[Match[str]]: ...\n    @overload\n    def finditer(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Iterator[Match[bytes]]: ...  # type: ignore[misc]\n    @overload\n    def finditer(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self: Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0) -> str: ...\n    @overload\n    def sub(  # type: ignore[misc]\n        self: Pattern[bytes],\n        repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n        string: ReadableBuffer,\n        count: int = 0,\n    ) -> bytes: ...\n    @overload\n    def sub(self, repl: AnyStr | Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = 0) -> AnyStr: ...\n    @overload\n    def subn(self: Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0) -> tuple[str, int]: ...\n    @overload\n    def subn(  # type: ignore[misc]\n        self: Pattern[bytes],\n        repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n        string: ReadableBuffer,\n        count: int = 0,\n    ) -> tuple[bytes, int]: ...\n    @overload\n    def subn(self, repl: AnyStr | Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = 0) -> tuple[AnyStr, int]: ...\n    def __copy__(self) -> Pattern[AnyStr]: ...\n    def __deepcopy__(self, __memo: Any) -> Pattern[AnyStr]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# ----- re variables and constants -----\n\nclass RegexFlag(enum.IntFlag):\n    A = sre_compile.SRE_FLAG_ASCII\n    ASCII = A\n    DEBUG = sre_compile.SRE_FLAG_DEBUG\n    I = sre_compile.SRE_FLAG_IGNORECASE\n    IGNORECASE = I\n    L = sre_compile.SRE_FLAG_LOCALE\n    LOCALE = L\n    M = sre_compile.SRE_FLAG_MULTILINE\n    MULTILINE = M\n    S = sre_compile.SRE_FLAG_DOTALL\n    DOTALL = S\n    X = sre_compile.SRE_FLAG_VERBOSE\n    VERBOSE = X\n    U = sre_compile.SRE_FLAG_UNICODE\n    UNICODE = U\n    T = sre_compile.SRE_FLAG_TEMPLATE\n    TEMPLATE = T\n    if sys.version_info >= (3, 11):\n        NOFLAG: int\n\nA = RegexFlag.A\nASCII = RegexFlag.ASCII\nDEBUG = RegexFlag.DEBUG\nI = RegexFlag.I\nIGNORECASE = RegexFlag.IGNORECASE\nL = RegexFlag.L\nLOCALE = RegexFlag.LOCALE\nM = RegexFlag.M\nMULTILINE = RegexFlag.MULTILINE\nS = RegexFlag.S\nDOTALL = RegexFlag.DOTALL\nX = RegexFlag.X\nVERBOSE = RegexFlag.VERBOSE\nU = RegexFlag.U\nUNICODE = RegexFlag.UNICODE\nT = RegexFlag.T\nTEMPLATE = RegexFlag.TEMPLATE\nif sys.version_info >= (3, 11):\n    NOFLAG = RegexFlag.NOFLAG\n_FlagsType: TypeAlias = int | RegexFlag\n\n# Type-wise the compile() overloads are unnecessary, they could also be modeled using\n# unions in the parameter types. However mypy has a bug regarding TypeVar\n# constraints (https://github.com/python/mypy/issues/11880),\n# which limits us here because AnyStr is a constrained TypeVar.\n\n# pattern arguments do *not* accept arbitrary buffers such as bytearray,\n# because the pattern must be hashable.\n@overload\ndef compile(pattern: AnyStr, flags: _FlagsType = 0) -> Pattern[AnyStr]: ...\n@overload\ndef compile(pattern: Pattern[AnyStr], flags: _FlagsType = 0) -> Pattern[AnyStr]: ...\n@overload\ndef search(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef search(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef match(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef match(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef fullmatch(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef fullmatch(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef split(pattern: str | Pattern[str], string: str, maxsplit: int = 0, flags: _FlagsType = 0) -> list[str | Any]: ...\n@overload\ndef split(\n    pattern: bytes | Pattern[bytes], string: ReadableBuffer, maxsplit: int = 0, flags: _FlagsType = 0\n) -> list[bytes | Any]: ...\n@overload\ndef findall(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> list[Any]: ...\n@overload\ndef findall(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> list[Any]: ...\n@overload\ndef finditer(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Iterator[Match[str]]: ...\n@overload\ndef finditer(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Iterator[Match[bytes]]: ...\n@overload\ndef sub(\n    pattern: str | Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0, flags: _FlagsType = 0\n) -> str: ...\n@overload\ndef sub(\n    pattern: bytes | Pattern[bytes],\n    repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n    string: ReadableBuffer,\n    count: int = 0,\n    flags: _FlagsType = 0,\n) -> bytes: ...\n@overload\ndef subn(\n    pattern: str | Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0, flags: _FlagsType = 0\n) -> tuple[str, int]: ...\n@overload\ndef subn(\n    pattern: bytes | Pattern[bytes],\n    repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n    string: ReadableBuffer,\n    count: int = 0,\n    flags: _FlagsType = 0,\n) -> tuple[bytes, int]: ...\ndef escape(pattern: AnyStr) -> AnyStr: ...\ndef purge() -> None: ...\ndef template(pattern: AnyStr | Pattern[AnyStr], flags: _FlagsType = 0) -> Pattern[AnyStr]: ...\n",
  "/typeshed/stdlib/readline.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Callable, Sequence\nfrom typing_extensions import TypeAlias\n\nif sys.platform != \"win32\":\n    _Completer: TypeAlias = Callable[[str, int], str | None]\n    _CompDisp: TypeAlias = Callable[[str, Sequence[str], int], None]\n\n    def parse_and_bind(__string: str) -> None: ...\n    def read_init_file(__filename: StrOrBytesPath | None = None) -> None: ...\n    def get_line_buffer() -> str: ...\n    def insert_text(__string: str) -> None: ...\n    def redisplay() -> None: ...\n    def read_history_file(__filename: StrOrBytesPath | None = None) -> None: ...\n    def write_history_file(__filename: StrOrBytesPath | None = None) -> None: ...\n    def append_history_file(__nelements: int, __filename: StrOrBytesPath | None = None) -> None: ...\n    def get_history_length() -> int: ...\n    def set_history_length(__length: int) -> None: ...\n    def clear_history() -> None: ...\n    def get_current_history_length() -> int: ...\n    def get_history_item(__index: int) -> str: ...\n    def remove_history_item(__pos: int) -> None: ...\n    def replace_history_item(__pos: int, __line: str) -> None: ...\n    def add_history(__string: str) -> None: ...\n    def set_auto_history(__enabled: bool) -> None: ...\n    def set_startup_hook(__function: Callable[[], object] | None = None) -> None: ...\n    def set_pre_input_hook(__function: Callable[[], object] | None = None) -> None: ...\n    def set_completer(__function: _Completer | None = None) -> None: ...\n    def get_completer() -> _Completer | None: ...\n    def get_completion_type() -> int: ...\n    def get_begidx() -> int: ...\n    def get_endidx() -> int: ...\n    def set_completer_delims(__string: str) -> None: ...\n    def get_completer_delims() -> str: ...\n    def set_completion_display_matches_hook(__function: _CompDisp | None = None) -> None: ...\n",
  "/typeshed/stdlib/reprlib.pyi": "import sys\nfrom array import array\nfrom collections import deque\nfrom collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"Repr\", \"repr\", \"recursive_repr\"]\n\n_ReprFunc: TypeAlias = Callable[[Any], str]\n\ndef recursive_repr(fillvalue: str = \"...\") -> Callable[[_ReprFunc], _ReprFunc]: ...\n\nclass Repr:\n    maxlevel: int\n    maxdict: int\n    maxlist: int\n    maxtuple: int\n    maxset: int\n    maxfrozenset: int\n    maxdeque: int\n    maxarray: int\n    maxlong: int\n    maxstring: int\n    maxother: int\n    if sys.version_info >= (3, 11):\n        fillvalue: str\n    if sys.version_info >= (3, 12):\n        indent: str | int | None\n\n    if sys.version_info >= (3, 12):\n        def __init__(\n            self,\n            *,\n            maxlevel: int = 6,\n            maxtuple: int = 6,\n            maxlist: int = 6,\n            maxarray: int = 5,\n            maxdict: int = 4,\n            maxset: int = 6,\n            maxfrozenset: int = 6,\n            maxdeque: int = 6,\n            maxstring: int = 30,\n            maxlong: int = 40,\n            maxother: int = 30,\n            fillvalue: str = \"...\",\n            indent: str | int | None = None,\n        ) -> None: ...\n\n    def repr(self, x: Any) -> str: ...\n    def repr1(self, x: Any, level: int) -> str: ...\n    def repr_tuple(self, x: tuple[Any, ...], level: int) -> str: ...\n    def repr_list(self, x: list[Any], level: int) -> str: ...\n    def repr_array(self, x: array[Any], level: int) -> str: ...\n    def repr_set(self, x: set[Any], level: int) -> str: ...\n    def repr_frozenset(self, x: frozenset[Any], level: int) -> str: ...\n    def repr_deque(self, x: deque[Any], level: int) -> str: ...\n    def repr_dict(self, x: dict[Any, Any], level: int) -> str: ...\n    def repr_str(self, x: str, level: int) -> str: ...\n    def repr_int(self, x: int, level: int) -> str: ...\n    def repr_instance(self, x: Any, level: int) -> str: ...\n\naRepr: Repr\n\ndef repr(x: object) -> str: ...\n",
  "/typeshed/stdlib/resource.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import overload\nfrom typing_extensions import Final, final\n\nif sys.platform != \"win32\":\n    RLIMIT_AS: int\n    RLIMIT_CORE: int\n    RLIMIT_CPU: int\n    RLIMIT_DATA: int\n    RLIMIT_FSIZE: int\n    RLIMIT_MEMLOCK: int\n    RLIMIT_NOFILE: int\n    RLIMIT_NPROC: int\n    RLIMIT_RSS: int\n    RLIMIT_STACK: int\n    RLIM_INFINITY: int\n    RUSAGE_CHILDREN: int\n    RUSAGE_SELF: int\n    if sys.platform == \"linux\":\n        RLIMIT_MSGQUEUE: int\n        RLIMIT_NICE: int\n        RLIMIT_OFILE: int\n        RLIMIT_RTPRIO: int\n        RLIMIT_RTTIME: int\n        RLIMIT_SIGPENDING: int\n        RUSAGE_THREAD: int\n    @final\n    class struct_rusage(\n        structseq[float], tuple[float, float, int, int, int, int, int, int, int, int, int, int, int, int, int, int]\n    ):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\n                \"ru_utime\",\n                \"ru_stime\",\n                \"ru_maxrss\",\n                \"ru_ixrss\",\n                \"ru_idrss\",\n                \"ru_isrss\",\n                \"ru_minflt\",\n                \"ru_majflt\",\n                \"ru_nswap\",\n                \"ru_inblock\",\n                \"ru_oublock\",\n                \"ru_msgsnd\",\n                \"ru_msgrcv\",\n                \"ru_nsignals\",\n                \"ru_nvcsw\",\n                \"ru_nivcsw\",\n            )\n        @property\n        def ru_utime(self) -> float: ...\n        @property\n        def ru_stime(self) -> float: ...\n        @property\n        def ru_maxrss(self) -> int: ...\n        @property\n        def ru_ixrss(self) -> int: ...\n        @property\n        def ru_idrss(self) -> int: ...\n        @property\n        def ru_isrss(self) -> int: ...\n        @property\n        def ru_minflt(self) -> int: ...\n        @property\n        def ru_majflt(self) -> int: ...\n        @property\n        def ru_nswap(self) -> int: ...\n        @property\n        def ru_inblock(self) -> int: ...\n        @property\n        def ru_oublock(self) -> int: ...\n        @property\n        def ru_msgsnd(self) -> int: ...\n        @property\n        def ru_msgrcv(self) -> int: ...\n        @property\n        def ru_nsignals(self) -> int: ...\n        @property\n        def ru_nvcsw(self) -> int: ...\n        @property\n        def ru_nivcsw(self) -> int: ...\n\n    def getpagesize() -> int: ...\n    def getrlimit(__resource: int) -> tuple[int, int]: ...\n    def getrusage(__who: int) -> struct_rusage: ...\n    def setrlimit(__resource: int, __limits: tuple[int, int]) -> None: ...\n    if sys.platform == \"linux\":\n        @overload\n        def prlimit(pid: int, resource: int, limits: tuple[int, int]) -> tuple[int, int]: ...\n        @overload\n        def prlimit(pid: int, resource: int) -> tuple[int, int]: ...\n    error = OSError\n",
  "/typeshed/stdlib/rlcompleter.pyi": "from typing import Any\n\n__all__ = [\"Completer\"]\n\nclass Completer:\n    def __init__(self, namespace: dict[str, Any] | None = None) -> None: ...\n    def complete(self, text: str, state: int) -> str | None: ...\n    def attr_matches(self, text: str) -> list[str]: ...\n    def global_matches(self, text: str) -> list[str]: ...\n",
  "/typeshed/stdlib/runpy.pyi": "from _typeshed import Unused\nfrom types import ModuleType\nfrom typing import Any\nfrom typing_extensions import Self\n\n__all__ = [\"run_module\", \"run_path\"]\n\nclass _TempModule:\n    mod_name: str\n    module: ModuleType\n    def __init__(self, mod_name: str) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n\nclass _ModifiedArgv0:\n    value: Any\n    def __init__(self, value: Any) -> None: ...\n    def __enter__(self) -> None: ...\n    def __exit__(self, *args: Unused) -> None: ...\n\ndef run_module(\n    mod_name: str, init_globals: dict[str, Any] | None = None, run_name: str | None = None, alter_sys: bool = False\n) -> dict[str, Any]: ...\ndef run_path(path_name: str, init_globals: dict[str, Any] | None = None, run_name: str | None = None) -> dict[str, Any]: ...\n",
  "/typeshed/stdlib/sched.pyi": "import sys\nfrom collections.abc import Callable\nfrom typing import Any, NamedTuple\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"scheduler\"]\n\n_ActionCallback: TypeAlias = Callable[..., Any]\n\nif sys.version_info >= (3, 10):\n    class Event(NamedTuple):\n        time: float\n        priority: Any\n        sequence: int\n        action: _ActionCallback\n        argument: tuple[Any, ...]\n        kwargs: dict[str, Any]\n\nelse:\n    class Event(NamedTuple):\n        time: float\n        priority: Any\n        action: _ActionCallback\n        argument: tuple[Any, ...]\n        kwargs: dict[str, Any]\n\nclass scheduler:\n    timefunc: Callable[[], float]\n    delayfunc: Callable[[float], object]\n\n    def __init__(self, timefunc: Callable[[], float] = ..., delayfunc: Callable[[float], object] = ...) -> None: ...\n    def enterabs(\n        self, time: float, priority: Any, action: _ActionCallback, argument: tuple[Any, ...] = (), kwargs: dict[str, Any] = ...\n    ) -> Event: ...\n    def enter(\n        self, delay: float, priority: Any, action: _ActionCallback, argument: tuple[Any, ...] = (), kwargs: dict[str, Any] = ...\n    ) -> Event: ...\n    def run(self, blocking: bool = True) -> float | None: ...\n    def cancel(self, event: Event) -> None: ...\n    def empty(self) -> bool: ...\n    @property\n    def queue(self) -> list[Event]: ...\n",
  "/typeshed/stdlib/secrets.pyi": "from _typeshed import SupportsLenAndGetItem\nfrom hmac import compare_digest as compare_digest\nfrom random import SystemRandom as SystemRandom\nfrom typing import TypeVar\n\n__all__ = [\"choice\", \"randbelow\", \"randbits\", \"SystemRandom\", \"token_bytes\", \"token_hex\", \"token_urlsafe\", \"compare_digest\"]\n\n_T = TypeVar(\"_T\")\n\ndef randbelow(exclusive_upper_bound: int) -> int: ...\ndef randbits(k: int) -> int: ...\ndef choice(seq: SupportsLenAndGetItem[_T]) -> _T: ...\ndef token_bytes(nbytes: int | None = None) -> bytes: ...\ndef token_hex(nbytes: int | None = None) -> str: ...\ndef token_urlsafe(nbytes: int | None = None) -> str: ...\n",
  "/typeshed/stdlib/select.pyi": "import sys\nfrom _typeshed import FileDescriptorLike\nfrom collections.abc import Iterable\nfrom types import TracebackType\nfrom typing import Any\nfrom typing_extensions import Self, final\n\nif sys.platform != \"win32\":\n    PIPE_BUF: int\n    POLLERR: int\n    POLLHUP: int\n    POLLIN: int\n    POLLMSG: int\n    POLLNVAL: int\n    POLLOUT: int\n    POLLPRI: int\n    POLLRDBAND: int\n    POLLRDHUP: int\n    POLLRDNORM: int\n    POLLWRBAND: int\n    POLLWRNORM: int\n\nclass poll:\n    def register(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...\n    def modify(self, fd: FileDescriptorLike, eventmask: int) -> None: ...\n    def unregister(self, fd: FileDescriptorLike) -> None: ...\n    def poll(self, timeout: float | None = ...) -> list[tuple[int, int]]: ...\n\ndef select(\n    __rlist: Iterable[Any], __wlist: Iterable[Any], __xlist: Iterable[Any], __timeout: float | None = None\n) -> tuple[list[Any], list[Any], list[Any]]: ...\n\nerror = OSError\n\nif sys.platform != \"linux\" and sys.platform != \"win32\":\n    # BSD only\n    @final\n    class kevent:\n        data: Any\n        fflags: int\n        filter: int\n        flags: int\n        ident: int\n        udata: Any\n        def __init__(\n            self,\n            ident: FileDescriptorLike,\n            filter: int = ...,\n            flags: int = ...,\n            fflags: int = ...,\n            data: Any = ...,\n            udata: Any = ...,\n        ) -> None: ...\n    # BSD only\n    @final\n    class kqueue:\n        closed: bool\n        def __init__(self) -> None: ...\n        def close(self) -> None: ...\n        def control(\n            self, __changelist: Iterable[kevent] | None, __maxevents: int, __timeout: float | None = None\n        ) -> list[kevent]: ...\n        def fileno(self) -> int: ...\n        @classmethod\n        def fromfd(cls, __fd: FileDescriptorLike) -> kqueue: ...\n    KQ_EV_ADD: int\n    KQ_EV_CLEAR: int\n    KQ_EV_DELETE: int\n    KQ_EV_DISABLE: int\n    KQ_EV_ENABLE: int\n    KQ_EV_EOF: int\n    KQ_EV_ERROR: int\n    KQ_EV_FLAG1: int\n    KQ_EV_ONESHOT: int\n    KQ_EV_SYSFLAGS: int\n    KQ_FILTER_AIO: int\n    KQ_FILTER_NETDEV: int\n    KQ_FILTER_PROC: int\n    KQ_FILTER_READ: int\n    KQ_FILTER_SIGNAL: int\n    KQ_FILTER_TIMER: int\n    KQ_FILTER_VNODE: int\n    KQ_FILTER_WRITE: int\n    KQ_NOTE_ATTRIB: int\n    KQ_NOTE_CHILD: int\n    KQ_NOTE_DELETE: int\n    KQ_NOTE_EXEC: int\n    KQ_NOTE_EXIT: int\n    KQ_NOTE_EXTEND: int\n    KQ_NOTE_FORK: int\n    KQ_NOTE_LINK: int\n    if sys.platform != \"darwin\":\n        KQ_NOTE_LINKDOWN: int\n        KQ_NOTE_LINKINV: int\n        KQ_NOTE_LINKUP: int\n    KQ_NOTE_LOWAT: int\n    KQ_NOTE_PCTRLMASK: int\n    KQ_NOTE_PDATAMASK: int\n    KQ_NOTE_RENAME: int\n    KQ_NOTE_REVOKE: int\n    KQ_NOTE_TRACK: int\n    KQ_NOTE_TRACKERR: int\n    KQ_NOTE_WRITE: int\n\nif sys.platform == \"linux\":\n    @final\n    class epoll:\n        def __init__(self, sizehint: int = ..., flags: int = ...) -> None: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(\n            self,\n            __exc_type: type[BaseException] | None = None,\n            __exc_value: BaseException | None = ...,\n            __exc_tb: TracebackType | None = None,\n        ) -> None: ...\n        def close(self) -> None: ...\n        closed: bool\n        def fileno(self) -> int: ...\n        def register(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...\n        def modify(self, fd: FileDescriptorLike, eventmask: int) -> None: ...\n        def unregister(self, fd: FileDescriptorLike) -> None: ...\n        def poll(self, timeout: float | None = None, maxevents: int = -1) -> list[tuple[int, int]]: ...\n        @classmethod\n        def fromfd(cls, __fd: FileDescriptorLike) -> epoll: ...\n    EPOLLERR: int\n    EPOLLEXCLUSIVE: int\n    EPOLLET: int\n    EPOLLHUP: int\n    EPOLLIN: int\n    EPOLLMSG: int\n    EPOLLONESHOT: int\n    EPOLLOUT: int\n    EPOLLPRI: int\n    EPOLLRDBAND: int\n    EPOLLRDHUP: int\n    EPOLLRDNORM: int\n    EPOLLWRBAND: int\n    EPOLLWRNORM: int\n    EPOLL_RDHUP: int\n    EPOLL_CLOEXEC: int\n\nif sys.platform != \"linux\" and sys.platform != \"darwin\" and sys.platform != \"win32\":\n    # Solaris only\n    class devpoll:\n        def close(self) -> None: ...\n        closed: bool\n        def fileno(self) -> int: ...\n        def register(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...\n        def modify(self, fd: FileDescriptorLike, eventmask: int = ...) -> None: ...\n        def unregister(self, fd: FileDescriptorLike) -> None: ...\n        def poll(self, timeout: float | None = ...) -> list[tuple[int, int]]: ...\n",
  "/typeshed/stdlib/selectors.pyi": "import sys\nfrom _typeshed import FileDescriptor, FileDescriptorLike, Unused\nfrom abc import ABCMeta, abstractmethod\nfrom collections.abc import Mapping\nfrom typing import Any, NamedTuple\nfrom typing_extensions import Self, TypeAlias\n\n_EventMask: TypeAlias = int\n\nEVENT_READ: _EventMask\nEVENT_WRITE: _EventMask\n\nclass SelectorKey(NamedTuple):\n    fileobj: FileDescriptorLike\n    fd: FileDescriptor\n    events: _EventMask\n    data: Any\n\nclass BaseSelector(metaclass=ABCMeta):\n    @abstractmethod\n    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n    @abstractmethod\n    def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    def modify(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n    @abstractmethod\n    def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n    def close(self) -> None: ...\n    def get_key(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    @abstractmethod\n    def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n\nclass SelectSelector(BaseSelector):\n    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n    def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n    def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n\nif sys.platform != \"win32\":\n    class PollSelector(BaseSelector):\n        def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n        def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n        def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n        def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n\nif sys.platform == \"linux\":\n    class EpollSelector(BaseSelector):\n        def fileno(self) -> int: ...\n        def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n        def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n        def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n        def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n\nclass DevpollSelector(BaseSelector):\n    def fileno(self) -> int: ...\n    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = ...) -> SelectorKey: ...\n    def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    def select(self, timeout: float | None = ...) -> list[tuple[SelectorKey, _EventMask]]: ...\n    def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n\nclass KqueueSelector(BaseSelector):\n    def fileno(self) -> int: ...\n    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n    def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n    def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n\nclass DefaultSelector(BaseSelector):\n    def register(self, fileobj: FileDescriptorLike, events: _EventMask, data: Any = None) -> SelectorKey: ...\n    def unregister(self, fileobj: FileDescriptorLike) -> SelectorKey: ...\n    def select(self, timeout: float | None = None) -> list[tuple[SelectorKey, _EventMask]]: ...\n    def get_map(self) -> Mapping[FileDescriptorLike, SelectorKey]: ...\n",
  "/typeshed/stdlib/shelve.pyi": "from collections.abc import Iterator, MutableMapping\nfrom dbm import _TFlags\nfrom types import TracebackType\nfrom typing import Any, TypeVar, overload\nfrom typing_extensions import Self\n\n__all__ = [\"Shelf\", \"BsdDbShelf\", \"DbfilenameShelf\", \"open\"]\n\n_T = TypeVar(\"_T\")\n_VT = TypeVar(\"_VT\")\n\nclass Shelf(MutableMapping[str, _VT]):\n    def __init__(\n        self, dict: MutableMapping[bytes, bytes], protocol: int | None = None, writeback: bool = False, keyencoding: str = \"utf-8\"\n    ) -> None: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def get(self, key: str) -> _VT | None: ...\n    @overload\n    def get(self, key: str, default: _T) -> _VT | _T: ...\n    def __getitem__(self, key: str) -> _VT: ...\n    def __setitem__(self, key: str, value: _VT) -> None: ...\n    def __delitem__(self, key: str) -> None: ...\n    def __contains__(self, key: str) -> bool: ...  # type: ignore[override]\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n    def close(self) -> None: ...\n    def sync(self) -> None: ...\n\nclass BsdDbShelf(Shelf[_VT]):\n    def set_location(self, key: str) -> tuple[str, _VT]: ...\n    def next(self) -> tuple[str, _VT]: ...\n    def previous(self) -> tuple[str, _VT]: ...\n    def first(self) -> tuple[str, _VT]: ...\n    def last(self) -> tuple[str, _VT]: ...\n\nclass DbfilenameShelf(Shelf[_VT]):\n    def __init__(self, filename: str, flag: _TFlags = \"c\", protocol: int | None = None, writeback: bool = False) -> None: ...\n\ndef open(filename: str, flag: _TFlags = \"c\", protocol: int | None = None, writeback: bool = False) -> Shelf[Any]: ...\n",
  "/typeshed/stdlib/shlex.pyi": "import sys\nfrom collections.abc import Iterable\nfrom typing import TextIO\nfrom typing_extensions import Self\n\nif sys.version_info >= (3, 8):\n    __all__ = [\"shlex\", \"split\", \"quote\", \"join\"]\nelse:\n    __all__ = [\"shlex\", \"split\", \"quote\"]\n\ndef split(s: str, comments: bool = False, posix: bool = True) -> list[str]: ...\n\nif sys.version_info >= (3, 8):\n    def join(split_command: Iterable[str]) -> str: ...\n\ndef quote(s: str) -> str: ...\n\nclass shlex(Iterable[str]):\n    commenters: str\n    wordchars: str\n    whitespace: str\n    escape: str\n    quotes: str\n    escapedquotes: str\n    whitespace_split: bool\n    infile: str | None\n    instream: TextIO\n    source: str\n    debug: int\n    lineno: int\n    token: str\n    eof: str | None\n    @property\n    def punctuation_chars(self) -> str: ...\n    def __init__(\n        self,\n        instream: str | TextIO | None = None,\n        infile: str | None = None,\n        posix: bool = False,\n        punctuation_chars: bool | str = False,\n    ) -> None: ...\n    def get_token(self) -> str | None: ...\n    def push_token(self, tok: str) -> None: ...\n    def read_token(self) -> str | None: ...\n    def sourcehook(self, newfile: str) -> tuple[str, TextIO] | None: ...\n    def push_source(self, newstream: str | TextIO, newfile: str | None = None) -> None: ...\n    def pop_source(self) -> None: ...\n    def error_leader(self, infile: str | None = None, lineno: int | None = None) -> str: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> str: ...\n",
  "/typeshed/stdlib/shutil.pyi": "import os\nimport sys\nfrom _typeshed import BytesPath, FileDescriptorOrPath, StrOrBytesPath, StrPath, SupportsRead, SupportsWrite\nfrom collections.abc import Callable, Iterable, Sequence\nfrom typing import Any, AnyStr, NamedTuple, Protocol, TypeVar, overload\nfrom typing_extensions import TypeAlias\n\n__all__ = [\n    \"copyfileobj\",\n    \"copyfile\",\n    \"copymode\",\n    \"copystat\",\n    \"copy\",\n    \"copy2\",\n    \"copytree\",\n    \"move\",\n    \"rmtree\",\n    \"Error\",\n    \"SpecialFileError\",\n    \"ExecError\",\n    \"make_archive\",\n    \"get_archive_formats\",\n    \"register_archive_format\",\n    \"unregister_archive_format\",\n    \"get_unpack_formats\",\n    \"register_unpack_format\",\n    \"unregister_unpack_format\",\n    \"unpack_archive\",\n    \"ignore_patterns\",\n    \"chown\",\n    \"which\",\n    \"get_terminal_size\",\n    \"SameFileError\",\n    \"disk_usage\",\n]\n\n_StrOrBytesPathT = TypeVar(\"_StrOrBytesPathT\", bound=StrOrBytesPath)\n_StrPathT = TypeVar(\"_StrPathT\", bound=StrPath)\n# Return value of some functions that may either return a path-like object that was passed in or\n# a string\n_PathReturn: TypeAlias = Any\n\nclass Error(OSError): ...\nclass SameFileError(Error): ...\nclass SpecialFileError(OSError): ...\nclass ExecError(OSError): ...\nclass ReadError(OSError): ...\nclass RegistryError(Exception): ...\n\nif sys.version_info >= (3, 8):\n    def copyfileobj(fsrc: SupportsRead[AnyStr], fdst: SupportsWrite[AnyStr], length: int = 0) -> None: ...\n\nelse:\n    def copyfileobj(fsrc: SupportsRead[AnyStr], fdst: SupportsWrite[AnyStr], length: int = 16384) -> None: ...\n\ndef copyfile(src: StrOrBytesPath, dst: _StrOrBytesPathT, *, follow_symlinks: bool = True) -> _StrOrBytesPathT: ...\ndef copymode(src: StrOrBytesPath, dst: StrOrBytesPath, *, follow_symlinks: bool = True) -> None: ...\ndef copystat(src: StrOrBytesPath, dst: StrOrBytesPath, *, follow_symlinks: bool = True) -> None: ...\n@overload\ndef copy(src: StrPath, dst: StrPath, *, follow_symlinks: bool = True) -> _PathReturn: ...\n@overload\ndef copy(src: BytesPath, dst: BytesPath, *, follow_symlinks: bool = True) -> _PathReturn: ...\n@overload\ndef copy2(src: StrPath, dst: StrPath, *, follow_symlinks: bool = True) -> _PathReturn: ...\n@overload\ndef copy2(src: BytesPath, dst: BytesPath, *, follow_symlinks: bool = True) -> _PathReturn: ...\ndef ignore_patterns(*patterns: StrPath) -> Callable[[Any, list[str]], set[str]]: ...\n\nif sys.version_info >= (3, 8):\n    def copytree(\n        src: StrPath,\n        dst: StrPath,\n        symlinks: bool = False,\n        ignore: None | Callable[[str, list[str]], Iterable[str]] | Callable[[StrPath, list[str]], Iterable[str]] = None,\n        copy_function: Callable[[str, str], object] = ...,\n        ignore_dangling_symlinks: bool = False,\n        dirs_exist_ok: bool = False,\n    ) -> _PathReturn: ...\n\nelse:\n    def copytree(\n        src: StrPath,\n        dst: StrPath,\n        symlinks: bool = False,\n        ignore: None | Callable[[str, list[str]], Iterable[str]] | Callable[[StrPath, list[str]], Iterable[str]] = None,\n        copy_function: Callable[[str, str], object] = ...,\n        ignore_dangling_symlinks: bool = False,\n    ) -> _PathReturn: ...\n\n_OnErrorCallback: TypeAlias = Callable[[Callable[..., Any], Any, Any], object]\n\nclass _RmtreeType(Protocol):\n    avoids_symlink_attacks: bool\n    if sys.version_info >= (3, 11):\n        def __call__(\n            self,\n            path: StrOrBytesPath,\n            ignore_errors: bool = ...,\n            onerror: _OnErrorCallback | None = ...,\n            *,\n            dir_fd: int | None = ...,\n        ) -> None: ...\n\n    else:\n        def __call__(self, path: StrOrBytesPath, ignore_errors: bool = ..., onerror: _OnErrorCallback | None = ...) -> None: ...\n\nrmtree: _RmtreeType\n\n_CopyFn: TypeAlias = Callable[[str, str], object] | Callable[[StrPath, StrPath], object]\n\n# N.B. shutil.move appears to take bytes arguments, however,\n# this does not work when dst is (or is within) an existing directory.\n# (#6832)\nif sys.version_info >= (3, 9):\n    def move(src: StrPath, dst: StrPath, copy_function: _CopyFn = ...) -> _PathReturn: ...\n\nelse:\n    # See https://bugs.python.org/issue32689\n    def move(src: str, dst: StrPath, copy_function: _CopyFn = ...) -> _PathReturn: ...\n\nclass _ntuple_diskusage(NamedTuple):\n    total: int\n    used: int\n    free: int\n\ndef disk_usage(path: FileDescriptorOrPath) -> _ntuple_diskusage: ...\n\n# While chown can be imported on Windows, it doesn't actually work;\n# see https://bugs.python.org/issue33140. We keep it here because it's\n# in __all__.\n@overload\ndef chown(path: StrOrBytesPath, user: str | int, group: None = None) -> None: ...\n@overload\ndef chown(path: StrOrBytesPath, user: None = None, *, group: str | int) -> None: ...\n@overload\ndef chown(path: StrOrBytesPath, user: None, group: str | int) -> None: ...\n@overload\ndef chown(path: StrOrBytesPath, user: str | int, group: str | int) -> None: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def which(cmd: _StrPathT, mode: int = 1, path: StrPath | None = None) -> str | _StrPathT | None: ...\n    @overload\n    def which(cmd: bytes, mode: int = 1, path: StrPath | None = None) -> bytes | None: ...\n\nelse:\n    def which(cmd: _StrPathT, mode: int = 1, path: StrPath | None = None) -> str | _StrPathT | None: ...\n\ndef make_archive(\n    base_name: str,\n    format: str,\n    root_dir: StrPath | None = None,\n    base_dir: StrPath | None = None,\n    verbose: bool = ...,\n    dry_run: bool = ...,\n    owner: str | None = None,\n    group: str | None = None,\n    logger: Any | None = None,\n) -> str: ...\ndef get_archive_formats() -> list[tuple[str, str]]: ...\n@overload\ndef register_archive_format(\n    name: str, function: Callable[..., object], extra_args: Sequence[tuple[str, Any] | list[Any]], description: str = \"\"\n) -> None: ...\n@overload\ndef register_archive_format(\n    name: str, function: Callable[[str, str], object], extra_args: None = None, description: str = \"\"\n) -> None: ...\ndef unregister_archive_format(name: str) -> None: ...\ndef unpack_archive(filename: StrPath, extract_dir: StrPath | None = None, format: str | None = None) -> None: ...\n@overload\ndef register_unpack_format(\n    name: str,\n    extensions: list[str],\n    function: Callable[..., object],\n    extra_args: Sequence[tuple[str, Any]],\n    description: str = \"\",\n) -> None: ...\n@overload\ndef register_unpack_format(\n    name: str, extensions: list[str], function: Callable[[str, str], object], extra_args: None = None, description: str = \"\"\n) -> None: ...\ndef unregister_unpack_format(name: str) -> None: ...\ndef get_unpack_formats() -> list[tuple[str, list[str], str]]: ...\ndef get_terminal_size(fallback: tuple[int, int] = (80, 24)) -> os.terminal_size: ...\n",
  "/typeshed/stdlib/signal.pyi": "import sys\nfrom _typeshed import structseq\nfrom collections.abc import Callable, Iterable\nfrom enum import IntEnum\nfrom types import FrameType\nfrom typing import Any\nfrom typing_extensions import Final, Never, TypeAlias, final\n\nNSIG: int\n\nclass Signals(IntEnum):\n    SIGABRT: int\n    SIGEMT: int\n    SIGFPE: int\n    SIGILL: int\n    SIGINFO: int\n    SIGINT: int\n    SIGSEGV: int\n    SIGTERM: int\n\n    if sys.platform == \"win32\":\n        SIGBREAK: int\n        CTRL_C_EVENT: int\n        CTRL_BREAK_EVENT: int\n    else:\n        SIGALRM: int\n        SIGBUS: int\n        SIGCHLD: int\n        SIGCONT: int\n        SIGHUP: int\n        SIGIO: int\n        SIGIOT: int\n        SIGKILL: int\n        SIGPIPE: int\n        SIGPROF: int\n        SIGQUIT: int\n        SIGSTOP: int\n        SIGSYS: int\n        SIGTRAP: int\n        SIGTSTP: int\n        SIGTTIN: int\n        SIGTTOU: int\n        SIGURG: int\n        SIGUSR1: int\n        SIGUSR2: int\n        SIGVTALRM: int\n        SIGWINCH: int\n        SIGXCPU: int\n        SIGXFSZ: int\n        if sys.platform != \"darwin\":\n            SIGCLD: int\n            SIGPOLL: int\n            SIGPWR: int\n            SIGRTMAX: int\n            SIGRTMIN: int\n            if sys.version_info >= (3, 11):\n                SIGSTKFLT: int\n\nclass Handlers(IntEnum):\n    SIG_DFL: int\n    SIG_IGN: int\n\nSIG_DFL: Handlers\nSIG_IGN: Handlers\n\n_SIGNUM: TypeAlias = int | Signals\n_HANDLER: TypeAlias = Callable[[int, FrameType | None], Any] | int | Handlers | None\n\ndef default_int_handler(__signalnum: int, __frame: FrameType | None) -> Never: ...\n\nif sys.version_info >= (3, 10):  # arguments changed in 3.10.2\n    def getsignal(signalnum: _SIGNUM) -> _HANDLER: ...\n    def signal(signalnum: _SIGNUM, handler: _HANDLER) -> _HANDLER: ...\n\nelse:\n    def getsignal(__signalnum: _SIGNUM) -> _HANDLER: ...\n    def signal(__signalnum: _SIGNUM, __handler: _HANDLER) -> _HANDLER: ...\n\nSIGABRT: Signals\nSIGEMT: Signals\nSIGFPE: Signals\nSIGILL: Signals\nSIGINFO: Signals\nSIGINT: Signals\nSIGSEGV: Signals\nSIGTERM: Signals\n\nif sys.platform == \"win32\":\n    SIGBREAK: Signals\n    CTRL_C_EVENT: Signals\n    CTRL_BREAK_EVENT: Signals\nelse:\n    SIGALRM: Signals\n    SIGBUS: Signals\n    SIGCHLD: Signals\n    SIGCONT: Signals\n    SIGHUP: Signals\n    SIGIO: Signals\n    SIGIOT: Signals\n    SIGKILL: Signals\n    SIGPIPE: Signals\n    SIGPROF: Signals\n    SIGQUIT: Signals\n    SIGSTOP: Signals\n    SIGSYS: Signals\n    SIGTRAP: Signals\n    SIGTSTP: Signals\n    SIGTTIN: Signals\n    SIGTTOU: Signals\n    SIGURG: Signals\n    SIGUSR1: Signals\n    SIGUSR2: Signals\n    SIGVTALRM: Signals\n    SIGWINCH: Signals\n    SIGXCPU: Signals\n    SIGXFSZ: Signals\n\n    class ItimerError(OSError): ...\n    ITIMER_PROF: int\n    ITIMER_REAL: int\n    ITIMER_VIRTUAL: int\n\n    class Sigmasks(IntEnum):\n        SIG_BLOCK: int\n        SIG_UNBLOCK: int\n        SIG_SETMASK: int\n    SIG_BLOCK = Sigmasks.SIG_BLOCK\n    SIG_UNBLOCK = Sigmasks.SIG_UNBLOCK\n    SIG_SETMASK = Sigmasks.SIG_SETMASK\n    def alarm(__seconds: int) -> int: ...\n    def getitimer(__which: int) -> tuple[float, float]: ...\n    def pause() -> None: ...\n    def pthread_kill(__thread_id: int, __signalnum: int) -> None: ...\n    if sys.version_info >= (3, 10):  # arguments changed in 3.10.2\n        def pthread_sigmask(how: int, mask: Iterable[int]) -> set[_SIGNUM]: ...\n    else:\n        def pthread_sigmask(__how: int, __mask: Iterable[int]) -> set[_SIGNUM]: ...\n\n    def setitimer(__which: int, __seconds: float, __interval: float = 0.0) -> tuple[float, float]: ...\n    def siginterrupt(__signalnum: int, __flag: bool) -> None: ...\n    def sigpending() -> Any: ...\n    if sys.version_info >= (3, 10):  # argument changed in 3.10.2\n        def sigwait(sigset: Iterable[int]) -> _SIGNUM: ...\n    else:\n        def sigwait(__sigset: Iterable[int]) -> _SIGNUM: ...\n    if sys.platform != \"darwin\":\n        SIGCLD: Signals\n        SIGPOLL: Signals\n        SIGPWR: Signals\n        SIGRTMAX: Signals\n        SIGRTMIN: Signals\n        if sys.version_info >= (3, 11):\n            SIGSTKFLT: Signals\n        @final\n        class struct_siginfo(structseq[int], tuple[int, int, int, int, int, int, int]):\n            if sys.version_info >= (3, 10):\n                __match_args__: Final = (\"si_signo\", \"si_code\", \"si_errno\", \"si_pid\", \"si_uid\", \"si_status\", \"si_band\")\n            @property\n            def si_signo(self) -> int: ...\n            @property\n            def si_code(self) -> int: ...\n            @property\n            def si_errno(self) -> int: ...\n            @property\n            def si_pid(self) -> int: ...\n            @property\n            def si_uid(self) -> int: ...\n            @property\n            def si_status(self) -> int: ...\n            @property\n            def si_band(self) -> int: ...\n\n        def sigtimedwait(sigset: Iterable[int], timeout: float) -> struct_siginfo | None: ...\n        def sigwaitinfo(sigset: Iterable[int]) -> struct_siginfo: ...\n\nif sys.version_info >= (3, 8):\n    def strsignal(__signalnum: _SIGNUM) -> str | None: ...\n    def valid_signals() -> set[Signals]: ...\n    def raise_signal(__signalnum: _SIGNUM) -> None: ...\n\ndef set_wakeup_fd(fd: int, *, warn_on_full_buffer: bool = ...) -> int: ...\n\nif sys.version_info >= (3, 9):\n    if sys.platform == \"linux\":\n        def pidfd_send_signal(__pidfd: int, __sig: int, __siginfo: None = None, __flags: int = ...) -> None: ...\n",
  "/typeshed/stdlib/site.pyi": "from _typeshed import StrPath\nfrom collections.abc import Iterable\n\nPREFIXES: list[str]\nENABLE_USER_SITE: bool | None\nUSER_SITE: str | None\nUSER_BASE: str | None\n\ndef main() -> None: ...\ndef abs_paths() -> None: ...  # undocumented\ndef addpackage(sitedir: StrPath, name: StrPath, known_paths: set[str] | None) -> set[str] | None: ...  # undocumented\ndef addsitedir(sitedir: str, known_paths: set[str] | None = None) -> None: ...\ndef addsitepackages(known_paths: set[str] | None, prefixes: Iterable[str] | None = None) -> set[str] | None: ...  # undocumented\ndef addusersitepackages(known_paths: set[str] | None) -> set[str] | None: ...  # undocumented\ndef check_enableusersite() -> bool | None: ...  # undocumented\ndef enablerlcompleter() -> None: ...  # undocumented\ndef execsitecustomize() -> None: ...  # undocumented\ndef execusercustomize() -> None: ...  # undocumented\ndef getsitepackages(prefixes: Iterable[str] | None = None) -> list[str]: ...\ndef getuserbase() -> str: ...\ndef getusersitepackages() -> str: ...\ndef makepath(*paths: StrPath) -> tuple[str, str]: ...  # undocumented\ndef removeduppaths() -> set[str]: ...  # undocumented\ndef setcopyright() -> None: ...  # undocumented\ndef sethelper() -> None: ...  # undocumented\ndef setquit() -> None: ...  # undocumented\ndef venv(known_paths: set[str] | None) -> set[str] | None: ...  # undocumented\n",
  "/typeshed/stdlib/smtpd.pyi": "import asynchat\nimport asyncore\nimport socket\nimport sys\nfrom collections import defaultdict\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\nif sys.version_info >= (3, 11):\n    __all__ = [\"SMTPChannel\", \"SMTPServer\", \"DebuggingServer\", \"PureProxy\"]\nelse:\n    __all__ = [\"SMTPChannel\", \"SMTPServer\", \"DebuggingServer\", \"PureProxy\", \"MailmanProxy\"]\n\n_Address: TypeAlias = tuple[str, int]  # (host, port)\n\nclass SMTPChannel(asynchat.async_chat):\n    COMMAND: int\n    DATA: int\n\n    command_size_limits: defaultdict[str, int]\n    smtp_server: SMTPServer\n    conn: socket.socket\n    addr: Any\n    received_lines: list[str]\n    smtp_state: int\n    seen_greeting: str\n    mailfrom: str\n    rcpttos: list[str]\n    received_data: str\n    fqdn: str\n    peer: str\n\n    command_size_limit: int\n    data_size_limit: int\n\n    enable_SMTPUTF8: bool\n    @property\n    def max_command_size_limit(self) -> int: ...\n    def __init__(\n        self,\n        server: SMTPServer,\n        conn: socket.socket,\n        addr: Any,\n        data_size_limit: int = 33554432,\n        map: asyncore._MapType | None = None,\n        enable_SMTPUTF8: bool = False,\n        decode_data: bool = False,\n    ) -> None: ...\n    # base asynchat.async_chat.push() accepts bytes\n    def push(self, msg: str) -> None: ...  # type: ignore[override]\n    def collect_incoming_data(self, data: bytes) -> None: ...\n    def found_terminator(self) -> None: ...\n    def smtp_HELO(self, arg: str) -> None: ...\n    def smtp_NOOP(self, arg: str) -> None: ...\n    def smtp_QUIT(self, arg: str) -> None: ...\n    def smtp_MAIL(self, arg: str) -> None: ...\n    def smtp_RCPT(self, arg: str) -> None: ...\n    def smtp_RSET(self, arg: str) -> None: ...\n    def smtp_DATA(self, arg: str) -> None: ...\n    def smtp_EHLO(self, arg: str) -> None: ...\n    def smtp_HELP(self, arg: str) -> None: ...\n    def smtp_VRFY(self, arg: str) -> None: ...\n    def smtp_EXPN(self, arg: str) -> None: ...\n\nclass SMTPServer(asyncore.dispatcher):\n    channel_class: type[SMTPChannel]\n\n    data_size_limit: int\n    enable_SMTPUTF8: bool\n    def __init__(\n        self,\n        localaddr: _Address,\n        remoteaddr: _Address,\n        data_size_limit: int = 33554432,\n        map: asyncore._MapType | None = None,\n        enable_SMTPUTF8: bool = False,\n        decode_data: bool = False,\n    ) -> None: ...\n    def handle_accepted(self, conn: socket.socket, addr: Any) -> None: ...\n    def process_message(\n        self, peer: _Address, mailfrom: str, rcpttos: list[str], data: bytes | str, **kwargs: Any\n    ) -> str | None: ...\n\nclass DebuggingServer(SMTPServer): ...\n\nclass PureProxy(SMTPServer):\n    def process_message(self, peer: _Address, mailfrom: str, rcpttos: list[str], data: bytes | str) -> str | None: ...  # type: ignore[override]\n\nif sys.version_info < (3, 11):\n    class MailmanProxy(PureProxy):\n        def process_message(self, peer: _Address, mailfrom: str, rcpttos: list[str], data: bytes | str) -> str | None: ...  # type: ignore[override]\n",
  "/typeshed/stdlib/smtplib.pyi": "import sys\nfrom _socket import _Address as _SourceAddress\nfrom _typeshed import ReadableBuffer, _BufferWithLen\nfrom collections.abc import Sequence\nfrom email.message import Message as _Message\nfrom re import Pattern\nfrom socket import socket\nfrom ssl import SSLContext\nfrom types import TracebackType\nfrom typing import Any, Protocol, overload\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\n    \"SMTPException\",\n    \"SMTPServerDisconnected\",\n    \"SMTPResponseException\",\n    \"SMTPSenderRefused\",\n    \"SMTPRecipientsRefused\",\n    \"SMTPDataError\",\n    \"SMTPConnectError\",\n    \"SMTPHeloError\",\n    \"SMTPAuthenticationError\",\n    \"quoteaddr\",\n    \"quotedata\",\n    \"SMTP\",\n    \"SMTP_SSL\",\n    \"SMTPNotSupportedError\",\n]\n\n_Reply: TypeAlias = tuple[int, bytes]\n_SendErrs: TypeAlias = dict[str, _Reply]\n\nSMTP_PORT: int\nSMTP_SSL_PORT: int\nCRLF: str\nbCRLF: bytes\n\nOLDSTYLE_AUTH: Pattern[str]\n\nclass SMTPException(OSError): ...\nclass SMTPNotSupportedError(SMTPException): ...\nclass SMTPServerDisconnected(SMTPException): ...\n\nclass SMTPResponseException(SMTPException):\n    smtp_code: int\n    smtp_error: bytes | str\n    args: tuple[int, bytes | str] | tuple[int, bytes, str]\n    def __init__(self, code: int, msg: bytes | str) -> None: ...\n\nclass SMTPSenderRefused(SMTPResponseException):\n    smtp_error: bytes\n    sender: str\n    args: tuple[int, bytes, str]\n    def __init__(self, code: int, msg: bytes, sender: str) -> None: ...\n\nclass SMTPRecipientsRefused(SMTPException):\n    recipients: _SendErrs\n    args: tuple[_SendErrs]\n    def __init__(self, recipients: _SendErrs) -> None: ...\n\nclass SMTPDataError(SMTPResponseException): ...\nclass SMTPConnectError(SMTPResponseException): ...\nclass SMTPHeloError(SMTPResponseException): ...\nclass SMTPAuthenticationError(SMTPResponseException): ...\n\ndef quoteaddr(addrstring: str) -> str: ...\ndef quotedata(data: str) -> str: ...\n\nclass _AuthObject(Protocol):\n    @overload\n    def __call__(self, challenge: None = None) -> str | None: ...\n    @overload\n    def __call__(self, challenge: bytes) -> str: ...\n\nclass SMTP:\n    debuglevel: int\n    sock: socket | None\n    # Type of file should match what socket.makefile() returns\n    file: Any | None\n    helo_resp: bytes | None\n    ehlo_msg: str\n    ehlo_resp: bytes | None\n    does_esmtp: bool\n    default_port: int\n    timeout: float\n    esmtp_features: dict[str, str]\n    command_encoding: str\n    source_address: _SourceAddress | None\n    local_hostname: str\n    def __init__(\n        self,\n        host: str = \"\",\n        port: int = 0,\n        local_hostname: str | None = None,\n        timeout: float = ...,\n        source_address: _SourceAddress | None = None,\n    ) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, tb: TracebackType | None\n    ) -> None: ...\n    def set_debuglevel(self, debuglevel: int) -> None: ...\n    def connect(self, host: str = \"localhost\", port: int = 0, source_address: _SourceAddress | None = None) -> _Reply: ...\n    def send(self, s: ReadableBuffer | str) -> None: ...\n    def putcmd(self, cmd: str, args: str = \"\") -> None: ...\n    def getreply(self) -> _Reply: ...\n    def docmd(self, cmd: str, args: str = \"\") -> _Reply: ...\n    def helo(self, name: str = \"\") -> _Reply: ...\n    def ehlo(self, name: str = \"\") -> _Reply: ...\n    def has_extn(self, opt: str) -> bool: ...\n    def help(self, args: str = \"\") -> bytes: ...\n    def rset(self) -> _Reply: ...\n    def noop(self) -> _Reply: ...\n    def mail(self, sender: str, options: Sequence[str] = ()) -> _Reply: ...\n    def rcpt(self, recip: str, options: Sequence[str] = ()) -> _Reply: ...\n    def data(self, msg: ReadableBuffer | str) -> _Reply: ...\n    def verify(self, address: str) -> _Reply: ...\n    vrfy = verify\n    def expn(self, address: str) -> _Reply: ...\n    def ehlo_or_helo_if_needed(self) -> None: ...\n    user: str\n    password: str\n    def auth(self, mechanism: str, authobject: _AuthObject, *, initial_response_ok: bool = True) -> _Reply: ...\n    @overload\n    def auth_cram_md5(self, challenge: None = None) -> None: ...\n    @overload\n    def auth_cram_md5(self, challenge: ReadableBuffer) -> str: ...\n    def auth_plain(self, challenge: ReadableBuffer | None = None) -> str: ...\n    def auth_login(self, challenge: ReadableBuffer | None = None) -> str: ...\n    def login(self, user: str, password: str, *, initial_response_ok: bool = True) -> _Reply: ...\n    def starttls(self, keyfile: str | None = None, certfile: str | None = None, context: SSLContext | None = None) -> _Reply: ...\n    def sendmail(\n        self,\n        from_addr: str,\n        to_addrs: str | Sequence[str],\n        msg: _BufferWithLen | str,\n        mail_options: Sequence[str] = (),\n        rcpt_options: Sequence[str] = (),\n    ) -> _SendErrs: ...\n    def send_message(\n        self,\n        msg: _Message,\n        from_addr: str | None = None,\n        to_addrs: str | Sequence[str] | None = None,\n        mail_options: Sequence[str] = (),\n        rcpt_options: Sequence[str] = (),\n    ) -> _SendErrs: ...\n    def close(self) -> None: ...\n    def quit(self) -> _Reply: ...\n\nclass SMTP_SSL(SMTP):\n    keyfile: str | None\n    certfile: str | None\n    context: SSLContext\n    def __init__(\n        self,\n        host: str = \"\",\n        port: int = 0,\n        local_hostname: str | None = None,\n        keyfile: str | None = None,\n        certfile: str | None = None,\n        timeout: float = ...,\n        source_address: _SourceAddress | None = None,\n        context: SSLContext | None = None,\n    ) -> None: ...\n\nLMTP_PORT: int\n\nclass LMTP(SMTP):\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            host: str = \"\",\n            port: int = 2003,\n            local_hostname: str | None = None,\n            source_address: _SourceAddress | None = None,\n            timeout: float = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            host: str = \"\",\n            port: int = 2003,\n            local_hostname: str | None = None,\n            source_address: _SourceAddress | None = None,\n        ) -> None: ...\n",
  "/typeshed/stdlib/sndhdr.pyi": "from _typeshed import StrOrBytesPath\nfrom typing import NamedTuple\n\n__all__ = [\"what\", \"whathdr\"]\n\nclass SndHeaders(NamedTuple):\n    filetype: str\n    framerate: int\n    nchannels: int\n    nframes: int\n    sampwidth: int | str\n\ndef what(filename: StrOrBytesPath) -> SndHeaders | None: ...\ndef whathdr(filename: StrOrBytesPath) -> SndHeaders | None: ...\n",
  "/typeshed/stdlib/socketserver.pyi": "import sys\nimport types\nfrom _socket import _Address, _RetAddress\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable\nfrom socket import socket as _socket\nfrom typing import Any, BinaryIO, ClassVar\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\n    \"BaseServer\",\n    \"TCPServer\",\n    \"UDPServer\",\n    \"ThreadingUDPServer\",\n    \"ThreadingTCPServer\",\n    \"BaseRequestHandler\",\n    \"StreamRequestHandler\",\n    \"DatagramRequestHandler\",\n    \"ThreadingMixIn\",\n]\nif sys.platform != \"win32\":\n    __all__ += [\n        \"ForkingMixIn\",\n        \"ForkingTCPServer\",\n        \"ForkingUDPServer\",\n        \"ThreadingUnixDatagramServer\",\n        \"ThreadingUnixStreamServer\",\n        \"UnixDatagramServer\",\n        \"UnixStreamServer\",\n    ]\n\n_RequestType: TypeAlias = _socket | tuple[bytes, _socket]\n_AfUnixAddress: TypeAlias = str | ReadableBuffer  # address acceptable for an AF_UNIX socket\n_AfInetAddress: TypeAlias = tuple[str | bytes | bytearray, int]  # address acceptable for an AF_INET socket\n\n# This can possibly be generic at some point:\nclass BaseServer:\n    address_family: int\n    server_address: _Address\n    socket: _socket\n    allow_reuse_address: bool\n    request_queue_size: int\n    socket_type: int\n    timeout: float | None\n    RequestHandlerClass: Callable[[Any, _RetAddress, Self], BaseRequestHandler]\n    def __init__(\n        self, server_address: _Address, RequestHandlerClass: Callable[[Any, _RetAddress, Self], BaseRequestHandler]\n    ) -> None: ...\n    def fileno(self) -> int: ...\n    def handle_request(self) -> None: ...\n    def serve_forever(self, poll_interval: float = 0.5) -> None: ...\n    def shutdown(self) -> None: ...\n    def server_close(self) -> None: ...\n    def finish_request(self, request: _RequestType, client_address: _RetAddress) -> None: ...\n    def get_request(self) -> tuple[Any, Any]: ...\n    def handle_error(self, request: _RequestType, client_address: _RetAddress) -> None: ...\n    def handle_timeout(self) -> None: ...\n    def process_request(self, request: _RequestType, client_address: _RetAddress) -> None: ...\n    def server_activate(self) -> None: ...\n    def server_bind(self) -> None: ...\n    def verify_request(self, request: _RequestType, client_address: _RetAddress) -> bool: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n    ) -> None: ...\n    def service_actions(self) -> None: ...\n    def shutdown_request(self, request: _RequestType) -> None: ...  # undocumented\n    def close_request(self, request: _RequestType) -> None: ...  # undocumented\n\nclass TCPServer(BaseServer):\n    if sys.version_info >= (3, 11):\n        allow_reuse_port: bool\n    server_address: _AfInetAddress\n    def __init__(\n        self,\n        server_address: _AfInetAddress,\n        RequestHandlerClass: Callable[[Any, _RetAddress, Self], BaseRequestHandler],\n        bind_and_activate: bool = True,\n    ) -> None: ...\n    def get_request(self) -> tuple[_socket, _RetAddress]: ...\n\nclass UDPServer(TCPServer):\n    max_packet_size: ClassVar[int]\n    def get_request(self) -> tuple[tuple[bytes, _socket], _RetAddress]: ...  # type: ignore[override]\n\nif sys.platform != \"win32\":\n    class UnixStreamServer(BaseServer):\n        server_address: _AfUnixAddress  # type: ignore[assignment]\n        def __init__(\n            self,\n            server_address: _AfUnixAddress,\n            RequestHandlerClass: Callable[[Any, _RetAddress, Self], BaseRequestHandler],\n            bind_and_activate: bool = True,\n        ) -> None: ...\n\n    class UnixDatagramServer(BaseServer):\n        server_address: _AfUnixAddress  # type: ignore[assignment]\n        def __init__(\n            self,\n            server_address: _AfUnixAddress,\n            RequestHandlerClass: Callable[[Any, _RetAddress, Self], BaseRequestHandler],\n            bind_and_activate: bool = True,\n        ) -> None: ...\n\nif sys.platform != \"win32\":\n    class ForkingMixIn:\n        timeout: float | None  # undocumented\n        active_children: set[int] | None  # undocumented\n        max_children: int  # undocumented\n        block_on_close: bool\n        def collect_children(self, *, blocking: bool = False) -> None: ...  # undocumented\n        def handle_timeout(self) -> None: ...  # undocumented\n        def service_actions(self) -> None: ...  # undocumented\n        def process_request(self, request: _RequestType, client_address: _RetAddress) -> None: ...\n        def server_close(self) -> None: ...\n\nclass ThreadingMixIn:\n    daemon_threads: bool\n    block_on_close: bool\n    def process_request_thread(self, request: _RequestType, client_address: _RetAddress) -> None: ...  # undocumented\n    def process_request(self, request: _RequestType, client_address: _RetAddress) -> None: ...\n    def server_close(self) -> None: ...\n\nif sys.platform != \"win32\":\n    class ForkingTCPServer(ForkingMixIn, TCPServer): ...\n    class ForkingUDPServer(ForkingMixIn, UDPServer): ...\n\nclass ThreadingTCPServer(ThreadingMixIn, TCPServer): ...\nclass ThreadingUDPServer(ThreadingMixIn, UDPServer): ...\n\nif sys.platform != \"win32\":\n    class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer): ...\n    class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer): ...\n\nclass BaseRequestHandler:\n    # `request` is technically of type _RequestType,\n    # but there are some concerns that having a union here would cause\n    # too much inconvenience to people using it (see\n    # https://github.com/python/typeshed/pull/384#issuecomment-234649696)\n    #\n    # Note also that _RetAddress is also just an alias for `Any`\n    request: Any\n    client_address: _RetAddress\n    server: BaseServer\n    def __init__(self, request: _RequestType, client_address: _RetAddress, server: BaseServer) -> None: ...\n    def setup(self) -> None: ...\n    def handle(self) -> None: ...\n    def finish(self) -> None: ...\n\nclass StreamRequestHandler(BaseRequestHandler):\n    rbufsize: ClassVar[int]  # undocumented\n    wbufsize: ClassVar[int]  # undocumented\n    timeout: ClassVar[float | None]  # undocumented\n    disable_nagle_algorithm: ClassVar[bool]  # undocumented\n    connection: Any  # undocumented\n    rfile: BinaryIO\n    wfile: BinaryIO\n\nclass DatagramRequestHandler(BaseRequestHandler):\n    packet: _socket  # undocumented\n    socket: _socket  # undocumented\n    rfile: BinaryIO\n    wfile: BinaryIO\n",
  "/typeshed/stdlib/spwd.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import Any\nfrom typing_extensions import Final, final\n\nif sys.platform != \"win32\":\n    @final\n    class struct_spwd(structseq[Any], tuple[str, str, int, int, int, int, int, int, int]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\n                \"sp_namp\",\n                \"sp_pwdp\",\n                \"sp_lstchg\",\n                \"sp_min\",\n                \"sp_max\",\n                \"sp_warn\",\n                \"sp_inact\",\n                \"sp_expire\",\n                \"sp_flag\",\n            )\n        @property\n        def sp_namp(self) -> str: ...\n        @property\n        def sp_pwdp(self) -> str: ...\n        @property\n        def sp_lstchg(self) -> int: ...\n        @property\n        def sp_min(self) -> int: ...\n        @property\n        def sp_max(self) -> int: ...\n        @property\n        def sp_warn(self) -> int: ...\n        @property\n        def sp_inact(self) -> int: ...\n        @property\n        def sp_expire(self) -> int: ...\n        @property\n        def sp_flag(self) -> int: ...\n\n    def getspall() -> list[struct_spwd]: ...\n    def getspnam(__arg: str) -> struct_spwd: ...\n",
  "/typeshed/stdlib/sre_compile.pyi": "from re import Pattern\nfrom sre_constants import *\nfrom sre_constants import _NamedIntConstant\nfrom sre_parse import SubPattern\nfrom typing import Any\n\nMAXCODE: int\n\ndef dis(code: list[_NamedIntConstant]) -> None: ...\ndef isstring(obj: Any) -> bool: ...\ndef compile(p: str | bytes | SubPattern, flags: int = 0) -> Pattern[Any]: ...\n",
  "/typeshed/stdlib/sre_constants.pyi": "import sys\nfrom typing import Any\nfrom typing_extensions import Self\n\nMAXGROUPS: int\n\nMAGIC: int\n\nclass error(Exception):\n    msg: str\n    pattern: str | bytes | None\n    pos: int | None\n    lineno: int\n    colno: int\n    def __init__(self, msg: str, pattern: str | bytes | None = None, pos: int | None = None) -> None: ...\n\nclass _NamedIntConstant(int):\n    name: Any\n    def __new__(cls, value: int, name: str) -> Self: ...\n\nMAXREPEAT: _NamedIntConstant\nOPCODES: list[_NamedIntConstant]\nATCODES: list[_NamedIntConstant]\nCHCODES: list[_NamedIntConstant]\nOP_IGNORE: dict[_NamedIntConstant, _NamedIntConstant]\nOP_LOCALE_IGNORE: dict[_NamedIntConstant, _NamedIntConstant]\nOP_UNICODE_IGNORE: dict[_NamedIntConstant, _NamedIntConstant]\nAT_MULTILINE: dict[_NamedIntConstant, _NamedIntConstant]\nAT_LOCALE: dict[_NamedIntConstant, _NamedIntConstant]\nAT_UNICODE: dict[_NamedIntConstant, _NamedIntConstant]\nCH_LOCALE: dict[_NamedIntConstant, _NamedIntConstant]\nCH_UNICODE: dict[_NamedIntConstant, _NamedIntConstant]\nSRE_FLAG_TEMPLATE: int\nSRE_FLAG_IGNORECASE: int\nSRE_FLAG_LOCALE: int\nSRE_FLAG_MULTILINE: int\nSRE_FLAG_DOTALL: int\nSRE_FLAG_UNICODE: int\nSRE_FLAG_VERBOSE: int\nSRE_FLAG_DEBUG: int\nSRE_FLAG_ASCII: int\nSRE_INFO_PREFIX: int\nSRE_INFO_LITERAL: int\nSRE_INFO_CHARSET: int\n\n# Stubgen above; manually defined constants below (dynamic at runtime)\n\n# from OPCODES\nFAILURE: _NamedIntConstant\nSUCCESS: _NamedIntConstant\nANY: _NamedIntConstant\nANY_ALL: _NamedIntConstant\nASSERT: _NamedIntConstant\nASSERT_NOT: _NamedIntConstant\nAT: _NamedIntConstant\nBRANCH: _NamedIntConstant\nif sys.version_info < (3, 11):\n    CALL: _NamedIntConstant\nCATEGORY: _NamedIntConstant\nCHARSET: _NamedIntConstant\nBIGCHARSET: _NamedIntConstant\nGROUPREF: _NamedIntConstant\nGROUPREF_EXISTS: _NamedIntConstant\nGROUPREF_IGNORE: _NamedIntConstant\nIN: _NamedIntConstant\nIN_IGNORE: _NamedIntConstant\nINFO: _NamedIntConstant\nJUMP: _NamedIntConstant\nLITERAL: _NamedIntConstant\nLITERAL_IGNORE: _NamedIntConstant\nMARK: _NamedIntConstant\nMAX_UNTIL: _NamedIntConstant\nMIN_UNTIL: _NamedIntConstant\nNOT_LITERAL: _NamedIntConstant\nNOT_LITERAL_IGNORE: _NamedIntConstant\nNEGATE: _NamedIntConstant\nRANGE: _NamedIntConstant\nREPEAT: _NamedIntConstant\nREPEAT_ONE: _NamedIntConstant\nSUBPATTERN: _NamedIntConstant\nMIN_REPEAT_ONE: _NamedIntConstant\nif sys.version_info >= (3, 11):\n    ATOMIC_GROUP: _NamedIntConstant\n    POSSESSIVE_REPEAT: _NamedIntConstant\n    POSSESSIVE_REPEAT_ONE: _NamedIntConstant\nRANGE_UNI_IGNORE: _NamedIntConstant\nGROUPREF_LOC_IGNORE: _NamedIntConstant\nGROUPREF_UNI_IGNORE: _NamedIntConstant\nIN_LOC_IGNORE: _NamedIntConstant\nIN_UNI_IGNORE: _NamedIntConstant\nLITERAL_LOC_IGNORE: _NamedIntConstant\nLITERAL_UNI_IGNORE: _NamedIntConstant\nNOT_LITERAL_LOC_IGNORE: _NamedIntConstant\nNOT_LITERAL_UNI_IGNORE: _NamedIntConstant\nMIN_REPEAT: _NamedIntConstant\nMAX_REPEAT: _NamedIntConstant\n\n# from ATCODES\nAT_BEGINNING: _NamedIntConstant\nAT_BEGINNING_LINE: _NamedIntConstant\nAT_BEGINNING_STRING: _NamedIntConstant\nAT_BOUNDARY: _NamedIntConstant\nAT_NON_BOUNDARY: _NamedIntConstant\nAT_END: _NamedIntConstant\nAT_END_LINE: _NamedIntConstant\nAT_END_STRING: _NamedIntConstant\nAT_LOC_BOUNDARY: _NamedIntConstant\nAT_LOC_NON_BOUNDARY: _NamedIntConstant\nAT_UNI_BOUNDARY: _NamedIntConstant\nAT_UNI_NON_BOUNDARY: _NamedIntConstant\n\n# from CHCODES\nCATEGORY_DIGIT: _NamedIntConstant\nCATEGORY_NOT_DIGIT: _NamedIntConstant\nCATEGORY_SPACE: _NamedIntConstant\nCATEGORY_NOT_SPACE: _NamedIntConstant\nCATEGORY_WORD: _NamedIntConstant\nCATEGORY_NOT_WORD: _NamedIntConstant\nCATEGORY_LINEBREAK: _NamedIntConstant\nCATEGORY_NOT_LINEBREAK: _NamedIntConstant\nCATEGORY_LOC_WORD: _NamedIntConstant\nCATEGORY_LOC_NOT_WORD: _NamedIntConstant\nCATEGORY_UNI_DIGIT: _NamedIntConstant\nCATEGORY_UNI_NOT_DIGIT: _NamedIntConstant\nCATEGORY_UNI_SPACE: _NamedIntConstant\nCATEGORY_UNI_NOT_SPACE: _NamedIntConstant\nCATEGORY_UNI_WORD: _NamedIntConstant\nCATEGORY_UNI_NOT_WORD: _NamedIntConstant\nCATEGORY_UNI_LINEBREAK: _NamedIntConstant\nCATEGORY_UNI_NOT_LINEBREAK: _NamedIntConstant\n",
  "/typeshed/stdlib/sre_parse.pyi": "import sys\nfrom collections.abc import Iterable\nfrom re import Match, Pattern as _Pattern\nfrom sre_constants import *\nfrom sre_constants import _NamedIntConstant as _NIC, error as _Error\nfrom typing import Any, overload\nfrom typing_extensions import TypeAlias\n\nSPECIAL_CHARS: str\nREPEAT_CHARS: str\nDIGITS: frozenset[str]\nOCTDIGITS: frozenset[str]\nHEXDIGITS: frozenset[str]\nASCIILETTERS: frozenset[str]\nWHITESPACE: frozenset[str]\nESCAPES: dict[str, tuple[_NIC, int]]\nCATEGORIES: dict[str, tuple[_NIC, _NIC] | tuple[_NIC, list[tuple[_NIC, _NIC]]]]\nFLAGS: dict[str, int]\nTYPE_FLAGS: int\nGLOBAL_FLAGS: int\n\nif sys.version_info < (3, 11):\n    class Verbose(Exception): ...\n\nclass _State:\n    flags: int\n    groupdict: dict[str, int]\n    groupwidths: list[int | None]\n    lookbehindgroups: int | None\n    @property\n    def groups(self) -> int: ...\n    def opengroup(self, name: str | None = ...) -> int: ...\n    def closegroup(self, gid: int, p: SubPattern) -> None: ...\n    def checkgroup(self, gid: int) -> bool: ...\n    def checklookbehindgroup(self, gid: int, source: Tokenizer) -> None: ...\n\nif sys.version_info >= (3, 8):\n    State: TypeAlias = _State\nelse:\n    Pattern: TypeAlias = _State\n\n_OpSubpatternType: TypeAlias = tuple[int | None, int, int, SubPattern]\n_OpGroupRefExistsType: TypeAlias = tuple[int, SubPattern, SubPattern]\n_OpInType: TypeAlias = list[tuple[_NIC, int]]\n_OpBranchType: TypeAlias = tuple[None, list[SubPattern]]\n_AvType: TypeAlias = _OpInType | _OpBranchType | Iterable[SubPattern] | _OpGroupRefExistsType | _OpSubpatternType\n_CodeType: TypeAlias = tuple[_NIC, _AvType]\n\nclass SubPattern:\n    data: list[_CodeType]\n    width: int | None\n\n    if sys.version_info >= (3, 8):\n        state: State\n        def __init__(self, state: State, data: list[_CodeType] | None = None) -> None: ...\n    else:\n        pattern: Pattern\n        def __init__(self, pattern: Pattern, data: list[_CodeType] | None = None) -> None: ...\n\n    def dump(self, level: int = 0) -> None: ...\n    def __len__(self) -> int: ...\n    def __delitem__(self, index: int | slice) -> None: ...\n    def __getitem__(self, index: int | slice) -> SubPattern | _CodeType: ...\n    def __setitem__(self, index: int | slice, code: _CodeType) -> None: ...\n    def insert(self, index: int, code: _CodeType) -> None: ...\n    def append(self, code: _CodeType) -> None: ...\n    def getwidth(self) -> tuple[int, int]: ...\n\nclass Tokenizer:\n    istext: bool\n    string: Any\n    decoded_string: str\n    index: int\n    next: str | None\n    def __init__(self, string: Any) -> None: ...\n    def match(self, char: str) -> bool: ...\n    def get(self) -> str | None: ...\n    def getwhile(self, n: int, charset: Iterable[str]) -> str: ...\n    if sys.version_info >= (3, 8):\n        def getuntil(self, terminator: str, name: str) -> str: ...\n    else:\n        def getuntil(self, terminator: str) -> str: ...\n\n    @property\n    def pos(self) -> int: ...\n    def tell(self) -> int: ...\n    def seek(self, index: int) -> None: ...\n    def error(self, msg: str, offset: int = 0) -> _Error: ...\n\n    if sys.version_info >= (3, 11):\n        def checkgroupname(self, name: str, offset: int, nested: int) -> None: ...\n\ndef fix_flags(src: str | bytes, flags: int) -> int: ...\n\n_TemplateType: TypeAlias = tuple[list[tuple[int, int]], list[str | None]]\n_TemplateByteType: TypeAlias = tuple[list[tuple[int, int]], list[bytes | None]]\nif sys.version_info >= (3, 8):\n    def parse(str: str, flags: int = 0, state: State | None = None) -> SubPattern: ...\n    @overload\n    def parse_template(source: str, state: _Pattern[Any]) -> _TemplateType: ...\n    @overload\n    def parse_template(source: bytes, state: _Pattern[Any]) -> _TemplateByteType: ...\n\nelse:\n    def parse(str: str, flags: int = 0, pattern: Pattern | None = None) -> SubPattern: ...\n    @overload\n    def parse_template(source: str, pattern: _Pattern[Any]) -> _TemplateType: ...\n    @overload\n    def parse_template(source: bytes, pattern: _Pattern[Any]) -> _TemplateByteType: ...\n\ndef expand_template(template: _TemplateType, match: Match[Any]) -> str: ...\n",
  "/typeshed/stdlib/ssl.pyi": "import enum\nimport socket\nimport sys\nfrom _typeshed import ReadableBuffer, StrOrBytesPath, WriteableBuffer\nfrom collections.abc import Callable, Iterable\nfrom typing import Any, NamedTuple, overload\nfrom typing_extensions import Literal, Self, TypeAlias, TypedDict, final\n\n_PCTRTT: TypeAlias = tuple[tuple[str, str], ...]\n_PCTRTTT: TypeAlias = tuple[_PCTRTT, ...]\n_PeerCertRetDictType: TypeAlias = dict[str, str | _PCTRTTT | _PCTRTT]\n_PeerCertRetType: TypeAlias = _PeerCertRetDictType | bytes | None\n_EnumRetType: TypeAlias = list[tuple[bytes, str, set[str] | bool]]\n_PasswordType: TypeAlias = Callable[[], str | bytes | bytearray] | str | bytes | bytearray\n\n_SrvnmeCbType: TypeAlias = Callable[[SSLSocket | SSLObject, str | None, SSLSocket], int | None]\n\nclass _Cipher(TypedDict):\n    aead: bool\n    alg_bits: int\n    auth: str\n    description: str\n    digest: str | None\n    id: int\n    kea: str\n    name: str\n    protocol: str\n    strength_bits: int\n    symmetric: str\n\nclass SSLError(OSError):\n    library: str\n    reason: str\n\nclass SSLZeroReturnError(SSLError): ...\nclass SSLWantReadError(SSLError): ...\nclass SSLWantWriteError(SSLError): ...\nclass SSLSyscallError(SSLError): ...\nclass SSLEOFError(SSLError): ...\n\nclass SSLCertVerificationError(SSLError, ValueError):\n    verify_code: int\n    verify_message: str\n\nCertificateError = SSLCertVerificationError\n\ndef wrap_socket(\n    sock: socket.socket,\n    keyfile: StrOrBytesPath | None = None,\n    certfile: StrOrBytesPath | None = None,\n    server_side: bool = False,\n    cert_reqs: int = ...,\n    ssl_version: int = ...,\n    ca_certs: str | None = None,\n    do_handshake_on_connect: bool = True,\n    suppress_ragged_eofs: bool = True,\n    ciphers: str | None = None,\n) -> SSLSocket: ...\ndef create_default_context(\n    purpose: Purpose = ...,\n    *,\n    cafile: StrOrBytesPath | None = None,\n    capath: StrOrBytesPath | None = None,\n    cadata: str | ReadableBuffer | None = None,\n) -> SSLContext: ...\n\nif sys.version_info >= (3, 10):\n    def _create_unverified_context(\n        protocol: int | None = None,\n        *,\n        cert_reqs: int = ...,\n        check_hostname: bool = False,\n        purpose: Purpose = ...,\n        certfile: StrOrBytesPath | None = None,\n        keyfile: StrOrBytesPath | None = None,\n        cafile: StrOrBytesPath | None = None,\n        capath: StrOrBytesPath | None = None,\n        cadata: str | ReadableBuffer | None = None,\n    ) -> SSLContext: ...\n\nelse:\n    def _create_unverified_context(\n        protocol: int = ...,\n        *,\n        cert_reqs: int = ...,\n        check_hostname: bool = False,\n        purpose: Purpose = ...,\n        certfile: StrOrBytesPath | None = None,\n        keyfile: StrOrBytesPath | None = None,\n        cafile: StrOrBytesPath | None = None,\n        capath: StrOrBytesPath | None = None,\n        cadata: str | ReadableBuffer | None = None,\n    ) -> SSLContext: ...\n\n_create_default_https_context: Callable[..., SSLContext]\n\ndef RAND_bytes(__n: int) -> bytes: ...\ndef RAND_pseudo_bytes(__n: int) -> tuple[bytes, bool]: ...\ndef RAND_status() -> bool: ...\ndef RAND_egd(path: str) -> None: ...\ndef RAND_add(__string: str | ReadableBuffer, __entropy: float) -> None: ...\n\nif sys.version_info < (3, 12):\n    def match_hostname(cert: _PeerCertRetDictType, hostname: str) -> None: ...\n\ndef cert_time_to_seconds(cert_time: str) -> int: ...\n\nif sys.version_info >= (3, 10):\n    def get_server_certificate(\n        addr: tuple[str, int], ssl_version: int = ..., ca_certs: str | None = None, timeout: float = ...\n    ) -> str: ...\n\nelse:\n    def get_server_certificate(addr: tuple[str, int], ssl_version: int = ..., ca_certs: str | None = None) -> str: ...\n\ndef DER_cert_to_PEM_cert(der_cert_bytes: ReadableBuffer) -> str: ...\ndef PEM_cert_to_DER_cert(pem_cert_string: str) -> bytes: ...\n\nclass DefaultVerifyPaths(NamedTuple):\n    cafile: str\n    capath: str\n    openssl_cafile_env: str\n    openssl_cafile: str\n    openssl_capath_env: str\n    openssl_capath: str\n\ndef get_default_verify_paths() -> DefaultVerifyPaths: ...\n\nif sys.platform == \"win32\":\n    def enum_certificates(store_name: str) -> _EnumRetType: ...\n    def enum_crls(store_name: str) -> _EnumRetType: ...\n\nclass VerifyMode(enum.IntEnum):\n    CERT_NONE: int\n    CERT_OPTIONAL: int\n    CERT_REQUIRED: int\n\nCERT_NONE: VerifyMode\nCERT_OPTIONAL: VerifyMode\nCERT_REQUIRED: VerifyMode\n\nclass VerifyFlags(enum.IntFlag):\n    VERIFY_DEFAULT: int\n    VERIFY_CRL_CHECK_LEAF: int\n    VERIFY_CRL_CHECK_CHAIN: int\n    VERIFY_X509_STRICT: int\n    VERIFY_X509_TRUSTED_FIRST: int\n    if sys.version_info >= (3, 10):\n        VERIFY_ALLOW_PROXY_CERTS: int\n        VERIFY_X509_PARTIAL_CHAIN: int\n\nVERIFY_DEFAULT: VerifyFlags\nVERIFY_CRL_CHECK_LEAF: VerifyFlags\nVERIFY_CRL_CHECK_CHAIN: VerifyFlags\nVERIFY_X509_STRICT: VerifyFlags\nVERIFY_X509_TRUSTED_FIRST: VerifyFlags\n\nif sys.version_info >= (3, 10):\n    VERIFY_ALLOW_PROXY_CERTS: VerifyFlags\n    VERIFY_X509_PARTIAL_CHAIN: VerifyFlags\n\nclass _SSLMethod(enum.IntEnum):\n    PROTOCOL_SSLv23: int\n    PROTOCOL_SSLv2: int\n    PROTOCOL_SSLv3: int\n    PROTOCOL_TLSv1: int\n    PROTOCOL_TLSv1_1: int\n    PROTOCOL_TLSv1_2: int\n    PROTOCOL_TLS: int\n    PROTOCOL_TLS_CLIENT: int\n    PROTOCOL_TLS_SERVER: int\n\nPROTOCOL_SSLv23: _SSLMethod\nPROTOCOL_SSLv2: _SSLMethod\nPROTOCOL_SSLv3: _SSLMethod\nPROTOCOL_TLSv1: _SSLMethod\nPROTOCOL_TLSv1_1: _SSLMethod\nPROTOCOL_TLSv1_2: _SSLMethod\nPROTOCOL_TLS: _SSLMethod\nPROTOCOL_TLS_CLIENT: _SSLMethod\nPROTOCOL_TLS_SERVER: _SSLMethod\n\nclass Options(enum.IntFlag):\n    OP_ALL: int\n    OP_NO_SSLv2: int\n    OP_NO_SSLv3: int\n    OP_NO_TLSv1: int\n    OP_NO_TLSv1_1: int\n    OP_NO_TLSv1_2: int\n    OP_NO_TLSv1_3: int\n    OP_CIPHER_SERVER_PREFERENCE: int\n    OP_SINGLE_DH_USE: int\n    OP_SINGLE_ECDH_USE: int\n    OP_NO_COMPRESSION: int\n    OP_NO_TICKET: int\n    OP_NO_RENEGOTIATION: int\n    if sys.version_info >= (3, 8):\n        OP_ENABLE_MIDDLEBOX_COMPAT: int\n        if sys.platform == \"linux\":\n            OP_IGNORE_UNEXPECTED_EOF: int\n\nOP_ALL: Options\nOP_NO_SSLv2: Options\nOP_NO_SSLv3: Options\nOP_NO_TLSv1: Options\nOP_NO_TLSv1_1: Options\nOP_NO_TLSv1_2: Options\nOP_NO_TLSv1_3: Options\nOP_CIPHER_SERVER_PREFERENCE: Options\nOP_SINGLE_DH_USE: Options\nOP_SINGLE_ECDH_USE: Options\nOP_NO_COMPRESSION: Options\nOP_NO_TICKET: Options\nOP_NO_RENEGOTIATION: Options\nif sys.version_info >= (3, 8):\n    OP_ENABLE_MIDDLEBOX_COMPAT: Options\n    if sys.platform == \"linux\":\n        OP_IGNORE_UNEXPECTED_EOF: Options\n\nHAS_NEVER_CHECK_COMMON_NAME: bool\nHAS_SSLv2: bool\nHAS_SSLv3: bool\nHAS_TLSv1: bool\nHAS_TLSv1_1: bool\nHAS_TLSv1_2: bool\nHAS_TLSv1_3: bool\nHAS_ALPN: bool\nHAS_ECDH: bool\nHAS_SNI: bool\nHAS_NPN: bool\nCHANNEL_BINDING_TYPES: list[str]\n\nOPENSSL_VERSION: str\nOPENSSL_VERSION_INFO: tuple[int, int, int, int, int]\nOPENSSL_VERSION_NUMBER: int\n\nclass AlertDescription(enum.IntEnum):\n    ALERT_DESCRIPTION_ACCESS_DENIED: int\n    ALERT_DESCRIPTION_BAD_CERTIFICATE: int\n    ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE: int\n    ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE: int\n    ALERT_DESCRIPTION_BAD_RECORD_MAC: int\n    ALERT_DESCRIPTION_CERTIFICATE_EXPIRED: int\n    ALERT_DESCRIPTION_CERTIFICATE_REVOKED: int\n    ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN: int\n    ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE: int\n    ALERT_DESCRIPTION_CLOSE_NOTIFY: int\n    ALERT_DESCRIPTION_DECODE_ERROR: int\n    ALERT_DESCRIPTION_DECOMPRESSION_FAILURE: int\n    ALERT_DESCRIPTION_DECRYPT_ERROR: int\n    ALERT_DESCRIPTION_HANDSHAKE_FAILURE: int\n    ALERT_DESCRIPTION_ILLEGAL_PARAMETER: int\n    ALERT_DESCRIPTION_INSUFFICIENT_SECURITY: int\n    ALERT_DESCRIPTION_INTERNAL_ERROR: int\n    ALERT_DESCRIPTION_NO_RENEGOTIATION: int\n    ALERT_DESCRIPTION_PROTOCOL_VERSION: int\n    ALERT_DESCRIPTION_RECORD_OVERFLOW: int\n    ALERT_DESCRIPTION_UNEXPECTED_MESSAGE: int\n    ALERT_DESCRIPTION_UNKNOWN_CA: int\n    ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY: int\n    ALERT_DESCRIPTION_UNRECOGNIZED_NAME: int\n    ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE: int\n    ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION: int\n    ALERT_DESCRIPTION_USER_CANCELLED: int\n\nALERT_DESCRIPTION_HANDSHAKE_FAILURE: AlertDescription\nALERT_DESCRIPTION_INTERNAL_ERROR: AlertDescription\nALERT_DESCRIPTION_ACCESS_DENIED: AlertDescription\nALERT_DESCRIPTION_BAD_CERTIFICATE: AlertDescription\nALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE: AlertDescription\nALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE: AlertDescription\nALERT_DESCRIPTION_BAD_RECORD_MAC: AlertDescription\nALERT_DESCRIPTION_CERTIFICATE_EXPIRED: AlertDescription\nALERT_DESCRIPTION_CERTIFICATE_REVOKED: AlertDescription\nALERT_DESCRIPTION_CERTIFICATE_UNKNOWN: AlertDescription\nALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE: AlertDescription\nALERT_DESCRIPTION_CLOSE_NOTIFY: AlertDescription\nALERT_DESCRIPTION_DECODE_ERROR: AlertDescription\nALERT_DESCRIPTION_DECOMPRESSION_FAILURE: AlertDescription\nALERT_DESCRIPTION_DECRYPT_ERROR: AlertDescription\nALERT_DESCRIPTION_ILLEGAL_PARAMETER: AlertDescription\nALERT_DESCRIPTION_INSUFFICIENT_SECURITY: AlertDescription\nALERT_DESCRIPTION_NO_RENEGOTIATION: AlertDescription\nALERT_DESCRIPTION_PROTOCOL_VERSION: AlertDescription\nALERT_DESCRIPTION_RECORD_OVERFLOW: AlertDescription\nALERT_DESCRIPTION_UNEXPECTED_MESSAGE: AlertDescription\nALERT_DESCRIPTION_UNKNOWN_CA: AlertDescription\nALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY: AlertDescription\nALERT_DESCRIPTION_UNRECOGNIZED_NAME: AlertDescription\nALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE: AlertDescription\nALERT_DESCRIPTION_UNSUPPORTED_EXTENSION: AlertDescription\nALERT_DESCRIPTION_USER_CANCELLED: AlertDescription\n\nclass _ASN1ObjectBase(NamedTuple):\n    nid: int\n    shortname: str\n    longname: str\n    oid: str\n\nclass _ASN1Object(_ASN1ObjectBase):\n    def __new__(cls, oid: str) -> Self: ...\n    @classmethod\n    def fromnid(cls, nid: int) -> Self: ...\n    @classmethod\n    def fromname(cls, name: str) -> Self: ...\n\nclass Purpose(_ASN1Object, enum.Enum):\n    SERVER_AUTH: _ASN1Object\n    CLIENT_AUTH: _ASN1Object\n\nclass SSLSocket(socket.socket):\n    context: SSLContext\n    server_side: bool\n    server_hostname: str | None\n    session: SSLSession | None\n    @property\n    def session_reused(self) -> bool | None: ...\n    def __init__(self, *args: Any, **kwargs: Any) -> None: ...\n    def connect(self, addr: socket._Address) -> None: ...\n    def connect_ex(self, addr: socket._Address) -> int: ...\n    def recv(self, buflen: int = 1024, flags: int = 0) -> bytes: ...\n    def recv_into(self, buffer: WriteableBuffer, nbytes: int | None = None, flags: int = 0) -> int: ...\n    def recvfrom(self, buflen: int = 1024, flags: int = 0) -> tuple[bytes, socket._RetAddress]: ...\n    def recvfrom_into(\n        self, buffer: WriteableBuffer, nbytes: int | None = None, flags: int = 0\n    ) -> tuple[int, socket._RetAddress]: ...\n    def send(self, data: ReadableBuffer, flags: int = 0) -> int: ...\n    def sendall(self, data: ReadableBuffer, flags: int = 0) -> None: ...\n    @overload\n    def sendto(self, data: ReadableBuffer, flags_or_addr: socket._Address, addr: None = None) -> int: ...\n    @overload\n    def sendto(self, data: ReadableBuffer, flags_or_addr: int, addr: socket._Address) -> int: ...\n    def shutdown(self, how: int) -> None: ...\n    def read(self, len: int = 1024, buffer: bytearray | None = None) -> bytes: ...\n    def write(self, data: ReadableBuffer) -> int: ...\n    def do_handshake(self, block: bool = False) -> None: ...  # block is undocumented\n    @overload\n    def getpeercert(self, binary_form: Literal[False] = False) -> _PeerCertRetDictType | None: ...\n    @overload\n    def getpeercert(self, binary_form: Literal[True]) -> bytes | None: ...\n    @overload\n    def getpeercert(self, binary_form: bool) -> _PeerCertRetType: ...\n    def cipher(self) -> tuple[str, str, int] | None: ...\n    def shared_ciphers(self) -> list[tuple[str, str, int]] | None: ...\n    def compression(self) -> str | None: ...\n    def get_channel_binding(self, cb_type: str = \"tls-unique\") -> bytes | None: ...\n    def selected_alpn_protocol(self) -> str | None: ...\n    def selected_npn_protocol(self) -> str | None: ...\n    def accept(self) -> tuple[SSLSocket, socket._RetAddress]: ...\n    def unwrap(self) -> socket.socket: ...\n    def version(self) -> str | None: ...\n    def pending(self) -> int: ...\n    if sys.version_info >= (3, 8):\n        def verify_client_post_handshake(self) -> None: ...\n\nclass TLSVersion(enum.IntEnum):\n    MINIMUM_SUPPORTED: int\n    MAXIMUM_SUPPORTED: int\n    SSLv3: int\n    TLSv1: int\n    TLSv1_1: int\n    TLSv1_2: int\n    TLSv1_3: int\n\nclass SSLContext:\n    check_hostname: bool\n    options: Options\n    verify_flags: VerifyFlags\n    verify_mode: VerifyMode\n    @property\n    def protocol(self) -> _SSLMethod: ...\n    hostname_checks_common_name: bool\n    maximum_version: TLSVersion\n    minimum_version: TLSVersion\n    sni_callback: Callable[[SSLObject, str, SSLContext], None | int] | None\n    # The following two attributes have class-level defaults.\n    # However, the docs explicitly state that it's OK to override these attributes on instances,\n    # so making these ClassVars wouldn't be appropriate\n    sslobject_class: type[SSLObject]\n    sslsocket_class: type[SSLSocket]\n    if sys.version_info >= (3, 8):\n        keylog_filename: str\n        post_handshake_auth: bool\n    if sys.version_info >= (3, 10):\n        security_level: int\n    if sys.version_info >= (3, 10):\n        # Using the default (None) for the `protocol` parameter is deprecated,\n        # but there isn't a good way of marking that in the stub unless/until PEP 702 is accepted\n        def __new__(cls, protocol: int | None = None, *args: Any, **kwargs: Any) -> Self: ...\n    else:\n        def __new__(cls, protocol: int = ..., *args: Any, **kwargs: Any) -> Self: ...\n\n    def cert_store_stats(self) -> dict[str, int]: ...\n    def load_cert_chain(\n        self, certfile: StrOrBytesPath, keyfile: StrOrBytesPath | None = None, password: _PasswordType | None = None\n    ) -> None: ...\n    def load_default_certs(self, purpose: Purpose = ...) -> None: ...\n    def load_verify_locations(\n        self,\n        cafile: StrOrBytesPath | None = None,\n        capath: StrOrBytesPath | None = None,\n        cadata: str | ReadableBuffer | None = None,\n    ) -> None: ...\n    @overload\n    def get_ca_certs(self, binary_form: Literal[False] = False) -> list[_PeerCertRetDictType]: ...\n    @overload\n    def get_ca_certs(self, binary_form: Literal[True]) -> list[bytes]: ...\n    @overload\n    def get_ca_certs(self, binary_form: bool = False) -> Any: ...\n    def get_ciphers(self) -> list[_Cipher]: ...\n    def set_default_verify_paths(self) -> None: ...\n    def set_ciphers(self, __cipherlist: str) -> None: ...\n    def set_alpn_protocols(self, alpn_protocols: Iterable[str]) -> None: ...\n    def set_npn_protocols(self, npn_protocols: Iterable[str]) -> None: ...\n    def set_servername_callback(self, server_name_callback: _SrvnmeCbType | None) -> None: ...\n    def load_dh_params(self, __path: str) -> None: ...\n    def set_ecdh_curve(self, __name: str) -> None: ...\n    def wrap_socket(\n        self,\n        sock: socket.socket,\n        server_side: bool = False,\n        do_handshake_on_connect: bool = True,\n        suppress_ragged_eofs: bool = True,\n        server_hostname: str | None = None,\n        session: SSLSession | None = None,\n    ) -> SSLSocket: ...\n    def wrap_bio(\n        self,\n        incoming: MemoryBIO,\n        outgoing: MemoryBIO,\n        server_side: bool = False,\n        server_hostname: str | None = None,\n        session: SSLSession | None = None,\n    ) -> SSLObject: ...\n    def session_stats(self) -> dict[str, int]: ...\n\nclass SSLObject:\n    context: SSLContext\n    @property\n    def server_side(self) -> bool: ...\n    @property\n    def server_hostname(self) -> str | None: ...\n    session: SSLSession | None\n    @property\n    def session_reused(self) -> bool: ...\n    def __init__(self, *args: Any, **kwargs: Any) -> None: ...\n    def read(self, len: int = 1024, buffer: bytearray | None = None) -> bytes: ...\n    def write(self, data: ReadableBuffer) -> int: ...\n    @overload\n    def getpeercert(self, binary_form: Literal[False] = False) -> _PeerCertRetDictType | None: ...\n    @overload\n    def getpeercert(self, binary_form: Literal[True]) -> bytes | None: ...\n    @overload\n    def getpeercert(self, binary_form: bool) -> _PeerCertRetType: ...\n    def selected_alpn_protocol(self) -> str | None: ...\n    def selected_npn_protocol(self) -> str | None: ...\n    def cipher(self) -> tuple[str, str, int] | None: ...\n    def shared_ciphers(self) -> list[tuple[str, str, int]] | None: ...\n    def compression(self) -> str | None: ...\n    def pending(self) -> int: ...\n    def do_handshake(self) -> None: ...\n    def unwrap(self) -> None: ...\n    def version(self) -> str | None: ...\n    def get_channel_binding(self, cb_type: str = \"tls-unique\") -> bytes | None: ...\n    if sys.version_info >= (3, 8):\n        def verify_client_post_handshake(self) -> None: ...\n\n@final\nclass MemoryBIO:\n    pending: int\n    eof: bool\n    def read(self, __size: int = -1) -> bytes: ...\n    def write(self, __b: ReadableBuffer) -> int: ...\n    def write_eof(self) -> None: ...\n\n@final\nclass SSLSession:\n    @property\n    def has_ticket(self) -> bool: ...\n    @property\n    def id(self) -> bytes: ...\n    @property\n    def ticket_lifetime_hint(self) -> int: ...\n    @property\n    def time(self) -> int: ...\n    @property\n    def timeout(self) -> int: ...\n\nclass SSLErrorNumber(enum.IntEnum):\n    SSL_ERROR_EOF: int\n    SSL_ERROR_INVALID_ERROR_CODE: int\n    SSL_ERROR_SSL: int\n    SSL_ERROR_SYSCALL: int\n    SSL_ERROR_WANT_CONNECT: int\n    SSL_ERROR_WANT_READ: int\n    SSL_ERROR_WANT_WRITE: int\n    SSL_ERROR_WANT_X509_LOOKUP: int\n    SSL_ERROR_ZERO_RETURN: int\n\nSSL_ERROR_EOF: SSLErrorNumber  # undocumented\nSSL_ERROR_INVALID_ERROR_CODE: SSLErrorNumber  # undocumented\nSSL_ERROR_SSL: SSLErrorNumber  # undocumented\nSSL_ERROR_SYSCALL: SSLErrorNumber  # undocumented\nSSL_ERROR_WANT_CONNECT: SSLErrorNumber  # undocumented\nSSL_ERROR_WANT_READ: SSLErrorNumber  # undocumented\nSSL_ERROR_WANT_WRITE: SSLErrorNumber  # undocumented\nSSL_ERROR_WANT_X509_LOOKUP: SSLErrorNumber  # undocumented\nSSL_ERROR_ZERO_RETURN: SSLErrorNumber  # undocumented\n\ndef get_protocol_name(protocol_code: int) -> str: ...\n\nif sys.version_info < (3, 9):\n    AF_INET: int\nPEM_FOOTER: str\nPEM_HEADER: str\nSOCK_STREAM: int\nSOL_SOCKET: int\nSO_TYPE: int\n",
  "/typeshed/stdlib/stat.pyi": "from _stat import *\n",
  "/typeshed/stdlib/statistics.pyi": "import sys\nfrom _typeshed import SupportsRichComparisonT\nfrom collections.abc import Hashable, Iterable, Sequence\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom typing import Any, NamedTuple, SupportsFloat, TypeVar\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\n    \"StatisticsError\",\n    \"pstdev\",\n    \"pvariance\",\n    \"stdev\",\n    \"variance\",\n    \"median\",\n    \"median_low\",\n    \"median_high\",\n    \"median_grouped\",\n    \"mean\",\n    \"mode\",\n    \"harmonic_mean\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"geometric_mean\", \"multimode\", \"NormalDist\", \"fmean\", \"quantiles\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"covariance\", \"correlation\", \"linear_regression\"]\n\n# Most functions in this module accept homogeneous collections of one of these types\n_Number: TypeAlias = float | Decimal | Fraction\n_NumberT = TypeVar(\"_NumberT\", float, Decimal, Fraction)\n\n# Used in mode, multimode\n_HashableT = TypeVar(\"_HashableT\", bound=Hashable)\n\nclass StatisticsError(ValueError): ...\n\nif sys.version_info >= (3, 11):\n    def fmean(data: Iterable[SupportsFloat], weights: Iterable[SupportsFloat] | None = None) -> float: ...\n\nelif sys.version_info >= (3, 8):\n    def fmean(data: Iterable[SupportsFloat]) -> float: ...\n\nif sys.version_info >= (3, 8):\n    def geometric_mean(data: Iterable[SupportsFloat]) -> float: ...\n\ndef mean(data: Iterable[_NumberT]) -> _NumberT: ...\n\nif sys.version_info >= (3, 10):\n    def harmonic_mean(data: Iterable[_NumberT], weights: Iterable[_Number] | None = None) -> _NumberT: ...\n\nelse:\n    def harmonic_mean(data: Iterable[_NumberT]) -> _NumberT: ...\n\ndef median(data: Iterable[_NumberT]) -> _NumberT: ...\ndef median_low(data: Iterable[SupportsRichComparisonT]) -> SupportsRichComparisonT: ...\ndef median_high(data: Iterable[SupportsRichComparisonT]) -> SupportsRichComparisonT: ...\n\nif sys.version_info >= (3, 11):\n    def median_grouped(data: Iterable[SupportsFloat], interval: SupportsFloat = 1.0) -> float: ...\n\nelse:\n    def median_grouped(data: Iterable[_NumberT], interval: _NumberT | float = 1) -> _NumberT | float: ...\n\ndef mode(data: Iterable[_HashableT]) -> _HashableT: ...\n\nif sys.version_info >= (3, 8):\n    def multimode(data: Iterable[_HashableT]) -> list[_HashableT]: ...\n\ndef pstdev(data: Iterable[_NumberT], mu: _NumberT | None = None) -> _NumberT: ...\ndef pvariance(data: Iterable[_NumberT], mu: _NumberT | None = None) -> _NumberT: ...\n\nif sys.version_info >= (3, 8):\n    def quantiles(\n        data: Iterable[_NumberT], *, n: int = 4, method: Literal[\"inclusive\", \"exclusive\"] = \"exclusive\"\n    ) -> list[_NumberT]: ...\n\ndef stdev(data: Iterable[_NumberT], xbar: _NumberT | None = None) -> _NumberT: ...\ndef variance(data: Iterable[_NumberT], xbar: _NumberT | None = None) -> _NumberT: ...\n\nif sys.version_info >= (3, 8):\n    class NormalDist:\n        def __init__(self, mu: float = 0.0, sigma: float = 1.0) -> None: ...\n        @property\n        def mean(self) -> float: ...\n        @property\n        def median(self) -> float: ...\n        @property\n        def mode(self) -> float: ...\n        @property\n        def stdev(self) -> float: ...\n        @property\n        def variance(self) -> float: ...\n        @classmethod\n        def from_samples(cls, data: Iterable[SupportsFloat]) -> Self: ...\n        def samples(self, n: int, *, seed: Any | None = None) -> list[float]: ...\n        def pdf(self, x: float) -> float: ...\n        def cdf(self, x: float) -> float: ...\n        def inv_cdf(self, p: float) -> float: ...\n        def overlap(self, other: NormalDist) -> float: ...\n        def quantiles(self, n: int = 4) -> list[float]: ...\n        if sys.version_info >= (3, 9):\n            def zscore(self, x: float) -> float: ...\n\n        def __eq__(self, x2: object) -> bool: ...\n        def __add__(self, x2: float | NormalDist) -> NormalDist: ...\n        def __sub__(self, x2: float | NormalDist) -> NormalDist: ...\n        def __mul__(self, x2: float) -> NormalDist: ...\n        def __truediv__(self, x2: float) -> NormalDist: ...\n        def __pos__(self) -> NormalDist: ...\n        def __neg__(self) -> NormalDist: ...\n        __radd__ = __add__\n        def __rsub__(self, x2: float | NormalDist) -> NormalDist: ...\n        __rmul__ = __mul__\n\nif sys.version_info >= (3, 10):\n    def correlation(__x: Sequence[_Number], __y: Sequence[_Number]) -> float: ...\n    def covariance(__x: Sequence[_Number], __y: Sequence[_Number]) -> float: ...\n\n    class LinearRegression(NamedTuple):\n        slope: float\n        intercept: float\n\nif sys.version_info >= (3, 11):\n    def linear_regression(\n        __regressor: Sequence[_Number], __dependent_variable: Sequence[_Number], *, proportional: bool = False\n    ) -> LinearRegression: ...\n\nelif sys.version_info >= (3, 10):\n    def linear_regression(__regressor: Sequence[_Number], __dependent_variable: Sequence[_Number]) -> LinearRegression: ...\n",
  "/typeshed/stdlib/string.pyi": "import sys\nfrom _typeshed import StrOrLiteralStr\nfrom collections.abc import Iterable, Mapping, Sequence\nfrom re import Pattern, RegexFlag\nfrom typing import Any, ClassVar, overload\nfrom typing_extensions import LiteralString, TypeAlias\n\n__all__ = [\n    \"ascii_letters\",\n    \"ascii_lowercase\",\n    \"ascii_uppercase\",\n    \"capwords\",\n    \"digits\",\n    \"hexdigits\",\n    \"octdigits\",\n    \"printable\",\n    \"punctuation\",\n    \"whitespace\",\n    \"Formatter\",\n    \"Template\",\n]\n\nascii_letters: LiteralString\nascii_lowercase: LiteralString\nascii_uppercase: LiteralString\ndigits: LiteralString\nhexdigits: LiteralString\noctdigits: LiteralString\npunctuation: LiteralString\nprintable: LiteralString\nwhitespace: LiteralString\n\ndef capwords(s: StrOrLiteralStr, sep: StrOrLiteralStr | None = None) -> StrOrLiteralStr: ...\n\nif sys.version_info >= (3, 9):\n    _TemplateMetaclass: TypeAlias = type\nelse:\n    class _TemplateMetaclass(type):\n        pattern: ClassVar[str]\n        def __init__(cls, name: str, bases: tuple[type, ...], dct: dict[str, Any]) -> None: ...\n\nclass Template(metaclass=_TemplateMetaclass):\n    template: str\n    delimiter: ClassVar[str]\n    idpattern: ClassVar[str]\n    braceidpattern: ClassVar[str | None]\n    flags: ClassVar[RegexFlag]\n    pattern: ClassVar[Pattern[str]]\n    def __init__(self, template: str) -> None: ...\n    def substitute(self, __mapping: Mapping[str, object] = {}, **kwds: object) -> str: ...\n    def safe_substitute(self, __mapping: Mapping[str, object] = {}, **kwds: object) -> str: ...\n    if sys.version_info >= (3, 11):\n        def get_identifiers(self) -> list[str]: ...\n        def is_valid(self) -> bool: ...\n\nclass Formatter:\n    @overload\n    def format(self, __format_string: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...\n    @overload\n    def format(self, __format_string: str, *args: Any, **kwargs: Any) -> str: ...\n    @overload\n    def vformat(\n        self, format_string: LiteralString, args: Sequence[LiteralString], kwargs: Mapping[LiteralString, LiteralString]\n    ) -> LiteralString: ...\n    @overload\n    def vformat(self, format_string: str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> str: ...\n    def _vformat(  # undocumented\n        self,\n        format_string: str,\n        args: Sequence[Any],\n        kwargs: Mapping[str, Any],\n        used_args: set[int | str],\n        recursion_depth: int,\n        auto_arg_index: int = 0,\n    ) -> tuple[str, int]: ...\n    def parse(\n        self, format_string: StrOrLiteralStr\n    ) -> Iterable[tuple[StrOrLiteralStr, StrOrLiteralStr | None, StrOrLiteralStr | None, StrOrLiteralStr | None]]: ...\n    def get_field(self, field_name: str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> Any: ...\n    def get_value(self, key: int | str, args: Sequence[Any], kwargs: Mapping[str, Any]) -> Any: ...\n    def check_unused_args(self, used_args: set[int | str], args: Sequence[Any], kwargs: Mapping[str, Any]) -> None: ...\n    def format_field(self, value: Any, format_spec: str) -> Any: ...\n    def convert_field(self, value: Any, conversion: str) -> Any: ...\n",
  "/typeshed/stdlib/stringprep.pyi": "b1_set: set[int]\nb3_exceptions: dict[int, str]\nc22_specials: set[int]\nc6_set: set[int]\nc7_set: set[int]\nc8_set: set[int]\nc9_set: set[int]\n\ndef in_table_a1(code: str) -> bool: ...\ndef in_table_b1(code: str) -> bool: ...\ndef map_table_b3(code: str) -> str: ...\ndef map_table_b2(a: str) -> str: ...\ndef in_table_c11(code: str) -> bool: ...\ndef in_table_c12(code: str) -> bool: ...\ndef in_table_c11_c12(code: str) -> bool: ...\ndef in_table_c21(code: str) -> bool: ...\ndef in_table_c22(code: str) -> bool: ...\ndef in_table_c21_c22(code: str) -> bool: ...\ndef in_table_c3(code: str) -> bool: ...\ndef in_table_c4(code: str) -> bool: ...\ndef in_table_c5(code: str) -> bool: ...\ndef in_table_c6(code: str) -> bool: ...\ndef in_table_c7(code: str) -> bool: ...\ndef in_table_c8(code: str) -> bool: ...\ndef in_table_c9(code: str) -> bool: ...\ndef in_table_d1(code: str) -> bool: ...\ndef in_table_d2(code: str) -> bool: ...\n",
  "/typeshed/stdlib/struct.pyi": "from _typeshed import ReadableBuffer, WriteableBuffer\nfrom collections.abc import Iterator\nfrom typing import Any\n\n__all__ = [\"calcsize\", \"pack\", \"pack_into\", \"unpack\", \"unpack_from\", \"iter_unpack\", \"Struct\", \"error\"]\n\nclass error(Exception): ...\n\ndef pack(__fmt: str | bytes, *v: Any) -> bytes: ...\ndef pack_into(__fmt: str | bytes, __buffer: WriteableBuffer, __offset: int, *v: Any) -> None: ...\ndef unpack(__format: str | bytes, __buffer: ReadableBuffer) -> tuple[Any, ...]: ...\ndef unpack_from(__format: str | bytes, buffer: ReadableBuffer, offset: int = 0) -> tuple[Any, ...]: ...\ndef iter_unpack(__format: str | bytes, __buffer: ReadableBuffer) -> Iterator[tuple[Any, ...]]: ...\ndef calcsize(__format: str | bytes) -> int: ...\n\nclass Struct:\n    @property\n    def format(self) -> str: ...\n    @property\n    def size(self) -> int: ...\n    def __init__(self, format: str | bytes) -> None: ...\n    def pack(self, *v: Any) -> bytes: ...\n    def pack_into(self, buffer: WriteableBuffer, offset: int, *v: Any) -> None: ...\n    def unpack(self, __buffer: ReadableBuffer) -> tuple[Any, ...]: ...\n    def unpack_from(self, buffer: ReadableBuffer, offset: int = 0) -> tuple[Any, ...]: ...\n    def iter_unpack(self, __buffer: ReadableBuffer) -> Iterator[tuple[Any, ...]]: ...\n",
  "/typeshed/stdlib/sunau.pyi": "import sys\nfrom _typeshed import Unused\nfrom typing import IO, Any, NamedTuple, NoReturn, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\n_File: TypeAlias = str | IO[bytes]\n\nclass Error(Exception): ...\n\nAUDIO_FILE_MAGIC: int\nAUDIO_FILE_ENCODING_MULAW_8: int\nAUDIO_FILE_ENCODING_LINEAR_8: int\nAUDIO_FILE_ENCODING_LINEAR_16: int\nAUDIO_FILE_ENCODING_LINEAR_24: int\nAUDIO_FILE_ENCODING_LINEAR_32: int\nAUDIO_FILE_ENCODING_FLOAT: int\nAUDIO_FILE_ENCODING_DOUBLE: int\nAUDIO_FILE_ENCODING_ADPCM_G721: int\nAUDIO_FILE_ENCODING_ADPCM_G722: int\nAUDIO_FILE_ENCODING_ADPCM_G723_3: int\nAUDIO_FILE_ENCODING_ADPCM_G723_5: int\nAUDIO_FILE_ENCODING_ALAW_8: int\nAUDIO_UNKNOWN_SIZE: int\n\nclass _sunau_params(NamedTuple):\n    nchannels: int\n    sampwidth: int\n    framerate: int\n    nframes: int\n    comptype: str\n    compname: str\n\nclass Au_read:\n    def __init__(self, f: _File) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def getfp(self) -> IO[bytes] | None: ...\n    def rewind(self) -> None: ...\n    def close(self) -> None: ...\n    def tell(self) -> int: ...\n    def getnchannels(self) -> int: ...\n    def getnframes(self) -> int: ...\n    def getsampwidth(self) -> int: ...\n    def getframerate(self) -> int: ...\n    def getcomptype(self) -> str: ...\n    def getcompname(self) -> str: ...\n    def getparams(self) -> _sunau_params: ...\n    def getmarkers(self) -> None: ...\n    def getmark(self, id: Any) -> NoReturn: ...\n    def setpos(self, pos: int) -> None: ...\n    def readframes(self, nframes: int) -> bytes | None: ...\n\nclass Au_write:\n    def __init__(self, f: _File) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def setnchannels(self, nchannels: int) -> None: ...\n    def getnchannels(self) -> int: ...\n    def setsampwidth(self, sampwidth: int) -> None: ...\n    def getsampwidth(self) -> int: ...\n    def setframerate(self, framerate: float) -> None: ...\n    def getframerate(self) -> int: ...\n    def setnframes(self, nframes: int) -> None: ...\n    def getnframes(self) -> int: ...\n    def setcomptype(self, type: str, name: str) -> None: ...\n    def getcomptype(self) -> str: ...\n    def getcompname(self) -> str: ...\n    def setparams(self, params: _sunau_params) -> None: ...\n    def getparams(self) -> _sunau_params: ...\n    def tell(self) -> int: ...\n    # should be any bytes-like object after 3.4, but we don't have a type for that\n    def writeframesraw(self, data: bytes) -> None: ...\n    def writeframes(self, data: bytes) -> None: ...\n    def close(self) -> None: ...\n\n@overload\ndef open(f: _File, mode: Literal[\"r\", \"rb\"]) -> Au_read: ...\n@overload\ndef open(f: _File, mode: Literal[\"w\", \"wb\"]) -> Au_write: ...\n@overload\ndef open(f: _File, mode: str | None = None) -> Any: ...\n\nif sys.version_info < (3, 9):\n    openfp = open\n",
  "/typeshed/stdlib/symbol.pyi": "import sys\n\nsingle_input: int\nfile_input: int\neval_input: int\ndecorator: int\ndecorators: int\ndecorated: int\nasync_funcdef: int\nfuncdef: int\nparameters: int\ntypedargslist: int\ntfpdef: int\nvarargslist: int\nvfpdef: int\nstmt: int\nsimple_stmt: int\nsmall_stmt: int\nexpr_stmt: int\nannassign: int\ntestlist_star_expr: int\naugassign: int\ndel_stmt: int\npass_stmt: int\nflow_stmt: int\nbreak_stmt: int\ncontinue_stmt: int\nreturn_stmt: int\nyield_stmt: int\nraise_stmt: int\nimport_stmt: int\nimport_name: int\nimport_from: int\nimport_as_name: int\ndotted_as_name: int\nimport_as_names: int\ndotted_as_names: int\ndotted_name: int\nglobal_stmt: int\nnonlocal_stmt: int\nassert_stmt: int\ncompound_stmt: int\nasync_stmt: int\nif_stmt: int\nwhile_stmt: int\nfor_stmt: int\ntry_stmt: int\nwith_stmt: int\nwith_item: int\nexcept_clause: int\nsuite: int\ntest: int\ntest_nocond: int\nlambdef: int\nlambdef_nocond: int\nor_test: int\nand_test: int\nnot_test: int\ncomparison: int\ncomp_op: int\nstar_expr: int\nexpr: int\nxor_expr: int\nand_expr: int\nshift_expr: int\narith_expr: int\nterm: int\nfactor: int\npower: int\natom_expr: int\natom: int\ntestlist_comp: int\ntrailer: int\nsubscriptlist: int\nsubscript: int\nsliceop: int\nexprlist: int\ntestlist: int\ndictorsetmaker: int\nclassdef: int\narglist: int\nargument: int\ncomp_iter: int\ncomp_for: int\ncomp_if: int\nencoding_decl: int\nyield_expr: int\nyield_arg: int\nsync_comp_for: int\nif sys.version_info >= (3, 8):\n    func_body_suite: int\n    func_type: int\n    func_type_input: int\n    namedexpr_test: int\n    typelist: int\n\nsym_name: dict[int, str]\n",
  "/typeshed/stdlib/symtable.pyi": "import sys\nfrom _collections_abc import dict_keys\nfrom collections.abc import Sequence\nfrom typing import Any\n\n__all__ = [\"symtable\", \"SymbolTable\", \"Class\", \"Function\", \"Symbol\"]\n\ndef symtable(code: str, filename: str, compile_type: str) -> SymbolTable: ...\n\nclass SymbolTable:\n    def __init__(self, raw_table: Any, filename: str) -> None: ...\n    def get_type(self) -> str: ...\n    def get_id(self) -> int: ...\n    def get_name(self) -> str: ...\n    def get_lineno(self) -> int: ...\n    def is_optimized(self) -> bool: ...\n    def is_nested(self) -> bool: ...\n    def has_children(self) -> bool: ...\n    if sys.version_info < (3, 9):\n        def has_exec(self) -> bool: ...\n\n    def get_identifiers(self) -> dict_keys[str, int]: ...\n    def lookup(self, name: str) -> Symbol: ...\n    def get_symbols(self) -> list[Symbol]: ...\n    def get_children(self) -> list[SymbolTable]: ...\n\nclass Function(SymbolTable):\n    def get_parameters(self) -> tuple[str, ...]: ...\n    def get_locals(self) -> tuple[str, ...]: ...\n    def get_globals(self) -> tuple[str, ...]: ...\n    def get_frees(self) -> tuple[str, ...]: ...\n    if sys.version_info >= (3, 8):\n        def get_nonlocals(self) -> tuple[str, ...]: ...\n\nclass Class(SymbolTable):\n    def get_methods(self) -> tuple[str, ...]: ...\n\nclass Symbol:\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self, name: str, flags: int, namespaces: Sequence[SymbolTable] | None = None, *, module_scope: bool = False\n        ) -> None: ...\n        def is_nonlocal(self) -> bool: ...\n    else:\n        def __init__(self, name: str, flags: int, namespaces: Sequence[SymbolTable] | None = None) -> None: ...\n\n    def get_name(self) -> str: ...\n    def is_referenced(self) -> bool: ...\n    def is_parameter(self) -> bool: ...\n    def is_global(self) -> bool: ...\n    def is_declared_global(self) -> bool: ...\n    def is_local(self) -> bool: ...\n    def is_annotated(self) -> bool: ...\n    def is_free(self) -> bool: ...\n    def is_imported(self) -> bool: ...\n    def is_assigned(self) -> bool: ...\n    def is_namespace(self) -> bool: ...\n    def get_namespaces(self) -> Sequence[SymbolTable]: ...\n    def get_namespace(self) -> SymbolTable: ...\n\nclass SymbolTableFactory:\n    def new(self, table: Any, filename: str) -> SymbolTable: ...\n    def __call__(self, table: Any, filename: str) -> SymbolTable: ...\n",
  "/typeshed/stdlib/sys.pyi": "import sys\nfrom _typeshed import OptExcInfo, ProfileFunction, TraceFunction, structseq\nfrom builtins import object as _object\nfrom collections.abc import AsyncGenerator, Callable, Coroutine, Sequence\nfrom importlib.abc import PathEntryFinder\nfrom importlib.machinery import ModuleSpec\nfrom io import TextIOWrapper\nfrom types import FrameType, ModuleType, TracebackType\nfrom typing import Any, NoReturn, Protocol, TextIO, TypeVar\nfrom typing_extensions import Final, Literal, TypeAlias, final\n\n_T = TypeVar(\"_T\")\n\n# see https://github.com/python/typeshed/issues/8513#issue-1333671093 for the rationale behind this alias\n_ExitCode: TypeAlias = str | int | None\n_OptExcInfo: TypeAlias = OptExcInfo  # noqa: Y047  # TODO: obsolete, remove fall 2022 or later\n\n# Intentionally omits one deprecated and one optional method of `importlib.abc.MetaPathFinder`\nclass _MetaPathFinder(Protocol):\n    def find_spec(self, fullname: str, path: Sequence[str] | None, target: ModuleType | None = ...) -> ModuleSpec | None: ...\n\n# ----- sys variables -----\nif sys.platform != \"win32\":\n    abiflags: str\nargv: list[str]\nbase_exec_prefix: str\nbase_prefix: str\nbyteorder: Literal[\"little\", \"big\"]\nbuiltin_module_names: Sequence[str]  # actually a tuple of strings\ncopyright: str\nif sys.platform == \"win32\":\n    dllhandle: int\ndont_write_bytecode: bool\ndisplayhook: Callable[[object], Any]\nexcepthook: Callable[[type[BaseException], BaseException, TracebackType | None], Any]\nexec_prefix: str\nexecutable: str\nfloat_repr_style: Literal[\"short\", \"legacy\"]\nhexversion: int\nlast_type: type[BaseException] | None\nlast_value: BaseException | None\nlast_traceback: TracebackType | None\nmaxsize: int\nmaxunicode: int\nmeta_path: list[_MetaPathFinder]\nmodules: dict[str, ModuleType]\nif sys.version_info >= (3, 10):\n    orig_argv: list[str]\npath: list[str]\npath_hooks: list[Callable[[str], PathEntryFinder]]\npath_importer_cache: dict[str, PathEntryFinder | None]\nplatform: str\nif sys.version_info >= (3, 9):\n    platlibdir: str\nprefix: str\nif sys.version_info >= (3, 8):\n    pycache_prefix: str | None\nps1: object\nps2: object\nstdin: TextIO\nstdout: TextIO\nstderr: TextIO\nif sys.version_info >= (3, 10):\n    stdlib_module_names: frozenset[str]\n\n__stdin__: Final[TextIOWrapper]  # Contains the original value of stdin\n__stdout__: Final[TextIOWrapper]  # Contains the original value of stdout\n__stderr__: Final[TextIOWrapper]  # Contains the original value of stderr\ntracebacklimit: int\nversion: str\napi_version: int\nwarnoptions: Any\n#  Each entry is a tuple of the form (action, message, category, module,\n#    lineno)\nif sys.platform == \"win32\":\n    winver: str\n_xoptions: dict[Any, Any]\n\n# Type alias used as a mixin for structseq classes that cannot be instantiated at runtime\n# This can't be represented in the type system, so we just use `structseq[Any]`\n_UninstantiableStructseq: TypeAlias = structseq[Any]\n\nflags: _flags\n\nif sys.version_info >= (3, 10):\n    _FlagTuple: TypeAlias = tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, bool, int, int]\nelse:\n    _FlagTuple: TypeAlias = tuple[int, int, int, int, int, int, int, int, int, int, int, int, int, bool, int]\n\n@final\nclass _flags(_UninstantiableStructseq, _FlagTuple):\n    @property\n    def debug(self) -> int: ...\n    @property\n    def inspect(self) -> int: ...\n    @property\n    def interactive(self) -> int: ...\n    @property\n    def optimize(self) -> int: ...\n    @property\n    def dont_write_bytecode(self) -> int: ...\n    @property\n    def no_user_site(self) -> int: ...\n    @property\n    def no_site(self) -> int: ...\n    @property\n    def ignore_environment(self) -> int: ...\n    @property\n    def verbose(self) -> int: ...\n    @property\n    def bytes_warning(self) -> int: ...\n    @property\n    def quiet(self) -> int: ...\n    @property\n    def hash_randomization(self) -> int: ...\n    @property\n    def isolated(self) -> int: ...\n    @property\n    def dev_mode(self) -> bool: ...\n    @property\n    def utf8_mode(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        @property\n        def warn_default_encoding(self) -> int: ...  # undocumented\n    if sys.version_info >= (3, 11):\n        @property\n        def safe_path(self) -> bool: ...\n\nfloat_info: _float_info\n\n@final\nclass _float_info(structseq[float], tuple[float, int, int, float, int, int, int, int, float, int, int]):\n    @property\n    def max(self) -> float: ...  # DBL_MAX\n    @property\n    def max_exp(self) -> int: ...  # DBL_MAX_EXP\n    @property\n    def max_10_exp(self) -> int: ...  # DBL_MAX_10_EXP\n    @property\n    def min(self) -> float: ...  # DBL_MIN\n    @property\n    def min_exp(self) -> int: ...  # DBL_MIN_EXP\n    @property\n    def min_10_exp(self) -> int: ...  # DBL_MIN_10_EXP\n    @property\n    def dig(self) -> int: ...  # DBL_DIG\n    @property\n    def mant_dig(self) -> int: ...  # DBL_MANT_DIG\n    @property\n    def epsilon(self) -> float: ...  # DBL_EPSILON\n    @property\n    def radix(self) -> int: ...  # FLT_RADIX\n    @property\n    def rounds(self) -> int: ...  # FLT_ROUNDS\n\nhash_info: _hash_info\n\n@final\nclass _hash_info(structseq[Any | int], tuple[int, int, int, int, int, str, int, int, int]):\n    @property\n    def width(self) -> int: ...\n    @property\n    def modulus(self) -> int: ...\n    @property\n    def inf(self) -> int: ...\n    @property\n    def nan(self) -> int: ...\n    @property\n    def imag(self) -> int: ...\n    @property\n    def algorithm(self) -> str: ...\n    @property\n    def hash_bits(self) -> int: ...\n    @property\n    def seed_bits(self) -> int: ...\n    @property\n    def cutoff(self) -> int: ...  # undocumented\n\nimplementation: _implementation\n\nclass _implementation:\n    name: str\n    version: _version_info\n    hexversion: int\n    cache_tag: str\n    # Define __getattr__, as the documentation states:\n    # > sys.implementation may contain additional attributes specific to the Python implementation.\n    # > These non-standard attributes must start with an underscore, and are not described here.\n    def __getattr__(self, name: str) -> Any: ...\n\nint_info: _int_info\n\n@final\nclass _int_info(structseq[int], tuple[int, int, int, int]):\n    @property\n    def bits_per_digit(self) -> int: ...\n    @property\n    def sizeof_digit(self) -> int: ...\n    @property\n    def default_max_str_digits(self) -> int: ...\n    @property\n    def str_digits_check_threshold(self) -> int: ...\n\n_ThreadInfoName: TypeAlias = Literal[\"nt\", \"pthread\", \"pthread-stubs\", \"solaris\"]\n_ThreadInfoLock: TypeAlias = Literal[\"semaphore\", \"mutex+cond\"] | None\n\n@final\nclass _thread_info(_UninstantiableStructseq, tuple[_ThreadInfoName, _ThreadInfoLock, str | None]):\n    @property\n    def name(self) -> _ThreadInfoName: ...\n    @property\n    def lock(self) -> _ThreadInfoLock: ...\n    @property\n    def version(self) -> str | None: ...\n\nthread_info: _thread_info\n\n@final\nclass _version_info(_UninstantiableStructseq, tuple[int, int, int, str, int]):\n    @property\n    def major(self) -> int: ...\n    @property\n    def minor(self) -> int: ...\n    @property\n    def micro(self) -> int: ...\n    @property\n    def releaselevel(self) -> str: ...\n    @property\n    def serial(self) -> int: ...\n\nversion_info: _version_info\n\ndef call_tracing(__func: Callable[..., _T], __args: Any) -> _T: ...\ndef _clear_type_cache() -> None: ...\ndef _current_frames() -> dict[int, FrameType]: ...\ndef _getframe(__depth: int = 0) -> FrameType: ...\ndef _debugmallocstats() -> None: ...\ndef __displayhook__(__object: object) -> None: ...\ndef __excepthook__(__exctype: type[BaseException], __value: BaseException, __traceback: TracebackType | None) -> None: ...\ndef exc_info() -> OptExcInfo: ...\n\nif sys.version_info >= (3, 11):\n    def exception() -> BaseException | None: ...\n\ndef exit(__status: _ExitCode = None) -> NoReturn: ...\ndef getallocatedblocks() -> int: ...\ndef getdefaultencoding() -> str: ...\n\nif sys.platform != \"win32\":\n    def getdlopenflags() -> int: ...\n\ndef getfilesystemencoding() -> str: ...\ndef getfilesystemencodeerrors() -> str: ...\ndef getrefcount(__object: Any) -> int: ...\ndef getrecursionlimit() -> int: ...\ndef getsizeof(obj: object, default: int = ...) -> int: ...\ndef getswitchinterval() -> float: ...\ndef getprofile() -> ProfileFunction | None: ...\ndef setprofile(profilefunc: ProfileFunction | None) -> None: ...\ndef gettrace() -> TraceFunction | None: ...\ndef settrace(tracefunc: TraceFunction | None) -> None: ...\n\nif sys.platform == \"win32\":\n    # A tuple of length 5, even though it has more than 5 attributes.\n    @final\n    class _WinVersion(_UninstantiableStructseq, tuple[int, int, int, int, str]):\n        @property\n        def major(self) -> int: ...\n        @property\n        def minor(self) -> int: ...\n        @property\n        def build(self) -> int: ...\n        @property\n        def platform(self) -> int: ...\n        @property\n        def service_pack(self) -> str: ...\n        @property\n        def service_pack_minor(self) -> int: ...\n        @property\n        def service_pack_major(self) -> int: ...\n        @property\n        def suite_mask(self) -> int: ...\n        @property\n        def product_type(self) -> int: ...\n        @property\n        def platform_version(self) -> tuple[int, int, int]: ...\n\n    def getwindowsversion() -> _WinVersion: ...\n\ndef intern(__string: str) -> str: ...\ndef is_finalizing() -> bool: ...\ndef breakpointhook(*args: Any, **kwargs: Any) -> Any: ...\n\n__breakpointhook__ = breakpointhook  # Contains the original value of breakpointhook\n\nif sys.platform != \"win32\":\n    def setdlopenflags(__flags: int) -> None: ...\n\ndef setrecursionlimit(__limit: int) -> None: ...\ndef setswitchinterval(__interval: float) -> None: ...\ndef gettotalrefcount() -> int: ...  # Debug builds only\n\nif sys.version_info < (3, 9):\n    def getcheckinterval() -> int: ...  # deprecated\n    def setcheckinterval(__n: int) -> None: ...  # deprecated\n\nif sys.version_info < (3, 9):\n    # An 11-tuple or None\n    def callstats() -> tuple[int, int, int, int, int, int, int, int, int, int, int] | None: ...\n\nif sys.version_info >= (3, 8):\n    # Doesn't exist at runtime, but exported in the stubs so pytest etc. can annotate their code more easily.\n    class UnraisableHookArgs:\n        exc_type: type[BaseException]\n        exc_value: BaseException | None\n        exc_traceback: TracebackType | None\n        err_msg: str | None\n        object: _object\n    unraisablehook: Callable[[UnraisableHookArgs], Any]\n    def __unraisablehook__(__unraisable: UnraisableHookArgs) -> Any: ...\n    def addaudithook(hook: Callable[[str, tuple[Any, ...]], Any]) -> None: ...\n    def audit(__event: str, *args: Any) -> None: ...\n\n_AsyncgenHook: TypeAlias = Callable[[AsyncGenerator[Any, Any]], None] | None\n\n@final\nclass _asyncgen_hooks(structseq[_AsyncgenHook], tuple[_AsyncgenHook, _AsyncgenHook]):\n    @property\n    def firstiter(self) -> _AsyncgenHook: ...\n    @property\n    def finalizer(self) -> _AsyncgenHook: ...\n\ndef get_asyncgen_hooks() -> _asyncgen_hooks: ...\ndef set_asyncgen_hooks(firstiter: _AsyncgenHook = ..., finalizer: _AsyncgenHook = ...) -> None: ...\n\nif sys.platform == \"win32\":\n    def _enablelegacywindowsfsencoding() -> None: ...\n\ndef get_coroutine_origin_tracking_depth() -> int: ...\ndef set_coroutine_origin_tracking_depth(depth: int) -> None: ...\n\nif sys.version_info < (3, 8):\n    _CoroWrapper: TypeAlias = Callable[[Coroutine[Any, Any, Any]], Any]\n    def set_coroutine_wrapper(__wrapper: _CoroWrapper) -> None: ...\n    def get_coroutine_wrapper() -> _CoroWrapper: ...\n\n# The following two functions were added in 3.11.0, 3.10.7, 3.9.14, 3.8.14, & 3.7.14,\n# as part of the response to CVE-2020-10735\ndef set_int_max_str_digits(maxdigits: int) -> None: ...\ndef get_int_max_str_digits() -> int: ...\n",
  "/typeshed/stdlib/sysconfig.pyi": "import sys\nfrom typing import IO, Any, overload\nfrom typing_extensions import Literal\n\n__all__ = [\n    \"get_config_h_filename\",\n    \"get_config_var\",\n    \"get_config_vars\",\n    \"get_makefile_filename\",\n    \"get_path\",\n    \"get_path_names\",\n    \"get_paths\",\n    \"get_platform\",\n    \"get_python_version\",\n    \"get_scheme_names\",\n    \"parse_config_h\",\n]\n\ndef get_config_var(name: str) -> Any: ...\n@overload\ndef get_config_vars() -> dict[str, Any]: ...\n@overload\ndef get_config_vars(arg: str, *args: str) -> list[Any]: ...\ndef get_scheme_names() -> tuple[str, ...]: ...\n\nif sys.version_info >= (3, 10):\n    def get_default_scheme() -> str: ...\n    def get_preferred_scheme(key: Literal[\"prefix\", \"home\", \"user\"]) -> str: ...\n\ndef get_path_names() -> tuple[str, ...]: ...\ndef get_path(name: str, scheme: str = ..., vars: dict[str, Any] | None = None, expand: bool = True) -> str: ...\ndef get_paths(scheme: str = ..., vars: dict[str, Any] | None = None, expand: bool = True) -> dict[str, str]: ...\ndef get_python_version() -> str: ...\ndef get_platform() -> str: ...\n\nif sys.version_info >= (3, 11):\n    def is_python_build(check_home: object = None) -> bool: ...\n\nelse:\n    def is_python_build(check_home: bool = False) -> bool: ...\n\ndef parse_config_h(fp: IO[Any], vars: dict[str, Any] | None = None) -> dict[str, Any]: ...\ndef get_config_h_filename() -> str: ...\ndef get_makefile_filename() -> str: ...\n",
  "/typeshed/stdlib/syslog.pyi": "import sys\nfrom typing import overload\nfrom typing_extensions import Literal\n\nif sys.platform != \"win32\":\n    LOG_ALERT: Literal[1]\n    LOG_AUTH: Literal[32]\n    LOG_AUTHPRIV: Literal[80]\n    LOG_CONS: Literal[2]\n    LOG_CRIT: Literal[2]\n    LOG_CRON: Literal[72]\n    LOG_DAEMON: Literal[24]\n    LOG_DEBUG: Literal[7]\n    LOG_EMERG: Literal[0]\n    LOG_ERR: Literal[3]\n    LOG_INFO: Literal[6]\n    LOG_KERN: Literal[0]\n    LOG_LOCAL0: Literal[128]\n    LOG_LOCAL1: Literal[136]\n    LOG_LOCAL2: Literal[144]\n    LOG_LOCAL3: Literal[152]\n    LOG_LOCAL4: Literal[160]\n    LOG_LOCAL5: Literal[168]\n    LOG_LOCAL6: Literal[176]\n    LOG_LOCAL7: Literal[184]\n    LOG_LPR: Literal[48]\n    LOG_MAIL: Literal[16]\n    LOG_NDELAY: Literal[8]\n    LOG_NEWS: Literal[56]\n    LOG_NOTICE: Literal[5]\n    LOG_NOWAIT: Literal[16]\n    LOG_ODELAY: Literal[4]\n    LOG_PERROR: Literal[32]\n    LOG_PID: Literal[1]\n    LOG_SYSLOG: Literal[40]\n    LOG_USER: Literal[8]\n    LOG_UUCP: Literal[64]\n    LOG_WARNING: Literal[4]\n    def LOG_MASK(a: int) -> int: ...\n    def LOG_UPTO(a: int) -> int: ...\n    def closelog() -> None: ...\n    def openlog(ident: str = ..., logoption: int = ..., facility: int = ...) -> None: ...\n    def setlogmask(x: int) -> int: ...\n    @overload\n    def syslog(priority: int, message: str) -> None: ...\n    @overload\n    def syslog(message: str) -> None: ...\n",
  "/typeshed/stdlib/tabnanny.pyi": "from _typeshed import StrOrBytesPath\nfrom collections.abc import Iterable\n\n__all__ = [\"check\", \"NannyNag\", \"process_tokens\"]\n\nverbose: int\nfilename_only: int\n\nclass NannyNag(Exception):\n    def __init__(self, lineno: int, msg: str, line: str) -> None: ...\n    def get_lineno(self) -> int: ...\n    def get_msg(self) -> str: ...\n    def get_line(self) -> str: ...\n\ndef check(file: StrOrBytesPath) -> None: ...\ndef process_tokens(tokens: Iterable[tuple[int, str, tuple[int, int], tuple[int, int], str]]) -> None: ...\n",
  "/typeshed/stdlib/tarfile.pyi": "import bz2\nimport io\nimport sys\nfrom _typeshed import StrOrBytesPath, StrPath\nfrom builtins import list as _list  # aliases to avoid name clashes with fields named \"type\" or \"list\"\nfrom collections.abc import Callable, Iterable, Iterator, Mapping\nfrom gzip import _ReadableFileobj as _GzipReadableFileobj, _WritableFileobj as _GzipWritableFileobj\nfrom types import TracebackType\nfrom typing import IO, ClassVar, Protocol, overload\nfrom typing_extensions import Literal, Self\n\n__all__ = [\n    \"TarFile\",\n    \"TarInfo\",\n    \"is_tarfile\",\n    \"TarError\",\n    \"ReadError\",\n    \"CompressionError\",\n    \"StreamError\",\n    \"ExtractError\",\n    \"HeaderError\",\n    \"ENCODING\",\n    \"USTAR_FORMAT\",\n    \"GNU_FORMAT\",\n    \"PAX_FORMAT\",\n    \"DEFAULT_FORMAT\",\n    \"open\",\n]\n\nclass _Fileobj(Protocol):\n    def read(self, __size: int) -> bytes: ...\n    def write(self, __b: bytes) -> object: ...\n    def tell(self) -> int: ...\n    def seek(self, __pos: int) -> object: ...\n    def close(self) -> object: ...\n    # Optional fields:\n    # name: str | bytes\n    # mode: Literal[\"rb\", \"r+b\", \"wb\", \"xb\"]\n\nclass _Bz2ReadableFileobj(bz2._ReadableFileobj):\n    def close(self) -> object: ...\n\nclass _Bz2WritableFileobj(bz2._WritableFileobj):\n    def close(self) -> object: ...\n\n# tar constants\nNUL: bytes\nBLOCKSIZE: int\nRECORDSIZE: int\nGNU_MAGIC: bytes\nPOSIX_MAGIC: bytes\n\nLENGTH_NAME: int\nLENGTH_LINK: int\nLENGTH_PREFIX: int\n\nREGTYPE: bytes\nAREGTYPE: bytes\nLNKTYPE: bytes\nSYMTYPE: bytes\nCONTTYPE: bytes\nBLKTYPE: bytes\nDIRTYPE: bytes\nFIFOTYPE: bytes\nCHRTYPE: bytes\n\nGNUTYPE_LONGNAME: bytes\nGNUTYPE_LONGLINK: bytes\nGNUTYPE_SPARSE: bytes\n\nXHDTYPE: bytes\nXGLTYPE: bytes\nSOLARIS_XHDTYPE: bytes\n\nUSTAR_FORMAT: int\nGNU_FORMAT: int\nPAX_FORMAT: int\nDEFAULT_FORMAT: int\n\n# tarfile constants\n\nSUPPORTED_TYPES: tuple[bytes, ...]\nREGULAR_TYPES: tuple[bytes, ...]\nGNU_TYPES: tuple[bytes, ...]\nPAX_FIELDS: tuple[str, ...]\nPAX_NUMBER_FIELDS: dict[str, type]\nPAX_NAME_FIELDS: set[str]\n\nENCODING: str\n\ndef open(\n    name: StrOrBytesPath | None = None,\n    mode: str = \"r\",\n    fileobj: IO[bytes] | None = None,  # depends on mode\n    bufsize: int = 10240,\n    *,\n    format: int | None = ...,\n    tarinfo: type[TarInfo] | None = ...,\n    dereference: bool | None = ...,\n    ignore_zeros: bool | None = ...,\n    encoding: str | None = ...,\n    errors: str = ...,\n    pax_headers: Mapping[str, str] | None = ...,\n    debug: int | None = ...,\n    errorlevel: int | None = ...,\n    compresslevel: int | None = ...,\n) -> TarFile: ...\n\nclass ExFileObject(io.BufferedReader):\n    def __init__(self, tarfile: TarFile, tarinfo: TarInfo) -> None: ...\n\nclass TarFile:\n    OPEN_METH: ClassVar[Mapping[str, str]]\n    name: StrOrBytesPath | None\n    mode: Literal[\"r\", \"a\", \"w\", \"x\"]\n    fileobj: _Fileobj | None\n    format: int | None\n    tarinfo: type[TarInfo]\n    dereference: bool | None\n    ignore_zeros: bool | None\n    encoding: str | None\n    errors: str\n    fileobject: type[ExFileObject]\n    pax_headers: Mapping[str, str] | None\n    debug: int | None\n    errorlevel: int | None\n    offset: int  # undocumented\n    def __init__(\n        self,\n        name: StrOrBytesPath | None = None,\n        mode: Literal[\"r\", \"a\", \"w\", \"x\"] = \"r\",\n        fileobj: _Fileobj | None = None,\n        format: int | None = None,\n        tarinfo: type[TarInfo] | None = None,\n        dereference: bool | None = None,\n        ignore_zeros: bool | None = None,\n        encoding: str | None = None,\n        errors: str = \"surrogateescape\",\n        pax_headers: Mapping[str, str] | None = None,\n        debug: int | None = None,\n        errorlevel: int | None = None,\n        copybufsize: int | None = None,  # undocumented\n    ) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n    def __iter__(self) -> Iterator[TarInfo]: ...\n    @classmethod\n    def open(\n        cls,\n        name: StrOrBytesPath | None = None,\n        mode: str = \"r\",\n        fileobj: IO[bytes] | None = None,  # depends on mode\n        bufsize: int = 10240,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        errors: str = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @classmethod\n    def taropen(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"r\", \"a\", \"w\", \"x\"] = \"r\",\n        fileobj: _Fileobj | None = None,\n        *,\n        compresslevel: int = ...,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @overload\n    @classmethod\n    def gzopen(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"r\"] = \"r\",\n        fileobj: _GzipReadableFileobj | None = None,\n        compresslevel: int = 9,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @overload\n    @classmethod\n    def gzopen(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"w\", \"x\"],\n        fileobj: _GzipWritableFileobj | None = None,\n        compresslevel: int = 9,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @overload\n    @classmethod\n    def bz2open(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"w\", \"x\"],\n        fileobj: _Bz2WritableFileobj | None = None,\n        compresslevel: int = 9,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @overload\n    @classmethod\n    def bz2open(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"r\"] = \"r\",\n        fileobj: _Bz2ReadableFileobj | None = None,\n        compresslevel: int = 9,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    @classmethod\n    def xzopen(\n        cls,\n        name: StrOrBytesPath | None,\n        mode: Literal[\"r\", \"w\", \"x\"] = \"r\",\n        fileobj: IO[bytes] | None = None,\n        preset: int | None = None,\n        *,\n        format: int | None = ...,\n        tarinfo: type[TarInfo] | None = ...,\n        dereference: bool | None = ...,\n        ignore_zeros: bool | None = ...,\n        encoding: str | None = ...,\n        pax_headers: Mapping[str, str] | None = ...,\n        debug: int | None = ...,\n        errorlevel: int | None = ...,\n    ) -> Self: ...\n    def getmember(self, name: str) -> TarInfo: ...\n    def getmembers(self) -> _list[TarInfo]: ...\n    def getnames(self) -> _list[str]: ...\n    def list(self, verbose: bool = True, *, members: _list[TarInfo] | None = None) -> None: ...\n    def next(self) -> TarInfo | None: ...\n    def extractall(\n        self, path: StrOrBytesPath = \".\", members: Iterable[TarInfo] | None = None, *, numeric_owner: bool = False\n    ) -> None: ...\n    def extract(\n        self, member: str | TarInfo, path: StrOrBytesPath = \"\", set_attrs: bool = True, *, numeric_owner: bool = False\n    ) -> None: ...\n    def _extract_member(\n        self, tarinfo: TarInfo, targetpath: str, set_attrs: bool = True, numeric_owner: bool = False\n    ) -> None: ...  # undocumented\n    def extractfile(self, member: str | TarInfo) -> IO[bytes] | None: ...\n    def makedir(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def makefile(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def makeunknown(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def makefifo(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def makedev(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def makelink(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def chown(self, tarinfo: TarInfo, targetpath: StrOrBytesPath, numeric_owner: bool) -> None: ...  # undocumented\n    def chmod(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def utime(self, tarinfo: TarInfo, targetpath: StrOrBytesPath) -> None: ...  # undocumented\n    def add(\n        self,\n        name: StrPath,\n        arcname: StrPath | None = None,\n        recursive: bool = True,\n        *,\n        filter: Callable[[TarInfo], TarInfo | None] | None = None,\n    ) -> None: ...\n    def addfile(self, tarinfo: TarInfo, fileobj: IO[bytes] | None = None) -> None: ...\n    def gettarinfo(\n        self, name: StrOrBytesPath | None = None, arcname: str | None = None, fileobj: IO[bytes] | None = None\n    ) -> TarInfo: ...\n    def close(self) -> None: ...\n\nif sys.version_info >= (3, 9):\n    def is_tarfile(name: StrOrBytesPath | IO[bytes]) -> bool: ...\n\nelse:\n    def is_tarfile(name: StrOrBytesPath) -> bool: ...\n\nif sys.version_info < (3, 8):\n    def filemode(mode: int) -> str: ...  # undocumented\n\nclass TarError(Exception): ...\nclass ReadError(TarError): ...\nclass CompressionError(TarError): ...\nclass StreamError(TarError): ...\nclass ExtractError(TarError): ...\nclass HeaderError(TarError): ...\n\nclass TarInfo:\n    name: str\n    path: str\n    size: int\n    mtime: int\n    chksum: int\n    devmajor: int\n    devminor: int\n    offset: int\n    offset_data: int\n    sparse: bytes | None\n    tarfile: TarFile | None\n    mode: int\n    type: bytes\n    linkname: str\n    uid: int\n    gid: int\n    uname: str\n    gname: str\n    pax_headers: Mapping[str, str]\n    def __init__(self, name: str = \"\") -> None: ...\n    @classmethod\n    def frombuf(cls, buf: bytes | bytearray, encoding: str, errors: str) -> Self: ...\n    @classmethod\n    def fromtarfile(cls, tarfile: TarFile) -> Self: ...\n    @property\n    def linkpath(self) -> str: ...\n    @linkpath.setter\n    def linkpath(self, linkname: str) -> None: ...\n    def get_info(self) -> Mapping[str, str | int | bytes | Mapping[str, str]]: ...\n    if sys.version_info >= (3, 8):\n        def tobuf(self, format: int | None = 2, encoding: str | None = \"utf-8\", errors: str = \"surrogateescape\") -> bytes: ...\n    else:\n        def tobuf(self, format: int | None = 1, encoding: str | None = \"utf-8\", errors: str = \"surrogateescape\") -> bytes: ...\n\n    def create_ustar_header(\n        self, info: Mapping[str, str | int | bytes | Mapping[str, str]], encoding: str, errors: str\n    ) -> bytes: ...\n    def create_gnu_header(\n        self, info: Mapping[str, str | int | bytes | Mapping[str, str]], encoding: str, errors: str\n    ) -> bytes: ...\n    def create_pax_header(self, info: Mapping[str, str | int | bytes | Mapping[str, str]], encoding: str) -> bytes: ...\n    @classmethod\n    def create_pax_global_header(cls, pax_headers: Mapping[str, str]) -> bytes: ...\n    def isfile(self) -> bool: ...\n    def isreg(self) -> bool: ...\n    def issparse(self) -> bool: ...\n    def isdir(self) -> bool: ...\n    def issym(self) -> bool: ...\n    def islnk(self) -> bool: ...\n    def ischr(self) -> bool: ...\n    def isblk(self) -> bool: ...\n    def isfifo(self) -> bool: ...\n    def isdev(self) -> bool: ...\n",
  "/typeshed/stdlib/tempfile.pyi": "import io\nimport sys\nfrom _typeshed import BytesPath, GenericPath, ReadableBuffer, StrPath, WriteableBuffer\nfrom collections.abc import Iterable, Iterator\nfrom types import TracebackType\nfrom typing import IO, Any, AnyStr, Generic, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"NamedTemporaryFile\",\n    \"TemporaryFile\",\n    \"SpooledTemporaryFile\",\n    \"TemporaryDirectory\",\n    \"mkstemp\",\n    \"mkdtemp\",\n    \"mktemp\",\n    \"TMP_MAX\",\n    \"gettempprefix\",\n    \"tempdir\",\n    \"gettempdir\",\n    \"gettempprefixb\",\n    \"gettempdirb\",\n]\n\n# global variables\nTMP_MAX: int\ntempdir: str | None\ntemplate: str\n\n_StrMode: TypeAlias = Literal[\"r\", \"w\", \"a\", \"x\", \"r+\", \"w+\", \"a+\", \"x+\", \"rt\", \"wt\", \"at\", \"xt\", \"r+t\", \"w+t\", \"a+t\", \"x+t\"]\n_BytesMode: TypeAlias = Literal[\"rb\", \"wb\", \"ab\", \"xb\", \"r+b\", \"w+b\", \"a+b\", \"x+b\"]\n\nif sys.version_info >= (3, 8):\n    @overload\n    def NamedTemporaryFile(\n        mode: _StrMode,\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n        *,\n        errors: str | None = None,\n    ) -> _TemporaryFileWrapper[str]: ...\n    @overload\n    def NamedTemporaryFile(\n        mode: _BytesMode = \"w+b\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n        *,\n        errors: str | None = None,\n    ) -> _TemporaryFileWrapper[bytes]: ...\n    @overload\n    def NamedTemporaryFile(\n        mode: str = \"w+b\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n        *,\n        errors: str | None = None,\n    ) -> _TemporaryFileWrapper[Any]: ...\n\nelse:\n    @overload\n    def NamedTemporaryFile(\n        mode: _StrMode,\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n    ) -> _TemporaryFileWrapper[str]: ...\n    @overload\n    def NamedTemporaryFile(\n        mode: _BytesMode = \"w+b\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n    ) -> _TemporaryFileWrapper[bytes]: ...\n    @overload\n    def NamedTemporaryFile(\n        mode: str = \"w+b\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        newline: str | None = None,\n        suffix: AnyStr | None = None,\n        prefix: AnyStr | None = None,\n        dir: GenericPath[AnyStr] | None = None,\n        delete: bool = True,\n    ) -> _TemporaryFileWrapper[Any]: ...\n\nif sys.platform == \"win32\":\n    TemporaryFile = NamedTemporaryFile\nelse:\n    if sys.version_info >= (3, 8):\n        @overload\n        def TemporaryFile(\n            mode: _StrMode,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: AnyStr | None = None,\n            prefix: AnyStr | None = None,\n            dir: GenericPath[AnyStr] | None = None,\n            *,\n            errors: str | None = None,\n        ) -> IO[str]: ...\n        @overload\n        def TemporaryFile(\n            mode: _BytesMode = \"w+b\",\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: AnyStr | None = None,\n            prefix: AnyStr | None = None,\n            dir: GenericPath[AnyStr] | None = None,\n            *,\n            errors: str | None = None,\n        ) -> IO[bytes]: ...\n        @overload\n        def TemporaryFile(\n            mode: str = \"w+b\",\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: AnyStr | None = None,\n            prefix: AnyStr | None = None,\n            dir: GenericPath[AnyStr] | None = None,\n            *,\n            errors: str | None = None,\n        ) -> IO[Any]: ...\n    else:\n        @overload\n        def TemporaryFile(\n            mode: _StrMode,\n            buffering: int = ...,\n            encoding: str | None = ...,\n            newline: str | None = ...,\n            suffix: AnyStr | None = ...,\n            prefix: AnyStr | None = ...,\n            dir: GenericPath[AnyStr] | None = ...,\n        ) -> IO[str]: ...\n        @overload\n        def TemporaryFile(\n            mode: _BytesMode = ...,\n            buffering: int = ...,\n            encoding: str | None = ...,\n            newline: str | None = ...,\n            suffix: AnyStr | None = ...,\n            prefix: AnyStr | None = ...,\n            dir: GenericPath[AnyStr] | None = ...,\n        ) -> IO[bytes]: ...\n        @overload\n        def TemporaryFile(\n            mode: str = ...,\n            buffering: int = ...,\n            encoding: str | None = ...,\n            newline: str | None = ...,\n            suffix: AnyStr | None = ...,\n            prefix: AnyStr | None = ...,\n            dir: GenericPath[AnyStr] | None = ...,\n        ) -> IO[Any]: ...\n\nclass _TemporaryFileWrapper(Generic[AnyStr], IO[AnyStr]):\n    file: IO[AnyStr]  # io.TextIOWrapper, io.BufferedReader or io.BufferedWriter\n    name: str\n    delete: bool\n    def __init__(self, file: IO[AnyStr], name: str, delete: bool = True) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, exc: type[BaseException] | None, value: BaseException | None, tb: TracebackType | None) -> None: ...\n    def __getattr__(self, name: str) -> Any: ...\n    def close(self) -> None: ...\n    # These methods don't exist directly on this object, but\n    # are delegated to the underlying IO object through __getattr__.\n    # We need to add them here so that this class is concrete.\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    # FIXME: __next__ doesn't actually exist on this class and should be removed:\n    #        see also https://github.com/python/typeshed/pull/5456#discussion_r633068648\n    # >>> import tempfile\n    # >>> ntf=tempfile.NamedTemporaryFile()\n    # >>> next(ntf)\n    # Traceback (most recent call last):\n    #   File \"<stdin>\", line 1, in <module>\n    # TypeError: '_TemporaryFileWrapper' object is not an iterator\n    def __next__(self) -> AnyStr: ...\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def read(self, n: int = ...) -> AnyStr: ...\n    def readable(self) -> bool: ...\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    def seekable(self) -> bool: ...\n    def tell(self) -> int: ...\n    def truncate(self, size: int | None = ...) -> int: ...\n    def writable(self) -> bool: ...\n    @overload\n    def write(self: _TemporaryFileWrapper[str], s: str) -> int: ...\n    @overload\n    def write(self: _TemporaryFileWrapper[bytes], s: ReadableBuffer) -> int: ...\n    @overload\n    def write(self, s: AnyStr) -> int: ...\n    @overload\n    def writelines(self: _TemporaryFileWrapper[str], lines: Iterable[str]) -> None: ...\n    @overload\n    def writelines(self: _TemporaryFileWrapper[bytes], lines: Iterable[ReadableBuffer]) -> None: ...\n    @overload\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n\nif sys.version_info >= (3, 11):\n    _SpooledTemporaryFileBase = io.IOBase\nelse:\n    _SpooledTemporaryFileBase = object\n\n# It does not actually derive from IO[AnyStr], but it does mostly behave\n# like one.\nclass SpooledTemporaryFile(IO[AnyStr], _SpooledTemporaryFileBase):\n    @property\n    def encoding(self) -> str: ...  # undocumented\n    @property\n    def newlines(self) -> str | tuple[str, ...] | None: ...  # undocumented\n    # bytes needs to go first, as default mode is to open as bytes\n    if sys.version_info >= (3, 8):\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[bytes],\n            max_size: int = 0,\n            mode: _BytesMode = \"w+b\",\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n            *,\n            errors: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[str],\n            max_size: int,\n            mode: _StrMode,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n            *,\n            errors: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[str],\n            max_size: int = 0,\n            *,\n            mode: _StrMode,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n            errors: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            max_size: int,\n            mode: str,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n            *,\n            errors: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            max_size: int = 0,\n            *,\n            mode: str,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n            errors: str | None = None,\n        ) -> None: ...\n        @property\n        def errors(self) -> str | None: ...\n    else:\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[bytes],\n            max_size: int = 0,\n            mode: _BytesMode = \"w+b\",\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[str],\n            max_size: int,\n            mode: _StrMode,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: SpooledTemporaryFile[str],\n            max_size: int = 0,\n            *,\n            mode: _StrMode,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            max_size: int,\n            mode: str,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            max_size: int = 0,\n            *,\n            mode: str,\n            buffering: int = -1,\n            encoding: str | None = None,\n            newline: str | None = None,\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: str | None = None,\n        ) -> None: ...\n\n    def rollover(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, exc: type[BaseException] | None, value: BaseException | None, tb: TracebackType | None) -> None: ...\n    # These methods are copied from the abstract methods of IO, because\n    # SpooledTemporaryFile implements IO.\n    # See also https://github.com/python/typeshed/pull/2452#issuecomment-420657918.\n    def close(self) -> None: ...\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    if sys.version_info >= (3, 11):\n        # These three work only if the SpooledTemporaryFile is opened in binary mode,\n        # because the underlying object in text mode does not have these methods.\n        def read1(self, __size: int = ...) -> AnyStr: ...\n        def readinto(self, b: WriteableBuffer) -> int: ...\n        def readinto1(self, b: WriteableBuffer) -> int: ...\n        def detach(self) -> io.RawIOBase: ...\n\n    def read(self, __n: int = ...) -> AnyStr: ...\n    def readline(self, __limit: int | None = ...) -> AnyStr: ...  # type: ignore[override]\n    def readlines(self, __hint: int = ...) -> list[AnyStr]: ...  # type: ignore[override]\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    def tell(self) -> int: ...\n    def truncate(self, size: int | None = None) -> None: ...  # type: ignore[override]\n    @overload\n    def write(self: SpooledTemporaryFile[str], s: str) -> int: ...\n    @overload\n    def write(self: SpooledTemporaryFile[bytes], s: ReadableBuffer) -> int: ...\n    @overload\n    def write(self, s: AnyStr) -> int: ...\n    @overload\n    def writelines(self: SpooledTemporaryFile[str], iterable: Iterable[str]) -> None: ...\n    @overload\n    def writelines(self: SpooledTemporaryFile[bytes], iterable: Iterable[ReadableBuffer]) -> None: ...\n    @overload\n    def writelines(self, iterable: Iterable[AnyStr]) -> None: ...\n    def __iter__(self) -> Iterator[AnyStr]: ...  # type: ignore[override]\n    # These exist at runtime only on 3.11+.\n    def readable(self) -> bool: ...\n    def seekable(self) -> bool: ...\n    def writable(self) -> bool: ...\n    def __next__(self) -> AnyStr: ...  # type: ignore[override]\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass TemporaryDirectory(Generic[AnyStr]):\n    name: AnyStr\n    if sys.version_info >= (3, 10):\n        @overload\n        def __init__(\n            self: TemporaryDirectory[str],\n            suffix: str | None = None,\n            prefix: str | None = None,\n            dir: StrPath | None = None,\n            ignore_cleanup_errors: bool = False,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: TemporaryDirectory[bytes],\n            suffix: bytes | None = None,\n            prefix: bytes | None = None,\n            dir: BytesPath | None = None,\n            ignore_cleanup_errors: bool = False,\n        ) -> None: ...\n    else:\n        @overload\n        def __init__(\n            self: TemporaryDirectory[str], suffix: str | None = None, prefix: str | None = None, dir: StrPath | None = None\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: TemporaryDirectory[bytes],\n            suffix: bytes | None = None,\n            prefix: bytes | None = None,\n            dir: BytesPath | None = None,\n        ) -> None: ...\n\n    def cleanup(self) -> None: ...\n    def __enter__(self) -> AnyStr: ...\n    def __exit__(self, exc: type[BaseException] | None, value: BaseException | None, tb: TracebackType | None) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# The overloads overlap, but they should still work fine.\n@overload\ndef mkstemp(  # type: ignore[misc]\n    suffix: str | None = None, prefix: str | None = None, dir: StrPath | None = None, text: bool = False\n) -> tuple[int, str]: ...\n@overload\ndef mkstemp(\n    suffix: bytes | None = None, prefix: bytes | None = None, dir: BytesPath | None = None, text: bool = False\n) -> tuple[int, bytes]: ...\n\n# The overloads overlap, but they should still work fine.\n@overload\ndef mkdtemp(suffix: str | None = None, prefix: str | None = None, dir: StrPath | None = None) -> str: ...  # type: ignore[misc]\n@overload\ndef mkdtemp(suffix: bytes | None = None, prefix: bytes | None = None, dir: BytesPath | None = None) -> bytes: ...\ndef mktemp(suffix: str = \"\", prefix: str = \"tmp\", dir: StrPath | None = None) -> str: ...\ndef gettempdirb() -> bytes: ...\ndef gettempprefixb() -> bytes: ...\ndef gettempdir() -> str: ...\ndef gettempprefix() -> str: ...\n",
  "/typeshed/stdlib/termios.pyi": "import sys\nfrom _typeshed import FileDescriptorLike\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\nif sys.platform != \"win32\":\n    # Must be a list of length 7, containing 6 ints and a list of NCCS 1-character bytes or ints.\n    _Attr: TypeAlias = list[int | list[bytes | int]]\n\n    B0: int\n    B1000000: int\n    B110: int\n    B115200: int\n    B1152000: int\n    B1200: int\n    B134: int\n    B150: int\n    B1500000: int\n    B1800: int\n    B19200: int\n    B200: int\n    B2000000: int\n    B230400: int\n    B2400: int\n    B2500000: int\n    B300: int\n    B3000000: int\n    B3500000: int\n    B38400: int\n    B4000000: int\n    B460800: int\n    B4800: int\n    B50: int\n    B500000: int\n    B57600: int\n    B576000: int\n    B600: int\n    B75: int\n    B921600: int\n    B9600: int\n    BRKINT: int\n    BS0: int\n    BS1: int\n    BSDLY: int\n    CBAUD: int\n    CBAUDEX: int\n    CDEL: int\n    CDSUSP: int\n    CEOF: int\n    CEOL: int\n    CEOL2: int\n    CEOT: int\n    CERASE: int\n    CESC: int\n    CFLUSH: int\n    CIBAUD: int\n    CINTR: int\n    CKILL: int\n    CLNEXT: int\n    CLOCAL: int\n    CNUL: int\n    COMMON: int\n    CQUIT: int\n    CR0: int\n    CR1: int\n    CR2: int\n    CR3: int\n    CRDLY: int\n    CREAD: int\n    CRPRNT: int\n    CRTSCTS: int\n    CS5: int\n    CS6: int\n    CS7: int\n    CS8: int\n    CSIZE: int\n    CSTART: int\n    CSTOP: int\n    CSTOPB: int\n    CSUSP: int\n    CSWTCH: int\n    CWERASE: int\n    ECHO: int\n    ECHOCTL: int\n    ECHOE: int\n    ECHOK: int\n    ECHOKE: int\n    ECHONL: int\n    ECHOPRT: int\n    EXTA: int\n    EXTB: int\n    FF0: int\n    FF1: int\n    FFDLY: int\n    FIOASYNC: int\n    FIOCLEX: int\n    FIONBIO: int\n    FIONCLEX: int\n    FIONREAD: int\n    FLUSHO: int\n    HUPCL: int\n    IBSHIFT: int\n    ICANON: int\n    ICRNL: int\n    IEXTEN: int\n    IGNBRK: int\n    IGNCR: int\n    IGNPAR: int\n    IMAXBEL: int\n    INIT_C_CC: int\n    INLCR: int\n    INPCK: int\n    IOCSIZE_MASK: int\n    IOCSIZE_SHIFT: int\n    ISIG: int\n    ISTRIP: int\n    IUCLC: int\n    IXANY: int\n    IXOFF: int\n    IXON: int\n    N_MOUSE: int\n    N_PPP: int\n    N_SLIP: int\n    N_STRIP: int\n    N_TTY: int\n    NCC: int\n    NCCS: int\n    NL0: int\n    NL1: int\n    NLDLY: int\n    NOFLSH: int\n    NSWTCH: int\n    OCRNL: int\n    OFDEL: int\n    OFILL: int\n    OLCUC: int\n    ONLCR: int\n    ONLRET: int\n    ONOCR: int\n    OPOST: int\n    PARENB: int\n    PARMRK: int\n    PARODD: int\n    PENDIN: int\n    TAB0: int\n    TAB1: int\n    TAB2: int\n    TAB3: int\n    TABDLY: int\n    TCFLSH: int\n    TCGETA: int\n    TCGETS: int\n    TCIFLUSH: int\n    TCIOFF: int\n    TCIOFLUSH: int\n    TCION: int\n    TCOFLUSH: int\n    TCOOFF: int\n    TCOON: int\n    TCSADRAIN: int\n    TCSAFLUSH: int\n    TCSANOW: int\n    TCSASOFT: int\n    TCSBRK: int\n    TCSBRKP: int\n    TCSETA: int\n    TCSETAF: int\n    TCSETAW: int\n    TCSETS: int\n    TCSETSF: int\n    TCSETSW: int\n    TCXONC: int\n    TIOCCONS: int\n    TIOCEXCL: int\n    TIOCGETD: int\n    TIOCGICOUNT: int\n    TIOCGLCKTRMIOS: int\n    TIOCGPGRP: int\n    TIOCGSERIAL: int\n    TIOCGSIZE: int\n    TIOCGSOFTCAR: int\n    TIOCGWINSZ: int\n    TIOCINQ: int\n    TIOCLINUX: int\n    TIOCM_CAR: int\n    TIOCM_CD: int\n    TIOCM_CTS: int\n    TIOCM_DSR: int\n    TIOCM_DTR: int\n    TIOCM_LE: int\n    TIOCM_RI: int\n    TIOCM_RNG: int\n    TIOCM_RTS: int\n    TIOCM_SR: int\n    TIOCM_ST: int\n    TIOCMBIC: int\n    TIOCMBIS: int\n    TIOCMGET: int\n    TIOCMIWAIT: int\n    TIOCMSET: int\n    TIOCNOTTY: int\n    TIOCNXCL: int\n    TIOCOUTQ: int\n    TIOCPKT_DATA: int\n    TIOCPKT_DOSTOP: int\n    TIOCPKT_FLUSHREAD: int\n    TIOCPKT_FLUSHWRITE: int\n    TIOCPKT_NOSTOP: int\n    TIOCPKT_START: int\n    TIOCPKT_STOP: int\n    TIOCPKT: int\n    TIOCSCTTY: int\n    TIOCSER_TEMT: int\n    TIOCSERCONFIG: int\n    TIOCSERGETLSR: int\n    TIOCSERGETMULTI: int\n    TIOCSERGSTRUCT: int\n    TIOCSERGWILD: int\n    TIOCSERSETMULTI: int\n    TIOCSERSWILD: int\n    TIOCSETD: int\n    TIOCSLCKTRMIOS: int\n    TIOCSPGRP: int\n    TIOCSSERIAL: int\n    TIOCSSIZE: int\n    TIOCSSOFTCAR: int\n    TIOCSTI: int\n    TIOCSWINSZ: int\n    TIOCTTYGSTRUCT: int\n    TOSTOP: int\n    VDISCARD: int\n    VEOF: int\n    VEOL: int\n    VEOL2: int\n    VERASE: int\n    VINTR: int\n    VKILL: int\n    VLNEXT: int\n    VMIN: int\n    VQUIT: int\n    VREPRINT: int\n    VSTART: int\n    VSTOP: int\n    VSUSP: int\n    VSWTC: int\n    VSWTCH: int\n    VT0: int\n    VT1: int\n    VTDLY: int\n    VTIME: int\n    VWERASE: int\n    XCASE: int\n    XTABS: int\n\n    def tcgetattr(__fd: FileDescriptorLike) -> list[Any]: ...  # Returns _Attr; we use Any to avoid a union in the return type\n    def tcsetattr(__fd: FileDescriptorLike, __when: int, __attributes: _Attr) -> None: ...\n    def tcsendbreak(__fd: FileDescriptorLike, __duration: int) -> None: ...\n    def tcdrain(__fd: FileDescriptorLike) -> None: ...\n    def tcflush(__fd: FileDescriptorLike, __queue: int) -> None: ...\n    def tcflow(__fd: FileDescriptorLike, __action: int) -> None: ...\n    if sys.version_info >= (3, 11):\n        def tcgetwinsize(__fd: FileDescriptorLike) -> tuple[int, int]: ...\n        def tcsetwinsize(__fd: FileDescriptorLike, __winsize: tuple[int, int]) -> None: ...\n\n    class error(Exception): ...\n",
  "/typeshed/stdlib/textwrap.pyi": "from collections.abc import Callable\nfrom re import Pattern\n\n__all__ = [\"TextWrapper\", \"wrap\", \"fill\", \"dedent\", \"indent\", \"shorten\"]\n\nclass TextWrapper:\n    width: int\n    initial_indent: str\n    subsequent_indent: str\n    expand_tabs: bool\n    replace_whitespace: bool\n    fix_sentence_endings: bool\n    drop_whitespace: bool\n    break_long_words: bool\n    break_on_hyphens: bool\n    tabsize: int\n    max_lines: int | None\n    placeholder: str\n\n    # Attributes not present in documentation\n    sentence_end_re: Pattern[str]\n    wordsep_re: Pattern[str]\n    wordsep_simple_re: Pattern[str]\n    whitespace_trans: str\n    unicode_whitespace_trans: dict[int, int]\n    uspace: int\n    x: str  # leaked loop variable\n    def __init__(\n        self,\n        width: int = 70,\n        initial_indent: str = \"\",\n        subsequent_indent: str = \"\",\n        expand_tabs: bool = True,\n        replace_whitespace: bool = True,\n        fix_sentence_endings: bool = False,\n        break_long_words: bool = True,\n        drop_whitespace: bool = True,\n        break_on_hyphens: bool = True,\n        tabsize: int = 8,\n        *,\n        max_lines: int | None = None,\n        placeholder: str = \" [...]\",\n    ) -> None: ...\n    # Private methods *are* part of the documented API for subclasses.\n    def _munge_whitespace(self, text: str) -> str: ...\n    def _split(self, text: str) -> list[str]: ...\n    def _fix_sentence_endings(self, chunks: list[str]) -> None: ...\n    def _handle_long_word(self, reversed_chunks: list[str], cur_line: list[str], cur_len: int, width: int) -> None: ...\n    def _wrap_chunks(self, chunks: list[str]) -> list[str]: ...\n    def _split_chunks(self, text: str) -> list[str]: ...\n    def wrap(self, text: str) -> list[str]: ...\n    def fill(self, text: str) -> str: ...\n\ndef wrap(\n    text: str,\n    width: int = 70,\n    *,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    expand_tabs: bool = True,\n    tabsize: int = 8,\n    replace_whitespace: bool = True,\n    fix_sentence_endings: bool = False,\n    break_long_words: bool = True,\n    break_on_hyphens: bool = True,\n    drop_whitespace: bool = True,\n    max_lines: int | None = None,\n    placeholder: str = \" [...]\",\n) -> list[str]: ...\ndef fill(\n    text: str,\n    width: int = 70,\n    *,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    expand_tabs: bool = True,\n    tabsize: int = 8,\n    replace_whitespace: bool = True,\n    fix_sentence_endings: bool = False,\n    break_long_words: bool = True,\n    break_on_hyphens: bool = True,\n    drop_whitespace: bool = True,\n    max_lines: int | None = None,\n    placeholder: str = \" [...]\",\n) -> str: ...\ndef shorten(\n    text: str,\n    width: int,\n    *,\n    initial_indent: str = \"\",\n    subsequent_indent: str = \"\",\n    expand_tabs: bool = True,\n    tabsize: int = 8,\n    replace_whitespace: bool = True,\n    fix_sentence_endings: bool = False,\n    break_long_words: bool = True,\n    break_on_hyphens: bool = True,\n    drop_whitespace: bool = True,\n    # Omit `max_lines: int = None`, it is forced to 1 here.\n    placeholder: str = \" [...]\",\n) -> str: ...\ndef dedent(text: str) -> str: ...\ndef indent(text: str, prefix: str, predicate: Callable[[str], bool] | None = None) -> str: ...\n",
  "/typeshed/stdlib/this.pyi": "s: str\nd: dict[str, str]\n",
  "/typeshed/stdlib/threading.pyi": "import sys\nfrom _typeshed import ProfileFunction, TraceFunction\nfrom collections.abc import Callable, Iterable, Mapping\nfrom types import TracebackType\nfrom typing import Any, TypeVar\nfrom typing_extensions import final\n\n_T = TypeVar(\"_T\")\n\n__all__ = [\n    \"get_ident\",\n    \"active_count\",\n    \"Condition\",\n    \"current_thread\",\n    \"enumerate\",\n    \"main_thread\",\n    \"TIMEOUT_MAX\",\n    \"Event\",\n    \"Lock\",\n    \"RLock\",\n    \"Semaphore\",\n    \"BoundedSemaphore\",\n    \"Thread\",\n    \"Barrier\",\n    \"BrokenBarrierError\",\n    \"Timer\",\n    \"ThreadError\",\n    \"setprofile\",\n    \"settrace\",\n    \"local\",\n    \"stack_size\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"ExceptHookArgs\", \"excepthook\", \"get_native_id\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"getprofile\", \"gettrace\"]\n\n_profile_hook: ProfileFunction | None\n\ndef active_count() -> int: ...\ndef activeCount() -> int: ...  # deprecated alias for active_count()\ndef current_thread() -> Thread: ...\ndef currentThread() -> Thread: ...  # deprecated alias for current_thread()\ndef get_ident() -> int: ...\ndef enumerate() -> list[Thread]: ...\ndef main_thread() -> Thread: ...\n\nif sys.version_info >= (3, 8):\n    from _thread import get_native_id as get_native_id\n\ndef settrace(func: TraceFunction) -> None: ...\ndef setprofile(func: ProfileFunction | None) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def gettrace() -> TraceFunction | None: ...\n    def getprofile() -> ProfileFunction | None: ...\n\ndef stack_size(size: int = ...) -> int: ...\n\nTIMEOUT_MAX: float\n\nclass ThreadError(Exception): ...\n\nclass local:\n    def __getattribute__(self, __name: str) -> Any: ...\n    def __setattr__(self, __name: str, __value: Any) -> None: ...\n    def __delattr__(self, __name: str) -> None: ...\n\nclass Thread:\n    name: str\n    @property\n    def ident(self) -> int | None: ...\n    daemon: bool\n    def __init__(\n        self,\n        group: None = None,\n        target: Callable[..., object] | None = None,\n        name: str | None = None,\n        args: Iterable[Any] = (),\n        kwargs: Mapping[str, Any] | None = None,\n        *,\n        daemon: bool | None = None,\n    ) -> None: ...\n    def start(self) -> None: ...\n    def run(self) -> None: ...\n    def join(self, timeout: float | None = None) -> None: ...\n    if sys.version_info >= (3, 8):\n        @property\n        def native_id(self) -> int | None: ...  # only available on some platforms\n\n    def is_alive(self) -> bool: ...\n    if sys.version_info < (3, 9):\n        def isAlive(self) -> bool: ...\n    # the following methods are all deprecated\n    def getName(self) -> str: ...\n    def setName(self, name: str) -> None: ...\n    def isDaemon(self) -> bool: ...\n    def setDaemon(self, daemonic: bool) -> None: ...\n\nclass _DummyThread(Thread):\n    def __init__(self) -> None: ...\n\n@final\nclass Lock:\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...\n    def release(self) -> None: ...\n    def locked(self) -> bool: ...\n\n@final\nclass _RLock:\n    def acquire(self, blocking: bool = True, timeout: float = -1) -> bool: ...\n    def release(self) -> None: ...\n    __enter__ = acquire\n    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n\nRLock = _RLock\n\nclass Condition:\n    def __init__(self, lock: Lock | _RLock | None = None) -> None: ...\n    def __enter__(self) -> bool: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def acquire(self, blocking: bool = ..., timeout: float = ...) -> bool: ...\n    def release(self) -> None: ...\n    def wait(self, timeout: float | None = None) -> bool: ...\n    def wait_for(self, predicate: Callable[[], _T], timeout: float | None = None) -> _T: ...\n    def notify(self, n: int = 1) -> None: ...\n    def notify_all(self) -> None: ...\n    def notifyAll(self) -> None: ...  # deprecated alias for notify_all()\n\nclass Semaphore:\n    _value: int\n    def __init__(self, value: int = 1) -> None: ...\n    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n    def acquire(self, blocking: bool = True, timeout: float | None = None) -> bool: ...\n    def __enter__(self, blocking: bool = True, timeout: float | None = None) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def release(self, n: int = 1) -> None: ...\n    else:\n        def release(self) -> None: ...\n\nclass BoundedSemaphore(Semaphore): ...\n\nclass Event:\n    def is_set(self) -> bool: ...\n    def isSet(self) -> bool: ...  # deprecated alias for is_set()\n    def set(self) -> None: ...\n    def clear(self) -> None: ...\n    def wait(self, timeout: float | None = None) -> bool: ...\n\nif sys.version_info >= (3, 8):\n    from _thread import _excepthook, _ExceptHookArgs\n\n    excepthook = _excepthook\n    ExceptHookArgs = _ExceptHookArgs\n\nclass Timer(Thread):\n    args: Iterable[Any]  # undocumented\n    finished: Event  # undocumented\n    function: Callable[..., Any]  # undocumented\n    interval: float  # undocumented\n    kwargs: Mapping[str, Any]  # undocumented\n\n    def __init__(\n        self,\n        interval: float,\n        function: Callable[..., object],\n        args: Iterable[Any] | None = None,\n        kwargs: Mapping[str, Any] | None = None,\n    ) -> None: ...\n    def cancel(self) -> None: ...\n\nclass Barrier:\n    @property\n    def parties(self) -> int: ...\n    @property\n    def n_waiting(self) -> int: ...\n    @property\n    def broken(self) -> bool: ...\n    def __init__(self, parties: int, action: Callable[[], None] | None = None, timeout: float | None = None) -> None: ...\n    def wait(self, timeout: float | None = None) -> int: ...\n    def reset(self) -> None: ...\n    def abort(self) -> None: ...\n\nclass BrokenBarrierError(RuntimeError): ...\n",
  "/typeshed/stdlib/time.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import Any, Protocol\nfrom typing_extensions import Final, Literal, TypeAlias, final\n\n_TimeTuple: TypeAlias = tuple[int, int, int, int, int, int, int, int, int]\n\naltzone: int\ndaylight: int\ntimezone: int\ntzname: tuple[str, str]\n\nif sys.platform == \"linux\":\n    CLOCK_BOOTTIME: int\nif sys.platform != \"linux\" and sys.platform != \"win32\" and sys.platform != \"darwin\":\n    CLOCK_PROF: int  # FreeBSD, NetBSD, OpenBSD\n    CLOCK_UPTIME: int  # FreeBSD, OpenBSD\n\nif sys.platform != \"win32\":\n    CLOCK_MONOTONIC: int\n    CLOCK_MONOTONIC_RAW: int\n    CLOCK_PROCESS_CPUTIME_ID: int\n    CLOCK_REALTIME: int\n    CLOCK_THREAD_CPUTIME_ID: int\n    if sys.platform != \"linux\" and sys.platform != \"darwin\":\n        CLOCK_HIGHRES: int  # Solaris only\n\nif sys.version_info >= (3, 8) and sys.platform == \"darwin\":\n    CLOCK_UPTIME_RAW: int\n\nif sys.version_info >= (3, 9) and sys.platform == \"linux\":\n    CLOCK_TAI: int\n\n# Constructor takes an iterable of any type, of length between 9 and 11 elements.\n# However, it always *behaves* like a tuple of 9 elements,\n# even if an iterable with length >9 is passed.\n# https://github.com/python/typeshed/pull/6560#discussion_r767162532\n@final\nclass struct_time(structseq[Any | int], _TimeTuple):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"tm_year\", \"tm_mon\", \"tm_mday\", \"tm_hour\", \"tm_min\", \"tm_sec\", \"tm_wday\", \"tm_yday\", \"tm_isdst\")\n    @property\n    def tm_year(self) -> int: ...\n    @property\n    def tm_mon(self) -> int: ...\n    @property\n    def tm_mday(self) -> int: ...\n    @property\n    def tm_hour(self) -> int: ...\n    @property\n    def tm_min(self) -> int: ...\n    @property\n    def tm_sec(self) -> int: ...\n    @property\n    def tm_wday(self) -> int: ...\n    @property\n    def tm_yday(self) -> int: ...\n    @property\n    def tm_isdst(self) -> int: ...\n    # These final two properties only exist if a 10- or 11-item sequence was passed to the constructor.\n    @property\n    def tm_zone(self) -> str: ...\n    @property\n    def tm_gmtoff(self) -> int: ...\n\ndef asctime(t: _TimeTuple | struct_time = ...) -> str: ...\n\nif sys.version_info < (3, 8):\n    def clock() -> float: ...\n\ndef ctime(secs: float | None = ...) -> str: ...\ndef gmtime(secs: float | None = ...) -> struct_time: ...\ndef localtime(secs: float | None = ...) -> struct_time: ...\ndef mktime(t: _TimeTuple | struct_time) -> float: ...\ndef sleep(secs: float) -> None: ...\ndef strftime(format: str, t: _TimeTuple | struct_time = ...) -> str: ...\ndef strptime(string: str, format: str = ...) -> struct_time: ...\ndef time() -> float: ...\n\nif sys.platform != \"win32\":\n    def tzset() -> None: ...  # Unix only\n\nclass _ClockInfo(Protocol):\n    adjustable: bool\n    implementation: str\n    monotonic: bool\n    resolution: float\n\ndef get_clock_info(name: Literal[\"monotonic\", \"perf_counter\", \"process_time\", \"time\", \"thread_time\"]) -> _ClockInfo: ...\ndef monotonic() -> float: ...\ndef perf_counter() -> float: ...\ndef process_time() -> float: ...\n\nif sys.platform != \"win32\":\n    def clock_getres(clk_id: int) -> float: ...  # Unix only\n    def clock_gettime(clk_id: int) -> float: ...  # Unix only\n    def clock_settime(clk_id: int, time: float) -> None: ...  # Unix only\n\nif sys.platform != \"win32\":\n    def clock_gettime_ns(clock_id: int) -> int: ...\n    def clock_settime_ns(clock_id: int, time: int) -> int: ...\n\nif sys.platform == \"linux\":\n    def pthread_getcpuclockid(thread_id: int) -> int: ...\n\ndef monotonic_ns() -> int: ...\ndef perf_counter_ns() -> int: ...\ndef process_time_ns() -> int: ...\ndef time_ns() -> int: ...\ndef thread_time() -> float: ...\ndef thread_time_ns() -> int: ...\n",
  "/typeshed/stdlib/timeit.pyi": "from collections.abc import Callable, Sequence\nfrom typing import IO, Any\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"Timer\", \"timeit\", \"repeat\", \"default_timer\"]\n\n_Timer: TypeAlias = Callable[[], float]\n_Stmt: TypeAlias = str | Callable[[], object]\n\ndefault_timer: _Timer\n\nclass Timer:\n    def __init__(\n        self, stmt: _Stmt = \"pass\", setup: _Stmt = \"pass\", timer: _Timer = ..., globals: dict[str, Any] | None = None\n    ) -> None: ...\n    def print_exc(self, file: IO[str] | None = None) -> None: ...\n    def timeit(self, number: int = 1000000) -> float: ...\n    def repeat(self, repeat: int = 5, number: int = 1000000) -> list[float]: ...\n    def autorange(self, callback: Callable[[int, float], object] | None = None) -> tuple[int, float]: ...\n\ndef timeit(\n    stmt: _Stmt = \"pass\", setup: _Stmt = \"pass\", timer: _Timer = ..., number: int = 1000000, globals: dict[str, Any] | None = None\n) -> float: ...\ndef repeat(\n    stmt: _Stmt = \"pass\",\n    setup: _Stmt = \"pass\",\n    timer: _Timer = ...,\n    repeat: int = 5,\n    number: int = 1000000,\n    globals: dict[str, Any] | None = None,\n) -> list[float]: ...\ndef main(args: Sequence[str] | None = None, *, _wrap_timer: Callable[[_Timer], _Timer] | None = None) -> None: ...\n",
  "/typeshed/stdlib/token.pyi": "import sys\n\n__all__ = [\n    \"AMPER\",\n    \"AMPEREQUAL\",\n    \"AT\",\n    \"ATEQUAL\",\n    \"CIRCUMFLEX\",\n    \"CIRCUMFLEXEQUAL\",\n    \"COLON\",\n    \"COMMA\",\n    \"DEDENT\",\n    \"DOT\",\n    \"DOUBLESLASH\",\n    \"DOUBLESLASHEQUAL\",\n    \"DOUBLESTAR\",\n    \"DOUBLESTAREQUAL\",\n    \"ELLIPSIS\",\n    \"ENDMARKER\",\n    \"EQEQUAL\",\n    \"EQUAL\",\n    \"ERRORTOKEN\",\n    \"GREATER\",\n    \"GREATEREQUAL\",\n    \"INDENT\",\n    \"ISEOF\",\n    \"ISNONTERMINAL\",\n    \"ISTERMINAL\",\n    \"LBRACE\",\n    \"LEFTSHIFT\",\n    \"LEFTSHIFTEQUAL\",\n    \"LESS\",\n    \"LESSEQUAL\",\n    \"LPAR\",\n    \"LSQB\",\n    \"MINEQUAL\",\n    \"MINUS\",\n    \"NAME\",\n    \"NEWLINE\",\n    \"NOTEQUAL\",\n    \"NT_OFFSET\",\n    \"NUMBER\",\n    \"N_TOKENS\",\n    \"OP\",\n    \"PERCENT\",\n    \"PERCENTEQUAL\",\n    \"PLUS\",\n    \"PLUSEQUAL\",\n    \"RARROW\",\n    \"RBRACE\",\n    \"RIGHTSHIFT\",\n    \"RIGHTSHIFTEQUAL\",\n    \"RPAR\",\n    \"RSQB\",\n    \"SEMI\",\n    \"SLASH\",\n    \"SLASHEQUAL\",\n    \"STAR\",\n    \"STAREQUAL\",\n    \"STRING\",\n    \"TILDE\",\n    \"VBAR\",\n    \"VBAREQUAL\",\n    \"tok_name\",\n    \"ENCODING\",\n    \"NL\",\n    \"COMMENT\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"ASYNC\", \"AWAIT\", \"COLONEQUAL\", \"TYPE_COMMENT\", \"TYPE_IGNORE\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"SOFT_KEYWORD\"]\n\nENDMARKER: int\nNAME: int\nNUMBER: int\nSTRING: int\nNEWLINE: int\nINDENT: int\nDEDENT: int\nLPAR: int\nRPAR: int\nLSQB: int\nRSQB: int\nCOLON: int\nCOMMA: int\nSEMI: int\nPLUS: int\nMINUS: int\nSTAR: int\nSLASH: int\nVBAR: int\nAMPER: int\nLESS: int\nGREATER: int\nEQUAL: int\nDOT: int\nPERCENT: int\nLBRACE: int\nRBRACE: int\nEQEQUAL: int\nNOTEQUAL: int\nLESSEQUAL: int\nGREATEREQUAL: int\nTILDE: int\nCIRCUMFLEX: int\nLEFTSHIFT: int\nRIGHTSHIFT: int\nDOUBLESTAR: int\nPLUSEQUAL: int\nMINEQUAL: int\nSTAREQUAL: int\nSLASHEQUAL: int\nPERCENTEQUAL: int\nAMPEREQUAL: int\nVBAREQUAL: int\nCIRCUMFLEXEQUAL: int\nLEFTSHIFTEQUAL: int\nRIGHTSHIFTEQUAL: int\nDOUBLESTAREQUAL: int\nDOUBLESLASH: int\nDOUBLESLASHEQUAL: int\nAT: int\nRARROW: int\nELLIPSIS: int\nATEQUAL: int\nif sys.version_info >= (3, 8):\n    AWAIT: int\n    ASYNC: int\nOP: int\nERRORTOKEN: int\nN_TOKENS: int\nNT_OFFSET: int\ntok_name: dict[int, str]\nCOMMENT: int\nNL: int\nENCODING: int\nif sys.version_info >= (3, 8):\n    TYPE_COMMENT: int\n    TYPE_IGNORE: int\n    COLONEQUAL: int\n    EXACT_TOKEN_TYPES: dict[str, int]\nif sys.version_info >= (3, 10):\n    SOFT_KEYWORD: int\n\ndef ISTERMINAL(x: int) -> bool: ...\ndef ISNONTERMINAL(x: int) -> bool: ...\ndef ISEOF(x: int) -> bool: ...\n",
  "/typeshed/stdlib/tokenize.pyi": "import sys\nfrom _typeshed import FileDescriptorOrPath\nfrom collections.abc import Callable, Generator, Iterable, Sequence\nfrom re import Pattern\nfrom token import *\nfrom typing import Any, NamedTuple, TextIO\nfrom typing_extensions import TypeAlias\n\n__all__ = [\n    \"AMPER\",\n    \"AMPEREQUAL\",\n    \"AT\",\n    \"ATEQUAL\",\n    \"CIRCUMFLEX\",\n    \"CIRCUMFLEXEQUAL\",\n    \"COLON\",\n    \"COMMA\",\n    \"COMMENT\",\n    \"DEDENT\",\n    \"DOT\",\n    \"DOUBLESLASH\",\n    \"DOUBLESLASHEQUAL\",\n    \"DOUBLESTAR\",\n    \"DOUBLESTAREQUAL\",\n    \"ELLIPSIS\",\n    \"ENCODING\",\n    \"ENDMARKER\",\n    \"EQEQUAL\",\n    \"EQUAL\",\n    \"ERRORTOKEN\",\n    \"GREATER\",\n    \"GREATEREQUAL\",\n    \"INDENT\",\n    \"ISEOF\",\n    \"ISNONTERMINAL\",\n    \"ISTERMINAL\",\n    \"LBRACE\",\n    \"LEFTSHIFT\",\n    \"LEFTSHIFTEQUAL\",\n    \"LESS\",\n    \"LESSEQUAL\",\n    \"LPAR\",\n    \"LSQB\",\n    \"MINEQUAL\",\n    \"MINUS\",\n    \"NAME\",\n    \"NEWLINE\",\n    \"NL\",\n    \"NOTEQUAL\",\n    \"NT_OFFSET\",\n    \"NUMBER\",\n    \"N_TOKENS\",\n    \"OP\",\n    \"PERCENT\",\n    \"PERCENTEQUAL\",\n    \"PLUS\",\n    \"PLUSEQUAL\",\n    \"RARROW\",\n    \"RBRACE\",\n    \"RIGHTSHIFT\",\n    \"RIGHTSHIFTEQUAL\",\n    \"RPAR\",\n    \"RSQB\",\n    \"SEMI\",\n    \"SLASH\",\n    \"SLASHEQUAL\",\n    \"STAR\",\n    \"STAREQUAL\",\n    \"STRING\",\n    \"TILDE\",\n    \"TokenInfo\",\n    \"VBAR\",\n    \"VBAREQUAL\",\n    \"detect_encoding\",\n    \"tok_name\",\n    \"tokenize\",\n    \"untokenize\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"ASYNC\", \"AWAIT\", \"COLONEQUAL\", \"generate_tokens\", \"TYPE_COMMENT\", \"TYPE_IGNORE\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"SOFT_KEYWORD\"]\n\nif sys.version_info >= (3, 8):\n    from token import EXACT_TOKEN_TYPES as EXACT_TOKEN_TYPES\nelse:\n    EXACT_TOKEN_TYPES: dict[str, int]\n\ncookie_re: Pattern[str]\nblank_re: Pattern[bytes]\n\n_Position: TypeAlias = tuple[int, int]\n\nclass _TokenInfo(NamedTuple):\n    type: int\n    string: str\n    start: _Position\n    end: _Position\n    line: str\n\nclass TokenInfo(_TokenInfo):\n    @property\n    def exact_type(self) -> int: ...\n\n# Backwards compatible tokens can be sequences of a shorter length too\n_Token: TypeAlias = TokenInfo | Sequence[int | str | _Position]\n\nclass TokenError(Exception): ...\nclass StopTokenizing(Exception): ...  # undocumented\n\nclass Untokenizer:\n    tokens: list[str]\n    prev_row: int\n    prev_col: int\n    encoding: str | None\n    def add_whitespace(self, start: _Position) -> None: ...\n    def untokenize(self, iterable: Iterable[_Token]) -> str: ...\n    def compat(self, token: Sequence[int | str], iterable: Iterable[_Token]) -> None: ...\n\n# the docstring says \"returns bytes\" but is incorrect --\n# if the ENCODING token is missing, it skips the encode\ndef untokenize(iterable: Iterable[_Token]) -> Any: ...\ndef detect_encoding(readline: Callable[[], bytes | bytearray]) -> tuple[str, Sequence[bytes]]: ...\ndef tokenize(readline: Callable[[], bytes | bytearray]) -> Generator[TokenInfo, None, None]: ...\ndef generate_tokens(readline: Callable[[], str]) -> Generator[TokenInfo, None, None]: ...  # undocumented\ndef open(filename: FileDescriptorOrPath) -> TextIO: ...\ndef group(*choices: str) -> str: ...  # undocumented\ndef any(*choices: str) -> str: ...  # undocumented\ndef maybe(*choices: str) -> str: ...  # undocumented\n\nWhitespace: str  # undocumented\nComment: str  # undocumented\nIgnore: str  # undocumented\nName: str  # undocumented\n\nHexnumber: str  # undocumented\nBinnumber: str  # undocumented\nOctnumber: str  # undocumented\nDecnumber: str  # undocumented\nIntnumber: str  # undocumented\nExponent: str  # undocumented\nPointfloat: str  # undocumented\nExpfloat: str  # undocumented\nFloatnumber: str  # undocumented\nImagnumber: str  # undocumented\nNumber: str  # undocumented\n\ndef _all_string_prefixes() -> set[str]: ...  # undocumented\n\nStringPrefix: str  # undocumented\n\nSingle: str  # undocumented\nDouble: str  # undocumented\nSingle3: str  # undocumented\nDouble3: str  # undocumented\nTriple: str  # undocumented\nString: str  # undocumented\n\nSpecial: str  # undocumented\nFunny: str  # undocumented\n\nPlainToken: str  # undocumented\nToken: str  # undocumented\n\nContStr: str  # undocumented\nPseudoExtras: str  # undocumented\nPseudoToken: str  # undocumented\n\nendpats: dict[str, str]  # undocumented\nsingle_quoted: set[str]  # undocumented\ntriple_quoted: set[str]  # undocumented\n\ntabsize: int  # undocumented\n",
  "/typeshed/stdlib/tomllib.pyi": "from _typeshed import SupportsRead\nfrom collections.abc import Callable\nfrom typing import Any\n\n__all__ = (\"loads\", \"load\", \"TOMLDecodeError\")\n\nclass TOMLDecodeError(ValueError): ...\n\ndef load(__fp: SupportsRead[bytes], *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...\ndef loads(__s: str, *, parse_float: Callable[[str], Any] = ...) -> dict[str, Any]: ...\n",
  "/typeshed/stdlib/trace.pyi": "import sys\nimport types\nfrom _typeshed import StrPath, TraceFunction\nfrom collections.abc import Callable, Mapping, Sequence\nfrom typing import Any, TypeVar\nfrom typing_extensions import ParamSpec, TypeAlias\n\n__all__ = [\"Trace\", \"CoverageResults\"]\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n_FileModuleFunction: TypeAlias = tuple[str, str | None, str]\n\nclass CoverageResults:\n    def __init__(\n        self,\n        counts: dict[tuple[str, int], int] | None = None,\n        calledfuncs: dict[_FileModuleFunction, int] | None = None,\n        infile: StrPath | None = None,\n        callers: dict[tuple[_FileModuleFunction, _FileModuleFunction], int] | None = None,\n        outfile: StrPath | None = None,\n    ) -> None: ...  # undocumented\n    def update(self, other: CoverageResults) -> None: ...\n    def write_results(self, show_missing: bool = True, summary: bool = False, coverdir: StrPath | None = None) -> None: ...\n    def write_results_file(\n        self, path: StrPath, lines: Sequence[str], lnotab: Any, lines_hit: Mapping[int, int], encoding: str | None = None\n    ) -> tuple[int, int]: ...\n    def is_ignored_filename(self, filename: str) -> bool: ...  # undocumented\n\nclass Trace:\n    def __init__(\n        self,\n        count: int = 1,\n        trace: int = 1,\n        countfuncs: int = 0,\n        countcallers: int = 0,\n        ignoremods: Sequence[str] = (),\n        ignoredirs: Sequence[str] = (),\n        infile: StrPath | None = None,\n        outfile: StrPath | None = None,\n        timing: bool = False,\n    ) -> None: ...\n    def run(self, cmd: str | types.CodeType) -> None: ...\n    def runctx(\n        self, cmd: str | types.CodeType, globals: Mapping[str, Any] | None = None, locals: Mapping[str, Any] | None = None\n    ) -> None: ...\n    if sys.version_info >= (3, 9):\n        def runfunc(self, __func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...\n    else:\n        def runfunc(self, func: Callable[_P, _T], *args: _P.args, **kw: _P.kwargs) -> _T: ...\n\n    def file_module_function_of(self, frame: types.FrameType) -> _FileModuleFunction: ...\n    def globaltrace_trackcallers(self, frame: types.FrameType, why: str, arg: Any) -> None: ...\n    def globaltrace_countfuncs(self, frame: types.FrameType, why: str, arg: Any) -> None: ...\n    def globaltrace_lt(self, frame: types.FrameType, why: str, arg: Any) -> None: ...\n    def localtrace_trace_and_count(self, frame: types.FrameType, why: str, arg: Any) -> TraceFunction: ...\n    def localtrace_trace(self, frame: types.FrameType, why: str, arg: Any) -> TraceFunction: ...\n    def localtrace_count(self, frame: types.FrameType, why: str, arg: Any) -> TraceFunction: ...\n    def results(self) -> CoverageResults: ...\n",
  "/typeshed/stdlib/traceback.pyi": "import sys\nfrom _typeshed import SupportsWrite\nfrom collections.abc import Generator, Iterable, Iterator, Mapping\nfrom types import FrameType, TracebackType\nfrom typing import Any, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\n    \"extract_stack\",\n    \"extract_tb\",\n    \"format_exception\",\n    \"format_exception_only\",\n    \"format_list\",\n    \"format_stack\",\n    \"format_tb\",\n    \"print_exc\",\n    \"format_exc\",\n    \"print_exception\",\n    \"print_last\",\n    \"print_stack\",\n    \"print_tb\",\n    \"clear_frames\",\n    \"FrameSummary\",\n    \"StackSummary\",\n    \"TracebackException\",\n    \"walk_stack\",\n    \"walk_tb\",\n]\n\n_PT: TypeAlias = tuple[str, int, str, str | None]\n\ndef print_tb(tb: TracebackType | None, limit: int | None = None, file: SupportsWrite[str] | None = None) -> None: ...\n\nif sys.version_info >= (3, 10):\n    @overload\n    def print_exception(\n        __exc: type[BaseException] | None,\n        value: BaseException | None = ...,\n        tb: TracebackType | None = ...,\n        limit: int | None = None,\n        file: SupportsWrite[str] | None = None,\n        chain: bool = True,\n    ) -> None: ...\n    @overload\n    def print_exception(\n        __exc: BaseException, *, limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True\n    ) -> None: ...\n    @overload\n    def format_exception(\n        __exc: type[BaseException] | None,\n        value: BaseException | None = ...,\n        tb: TracebackType | None = ...,\n        limit: int | None = None,\n        chain: bool = True,\n    ) -> list[str]: ...\n    @overload\n    def format_exception(__exc: BaseException, *, limit: int | None = None, chain: bool = True) -> list[str]: ...\n\nelse:\n    def print_exception(\n        etype: type[BaseException] | None,\n        value: BaseException | None,\n        tb: TracebackType | None,\n        limit: int | None = None,\n        file: SupportsWrite[str] | None = None,\n        chain: bool = True,\n    ) -> None: ...\n    def format_exception(\n        etype: type[BaseException] | None,\n        value: BaseException | None,\n        tb: TracebackType | None,\n        limit: int | None = None,\n        chain: bool = True,\n    ) -> list[str]: ...\n\ndef print_exc(limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True) -> None: ...\ndef print_last(limit: int | None = None, file: SupportsWrite[str] | None = None, chain: bool = True) -> None: ...\ndef print_stack(f: FrameType | None = None, limit: int | None = None, file: SupportsWrite[str] | None = None) -> None: ...\ndef extract_tb(tb: TracebackType | None, limit: int | None = None) -> StackSummary: ...\ndef extract_stack(f: FrameType | None = None, limit: int | None = None) -> StackSummary: ...\ndef format_list(extracted_list: list[FrameSummary]) -> list[str]: ...\n\n# undocumented\ndef print_list(extracted_list: list[FrameSummary], file: SupportsWrite[str] | None = None) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def format_exception_only(__exc: type[BaseException] | None, value: BaseException | None = ...) -> list[str]: ...\n\nelse:\n    def format_exception_only(etype: type[BaseException] | None, value: BaseException | None) -> list[str]: ...\n\ndef format_exc(limit: int | None = None, chain: bool = True) -> str: ...\ndef format_tb(tb: TracebackType | None, limit: int | None = None) -> list[str]: ...\ndef format_stack(f: FrameType | None = None, limit: int | None = None) -> list[str]: ...\ndef clear_frames(tb: TracebackType | None) -> None: ...\ndef walk_stack(f: FrameType | None) -> Iterator[tuple[FrameType, int]]: ...\ndef walk_tb(tb: TracebackType | None) -> Iterator[tuple[FrameType, int]]: ...\n\nif sys.version_info >= (3, 11):\n    class _ExceptionPrintContext:\n        def indent(self) -> str: ...\n        def emit(self, text_gen: str | Iterable[str], margin_char: str | None = None) -> Generator[str, None, None]: ...\n\nclass TracebackException:\n    __cause__: TracebackException\n    __context__: TracebackException\n    __suppress_context__: bool\n    stack: StackSummary\n    exc_type: type[BaseException]\n    filename: str\n    lineno: int\n    text: str\n    offset: int\n    msg: str\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            exc_type: type[BaseException],\n            exc_value: BaseException,\n            exc_traceback: TracebackType | None,\n            *,\n            limit: int | None = None,\n            lookup_lines: bool = True,\n            capture_locals: bool = False,\n            compact: bool = False,\n            max_group_width: int = 15,\n            max_group_depth: int = 10,\n            _seen: set[int] | None = None,\n        ) -> None: ...\n        @classmethod\n        def from_exception(\n            cls,\n            exc: BaseException,\n            *,\n            limit: int | None = None,\n            lookup_lines: bool = True,\n            capture_locals: bool = False,\n            compact: bool = False,\n            max_group_width: int = 15,\n            max_group_depth: int = 10,\n        ) -> Self: ...\n    elif sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            exc_type: type[BaseException],\n            exc_value: BaseException,\n            exc_traceback: TracebackType | None,\n            *,\n            limit: int | None = None,\n            lookup_lines: bool = True,\n            capture_locals: bool = False,\n            compact: bool = False,\n            _seen: set[int] | None = None,\n        ) -> None: ...\n        @classmethod\n        def from_exception(\n            cls,\n            exc: BaseException,\n            *,\n            limit: int | None = None,\n            lookup_lines: bool = True,\n            capture_locals: bool = False,\n            compact: bool = False,\n        ) -> Self: ...\n    else:\n        def __init__(\n            self,\n            exc_type: type[BaseException],\n            exc_value: BaseException,\n            exc_traceback: TracebackType | None,\n            *,\n            limit: int | None = None,\n            lookup_lines: bool = True,\n            capture_locals: bool = False,\n            _seen: set[int] | None = None,\n        ) -> None: ...\n        @classmethod\n        def from_exception(\n            cls, exc: BaseException, *, limit: int | None = None, lookup_lines: bool = True, capture_locals: bool = False\n        ) -> Self: ...\n\n    def __eq__(self, other: object) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def format(self, *, chain: bool = True, _ctx: _ExceptionPrintContext | None = None) -> Generator[str, None, None]: ...\n    else:\n        def format(self, *, chain: bool = True) -> Generator[str, None, None]: ...\n\n    def format_exception_only(self) -> Generator[str, None, None]: ...\n\n    if sys.version_info >= (3, 11):\n        def print(self, *, file: SupportsWrite[str] | None = None, chain: bool = True) -> None: ...\n\nclass FrameSummary(Iterable[Any]):\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            filename: str,\n            lineno: int | None,\n            name: str,\n            *,\n            lookup_line: bool = True,\n            locals: Mapping[str, str] | None = None,\n            line: str | None = None,\n            end_lineno: int | None = None,\n            colno: int | None = None,\n            end_colno: int | None = None,\n        ) -> None: ...\n        end_lineno: int | None\n        colno: int | None\n        end_colno: int | None\n    else:\n        def __init__(\n            self,\n            filename: str,\n            lineno: int | None,\n            name: str,\n            *,\n            lookup_line: bool = True,\n            locals: Mapping[str, str] | None = None,\n            line: str | None = None,\n        ) -> None: ...\n    filename: str\n    lineno: int | None\n    name: str\n    locals: dict[str, str] | None\n    @property\n    def line(self) -> str | None: ...\n    @overload\n    def __getitem__(self, pos: Literal[0]) -> str: ...\n    @overload\n    def __getitem__(self, pos: Literal[1]) -> int: ...\n    @overload\n    def __getitem__(self, pos: Literal[2]) -> str: ...\n    @overload\n    def __getitem__(self, pos: Literal[3]) -> str | None: ...\n    @overload\n    def __getitem__(self, pos: int) -> Any: ...\n    def __iter__(self) -> Iterator[Any]: ...\n    def __eq__(self, other: object) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def __len__(self) -> Literal[4]: ...\n\nclass StackSummary(list[FrameSummary]):\n    @classmethod\n    def extract(\n        cls,\n        frame_gen: Iterable[tuple[FrameType, int]],\n        *,\n        limit: int | None = None,\n        lookup_lines: bool = True,\n        capture_locals: bool = False,\n    ) -> StackSummary: ...\n    @classmethod\n    def from_list(cls, a_list: Iterable[FrameSummary | _PT]) -> StackSummary: ...\n    if sys.version_info >= (3, 11):\n        def format_frame_summary(self, frame_summary: FrameSummary) -> str: ...\n\n    def format(self) -> list[str]: ...\n",
  "/typeshed/stdlib/tracemalloc.pyi": "import sys\nfrom _tracemalloc import *\nfrom collections.abc import Sequence\nfrom typing import Any, overload\nfrom typing_extensions import SupportsIndex, TypeAlias\n\ndef get_object_traceback(obj: object) -> Traceback | None: ...\ndef take_snapshot() -> Snapshot: ...\n\nclass BaseFilter:\n    inclusive: bool\n    def __init__(self, inclusive: bool) -> None: ...\n\nclass DomainFilter(BaseFilter):\n    @property\n    def domain(self) -> int: ...\n    def __init__(self, inclusive: bool, domain: int) -> None: ...\n\nclass Filter(BaseFilter):\n    domain: int | None\n    lineno: int | None\n    @property\n    def filename_pattern(self) -> str: ...\n    all_frames: bool\n    def __init__(\n        self,\n        inclusive: bool,\n        filename_pattern: str,\n        lineno: int | None = None,\n        all_frames: bool = False,\n        domain: int | None = None,\n    ) -> None: ...\n\nclass Statistic:\n    count: int\n    size: int\n    traceback: Traceback\n    def __init__(self, traceback: Traceback, size: int, count: int) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass StatisticDiff:\n    count: int\n    count_diff: int\n    size: int\n    size_diff: int\n    traceback: Traceback\n    def __init__(self, traceback: Traceback, size: int, size_diff: int, count: int, count_diff: int) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\n_FrameTuple: TypeAlias = tuple[str, int]\n\nclass Frame:\n    @property\n    def filename(self) -> str: ...\n    @property\n    def lineno(self) -> int: ...\n    def __init__(self, frame: _FrameTuple) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: Frame) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __gt__(self, other: Frame) -> bool: ...\n        def __ge__(self, other: Frame) -> bool: ...\n        def __le__(self, other: Frame) -> bool: ...\n    else:\n        def __gt__(self, other: Frame, NotImplemented: Any = ...) -> bool: ...\n        def __ge__(self, other: Frame, NotImplemented: Any = ...) -> bool: ...\n        def __le__(self, other: Frame, NotImplemented: Any = ...) -> bool: ...\n\nif sys.version_info >= (3, 9):\n    _TraceTuple: TypeAlias = tuple[int, int, Sequence[_FrameTuple], int | None] | tuple[int, int, Sequence[_FrameTuple]]\nelse:\n    _TraceTuple: TypeAlias = tuple[int, int, Sequence[_FrameTuple]]\n\nclass Trace:\n    @property\n    def domain(self) -> int: ...\n    @property\n    def size(self) -> int: ...\n    @property\n    def traceback(self) -> Traceback: ...\n    def __init__(self, trace: _TraceTuple) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass Traceback(Sequence[Frame]):\n    if sys.version_info >= (3, 9):\n        @property\n        def total_nframe(self) -> int | None: ...\n        def __init__(self, frames: Sequence[_FrameTuple], total_nframe: int | None = None) -> None: ...\n    else:\n        def __init__(self, frames: Sequence[_FrameTuple]) -> None: ...\n\n    def format(self, limit: int | None = None, most_recent_first: bool = False) -> list[str]: ...\n    @overload\n    def __getitem__(self, index: SupportsIndex) -> Frame: ...\n    @overload\n    def __getitem__(self, index: slice) -> Sequence[Frame]: ...\n    def __contains__(self, frame: Frame) -> bool: ...  # type: ignore[override]\n    def __len__(self) -> int: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: Traceback) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __gt__(self, other: Traceback) -> bool: ...\n        def __ge__(self, other: Traceback) -> bool: ...\n        def __le__(self, other: Traceback) -> bool: ...\n    else:\n        def __gt__(self, other: Traceback, NotImplemented: Any = ...) -> bool: ...\n        def __ge__(self, other: Traceback, NotImplemented: Any = ...) -> bool: ...\n        def __le__(self, other: Traceback, NotImplemented: Any = ...) -> bool: ...\n\nclass Snapshot:\n    def __init__(self, traces: Sequence[_TraceTuple], traceback_limit: int) -> None: ...\n    def compare_to(self, old_snapshot: Snapshot, key_type: str, cumulative: bool = False) -> list[StatisticDiff]: ...\n    def dump(self, filename: str) -> None: ...\n    def filter_traces(self, filters: Sequence[DomainFilter | Filter]) -> Snapshot: ...\n    @staticmethod\n    def load(filename: str) -> Snapshot: ...\n    def statistics(self, key_type: str, cumulative: bool = False) -> list[Statistic]: ...\n    traceback_limit: int\n    traces: Sequence[Trace]\n",
  "/typeshed/stdlib/tty.pyi": "import sys\nfrom typing import IO\nfrom typing_extensions import TypeAlias\n\nif sys.platform != \"win32\":\n    __all__ = [\"setraw\", \"setcbreak\"]\n\n    _FD: TypeAlias = int | IO[str]\n\n    # XXX: Undocumented integer constants\n    IFLAG: int\n    OFLAG: int\n    CFLAG: int\n    LFLAG: int\n    ISPEED: int\n    OSPEED: int\n    CC: int\n    def setraw(fd: _FD, when: int = 2) -> None: ...\n    def setcbreak(fd: _FD, when: int = 2) -> None: ...\n",
  "/typeshed/stdlib/turtle.pyi": "from collections.abc import Callable, Sequence\nfrom tkinter import Canvas, Frame, Misc, PhotoImage, Scrollbar\nfrom typing import Any, ClassVar, overload\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\n    \"ScrolledCanvas\",\n    \"TurtleScreen\",\n    \"Screen\",\n    \"RawTurtle\",\n    \"Turtle\",\n    \"RawPen\",\n    \"Pen\",\n    \"Shape\",\n    \"Vec2D\",\n    \"addshape\",\n    \"bgcolor\",\n    \"bgpic\",\n    \"bye\",\n    \"clearscreen\",\n    \"colormode\",\n    \"delay\",\n    \"exitonclick\",\n    \"getcanvas\",\n    \"getshapes\",\n    \"listen\",\n    \"mainloop\",\n    \"mode\",\n    \"numinput\",\n    \"onkey\",\n    \"onkeypress\",\n    \"onkeyrelease\",\n    \"onscreenclick\",\n    \"ontimer\",\n    \"register_shape\",\n    \"resetscreen\",\n    \"screensize\",\n    \"setup\",\n    \"setworldcoordinates\",\n    \"textinput\",\n    \"title\",\n    \"tracer\",\n    \"turtles\",\n    \"update\",\n    \"window_height\",\n    \"window_width\",\n    \"back\",\n    \"backward\",\n    \"begin_fill\",\n    \"begin_poly\",\n    \"bk\",\n    \"circle\",\n    \"clear\",\n    \"clearstamp\",\n    \"clearstamps\",\n    \"clone\",\n    \"color\",\n    \"degrees\",\n    \"distance\",\n    \"dot\",\n    \"down\",\n    \"end_fill\",\n    \"end_poly\",\n    \"fd\",\n    \"fillcolor\",\n    \"filling\",\n    \"forward\",\n    \"get_poly\",\n    \"getpen\",\n    \"getscreen\",\n    \"get_shapepoly\",\n    \"getturtle\",\n    \"goto\",\n    \"heading\",\n    \"hideturtle\",\n    \"home\",\n    \"ht\",\n    \"isdown\",\n    \"isvisible\",\n    \"left\",\n    \"lt\",\n    \"onclick\",\n    \"ondrag\",\n    \"onrelease\",\n    \"pd\",\n    \"pen\",\n    \"pencolor\",\n    \"pendown\",\n    \"pensize\",\n    \"penup\",\n    \"pos\",\n    \"position\",\n    \"pu\",\n    \"radians\",\n    \"right\",\n    \"reset\",\n    \"resizemode\",\n    \"rt\",\n    \"seth\",\n    \"setheading\",\n    \"setpos\",\n    \"setposition\",\n    \"settiltangle\",\n    \"setundobuffer\",\n    \"setx\",\n    \"sety\",\n    \"shape\",\n    \"shapesize\",\n    \"shapetransform\",\n    \"shearfactor\",\n    \"showturtle\",\n    \"speed\",\n    \"st\",\n    \"stamp\",\n    \"tilt\",\n    \"tiltangle\",\n    \"towards\",\n    \"turtlesize\",\n    \"undo\",\n    \"undobufferentries\",\n    \"up\",\n    \"width\",\n    \"write\",\n    \"xcor\",\n    \"ycor\",\n    \"write_docstringdict\",\n    \"done\",\n    \"Terminator\",\n]\n\n# Note: '_Color' is the alias we use for arguments and _AnyColor is the\n# alias we use for return types. Really, these two aliases should be the\n# same, but as per the \"no union returns\" typeshed policy, we'll return\n# Any instead.\n_Color: TypeAlias = str | tuple[float, float, float]\n_AnyColor: TypeAlias = Any\n\n# TODO: Replace this with a TypedDict once it becomes standardized.\n_PenState: TypeAlias = dict[str, Any]\n\n_Speed: TypeAlias = str | float\n_PolygonCoords: TypeAlias = Sequence[tuple[float, float]]\n\nclass Vec2D(tuple[float, float]):\n    def __new__(cls, x: float, y: float) -> Self: ...\n    def __add__(self, other: tuple[float, float]) -> Vec2D: ...  # type: ignore[override]\n    @overload  # type: ignore[override]\n    def __mul__(self, other: Vec2D) -> float: ...\n    @overload\n    def __mul__(self, other: float) -> Vec2D: ...\n    def __rmul__(self, other: float) -> Vec2D: ...  # type: ignore[override]\n    def __sub__(self, other: tuple[float, float]) -> Vec2D: ...\n    def __neg__(self) -> Vec2D: ...\n    def __abs__(self) -> float: ...\n    def rotate(self, angle: float) -> Vec2D: ...\n\n# Does not actually inherit from Canvas, but dynamically gets all methods of Canvas\nclass ScrolledCanvas(Canvas, Frame):  # type: ignore[misc]\n    bg: str\n    hscroll: Scrollbar\n    vscroll: Scrollbar\n    def __init__(\n        self, master: Misc | None, width: int = 500, height: int = 350, canvwidth: int = 600, canvheight: int = 500\n    ) -> None: ...\n    canvwidth: int\n    canvheight: int\n    def reset(self, canvwidth: int | None = None, canvheight: int | None = None, bg: str | None = None) -> None: ...\n\nclass TurtleScreenBase:\n    cv: Canvas\n    canvwidth: int\n    canvheight: int\n    xscale: float\n    yscale: float\n    def __init__(self, cv: Canvas) -> None: ...\n    def mainloop(self) -> None: ...\n    def textinput(self, title: str, prompt: str) -> str | None: ...\n    def numinput(\n        self, title: str, prompt: str, default: float | None = None, minval: float | None = None, maxval: float | None = None\n    ) -> float | None: ...\n\nclass Terminator(Exception): ...\nclass TurtleGraphicsError(Exception): ...\n\nclass Shape:\n    def __init__(self, type_: str, data: _PolygonCoords | PhotoImage | None = None) -> None: ...\n    def addcomponent(self, poly: _PolygonCoords, fill: _Color, outline: _Color | None = None) -> None: ...\n\nclass TurtleScreen(TurtleScreenBase):\n    def __init__(self, cv: Canvas, mode: str = \"standard\", colormode: float = 1.0, delay: int = 10) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def mode(self, mode: None = None) -> str: ...\n    @overload\n    def mode(self, mode: str) -> None: ...\n    def setworldcoordinates(self, llx: float, lly: float, urx: float, ury: float) -> None: ...\n    def register_shape(self, name: str, shape: _PolygonCoords | Shape | None = None) -> None: ...\n    @overload\n    def colormode(self, cmode: None = None) -> float: ...\n    @overload\n    def colormode(self, cmode: float) -> None: ...\n    def reset(self) -> None: ...\n    def turtles(self) -> list[Turtle]: ...\n    @overload\n    def bgcolor(self) -> _AnyColor: ...\n    @overload\n    def bgcolor(self, color: _Color) -> None: ...\n    @overload\n    def bgcolor(self, r: float, g: float, b: float) -> None: ...\n    @overload\n    def tracer(self, n: None = None) -> int: ...\n    @overload\n    def tracer(self, n: int, delay: int | None = None) -> None: ...\n    @overload\n    def delay(self, delay: None = None) -> int: ...\n    @overload\n    def delay(self, delay: int) -> None: ...\n    def update(self) -> None: ...\n    def window_width(self) -> int: ...\n    def window_height(self) -> int: ...\n    def getcanvas(self) -> Canvas: ...\n    def getshapes(self) -> list[str]: ...\n    def onclick(self, fun: Callable[[float, float], object], btn: int = 1, add: Any | None = None) -> None: ...\n    def onkey(self, fun: Callable[[], object], key: str) -> None: ...\n    def listen(self, xdummy: float | None = None, ydummy: float | None = None) -> None: ...\n    def ontimer(self, fun: Callable[[], object], t: int = 0) -> None: ...\n    @overload\n    def bgpic(self, picname: None = None) -> str: ...\n    @overload\n    def bgpic(self, picname: str) -> None: ...\n    @overload\n    def screensize(self, canvwidth: None = None, canvheight: None = None, bg: None = None) -> tuple[int, int]: ...\n    # Looks like if self.cv is not a ScrolledCanvas, this could return a tuple as well\n    @overload\n    def screensize(self, canvwidth: int, canvheight: int, bg: _Color | None = None) -> None: ...\n    onscreenclick = onclick\n    resetscreen = reset\n    clearscreen = clear\n    addshape = register_shape\n    def onkeypress(self, fun: Callable[[], object], key: str | None = None) -> None: ...\n    onkeyrelease = onkey\n\nclass TNavigator:\n    START_ORIENTATION: dict[str, Vec2D]\n    DEFAULT_MODE: str\n    DEFAULT_ANGLEOFFSET: int\n    DEFAULT_ANGLEORIENT: int\n    def __init__(self, mode: str = \"standard\") -> None: ...\n    def reset(self) -> None: ...\n    def degrees(self, fullcircle: float = 360.0) -> None: ...\n    def radians(self) -> None: ...\n    def forward(self, distance: float) -> None: ...\n    def back(self, distance: float) -> None: ...\n    def right(self, angle: float) -> None: ...\n    def left(self, angle: float) -> None: ...\n    def pos(self) -> Vec2D: ...\n    def xcor(self) -> float: ...\n    def ycor(self) -> float: ...\n    @overload\n    def goto(self, x: tuple[float, float], y: None = None) -> None: ...\n    @overload\n    def goto(self, x: float, y: float) -> None: ...\n    def home(self) -> None: ...\n    def setx(self, x: float) -> None: ...\n    def sety(self, y: float) -> None: ...\n    @overload\n    def distance(self, x: TNavigator | tuple[float, float], y: None = None) -> float: ...\n    @overload\n    def distance(self, x: float, y: float) -> float: ...\n    @overload\n    def towards(self, x: TNavigator | tuple[float, float], y: None = None) -> float: ...\n    @overload\n    def towards(self, x: float, y: float) -> float: ...\n    def heading(self) -> float: ...\n    def setheading(self, to_angle: float) -> None: ...\n    def circle(self, radius: float, extent: float | None = None, steps: int | None = None) -> None: ...\n    fd = forward\n    bk = back\n    backward = back\n    rt = right\n    lt = left\n    position = pos\n    setpos = goto\n    setposition = goto\n    seth = setheading\n\nclass TPen:\n    def __init__(self, resizemode: str = \"noresize\") -> None: ...\n    @overload\n    def resizemode(self, rmode: None = None) -> str: ...\n    @overload\n    def resizemode(self, rmode: str) -> None: ...\n    @overload\n    def pensize(self, width: None = None) -> int: ...\n    @overload\n    def pensize(self, width: int) -> None: ...\n    def penup(self) -> None: ...\n    def pendown(self) -> None: ...\n    def isdown(self) -> bool: ...\n    @overload\n    def speed(self, speed: None = None) -> int: ...\n    @overload\n    def speed(self, speed: _Speed) -> None: ...\n    @overload\n    def pencolor(self) -> _AnyColor: ...\n    @overload\n    def pencolor(self, color: _Color) -> None: ...\n    @overload\n    def pencolor(self, r: float, g: float, b: float) -> None: ...\n    @overload\n    def fillcolor(self) -> _AnyColor: ...\n    @overload\n    def fillcolor(self, color: _Color) -> None: ...\n    @overload\n    def fillcolor(self, r: float, g: float, b: float) -> None: ...\n    @overload\n    def color(self) -> tuple[_AnyColor, _AnyColor]: ...\n    @overload\n    def color(self, color: _Color) -> None: ...\n    @overload\n    def color(self, r: float, g: float, b: float) -> None: ...\n    @overload\n    def color(self, color1: _Color, color2: _Color) -> None: ...\n    def showturtle(self) -> None: ...\n    def hideturtle(self) -> None: ...\n    def isvisible(self) -> bool: ...\n    # Note: signatures 1 and 2 overlap unsafely when no arguments are provided\n    @overload\n    def pen(self) -> _PenState: ...  # type: ignore[misc]\n    @overload\n    def pen(\n        self,\n        pen: _PenState | None = None,\n        *,\n        shown: bool = ...,\n        pendown: bool = ...,\n        pencolor: _Color = ...,\n        fillcolor: _Color = ...,\n        pensize: int = ...,\n        speed: int = ...,\n        resizemode: str = ...,\n        stretchfactor: tuple[float, float] = ...,\n        outline: int = ...,\n        tilt: float = ...,\n    ) -> None: ...\n    width = pensize\n    up = penup\n    pu = penup\n    pd = pendown\n    down = pendown\n    st = showturtle\n    ht = hideturtle\n\nclass RawTurtle(TPen, TNavigator):\n    screen: TurtleScreen\n    screens: ClassVar[list[TurtleScreen]]\n    def __init__(\n        self,\n        canvas: Canvas | TurtleScreen | None = None,\n        shape: str = \"classic\",\n        undobuffersize: int = 1000,\n        visible: bool = True,\n    ) -> None: ...\n    def reset(self) -> None: ...\n    def setundobuffer(self, size: int | None) -> None: ...\n    def undobufferentries(self) -> int: ...\n    def clear(self) -> None: ...\n    def clone(self) -> Self: ...\n    @overload\n    def shape(self, name: None = None) -> str: ...\n    @overload\n    def shape(self, name: str) -> None: ...\n    # Unsafely overlaps when no arguments are provided\n    @overload\n    def shapesize(self) -> tuple[float, float, float]: ...  # type: ignore[misc]\n    @overload\n    def shapesize(\n        self, stretch_wid: float | None = None, stretch_len: float | None = None, outline: float | None = None\n    ) -> None: ...\n    @overload\n    def shearfactor(self, shear: None = None) -> float: ...\n    @overload\n    def shearfactor(self, shear: float) -> None: ...\n    # Unsafely overlaps when no arguments are provided\n    @overload\n    def shapetransform(self) -> tuple[float, float, float, float]: ...  # type: ignore[misc]\n    @overload\n    def shapetransform(\n        self, t11: float | None = None, t12: float | None = None, t21: float | None = None, t22: float | None = None\n    ) -> None: ...\n    def get_shapepoly(self) -> _PolygonCoords | None: ...\n    def settiltangle(self, angle: float) -> None: ...\n    @overload\n    def tiltangle(self, angle: None = None) -> float: ...\n    @overload\n    def tiltangle(self, angle: float) -> None: ...\n    def tilt(self, angle: float) -> None: ...\n    # Can return either 'int' or Tuple[int, ...] based on if the stamp is\n    # a compound stamp or not. So, as per the \"no Union return\" policy,\n    # we return Any.\n    def stamp(self) -> Any: ...\n    def clearstamp(self, stampid: int | tuple[int, ...]) -> None: ...\n    def clearstamps(self, n: int | None = None) -> None: ...\n    def filling(self) -> bool: ...\n    def begin_fill(self) -> None: ...\n    def end_fill(self) -> None: ...\n    def dot(self, size: int | None = None, *color: _Color) -> None: ...\n    def write(\n        self, arg: object, move: bool = False, align: str = \"left\", font: tuple[str, int, str] = (\"Arial\", 8, \"normal\")\n    ) -> None: ...\n    def begin_poly(self) -> None: ...\n    def end_poly(self) -> None: ...\n    def get_poly(self) -> _PolygonCoords | None: ...\n    def getscreen(self) -> TurtleScreen: ...\n    def getturtle(self) -> Self: ...\n    getpen = getturtle\n    def onclick(self, fun: Callable[[float, float], object], btn: int = 1, add: bool | None = None) -> None: ...\n    def onrelease(self, fun: Callable[[float, float], object], btn: int = 1, add: bool | None = None) -> None: ...\n    def ondrag(self, fun: Callable[[float, float], object], btn: int = 1, add: bool | None = None) -> None: ...\n    def undo(self) -> None: ...\n    turtlesize = shapesize\n\nclass _Screen(TurtleScreen):\n    def __init__(self) -> None: ...\n    # Note int and float are interpreted differently, hence the Union instead of just float\n    def setup(\n        self,\n        width: int | float = 0.5,  # noqa: Y041\n        height: int | float = 0.75,  # noqa: Y041\n        startx: int | None = None,\n        starty: int | None = None,\n    ) -> None: ...\n    def title(self, titlestring: str) -> None: ...\n    def bye(self) -> None: ...\n    def exitonclick(self) -> None: ...\n\nclass Turtle(RawTurtle):\n    def __init__(self, shape: str = \"classic\", undobuffersize: int = 1000, visible: bool = True) -> None: ...\n\nRawPen = RawTurtle\nPen = Turtle\n\ndef write_docstringdict(filename: str = \"turtle_docstringdict\") -> None: ...\n\n# Note: it's somewhat unfortunate that we have to copy the function signatures.\n# It would be nice if we could partially reduce the redundancy by doing something\n# like the following:\n#\n#     _screen: Screen\n#     clear = _screen.clear\n#\n# However, it seems pytype does not support this type of syntax in pyi files.\n\n# Functions copied from TurtleScreenBase:\n\n# Note: mainloop() was always present in the global scope, but was added to\n# TurtleScreenBase in Python 3.0\ndef mainloop() -> None: ...\ndef textinput(title: str, prompt: str) -> str | None: ...\ndef numinput(\n    title: str, prompt: str, default: float | None = None, minval: float | None = None, maxval: float | None = None\n) -> float | None: ...\n\n# Functions copied from TurtleScreen:\n\ndef clear() -> None: ...\n@overload\ndef mode(mode: None = None) -> str: ...\n@overload\ndef mode(mode: str) -> None: ...\ndef setworldcoordinates(llx: float, lly: float, urx: float, ury: float) -> None: ...\ndef register_shape(name: str, shape: _PolygonCoords | Shape | None = None) -> None: ...\n@overload\ndef colormode(cmode: None = None) -> float: ...\n@overload\ndef colormode(cmode: float) -> None: ...\ndef reset() -> None: ...\ndef turtles() -> list[Turtle]: ...\n@overload\ndef bgcolor() -> _AnyColor: ...\n@overload\ndef bgcolor(color: _Color) -> None: ...\n@overload\ndef bgcolor(r: float, g: float, b: float) -> None: ...\n@overload\ndef tracer(n: None = None) -> int: ...\n@overload\ndef tracer(n: int, delay: int | None = None) -> None: ...\n@overload\ndef delay(delay: None = None) -> int: ...\n@overload\ndef delay(delay: int) -> None: ...\ndef update() -> None: ...\ndef window_width() -> int: ...\ndef window_height() -> int: ...\ndef getcanvas() -> Canvas: ...\ndef getshapes() -> list[str]: ...\ndef onclick(fun: Callable[[float, float], object], btn: int = 1, add: Any | None = None) -> None: ...\ndef onkey(fun: Callable[[], object], key: str) -> None: ...\ndef listen(xdummy: float | None = None, ydummy: float | None = None) -> None: ...\ndef ontimer(fun: Callable[[], object], t: int = 0) -> None: ...\n@overload\ndef bgpic(picname: None = None) -> str: ...\n@overload\ndef bgpic(picname: str) -> None: ...\n@overload\ndef screensize(canvwidth: None = None, canvheight: None = None, bg: None = None) -> tuple[int, int]: ...\n@overload\ndef screensize(canvwidth: int, canvheight: int, bg: _Color | None = None) -> None: ...\n\nonscreenclick = onclick\nresetscreen = reset\nclearscreen = clear\naddshape = register_shape\n\ndef onkeypress(fun: Callable[[], object], key: str | None = None) -> None: ...\n\nonkeyrelease = onkey\n\n# Functions copied from _Screen:\n\ndef setup(width: float = 0.5, height: float = 0.75, startx: int | None = None, starty: int | None = None) -> None: ...\ndef title(titlestring: str) -> None: ...\ndef bye() -> None: ...\ndef exitonclick() -> None: ...\ndef Screen() -> _Screen: ...\n\n# Functions copied from TNavigator:\n\ndef degrees(fullcircle: float = 360.0) -> None: ...\ndef radians() -> None: ...\ndef forward(distance: float) -> None: ...\ndef back(distance: float) -> None: ...\ndef right(angle: float) -> None: ...\ndef left(angle: float) -> None: ...\ndef pos() -> Vec2D: ...\ndef xcor() -> float: ...\ndef ycor() -> float: ...\n@overload\ndef goto(x: tuple[float, float], y: None = None) -> None: ...\n@overload\ndef goto(x: float, y: float) -> None: ...\ndef home() -> None: ...\ndef setx(x: float) -> None: ...\ndef sety(y: float) -> None: ...\n@overload\ndef distance(x: TNavigator | tuple[float, float], y: None = None) -> float: ...\n@overload\ndef distance(x: float, y: float) -> float: ...\n@overload\ndef towards(x: TNavigator | tuple[float, float], y: None = None) -> float: ...\n@overload\ndef towards(x: float, y: float) -> float: ...\ndef heading() -> float: ...\ndef setheading(to_angle: float) -> None: ...\ndef circle(radius: float, extent: float | None = None, steps: int | None = None) -> None: ...\n\nfd = forward\nbk = back\nbackward = back\nrt = right\nlt = left\nposition = pos\nsetpos = goto\nsetposition = goto\nseth = setheading\n\n# Functions copied from TPen:\n@overload\ndef resizemode(rmode: None = None) -> str: ...\n@overload\ndef resizemode(rmode: str) -> None: ...\n@overload\ndef pensize(width: None = None) -> int: ...\n@overload\ndef pensize(width: int) -> None: ...\ndef penup() -> None: ...\ndef pendown() -> None: ...\ndef isdown() -> bool: ...\n@overload\ndef speed(speed: None = None) -> int: ...\n@overload\ndef speed(speed: _Speed) -> None: ...\n@overload\ndef pencolor() -> _AnyColor: ...\n@overload\ndef pencolor(color: _Color) -> None: ...\n@overload\ndef pencolor(r: float, g: float, b: float) -> None: ...\n@overload\ndef fillcolor() -> _AnyColor: ...\n@overload\ndef fillcolor(color: _Color) -> None: ...\n@overload\ndef fillcolor(r: float, g: float, b: float) -> None: ...\n@overload\ndef color() -> tuple[_AnyColor, _AnyColor]: ...\n@overload\ndef color(color: _Color) -> None: ...\n@overload\ndef color(r: float, g: float, b: float) -> None: ...\n@overload\ndef color(color1: _Color, color2: _Color) -> None: ...\ndef showturtle() -> None: ...\ndef hideturtle() -> None: ...\ndef isvisible() -> bool: ...\n\n# Note: signatures 1 and 2 overlap unsafely when no arguments are provided\n@overload\ndef pen() -> _PenState: ...  # type: ignore[misc]\n@overload\ndef pen(\n    pen: _PenState | None = None,\n    *,\n    shown: bool = ...,\n    pendown: bool = ...,\n    pencolor: _Color = ...,\n    fillcolor: _Color = ...,\n    pensize: int = ...,\n    speed: int = ...,\n    resizemode: str = ...,\n    stretchfactor: tuple[float, float] = ...,\n    outline: int = ...,\n    tilt: float = ...,\n) -> None: ...\n\nwidth = pensize\nup = penup\npu = penup\npd = pendown\ndown = pendown\nst = showturtle\nht = hideturtle\n\n# Functions copied from RawTurtle:\n\ndef setundobuffer(size: int | None) -> None: ...\ndef undobufferentries() -> int: ...\n@overload\ndef shape(name: None = None) -> str: ...\n@overload\ndef shape(name: str) -> None: ...\n\n# Unsafely overlaps when no arguments are provided\n@overload\ndef shapesize() -> tuple[float, float, float]: ...  # type: ignore[misc]\n@overload\ndef shapesize(stretch_wid: float | None = None, stretch_len: float | None = None, outline: float | None = None) -> None: ...\n@overload\ndef shearfactor(shear: None = None) -> float: ...\n@overload\ndef shearfactor(shear: float) -> None: ...\n\n# Unsafely overlaps when no arguments are provided\n@overload\ndef shapetransform() -> tuple[float, float, float, float]: ...  # type: ignore[misc]\n@overload\ndef shapetransform(\n    t11: float | None = None, t12: float | None = None, t21: float | None = None, t22: float | None = None\n) -> None: ...\ndef get_shapepoly() -> _PolygonCoords | None: ...\ndef settiltangle(angle: float) -> None: ...\n@overload\ndef tiltangle(angle: None = None) -> float: ...\n@overload\ndef tiltangle(angle: float) -> None: ...\ndef tilt(angle: float) -> None: ...\n\n# Can return either 'int' or Tuple[int, ...] based on if the stamp is\n# a compound stamp or not. So, as per the \"no Union return\" policy,\n# we return Any.\ndef stamp() -> Any: ...\ndef clearstamp(stampid: int | tuple[int, ...]) -> None: ...\ndef clearstamps(n: int | None = None) -> None: ...\ndef filling() -> bool: ...\ndef begin_fill() -> None: ...\ndef end_fill() -> None: ...\ndef dot(size: int | None = None, *color: _Color) -> None: ...\ndef write(arg: object, move: bool = False, align: str = \"left\", font: tuple[str, int, str] = (\"Arial\", 8, \"normal\")) -> None: ...\ndef begin_poly() -> None: ...\ndef end_poly() -> None: ...\ndef get_poly() -> _PolygonCoords | None: ...\ndef getscreen() -> TurtleScreen: ...\ndef getturtle() -> Turtle: ...\n\ngetpen = getturtle\n\ndef onrelease(fun: Callable[[float, float], object], btn: int = 1, add: Any | None = None) -> None: ...\ndef ondrag(fun: Callable[[float, float], object], btn: int = 1, add: Any | None = None) -> None: ...\ndef undo() -> None: ...\n\nturtlesize = shapesize\n\n# Functions copied from RawTurtle with a few tweaks:\n\ndef clone() -> Turtle: ...\n\n# Extra functions present only in the global scope:\n\ndone = mainloop\n",
  "/typeshed/stdlib/types.pyi": "import sys\nfrom _typeshed import SupportsKeysAndGetItem\nfrom collections.abc import (\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Generator,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    MutableSequence,\n    ValuesView,\n)\nfrom importlib.machinery import ModuleSpec\n\n# pytype crashes if types.MappingProxyType inherits from collections.abc.Mapping instead of typing.Mapping\nfrom typing import Any, ClassVar, Generic, Mapping, Protocol, TypeVar, overload  # noqa: Y022\nfrom typing_extensions import Literal, ParamSpec, final\n\n__all__ = [\n    \"FunctionType\",\n    \"LambdaType\",\n    \"CodeType\",\n    \"MappingProxyType\",\n    \"SimpleNamespace\",\n    \"GeneratorType\",\n    \"CoroutineType\",\n    \"AsyncGeneratorType\",\n    \"MethodType\",\n    \"BuiltinFunctionType\",\n    \"ModuleType\",\n    \"TracebackType\",\n    \"FrameType\",\n    \"GetSetDescriptorType\",\n    \"MemberDescriptorType\",\n    \"new_class\",\n    \"prepare_class\",\n    \"DynamicClassAttribute\",\n    \"coroutine\",\n    \"BuiltinMethodType\",\n    \"ClassMethodDescriptorType\",\n    \"MethodDescriptorType\",\n    \"MethodWrapperType\",\n    \"WrapperDescriptorType\",\n    \"resolve_bases\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"CellType\"]\n\nif sys.version_info >= (3, 9):\n    __all__ += [\"GenericAlias\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"EllipsisType\", \"NoneType\", \"NotImplementedType\", \"UnionType\"]\n\n# Note, all classes \"defined\" here require special handling.\n\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    if sys.version_info >= (3, 8):\n        def __init__(self, __contents: object = ...) -> None: ...\n\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    cell_contents: Any\n\n# Make sure this class definition stays roughly in line with `builtins.function`\n@final\nclass FunctionType:\n    @property\n    def __closure__(self) -> tuple[_Cell, ...] | None: ...\n    __code__: CodeType\n    __defaults__: tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    @property\n    def __globals__(self) -> dict[str, Any]: ...\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    if sys.version_info >= (3, 10):\n        @property\n        def __builtins__(self) -> dict[str, Any]: ...\n\n    __module__: str\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: tuple[object, ...] | None = ...,\n        closure: tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    @overload\n    def __get__(self, __instance: None, __owner: type) -> FunctionType: ...\n    @overload\n    def __get__(self, __instance: object, __owner: type | None = None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    @property\n    def co_argcount(self) -> int: ...\n    if sys.version_info >= (3, 8):\n        @property\n        def co_posonlyargcount(self) -> int: ...\n\n    @property\n    def co_kwonlyargcount(self) -> int: ...\n    @property\n    def co_nlocals(self) -> int: ...\n    @property\n    def co_stacksize(self) -> int: ...\n    @property\n    def co_flags(self) -> int: ...\n    @property\n    def co_code(self) -> bytes: ...\n    @property\n    def co_consts(self) -> tuple[Any, ...]: ...\n    @property\n    def co_names(self) -> tuple[str, ...]: ...\n    @property\n    def co_varnames(self) -> tuple[str, ...]: ...\n    @property\n    def co_filename(self) -> str: ...\n    @property\n    def co_name(self) -> str: ...\n    @property\n    def co_firstlineno(self) -> int: ...\n    @property\n    def co_lnotab(self) -> bytes: ...\n    @property\n    def co_freevars(self) -> tuple[str, ...]: ...\n    @property\n    def co_cellvars(self) -> tuple[str, ...]: ...\n    if sys.version_info >= (3, 10):\n        @property\n        def co_linetable(self) -> bytes: ...\n        def co_lines(self) -> Iterator[tuple[int, int, int | None]]: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def co_exceptiontable(self) -> bytes: ...\n        @property\n        def co_qualname(self) -> str: ...\n        def co_positions(self) -> Iterable[tuple[int | None, int | None, int | None, int | None]]: ...\n\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            __argcount: int,\n            __posonlyargcount: int,\n            __kwonlyargcount: int,\n            __nlocals: int,\n            __stacksize: int,\n            __flags: int,\n            __codestring: bytes,\n            __constants: tuple[object, ...],\n            __names: tuple[str, ...],\n            __varnames: tuple[str, ...],\n            __filename: str,\n            __name: str,\n            __qualname: str,\n            __firstlineno: int,\n            __linetable: bytes,\n            __exceptiontable: bytes,\n            __freevars: tuple[str, ...] = ...,\n            __cellvars: tuple[str, ...] = ...,\n        ) -> None: ...\n    elif sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            __argcount: int,\n            __posonlyargcount: int,\n            __kwonlyargcount: int,\n            __nlocals: int,\n            __stacksize: int,\n            __flags: int,\n            __codestring: bytes,\n            __constants: tuple[object, ...],\n            __names: tuple[str, ...],\n            __varnames: tuple[str, ...],\n            __filename: str,\n            __name: str,\n            __firstlineno: int,\n            __linetable: bytes,\n            __freevars: tuple[str, ...] = ...,\n            __cellvars: tuple[str, ...] = ...,\n        ) -> None: ...\n    elif sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            __argcount: int,\n            __posonlyargcount: int,\n            __kwonlyargcount: int,\n            __nlocals: int,\n            __stacksize: int,\n            __flags: int,\n            __codestring: bytes,\n            __constants: tuple[object, ...],\n            __names: tuple[str, ...],\n            __varnames: tuple[str, ...],\n            __filename: str,\n            __name: str,\n            __firstlineno: int,\n            __lnotab: bytes,\n            __freevars: tuple[str, ...] = ...,\n            __cellvars: tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            __argcount: int,\n            __kwonlyargcount: int,\n            __nlocals: int,\n            __stacksize: int,\n            __flags: int,\n            __codestring: bytes,\n            __constants: tuple[object, ...],\n            __names: tuple[str, ...],\n            __varnames: tuple[str, ...],\n            __filename: str,\n            __name: str,\n            __firstlineno: int,\n            __lnotab: bytes,\n            __freevars: tuple[str, ...] = ...,\n            __cellvars: tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 11):\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_qualname: str = ...,\n            co_linetable: bytes = ...,\n            co_exceptiontable: bytes = ...,\n        ) -> CodeType: ...\n    elif sys.version_info >= (3, 10):\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_linetable: bytes = ...,\n        ) -> CodeType: ...\n    elif sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __init__(self, mapping: SupportsKeysAndGetItem[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, __key: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, __name: str) -> Any: ...\n    def __setattr__(self, __name: str, __value: Any) -> None: ...\n    def __delattr__(self, __name: str) -> None: ...\n\nclass _LoaderProtocol(Protocol):\n    def load_module(self, fullname: str) -> ModuleType: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str | None\n    @property\n    def __dict__(self) -> dict[str, Any]: ...  # type: ignore[override]\n    __loader__: _LoaderProtocol | None\n    __package__: str | None\n    __path__: MutableSequence[str]\n    __spec__: ModuleSpec | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n    # __getattr__ doesn't exist at runtime,\n    # but having it here in typeshed makes dynamic imports\n    # using `builtins.__import__` or `importlib.import_module` less painful\n    def __getattr__(self, name: str) -> Any: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    @property\n    def gi_yieldfrom(self) -> GeneratorType[_T_co, _T_contra, Any] | None: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def gi_suspended(self) -> bool: ...\n    __name__: str\n    __qualname__: str\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n    @overload\n    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    @property\n    def ag_await(self) -> Awaitable[Any] | None: ...\n    __name__: str\n    __qualname__: str\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Coroutine[Any, Any, _T_co]: ...\n    def asend(self, __val: _T_contra) -> Coroutine[Any, Any, _T_co]: ...\n    @overload\n    async def athrow(\n        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n    @overload\n    async def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _T_co: ...\n    def aclose(self) -> Coroutine[Any, Any, None]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\n@final\nclass CoroutineType(Coroutine[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_origin(self) -> tuple[tuple[str, int, str], ...] | None: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def cr_suspended(self) -> bool: ...\n\n    def close(self) -> None: ...\n    def __await__(self) -> Generator[Any, None, _V_co]: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: type[BaseException], __val: BaseException | object = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n    @overload\n    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = ...) -> _T_co: ...\n\nclass _StaticFunctionType:\n    # Fictional type to correct the type of MethodType.__func__.\n    # FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    # converts MethodType.__func__ back to MethodType (the return type of\n    # FunctionType.__get__). But this is actually a special case; MethodType is\n    # implemented in C and its attribute access doesn't go through\n    # __getattribute__.\n    # By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    # similar to wrapping a function in staticmethod() at runtime to prevent it\n    # being bound as a method.\n    def __get__(self, obj: object, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    @property\n    def __closure__(self) -> tuple[_Cell, ...] | None: ...  # inherited from the added function\n    @property\n    def __defaults__(self) -> tuple[Any, ...] | None: ...  # inherited from the added function\n    @property\n    def __func__(self) -> _StaticFunctionType: ...\n    @property\n    def __self__(self) -> object: ...\n    @property\n    def __name__(self) -> str: ...  # inherited from the added function\n    @property\n    def __qualname__(self) -> str: ...  # inherited from the added function\n    def __init__(self, __func: Callable[..., Any], __obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    @property\n    def __self__(self) -> object | ModuleType: ...\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\n@final\nclass WrapperDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n\n@final\nclass MethodWrapperType:\n    @property\n    def __self__(self) -> object: ...\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __eq__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n\n@final\nclass MethodDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n\n@final\nclass ClassMethodDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n\n@final\nclass TracebackType:\n    def __init__(self, tb_next: TracebackType | None, tb_frame: FrameType, tb_lasti: int, tb_lineno: int) -> None: ...\n    tb_next: TracebackType | None\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    @property\n    def f_back(self) -> FrameType | None: ...\n    @property\n    def f_builtins(self) -> dict[str, Any]: ...\n    @property\n    def f_code(self) -> CodeType: ...\n    @property\n    def f_globals(self) -> dict[str, Any]: ...\n    @property\n    def f_lasti(self) -> int: ...\n    # see discussion in #6769: f_lineno *can* sometimes be None,\n    # but you should probably file a bug report with CPython if you encounter it being None in the wild.\n    # An `int | None` annotation here causes too many false-positive errors.\n    @property\n    def f_lineno(self) -> int | Any: ...\n    @property\n    def f_locals(self) -> dict[str, Any]: ...\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    f_trace_lines: bool\n    f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, __instance: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __get__(self, __instance: Any, __owner: type | None = None) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, __instance: Any) -> None: ...\n\ndef new_class(\n    name: str,\n    bases: Iterable[object] = (),\n    kwds: dict[str, Any] | None = None,\n    exec_body: Callable[[dict[str, Any]], object] | None = None,\n) -> type: ...\ndef resolve_bases(bases: Iterable[object]) -> tuple[Any, ...]: ...\ndef prepare_class(\n    name: str, bases: tuple[type, ...] = (), kwds: dict[str, Any] | None = None\n) -> tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\n_Fn = TypeVar(\"_Fn\", bound=Callable[..., object])\n_R = TypeVar(\"_R\")\n_P = ParamSpec(\"_P\")\n\n# it's not really an Awaitable, but can be used in an await expression. Real type: Generator & Awaitable\n# The type: ignore is due to overlapping overloads, not the use of ParamSpec\n@overload\ndef coroutine(func: Callable[_P, Generator[Any, Any, _R]]) -> Callable[_P, Awaitable[_R]]: ...  # type: ignore[misc]\n@overload\ndef coroutine(func: _Fn) -> _Fn: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        @property\n        def __origin__(self) -> type: ...\n        @property\n        def __args__(self) -> tuple[Any, ...]: ...\n        @property\n        def __parameters__(self) -> tuple[Any, ...]: ...\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getitem__(self, __typeargs: Any) -> GenericAlias: ...\n        if sys.version_info >= (3, 11):\n            @property\n            def __unpacked__(self) -> bool: ...\n            @property\n            def __typing_unpacked_tuple_args__(self) -> tuple[Any, ...] | None: ...\n\n        # GenericAlias delegates attr access to `__origin__`\n        def __getattr__(self, name: str) -> Any: ...\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa: F821 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType\n    @final\n    class UnionType:\n        @property\n        def __args__(self) -> tuple[Any, ...]: ...\n        def __or__(self, __value: Any) -> UnionType: ...\n        def __ror__(self, __value: Any) -> UnionType: ...\n",
  "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nimport typing_extensions\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import IdentityFunction, Incomplete, ReadableBuffer, SupportsKeysAndGetItem\nfrom abc import ABCMeta, abstractmethod\nfrom contextlib import AbstractAsyncContextManager, AbstractContextManager\nfrom re import Match as Match, Pattern as Pattern\nfrom types import (\n    BuiltinFunctionType,\n    CodeType,\n    FrameType,\n    FunctionType,\n    MethodDescriptorType,\n    MethodType,\n    MethodWrapperType,\n    ModuleType,\n    TracebackType,\n    WrapperDescriptorType,\n)\nfrom typing_extensions import Never as _Never, ParamSpec as _ParamSpec, final as _final\n\nif sys.version_info >= (3, 10):\n    from types import UnionType\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"AbstractSet\",\n    \"Any\",\n    \"AnyStr\",\n    \"AsyncContextManager\",\n    \"AsyncGenerator\",\n    \"AsyncIterable\",\n    \"AsyncIterator\",\n    \"Awaitable\",\n    \"ByteString\",\n    \"Callable\",\n    \"ChainMap\",\n    \"ClassVar\",\n    \"Collection\",\n    \"Container\",\n    \"ContextManager\",\n    \"Coroutine\",\n    \"Counter\",\n    \"DefaultDict\",\n    \"Deque\",\n    \"Dict\",\n    \"FrozenSet\",\n    \"Generator\",\n    \"Generic\",\n    \"Hashable\",\n    \"ItemsView\",\n    \"Iterable\",\n    \"Iterator\",\n    \"KeysView\",\n    \"List\",\n    \"Mapping\",\n    \"MappingView\",\n    \"MutableMapping\",\n    \"MutableSequence\",\n    \"MutableSet\",\n    \"NamedTuple\",\n    \"NewType\",\n    \"Optional\",\n    \"Reversible\",\n    \"Sequence\",\n    \"Set\",\n    \"Sized\",\n    \"SupportsAbs\",\n    \"SupportsBytes\",\n    \"SupportsComplex\",\n    \"SupportsFloat\",\n    \"SupportsInt\",\n    \"SupportsRound\",\n    \"Text\",\n    \"Tuple\",\n    \"Type\",\n    \"TypeVar\",\n    \"Union\",\n    \"ValuesView\",\n    \"TYPE_CHECKING\",\n    \"cast\",\n    \"get_type_hints\",\n    \"no_type_check\",\n    \"no_type_check_decorator\",\n    \"overload\",\n    \"ForwardRef\",\n    \"NoReturn\",\n    \"OrderedDict\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\n        \"Final\",\n        \"Literal\",\n        \"Protocol\",\n        \"SupportsIndex\",\n        \"TypedDict\",\n        \"final\",\n        \"get_args\",\n        \"get_origin\",\n        \"runtime_checkable\",\n    ]\n\nif sys.version_info >= (3, 9):\n    __all__ += [\"Annotated\", \"BinaryIO\", \"IO\", \"Match\", \"Pattern\", \"TextIO\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"Concatenate\", \"ParamSpec\", \"ParamSpecArgs\", \"ParamSpecKwargs\", \"TypeAlias\", \"TypeGuard\", \"is_typeddict\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\n        \"LiteralString\",\n        \"Never\",\n        \"NotRequired\",\n        \"Required\",\n        \"Self\",\n        \"TypeVarTuple\",\n        \"Unpack\",\n        \"assert_never\",\n        \"assert_type\",\n        \"clear_overloads\",\n        \"dataclass_transform\",\n        \"get_overloads\",\n        \"reveal_type\",\n    ]\n\nContextManager = AbstractContextManager\nAsyncContextManager = AbstractAsyncContextManager\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nAny = object()\n\n@_final\nclass TypeVar:\n    __name__: str\n    __bound__: Any | None\n    __constraints__: tuple[Any, ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self, name: str, *constraints: Any, bound: Any | None = None, covariant: bool = False, contravariant: bool = False\n    ) -> None: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, right: Any) -> _SpecialForm: ...\n        def __ror__(self, left: Any) -> _SpecialForm: ...\n    if sys.version_info >= (3, 11):\n        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...\n\n# Used for an undocumented mypy feature. Does not exist at runtime.\n_promote = object()\n\n# N.B. Keep this definition in sync with typing_extensions._SpecialForm\n@_final\nclass _SpecialForm:\n    def __getitem__(self, parameters: Any) -> object: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_P = _ParamSpec(\"_P\")\n_T = TypeVar(\"_T\")\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm\nGeneric: _SpecialForm\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm\nCallable: _SpecialForm\nType: _SpecialForm\nNoReturn: _SpecialForm\nClassVar: _SpecialForm\n\nOptional: _SpecialForm\nTuple: _SpecialForm\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm\n    def final(f: _T) -> _T: ...\n    Literal: _SpecialForm\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info >= (3, 11):\n    Self: _SpecialForm\n    Never: _SpecialForm\n    Unpack: _SpecialForm\n    Required: _SpecialForm\n    NotRequired: _SpecialForm\n    LiteralString: _SpecialForm\n\n    class TypeVarTuple:\n        __name__: str\n        def __init__(self, name: str) -> None: ...\n        def __iter__(self) -> Any: ...\n        def __typing_subst__(self, arg: Never) -> Never: ...\n        def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    class ParamSpec:\n        __name__: str\n        __bound__: Any | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Any | None = None, contravariant: bool = False, covariant: bool = False\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n        if sys.version_info >= (3, 11):\n            def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...\n            def __typing_prepare_subst__(self, alias: Incomplete, args: Incomplete) -> Incomplete: ...\n\n        def __or__(self, right: Any) -> _SpecialForm: ...\n        def __ror__(self, left: Any) -> _SpecialForm: ...\n    Concatenate: _SpecialForm\n    TypeAlias: _SpecialForm\n    TypeGuard: _SpecialForm\n\n    class NewType:\n        def __init__(self, name: str, tp: Any) -> None: ...\n        def __call__(self, x: _T) -> _T: ...\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n        __supertype__: type\n\nelse:\n    def NewType(name: str, tp: Any) -> Any: ...\n\n# These type variables are used by the container types.\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: Callable[_P, _T]) -> Callable[_P, _T]: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nOrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)  # noqa: Y001\n\n# Technically in 3.7 this inherited from GenericMeta. But let's not reflect that, since\n# type checkers tend to assume that Protocols all have the ABCMeta metaclass.\nclass _ProtocolMeta(ABCMeta): ...\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, __ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Generator[Any, Any, Any] | None: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Any | None: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484 but mypy needs it to exist.\n# The parameters correspond to Generator, but the 4th is the original type.\n@type_check_only\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: BaseException | object = None, __tb: TracebackType | None = None\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = None, __tb: TracebackType | None = None) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    # This is generic more on vibes than anything else\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\nclass Sequence(Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = 0, stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, value: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, index: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, index: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = -1) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, values: Iterable[_T]) -> typing_extensions.Self: ...\n\nclass AbstractSet(Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    def _hash(self) -> int: ...\n    # Mixin methods\n    def __le__(self, other: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, other: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, other: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, other: AbstractSet[Any]) -> bool: ...\n    def __and__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...\n    def __sub__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, it: AbstractSet[_T]) -> typing_extensions.Self: ...  # type: ignore[override,misc]\n    def __iand__(self, it: AbstractSet[Any]) -> typing_extensions.Self: ...\n    def __ixor__(self, it: AbstractSet[_T]) -> typing_extensions.Self: ...  # type: ignore[override,misc]\n    def __isub__(self, it: AbstractSet[Any]) -> typing_extensions.Self: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __contains__(self, item: object) -> bool: ...\n    def __iter__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n\n    def __or__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __ror__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __sub__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __xor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __rxor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, other: Iterable[Any]) -> set[_KT_co]: ...\n    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n\n    def __or__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __ror__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __sub__(self, other: Iterable[Any]) -> set[_KT_co]: ...\n    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __xor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __rxor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n\nclass ValuesView(MappingView, Collection[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, value: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\nclass Mapping(Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https://github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, __key: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, __key: _KT) -> _VT_co | None: ...\n    @overload\n    def get(self, __key: _KT, default: _VT_co | _T) -> _VT_co | _T: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, __key: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, __key: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, __key: _KT) -> _VT: ...\n    @overload\n    def pop(self, __key: _KT, default: _VT | _T) -> _VT | _T: ...\n    def popitem(self) -> tuple[_KT, _VT]: ...\n    # This overload should be allowed only if the value type is compatible with None.\n    #\n    # Keep the following methods in line with MutableMapping.setdefault, modulo positional-only differences:\n    # -- collections.OrderedDict.setdefault\n    # -- collections.ChainMap.setdefault\n    # -- weakref.WeakKeyDictionary.setdefault\n    @overload\n    def setdefault(self: MutableMapping[_KT, _T | None], __key: _KT, __default: None = None) -> _T | None: ...\n    @overload\n    def setdefault(self, __key: _KT, __default: _VT) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[tuple[_KT, _VT], W] is a subclass of Iterable[tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    #\n    # Various mapping classes have __ior__ methods that should be kept roughly in line with .update():\n    # -- dict.__ior__\n    # -- os._Environ.__ior__\n    # -- collections.UserDict.__ior__\n    # -- collections.ChainMap.__ior__\n    # -- peewee.attrdict.__add__\n    # -- peewee.attrdict.__iadd__\n    # -- weakref.WeakValueDictionary.__ior__\n    # -- weakref.WeakKeyDictionary.__ior__\n    @overload\n    def update(self, __m: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING: bool\n\n# In stubs, the arguments of the IO class are marked as positional-only.\n# This differs from runtime, but better reflects the fact that in reality\n# classes deriving from IO use different names for the arguments.\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # At runtime these are all abstract properties,\n    # but making them abstract in the stub is hugely disruptive, for not much gain.\n    # See #8726\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, __n: int = -1) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, __limit: int = -1) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, __hint: int = -1) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, __offset: int, __whence: int = 0) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, __size: int | None = None) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    @overload\n    def write(self: IO[str], __s: str) -> int: ...\n    @abstractmethod\n    @overload\n    def write(self: IO[bytes], __s: ReadableBuffer) -> int: ...\n    @abstractmethod\n    @overload\n    def write(self, __s: AnyStr) -> int: ...\n    @abstractmethod\n    @overload\n    def writelines(self: IO[str], __lines: Iterable[str]) -> None: ...\n    @abstractmethod\n    @overload\n    def writelines(self: IO[bytes], __lines: Iterable[ReadableBuffer]) -> None: ...\n    @abstractmethod\n    @overload\n    def writelines(self, __lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, __type: Type[BaseException] | None, __value: BaseException | None, __traceback: TracebackType | None\n    ) -> None: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # See comment regarding the @properties in the `IO` class\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> str | None: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\n# Functions\n\n_get_type_hints_obj_allowed_types: typing_extensions.TypeAlias = (  # noqa: Y042\n    object\n    | Callable[..., Any]\n    | FunctionType\n    | BuiltinFunctionType\n    | MethodType\n    | ModuleType\n    | WrapperDescriptorType\n    | MethodWrapperType\n    | MethodDescriptorType\n)\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: dict[str, Any] | None = None,\n        localns: dict[str, Any] | None = None,\n        include_extras: bool = False,\n    ) -> dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None\n    ) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_args(tp: Any) -> tuple[Any, ...]: ...\n\n    if sys.version_info >= (3, 10):\n        @overload\n        def get_origin(tp: ParamSpecArgs | ParamSpecKwargs) -> ParamSpec: ...\n        @overload\n        def get_origin(tp: UnionType) -> type[UnionType]: ...\n    if sys.version_info >= (3, 9):\n        @overload\n        def get_origin(tp: GenericAlias) -> type: ...\n        @overload\n        def get_origin(tp: Any) -> Any | None: ...\n    else:\n        def get_origin(tp: Any) -> Any | None: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\nif sys.version_info >= (3, 11):\n    def reveal_type(__obj: _T) -> _T: ...\n    def assert_never(__arg: Never) -> Never: ...\n    def assert_type(__val: _T, __typ: Any) -> _T: ...\n    def clear_overloads() -> None: ...\n    def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...\n    def dataclass_transform(\n        *,\n        eq_default: bool = True,\n        order_default: bool = False,\n        kw_only_default: bool = False,\n        frozen_default: bool = False,  # on 3.11, runtime accepts it as part of kwargs\n        field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),\n        **kwargs: Any,\n    ) -> IdentityFunction: ...\n\n# Type constructors\n\nclass NamedTuple(tuple[Any, ...]):\n    if sys.version_info < (3, 8):\n        _field_types: collections.OrderedDict[str, type]\n    elif sys.version_info < (3, 9):\n        _field_types: dict[str, type]\n    _field_defaults: dict[str, Any]\n    _fields: tuple[str, ...]\n    _source: str\n    @overload\n    def __init__(self, typename: str, fields: Iterable[tuple[str, Any]] = ...) -> None: ...\n    @overload\n    def __init__(self, typename: str, fields: None = None, **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n\n    def _replace(self, **kwargs: Any) -> typing_extensions.Self: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\n# N.B. Keep this mostly in sync with typing_extensions._TypedDict/mypy_extensions._TypedDict\n@type_check_only\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    __total__: ClassVar[bool]\n    if sys.version_info >= (3, 9):\n        __required_keys__: ClassVar[frozenset[str]]\n        __optional_keys__: ClassVar[frozenset[str]]\n    def copy(self) -> typing_extensions.Self: ...\n    # Using Never so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: _Never, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: _Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: _Never) -> None: ...\n    def items(self) -> dict_items[str, object]: ...\n    def keys(self) -> dict_keys[str, object]: ...\n    def values(self) -> dict_values[str, object]: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...\n        def __ior__(self, __value: typing_extensions.Self) -> typing_extensions.Self: ...\n\n@_final\nclass ForwardRef:\n    __forward_arg__: str\n    __forward_code__: CodeType\n    __forward_evaluated__: bool\n    __forward_value__: Any | None\n    __forward_is_argument__: bool\n    __forward_is_class__: bool\n    __forward_module__: Any | None\n    if sys.version_info >= (3, 9):\n        # The module and is_class arguments were added in later Python 3.9 versions.\n        def __init__(self, arg: str, is_argument: bool = True, module: Any | None = None, *, is_class: bool = False) -> None: ...\n    else:\n        def __init__(self, arg: str, is_argument: bool = True) -> None: ...\n\n    if sys.version_info >= (3, 9):\n        def _evaluate(\n            self, globalns: dict[str, Any] | None, localns: dict[str, Any] | None, recursive_guard: frozenset[str]\n        ) -> Any | None: ...\n    else:\n        def _evaluate(self, globalns: dict[str, Any] | None, localns: dict[str, Any] | None) -> Any | None: ...\n\n    def __eq__(self, other: object) -> bool: ...\n    if sys.version_info >= (3, 11):\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: object) -> bool: ...\n\ndef _type_repr(obj: object) -> str: ...\n",
  "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport collections\nimport sys\nimport typing\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import IdentityFunction, Incomplete\nfrom collections.abc import Iterable\nfrom typing import (  # noqa: Y022,Y039\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any as Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Sequence,\n    Text as Text,\n    Type as Type,\n    _Alias,\n    overload as overload,\n    type_check_only,\n)\n\nif sys.version_info >= (3, 10):\n    from types import UnionType\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"Any\",\n    \"ClassVar\",\n    \"Concatenate\",\n    \"Final\",\n    \"LiteralString\",\n    \"ParamSpec\",\n    \"ParamSpecArgs\",\n    \"ParamSpecKwargs\",\n    \"Self\",\n    \"Type\",\n    \"TypeVar\",\n    \"TypeVarTuple\",\n    \"Unpack\",\n    \"Awaitable\",\n    \"AsyncIterator\",\n    \"AsyncIterable\",\n    \"Coroutine\",\n    \"AsyncGenerator\",\n    \"AsyncContextManager\",\n    \"ChainMap\",\n    \"ContextManager\",\n    \"Counter\",\n    \"Deque\",\n    \"DefaultDict\",\n    \"NamedTuple\",\n    \"OrderedDict\",\n    \"TypedDict\",\n    \"SupportsIndex\",\n    \"Annotated\",\n    \"assert_never\",\n    \"assert_type\",\n    \"dataclass_transform\",\n    \"deprecated\",\n    \"final\",\n    \"IntVar\",\n    \"is_typeddict\",\n    \"Literal\",\n    \"NewType\",\n    \"overload\",\n    \"override\",\n    \"Protocol\",\n    \"reveal_type\",\n    \"runtime\",\n    \"runtime_checkable\",\n    \"Text\",\n    \"TypeAlias\",\n    \"TypeGuard\",\n    \"TYPE_CHECKING\",\n    \"Never\",\n    \"NoReturn\",\n    \"Required\",\n    \"NotRequired\",\n    \"clear_overloads\",\n    \"get_args\",\n    \"get_origin\",\n    \"get_overloads\",\n    \"get_type_hints\",\n]\n\n_T = typing.TypeVar(\"_T\")\n_F = typing.TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = typing.TypeVar(\"_TC\", bound=Type[object])\n\n# unfortunately we have to duplicate this class definition from typing.pyi or we break pytype\nclass _SpecialForm:\n    def __getitem__(self, parameters: Any) -> object: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n\n# Do not import (and re-export) Protocol or runtime_checkable from\n# typing module because type checkers need to be able to distinguish\n# typing.Protocol and typing_extensions.Protocol so they can properly\n# warn users about potential runtime exceptions when using typing.Protocol\n# on older versions of Python.\nProtocol: _SpecialForm\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nFinal: _SpecialForm\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\n# N.B. Keep this mostly in sync with typing._TypedDict/mypy_extensions._TypedDict\n@type_check_only\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    __required_keys__: ClassVar[frozenset[str]]\n    __optional_keys__: ClassVar[frozenset[str]]\n    __total__: ClassVar[bool]\n    def copy(self) -> Self: ...\n    # Using Never so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: Never, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> dict_items[str, object]: ...\n    def keys(self) -> dict_keys[str, object]: ...\n    def values(self) -> dict_values[str, object]: ...\n    def __delitem__(self, k: Never) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, __value: Self) -> Self: ...\n        def __ior__(self, __value: Self) -> Self: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = None,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n) -> dict[str, Any]: ...\ndef get_args(tp: Any) -> tuple[Any, ...]: ...\n\nif sys.version_info >= (3, 10):\n    @overload\n    def get_origin(tp: UnionType) -> type[UnionType]: ...\n\nif sys.version_info >= (3, 9):\n    @overload\n    def get_origin(tp: GenericAlias) -> type: ...\n\n@overload\ndef get_origin(tp: ParamSpecArgs | ParamSpecKwargs) -> ParamSpec: ...\n@overload\ndef get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm\n_AnnotatedAlias: Any  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# New things in 3.10\nif sys.version_info >= (3, 10):\n    from typing import (\n        Concatenate as Concatenate,\n        ParamSpecArgs as ParamSpecArgs,\n        ParamSpecKwargs as ParamSpecKwargs,\n        TypeAlias as TypeAlias,\n        TypeGuard as TypeGuard,\n        is_typeddict as is_typeddict,\n    )\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    Concatenate: _SpecialForm\n    TypeAlias: _SpecialForm\n    TypeGuard: _SpecialForm\n    def is_typeddict(tp: object) -> bool: ...\n\n# New things in 3.11\n# NamedTuples are not new, but the ability to create generic NamedTuples is new in 3.11\nif sys.version_info >= (3, 11):\n    from typing import (\n        LiteralString as LiteralString,\n        NamedTuple as NamedTuple,\n        Never as Never,\n        NotRequired as NotRequired,\n        Required as Required,\n        Self as Self,\n        Unpack as Unpack,\n        assert_never as assert_never,\n        assert_type as assert_type,\n        clear_overloads as clear_overloads,\n        dataclass_transform as dataclass_transform,\n        get_overloads as get_overloads,\n        reveal_type as reveal_type,\n    )\nelse:\n    Self: _SpecialForm\n    Never: _SpecialForm\n    def reveal_type(__obj: _T) -> _T: ...\n    def assert_never(__arg: Never) -> Never: ...\n    def assert_type(__val: _T, __typ: Any) -> _T: ...\n    def clear_overloads() -> None: ...\n    def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...\n\n    Required: _SpecialForm\n    NotRequired: _SpecialForm\n    LiteralString: _SpecialForm\n    Unpack: _SpecialForm\n\n    def dataclass_transform(\n        *,\n        eq_default: bool = True,\n        order_default: bool = False,\n        kw_only_default: bool = False,\n        frozen_default: bool = False,\n        field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),\n        **kwargs: object,\n    ) -> IdentityFunction: ...\n\n    class NamedTuple(tuple[Any, ...]):\n        if sys.version_info < (3, 8):\n            _field_types: collections.OrderedDict[str, type]\n        elif sys.version_info < (3, 9):\n            _field_types: dict[str, type]\n        _field_defaults: dict[str, Any]\n        _fields: tuple[str, ...]\n        _source: str\n        @overload\n        def __init__(self, typename: str, fields: Iterable[tuple[str, Any]] = ...) -> None: ...\n        @overload\n        def __init__(self, typename: str, fields: None = None, **kwargs: Any) -> None: ...\n        @classmethod\n        def _make(cls, iterable: Iterable[Any]) -> Self: ...\n        if sys.version_info >= (3, 8):\n            def _asdict(self) -> dict[str, Any]: ...\n        else:\n            def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n\n        def _replace(self, **kwargs: Any) -> Self: ...\n\n# New things in 3.xx\n# The `default` parameter was added to TypeVar, ParamSpec, and TypeVarTuple (PEP 696)\n# The `infer_variance` parameter was added to TypeVar (PEP 695)\n# typing_extensions.override (PEP 698)\n@final\nclass TypeVar:\n    __name__: str\n    __bound__: Any | None\n    __constraints__: tuple[Any, ...]\n    __covariant__: bool\n    __contravariant__: bool\n    __default__: Any | None\n    def __init__(\n        self,\n        name: str,\n        *constraints: Any,\n        bound: Any | None = None,\n        covariant: bool = False,\n        contravariant: bool = False,\n        default: Any | None = None,\n        infer_variance: bool = False,\n    ) -> None: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, right: Any) -> _SpecialForm: ...\n        def __ror__(self, left: Any) -> _SpecialForm: ...\n    if sys.version_info >= (3, 11):\n        def __typing_subst__(self, arg: Incomplete) -> Incomplete: ...\n\n@final\nclass ParamSpec:\n    __name__: str\n    __bound__: type[Any] | None\n    __covariant__: bool\n    __contravariant__: bool\n    __default__: type[Any] | None\n    def __init__(\n        self,\n        name: str,\n        *,\n        bound: None | type[Any] | str = None,\n        contravariant: bool = False,\n        covariant: bool = False,\n        default: type[Any] | str | None = None,\n    ) -> None: ...\n    @property\n    def args(self) -> ParamSpecArgs: ...\n    @property\n    def kwargs(self) -> ParamSpecKwargs: ...\n\n@final\nclass TypeVarTuple:\n    __name__: str\n    __default__: Any | None\n    def __init__(self, name: str, *, default: Any | None = None) -> None: ...\n    def __iter__(self) -> Any: ...  # Unpack[Self]\n\ndef override(__arg: _F) -> _F: ...\ndef deprecated(__msg: str, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> Callable[[_T], _T]: ...\n",
  "/typeshed/stdlib/unicodedata.pyi": "import sys\nfrom _typeshed import ReadOnlyBuffer\nfrom typing import Any, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias, final\n\nucd_3_2_0: UCD\nunidata_version: str\n\nif sys.version_info < (3, 10):\n    ucnhash_CAPI: Any\n\n_T = TypeVar(\"_T\")\n\ndef bidirectional(__chr: str) -> str: ...\ndef category(__chr: str) -> str: ...\ndef combining(__chr: str) -> int: ...\n@overload\ndef decimal(__chr: str) -> int: ...\n@overload\ndef decimal(__chr: str, __default: _T) -> int | _T: ...\ndef decomposition(__chr: str) -> str: ...\n@overload\ndef digit(__chr: str) -> int: ...\n@overload\ndef digit(__chr: str, __default: _T) -> int | _T: ...\n\n_EastAsianWidth: TypeAlias = Literal[\"F\", \"H\", \"W\", \"Na\", \"A\", \"N\"]\n\ndef east_asian_width(__chr: str) -> _EastAsianWidth: ...\n\nif sys.version_info >= (3, 8):\n    def is_normalized(__form: str, __unistr: str) -> bool: ...\n\ndef lookup(__name: str | ReadOnlyBuffer) -> str: ...\ndef mirrored(__chr: str) -> int: ...\n@overload\ndef name(__chr: str) -> str: ...\n@overload\ndef name(__chr: str, __default: _T) -> str | _T: ...\ndef normalize(__form: str, __unistr: str) -> str: ...\n@overload\ndef numeric(__chr: str) -> float: ...\n@overload\ndef numeric(__chr: str, __default: _T) -> float | _T: ...\n@final\nclass UCD:\n    # The methods below are constructed from the same array in C\n    # (unicodedata_functions) and hence identical to the functions above.\n    unidata_version: str\n    def bidirectional(self, __chr: str) -> str: ...\n    def category(self, __chr: str) -> str: ...\n    def combining(self, __chr: str) -> int: ...\n    @overload\n    def decimal(self, __chr: str) -> int: ...\n    @overload\n    def decimal(self, __chr: str, __default: _T) -> int | _T: ...\n    def decomposition(self, __chr: str) -> str: ...\n    @overload\n    def digit(self, __chr: str) -> int: ...\n    @overload\n    def digit(self, __chr: str, __default: _T) -> int | _T: ...\n    def east_asian_width(self, __chr: str) -> _EastAsianWidth: ...\n    if sys.version_info >= (3, 8):\n        def is_normalized(self, __form: str, __unistr: str) -> bool: ...\n\n    def lookup(self, __name: str | ReadOnlyBuffer) -> str: ...\n    def mirrored(self, __chr: str) -> int: ...\n    @overload\n    def name(self, __chr: str) -> str: ...\n    @overload\n    def name(self, __chr: str, __default: _T) -> str | _T: ...\n    def normalize(self, __form: str, __unistr: str) -> str: ...\n    @overload\n    def numeric(self, __chr: str) -> float: ...\n    @overload\n    def numeric(self, __chr: str, __default: _T) -> float | _T: ...\n",
  "/typeshed/stdlib/uu.pyi": "from typing import BinaryIO\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"Error\", \"encode\", \"decode\"]\n\n_File: TypeAlias = str | BinaryIO\n\nclass Error(Exception): ...\n\ndef encode(\n    in_file: _File, out_file: _File, name: str | None = None, mode: int | None = None, *, backtick: bool = False\n) -> None: ...\ndef decode(in_file: _File, out_file: _File | None = None, mode: int | None = None, quiet: bool = False) -> None: ...\n",
  "/typeshed/stdlib/uuid.pyi": "import sys\nfrom _typeshed import Unused\nfrom enum import Enum\nfrom typing_extensions import TypeAlias\n\n# Because UUID has properties called int and bytes we need to rename these temporarily.\n_Int: TypeAlias = int\n_Bytes: TypeAlias = bytes\n_FieldsType: TypeAlias = tuple[int, int, int, int, int, int]\n\nclass SafeUUID(Enum):\n    safe: int\n    unsafe: int\n    unknown: None\n\nclass UUID:\n    def __init__(\n        self,\n        hex: str | None = None,\n        bytes: _Bytes | None = None,\n        bytes_le: _Bytes | None = None,\n        fields: _FieldsType | None = None,\n        int: _Int | None = None,\n        version: _Int | None = None,\n        *,\n        is_safe: SafeUUID = ...,\n    ) -> None: ...\n    @property\n    def is_safe(self) -> SafeUUID: ...\n    @property\n    def bytes(self) -> _Bytes: ...\n    @property\n    def bytes_le(self) -> _Bytes: ...\n    @property\n    def clock_seq(self) -> _Int: ...\n    @property\n    def clock_seq_hi_variant(self) -> _Int: ...\n    @property\n    def clock_seq_low(self) -> _Int: ...\n    @property\n    def fields(self) -> _FieldsType: ...\n    @property\n    def hex(self) -> str: ...\n    @property\n    def int(self) -> _Int: ...\n    @property\n    def node(self) -> _Int: ...\n    @property\n    def time(self) -> _Int: ...\n    @property\n    def time_hi_version(self) -> _Int: ...\n    @property\n    def time_low(self) -> _Int: ...\n    @property\n    def time_mid(self) -> _Int: ...\n    @property\n    def urn(self) -> str: ...\n    @property\n    def variant(self) -> str: ...\n    @property\n    def version(self) -> _Int | None: ...\n    def __int__(self) -> _Int: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: UUID) -> bool: ...\n    def __le__(self, other: UUID) -> bool: ...\n    def __gt__(self, other: UUID) -> bool: ...\n    def __ge__(self, other: UUID) -> bool: ...\n\nif sys.version_info >= (3, 9):\n    def getnode() -> int: ...\n\nelse:\n    def getnode(*, getters: Unused = None) -> int: ...  # undocumented\n\ndef uuid1(node: _Int | None = None, clock_seq: _Int | None = None) -> UUID: ...\n\nif sys.version_info >= (3, 12):\n    def uuid3(namespace: UUID, name: str | bytes) -> UUID: ...\n\nelse:\n    def uuid3(namespace: UUID, name: str) -> UUID: ...\n\ndef uuid4() -> UUID: ...\n\nif sys.version_info >= (3, 12):\n    def uuid5(namespace: UUID, name: str | bytes) -> UUID: ...\n\nelse:\n    def uuid5(namespace: UUID, name: str) -> UUID: ...\n\nNAMESPACE_DNS: UUID\nNAMESPACE_URL: UUID\nNAMESPACE_OID: UUID\nNAMESPACE_X500: UUID\nRESERVED_NCS: str\nRFC_4122: str\nRESERVED_MICROSOFT: str\nRESERVED_FUTURE: str\n",
  "/typeshed/stdlib/warnings.pyi": "import sys\nfrom _warnings import warn as warn, warn_explicit as warn_explicit\nfrom collections.abc import Sequence\nfrom types import ModuleType, TracebackType\nfrom typing import Any, Generic, TextIO, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias\n\n__all__ = [\n    \"warn\",\n    \"warn_explicit\",\n    \"showwarning\",\n    \"formatwarning\",\n    \"filterwarnings\",\n    \"simplefilter\",\n    \"resetwarnings\",\n    \"catch_warnings\",\n]\n\n_W = TypeVar(\"_W\", bound=list[WarningMessage] | None)\n_ActionKind: TypeAlias = Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\n\nfilters: Sequence[tuple[str, str | None, type[Warning], str | None, int]]  # undocumented, do not mutate\n\ndef showwarning(\n    message: Warning | str,\n    category: type[Warning],\n    filename: str,\n    lineno: int,\n    file: TextIO | None = None,\n    line: str | None = None,\n) -> None: ...\ndef formatwarning(\n    message: Warning | str, category: type[Warning], filename: str, lineno: int, line: str | None = None\n) -> str: ...\ndef filterwarnings(\n    action: _ActionKind, message: str = \"\", category: type[Warning] = ..., module: str = \"\", lineno: int = 0, append: bool = False\n) -> None: ...\ndef simplefilter(action: _ActionKind, category: type[Warning] = ..., lineno: int = 0, append: bool = False) -> None: ...\ndef resetwarnings() -> None: ...\n\nclass _OptionError(Exception): ...\n\nclass WarningMessage:\n    message: Warning | str\n    category: type[Warning]\n    filename: str\n    lineno: int\n    file: TextIO | None\n    line: str | None\n    source: Any | None\n    def __init__(\n        self,\n        message: Warning | str,\n        category: type[Warning],\n        filename: str,\n        lineno: int,\n        file: TextIO | None = None,\n        line: str | None = None,\n        source: Any | None = None,\n    ) -> None: ...\n\nclass catch_warnings(Generic[_W]):\n    if sys.version_info >= (3, 11):\n        @overload\n        def __init__(\n            self: catch_warnings[None],\n            *,\n            record: Literal[False] = False,\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage]],\n            *,\n            record: Literal[True],\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage] | None],\n            *,\n            record: bool,\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n    else:\n        @overload\n        def __init__(self: catch_warnings[None], *, record: Literal[False] = False, module: ModuleType | None = None) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage]], *, record: Literal[True], module: ModuleType | None = None\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage] | None], *, record: bool, module: ModuleType | None = None\n        ) -> None: ...\n\n    def __enter__(self) -> _W: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n",
  "/typeshed/stdlib/wave.pyi": "import sys\nfrom _typeshed import ReadableBuffer, Unused\nfrom typing import IO, Any, BinaryIO, NamedTuple, NoReturn, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    __all__ = [\"open\", \"Error\", \"Wave_read\", \"Wave_write\"]\nelse:\n    __all__ = [\"open\", \"openfp\", \"Error\", \"Wave_read\", \"Wave_write\"]\n\n_File: TypeAlias = str | IO[bytes]\n\nclass Error(Exception): ...\n\nWAVE_FORMAT_PCM: Literal[1]\n\nclass _wave_params(NamedTuple):\n    nchannels: int\n    sampwidth: int\n    framerate: int\n    nframes: int\n    comptype: str\n    compname: str\n\nclass Wave_read:\n    def __init__(self, f: _File) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def getfp(self) -> BinaryIO | None: ...\n    def rewind(self) -> None: ...\n    def close(self) -> None: ...\n    def tell(self) -> int: ...\n    def getnchannels(self) -> int: ...\n    def getnframes(self) -> int: ...\n    def getsampwidth(self) -> int: ...\n    def getframerate(self) -> int: ...\n    def getcomptype(self) -> str: ...\n    def getcompname(self) -> str: ...\n    def getparams(self) -> _wave_params: ...\n    def getmarkers(self) -> None: ...\n    def getmark(self, id: Any) -> NoReturn: ...\n    def setpos(self, pos: int) -> None: ...\n    def readframes(self, nframes: int) -> bytes: ...\n\nclass Wave_write:\n    def __init__(self, f: _File) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def setnchannels(self, nchannels: int) -> None: ...\n    def getnchannels(self) -> int: ...\n    def setsampwidth(self, sampwidth: int) -> None: ...\n    def getsampwidth(self) -> int: ...\n    def setframerate(self, framerate: float) -> None: ...\n    def getframerate(self) -> int: ...\n    def setnframes(self, nframes: int) -> None: ...\n    def getnframes(self) -> int: ...\n    def setcomptype(self, comptype: str, compname: str) -> None: ...\n    def getcomptype(self) -> str: ...\n    def getcompname(self) -> str: ...\n    def setparams(self, params: _wave_params | tuple[int, int, int, int, str, str]) -> None: ...\n    def getparams(self) -> _wave_params: ...\n    def setmark(self, id: Any, pos: Any, name: Any) -> NoReturn: ...\n    def getmark(self, id: Any) -> NoReturn: ...\n    def getmarkers(self) -> None: ...\n    def tell(self) -> int: ...\n    def writeframesraw(self, data: ReadableBuffer) -> None: ...\n    def writeframes(self, data: ReadableBuffer) -> None: ...\n    def close(self) -> None: ...\n\n@overload\ndef open(f: _File, mode: Literal[\"r\", \"rb\"]) -> Wave_read: ...\n@overload\ndef open(f: _File, mode: Literal[\"w\", \"wb\"]) -> Wave_write: ...\n@overload\ndef open(f: _File, mode: str | None = None) -> Any: ...\n\nif sys.version_info < (3, 9):\n    openfp = open\n",
  "/typeshed/stdlib/weakref.pyi": "import sys\nfrom _typeshed import SupportsKeysAndGetItem\nfrom _weakref import (\n    CallableProxyType as CallableProxyType,\n    ProxyType as ProxyType,\n    ReferenceType as ReferenceType,\n    getweakrefcount as getweakrefcount,\n    getweakrefs as getweakrefs,\n    proxy as proxy,\n    ref as ref,\n)\nfrom _weakrefset import WeakSet as WeakSet\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, MutableMapping\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import ParamSpec, Self\n\n__all__ = [\n    \"ref\",\n    \"proxy\",\n    \"getweakrefcount\",\n    \"getweakrefs\",\n    \"WeakKeyDictionary\",\n    \"ReferenceType\",\n    \"ProxyType\",\n    \"CallableProxyType\",\n    \"ProxyTypes\",\n    \"WeakValueDictionary\",\n    \"WeakSet\",\n    \"WeakMethod\",\n    \"finalize\",\n]\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_CallableT = TypeVar(\"_CallableT\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\nProxyTypes: tuple[type[Any], ...]\n\nclass WeakMethod(ref[_CallableT], Generic[_CallableT]):\n    def __new__(cls, meth: _CallableT, callback: Callable[[_CallableT], object] | None = None) -> Self: ...\n    def __call__(self) -> _CallableT | None: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __ne__(self, other: object) -> bool: ...\n\nclass WeakValueDictionary(MutableMapping[_KT, _VT]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self: WeakValueDictionary[_KT, _VT], __other: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]]) -> None: ...\n    @overload\n    def __init__(\n        self: WeakValueDictionary[str, _VT], __other: Mapping[str, _VT] | Iterable[tuple[str, _VT]] = (), **kwargs: _VT\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def copy(self) -> WeakValueDictionary[_KT, _VT]: ...\n    __copy__ = copy\n    def __deepcopy__(self, memo: Any) -> Self: ...\n    # These are incompatible with Mapping\n    def keys(self) -> Iterator[_KT]: ...  # type: ignore[override]\n    def values(self) -> Iterator[_VT]: ...  # type: ignore[override]\n    def items(self) -> Iterator[tuple[_KT, _VT]]: ...  # type: ignore[override]\n    def itervaluerefs(self) -> Iterator[KeyedRef[_KT, _VT]]: ...\n    def valuerefs(self) -> list[KeyedRef[_KT, _VT]]: ...\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...  # type: ignore[override]\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT | _T = ...) -> _VT | _T: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, other: Mapping[_T1, _T2]) -> WeakValueDictionary[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, other: Mapping[_T1, _T2]) -> WeakValueDictionary[_KT | _T1, _VT | _T2]: ...\n        # WeakValueDictionary.__ior__ should be kept roughly in line with MutableMapping.update()\n        @overload  # type: ignore[misc]\n        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n        @overload\n        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass KeyedRef(ref[_T], Generic[_KT, _T]):\n    key: _KT\n    # This __new__ method uses a non-standard name for the \"cls\" parameter\n    def __new__(type, ob: _T, callback: Callable[[_T], Any], key: _KT) -> Self: ...\n    def __init__(self, ob: _T, callback: Callable[[_T], Any], key: _KT) -> None: ...\n\nclass WeakKeyDictionary(MutableMapping[_KT, _VT]):\n    @overload\n    def __init__(self, dict: None = None) -> None: ...\n    @overload\n    def __init__(self, dict: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]]) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def copy(self) -> WeakKeyDictionary[_KT, _VT]: ...\n    __copy__ = copy\n    def __deepcopy__(self, memo: Any) -> Self: ...\n    # These are incompatible with Mapping\n    def keys(self) -> Iterator[_KT]: ...  # type: ignore[override]\n    def values(self) -> Iterator[_VT]: ...  # type: ignore[override]\n    def items(self) -> Iterator[tuple[_KT, _VT]]: ...  # type: ignore[override]\n    def keyrefs(self) -> list[ref[_KT]]: ...\n    # Keep WeakKeyDictionary.setdefault in line with MutableMapping.setdefault, modulo positional-only differences\n    @overload\n    def setdefault(self: WeakKeyDictionary[_KT, _VT | None], key: _KT, default: None = None) -> _VT: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT | _T = ...) -> _VT | _T: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, other: Mapping[_T1, _T2]) -> WeakKeyDictionary[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, other: Mapping[_T1, _T2]) -> WeakKeyDictionary[_KT | _T1, _VT | _T2]: ...\n        # WeakKeyDictionary.__ior__ should be kept roughly in line with MutableMapping.update()\n        @overload  # type: ignore[misc]\n        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n        @overload\n        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass finalize:  # TODO: This is a good candidate for to be a `Generic[_P, _T]` class\n    def __init__(self, __obj: object, __func: Callable[_P, Any], *args: _P.args, **kwargs: _P.kwargs) -> None: ...\n    def __call__(self, _: Any = None) -> Any | None: ...\n    def detach(self) -> tuple[Any, Any, tuple[Any, ...], dict[str, Any]] | None: ...\n    def peek(self) -> tuple[Any, Any, tuple[Any, ...], dict[str, Any]] | None: ...\n    @property\n    def alive(self) -> bool: ...\n    atexit: bool\n",
  "/typeshed/stdlib/webbrowser.pyi": "import sys\nfrom abc import abstractmethod\nfrom collections.abc import Callable, Sequence\nfrom typing_extensions import Literal\n\n__all__ = [\"Error\", \"open\", \"open_new\", \"open_new_tab\", \"get\", \"register\"]\n\nclass Error(Exception): ...\n\ndef register(\n    name: str, klass: Callable[[], BaseBrowser] | None, instance: BaseBrowser | None = None, *, preferred: bool = False\n) -> None: ...\ndef get(using: str | None = None) -> BaseBrowser: ...\ndef open(url: str, new: int = 0, autoraise: bool = True) -> bool: ...\ndef open_new(url: str) -> bool: ...\ndef open_new_tab(url: str) -> bool: ...\n\nclass BaseBrowser:\n    args: list[str]\n    name: str\n    basename: str\n    def __init__(self, name: str = \"\") -> None: ...\n    @abstractmethod\n    def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n    def open_new(self, url: str) -> bool: ...\n    def open_new_tab(self, url: str) -> bool: ...\n\nclass GenericBrowser(BaseBrowser):\n    def __init__(self, name: str | Sequence[str]) -> None: ...\n    def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n\nclass BackgroundBrowser(GenericBrowser): ...\n\nclass UnixBrowser(BaseBrowser):\n    def open(self, url: str, new: Literal[0, 1, 2] = 0, autoraise: bool = True) -> bool: ...  # type: ignore[override]\n    raise_opts: list[str] | None\n    background: bool\n    redirect_stdout: bool\n    remote_args: list[str]\n    remote_action: str\n    remote_action_newwin: str\n    remote_action_newtab: str\n\nclass Mozilla(UnixBrowser): ...\n\nclass Galeon(UnixBrowser):\n    raise_opts: list[str]\n\nclass Chrome(UnixBrowser): ...\nclass Opera(UnixBrowser): ...\nclass Elinks(UnixBrowser): ...\n\nclass Konqueror(BaseBrowser):\n    def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n\nclass Grail(BaseBrowser):\n    def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n\nif sys.platform == \"win32\":\n    class WindowsDefault(BaseBrowser):\n        def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n\nif sys.platform == \"darwin\":\n    class MacOSX(BaseBrowser):\n        def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n\n    class MacOSXOSAScript(BaseBrowser):  # In runtime this class does not have `name` and `basename`\n        if sys.version_info >= (3, 11):\n            def __init__(self, name: str = \"default\") -> None: ...\n        else:\n            def __init__(self, name: str) -> None: ...\n\n        def open(self, url: str, new: int = 0, autoraise: bool = True) -> bool: ...\n",
  "/typeshed/stdlib/xdrlib.pyi": "from collections.abc import Callable, Sequence\nfrom typing import TypeVar\n\n__all__ = [\"Error\", \"Packer\", \"Unpacker\", \"ConversionError\"]\n\n_T = TypeVar(\"_T\")\n\nclass Error(Exception):\n    msg: str\n    def __init__(self, msg: str) -> None: ...\n\nclass ConversionError(Error): ...\n\nclass Packer:\n    def reset(self) -> None: ...\n    def get_buffer(self) -> bytes: ...\n    def get_buf(self) -> bytes: ...\n    def pack_uint(self, x: int) -> None: ...\n    def pack_int(self, x: int) -> None: ...\n    def pack_enum(self, x: int) -> None: ...\n    def pack_bool(self, x: bool) -> None: ...\n    def pack_uhyper(self, x: int) -> None: ...\n    def pack_hyper(self, x: int) -> None: ...\n    def pack_float(self, x: float) -> None: ...\n    def pack_double(self, x: float) -> None: ...\n    def pack_fstring(self, n: int, s: bytes) -> None: ...\n    def pack_fopaque(self, n: int, s: bytes) -> None: ...\n    def pack_string(self, s: bytes) -> None: ...\n    def pack_opaque(self, s: bytes) -> None: ...\n    def pack_bytes(self, s: bytes) -> None: ...\n    def pack_list(self, list: Sequence[_T], pack_item: Callable[[_T], object]) -> None: ...\n    def pack_farray(self, n: int, list: Sequence[_T], pack_item: Callable[[_T], object]) -> None: ...\n    def pack_array(self, list: Sequence[_T], pack_item: Callable[[_T], object]) -> None: ...\n\nclass Unpacker:\n    def __init__(self, data: bytes) -> None: ...\n    def reset(self, data: bytes) -> None: ...\n    def get_position(self) -> int: ...\n    def set_position(self, position: int) -> None: ...\n    def get_buffer(self) -> bytes: ...\n    def done(self) -> None: ...\n    def unpack_uint(self) -> int: ...\n    def unpack_int(self) -> int: ...\n    def unpack_enum(self) -> int: ...\n    def unpack_bool(self) -> bool: ...\n    def unpack_uhyper(self) -> int: ...\n    def unpack_hyper(self) -> int: ...\n    def unpack_float(self) -> float: ...\n    def unpack_double(self) -> float: ...\n    def unpack_fstring(self, n: int) -> bytes: ...\n    def unpack_fopaque(self, n: int) -> bytes: ...\n    def unpack_string(self) -> bytes: ...\n    def unpack_opaque(self) -> bytes: ...\n    def unpack_bytes(self) -> bytes: ...\n    def unpack_list(self, unpack_item: Callable[[], _T]) -> list[_T]: ...\n    def unpack_farray(self, n: int, unpack_item: Callable[[], _T]) -> list[_T]: ...\n    def unpack_array(self, unpack_item: Callable[[], _T]) -> list[_T]: ...\n",
  "/typeshed/stdlib/xxlimited.pyi": "import sys\nfrom typing import Any\nfrom typing_extensions import final\n\nclass Str: ...\n\n@final\nclass Xxo:\n    def demo(self) -> None: ...\n\ndef foo(__i: int, __j: int) -> Any: ...\ndef new() -> Xxo: ...\n\nif sys.version_info >= (3, 10):\n    class Error: ...\n\nelse:\n    class error: ...\n    class Null: ...\n\n    def roj(__b: Any) -> None: ...\n",
  "/typeshed/stdlib/zipapp.pyi": "from collections.abc import Callable\nfrom pathlib import Path\nfrom typing import BinaryIO\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"ZipAppError\", \"create_archive\", \"get_interpreter\"]\n\n_Path: TypeAlias = str | Path | BinaryIO\n\nclass ZipAppError(ValueError): ...\n\ndef create_archive(\n    source: _Path,\n    target: _Path | None = None,\n    interpreter: str | None = None,\n    main: str | None = None,\n    filter: Callable[[Path], bool] | None = None,\n    compressed: bool = False,\n) -> None: ...\ndef get_interpreter(archive: _Path) -> str: ...\n",
  "/typeshed/stdlib/zipfile.pyi": "import io\nimport sys\nfrom _typeshed import StrOrBytesPath, StrPath, _BufferWithLen\nfrom collections.abc import Callable, Iterable, Iterator\nfrom os import PathLike\nfrom types import TracebackType\nfrom typing import IO, Any, Protocol, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\n    \"BadZipFile\",\n    \"BadZipfile\",\n    \"error\",\n    \"ZIP_STORED\",\n    \"ZIP_DEFLATED\",\n    \"ZIP_BZIP2\",\n    \"ZIP_LZMA\",\n    \"is_zipfile\",\n    \"ZipInfo\",\n    \"ZipFile\",\n    \"PyZipFile\",\n    \"LargeZipFile\",\n]\n\nif sys.version_info >= (3, 8):\n    __all__ += [\"Path\"]\n\n_DateTuple: TypeAlias = tuple[int, int, int, int, int, int]\n_ReadWriteMode: TypeAlias = Literal[\"r\", \"w\"]\n_ReadWriteBinaryMode: TypeAlias = Literal[\"r\", \"w\", \"rb\", \"wb\"]\n_ZipFileMode: TypeAlias = Literal[\"r\", \"w\", \"x\", \"a\"]\n\nclass BadZipFile(Exception): ...\n\nBadZipfile = BadZipFile\nerror = BadZipfile\n\nclass LargeZipFile(Exception): ...\n\nclass _ZipStream(Protocol):\n    def read(self, __n: int) -> bytes: ...\n    # The following methods are optional:\n    # def seekable(self) -> bool: ...\n    # def tell(self) -> int: ...\n    # def seek(self, __n: int) -> object: ...\n\n# Stream shape as required by _EndRecData() and _EndRecData64().\nclass _SupportsReadSeekTell(Protocol):\n    def read(self, __n: int = ...) -> bytes: ...\n    def seek(self, __cookie: int, __whence: int) -> object: ...\n    def tell(self) -> int: ...\n\nclass _ClosableZipStream(_ZipStream, Protocol):\n    def close(self) -> object: ...\n\nclass ZipExtFile(io.BufferedIOBase):\n    MAX_N: int\n    MIN_READ_SIZE: int\n    MAX_SEEK_READ: int\n    newlines: list[bytes] | None\n    mode: _ReadWriteMode\n    name: str\n    @overload\n    def __init__(\n        self, fileobj: _ClosableZipStream, mode: _ReadWriteMode, zipinfo: ZipInfo, pwd: bytes | None, close_fileobj: Literal[True]\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        fileobj: _ClosableZipStream,\n        mode: _ReadWriteMode,\n        zipinfo: ZipInfo,\n        pwd: bytes | None = None,\n        *,\n        close_fileobj: Literal[True],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        fileobj: _ZipStream,\n        mode: _ReadWriteMode,\n        zipinfo: ZipInfo,\n        pwd: bytes | None = None,\n        close_fileobj: Literal[False] = False,\n    ) -> None: ...\n    def read(self, n: int | None = -1) -> bytes: ...\n    def readline(self, limit: int = -1) -> bytes: ...  # type: ignore[override]\n    def peek(self, n: int = 1) -> bytes: ...\n    def read1(self, n: int | None) -> bytes: ...  # type: ignore[override]\n    def seek(self, offset: int, whence: int = 0) -> int: ...\n\nclass _Writer(Protocol):\n    def write(self, __s: str) -> object: ...\n\nclass ZipFile:\n    filename: str | None\n    debug: int\n    comment: bytes\n    filelist: list[ZipInfo]\n    fp: IO[bytes] | None\n    NameToInfo: dict[str, ZipInfo]\n    start_dir: int  # undocumented\n    compression: int  # undocumented\n    compresslevel: int | None  # undocumented\n    mode: _ZipFileMode  # undocumented\n    pwd: bytes | None  # undocumented\n    if sys.version_info >= (3, 11):\n        @overload\n        def __init__(\n            self,\n            file: StrPath | IO[bytes],\n            mode: Literal[\"r\"] = \"r\",\n            compression: int = 0,\n            allowZip64: bool = True,\n            compresslevel: int | None = None,\n            *,\n            strict_timestamps: bool = True,\n            metadata_encoding: str | None,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            file: StrPath | IO[bytes],\n            mode: _ZipFileMode = \"r\",\n            compression: int = 0,\n            allowZip64: bool = True,\n            compresslevel: int | None = None,\n            *,\n            strict_timestamps: bool = True,\n            metadata_encoding: None = None,\n        ) -> None: ...\n    elif sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            file: StrPath | IO[bytes],\n            mode: _ZipFileMode = \"r\",\n            compression: int = 0,\n            allowZip64: bool = True,\n            compresslevel: int | None = None,\n            *,\n            strict_timestamps: bool = True,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            file: StrPath | IO[bytes],\n            mode: _ZipFileMode = \"r\",\n            compression: int = 0,\n            allowZip64: bool = True,\n            compresslevel: int | None = None,\n        ) -> None: ...\n\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n    def close(self) -> None: ...\n    def getinfo(self, name: str) -> ZipInfo: ...\n    def infolist(self) -> list[ZipInfo]: ...\n    def namelist(self) -> list[str]: ...\n    def open(\n        self, name: str | ZipInfo, mode: _ReadWriteMode = \"r\", pwd: bytes | None = None, *, force_zip64: bool = False\n    ) -> IO[bytes]: ...\n    def extract(self, member: str | ZipInfo, path: StrPath | None = None, pwd: bytes | None = None) -> str: ...\n    def extractall(\n        self, path: StrPath | None = None, members: Iterable[str | ZipInfo] | None = None, pwd: bytes | None = None\n    ) -> None: ...\n    def printdir(self, file: _Writer | None = None) -> None: ...\n    def setpassword(self, pwd: bytes) -> None: ...\n    def read(self, name: str | ZipInfo, pwd: bytes | None = None) -> bytes: ...\n    def testzip(self) -> str | None: ...\n    def write(\n        self,\n        filename: StrPath,\n        arcname: StrPath | None = None,\n        compress_type: int | None = None,\n        compresslevel: int | None = None,\n    ) -> None: ...\n    def writestr(\n        self,\n        zinfo_or_arcname: str | ZipInfo,\n        data: _BufferWithLen | str,\n        compress_type: int | None = None,\n        compresslevel: int | None = None,\n    ) -> None: ...\n    if sys.version_info >= (3, 11):\n        def mkdir(self, zinfo_or_directory_name: str | ZipInfo, mode: int = 0o777) -> None: ...\n\nclass PyZipFile(ZipFile):\n    def __init__(\n        self, file: str | IO[bytes], mode: _ZipFileMode = \"r\", compression: int = 0, allowZip64: bool = True, optimize: int = -1\n    ) -> None: ...\n    def writepy(self, pathname: str, basename: str = \"\", filterfunc: Callable[[str], bool] | None = None) -> None: ...\n\nclass ZipInfo:\n    filename: str\n    date_time: _DateTuple\n    compress_type: int\n    comment: bytes\n    extra: bytes\n    create_system: int\n    create_version: int\n    extract_version: int\n    reserved: int\n    flag_bits: int\n    volume: int\n    internal_attr: int\n    external_attr: int\n    header_offset: int\n    CRC: int\n    compress_size: int\n    file_size: int\n    orig_filename: str  # undocumented\n    def __init__(self, filename: str = \"NoName\", date_time: _DateTuple = (1980, 1, 1, 0, 0, 0)) -> None: ...\n    if sys.version_info >= (3, 8):\n        @classmethod\n        def from_file(cls, filename: StrPath, arcname: StrPath | None = None, *, strict_timestamps: bool = True) -> Self: ...\n    else:\n        @classmethod\n        def from_file(cls, filename: StrPath, arcname: StrPath | None = None) -> Self: ...\n\n    def is_dir(self) -> bool: ...\n    def FileHeader(self, zip64: bool | None = None) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    if sys.version_info < (3, 9):\n        class _PathOpenProtocol(Protocol):\n            def __call__(self, mode: _ReadWriteMode = \"r\", pwd: bytes | None = ..., *, force_zip64: bool = ...) -> IO[bytes]: ...\n\n    class Path:\n        @property\n        def name(self) -> str: ...\n        @property\n        def parent(self) -> PathLike[str]: ...  # undocumented\n        if sys.version_info >= (3, 10):\n            @property\n            def filename(self) -> PathLike[str]: ...  # undocumented\n        if sys.version_info >= (3, 11):\n            @property\n            def suffix(self) -> str: ...\n            @property\n            def suffixes(self) -> list[str]: ...\n            @property\n            def stem(self) -> str: ...\n\n        def __init__(self, root: ZipFile | StrPath | IO[bytes], at: str = \"\") -> None: ...\n        if sys.version_info >= (3, 9):\n            def open(\n                self,\n                mode: _ReadWriteBinaryMode = \"r\",\n                encoding: str | None = None,\n                *args: Any,\n                pwd: bytes | None = None,\n                **kwargs: Any,\n            ) -> IO[bytes]: ...\n        else:\n            @property\n            def open(self) -> _PathOpenProtocol: ...\n\n        def iterdir(self) -> Iterator[Path]: ...\n        def is_dir(self) -> bool: ...\n        def is_file(self) -> bool: ...\n        def exists(self) -> bool: ...\n        def read_text(\n            self,\n            encoding: str | None = ...,\n            errors: str | None = ...,\n            newline: str | None = ...,\n            line_buffering: bool = ...,\n            write_through: bool = ...,\n        ) -> str: ...\n        def read_bytes(self) -> bytes: ...\n        if sys.version_info >= (3, 10):\n            def joinpath(self, *other: StrPath) -> Path: ...\n        else:\n            def joinpath(self, add: StrPath) -> Path: ...  # undocumented\n\n        def __truediv__(self, add: StrPath) -> Path: ...\n\ndef is_zipfile(filename: StrOrBytesPath | _SupportsReadSeekTell) -> bool: ...\n\nZIP_STORED: int\nZIP_DEFLATED: int\nZIP64_LIMIT: int\nZIP_FILECOUNT_LIMIT: int\nZIP_MAX_COMMENT: int\nZIP_BZIP2: int\nZIP_LZMA: int\n",
  "/typeshed/stdlib/zipimport.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom importlib.abc import ResourceReader\nfrom importlib.machinery import ModuleSpec\nfrom types import CodeType, ModuleType\n\nif sys.version_info >= (3, 8):\n    __all__ = [\"ZipImportError\", \"zipimporter\"]\n\nclass ZipImportError(ImportError): ...\n\nclass zipimporter:\n    archive: str\n    prefix: str\n    if sys.version_info >= (3, 11):\n        def __init__(self, path: str) -> None: ...\n    else:\n        def __init__(self, path: StrOrBytesPath) -> None: ...\n\n    def find_loader(self, fullname: str, path: str | None = None) -> tuple[zipimporter | None, list[str]]: ...  # undocumented\n    def find_module(self, fullname: str, path: str | None = None) -> zipimporter | None: ...\n    def get_code(self, fullname: str) -> CodeType: ...\n    def get_data(self, pathname: str) -> bytes: ...\n    def get_filename(self, fullname: str) -> str: ...\n    def get_resource_reader(self, fullname: str) -> ResourceReader | None: ...  # undocumented\n    def get_source(self, fullname: str) -> str | None: ...\n    def is_package(self, fullname: str) -> bool: ...\n    def load_module(self, fullname: str) -> ModuleType: ...\n    if sys.version_info >= (3, 10):\n        def find_spec(self, fullname: str, target: ModuleType | None = None) -> ModuleSpec | None: ...\n        def invalidate_caches(self) -> None: ...\n",
  "/typeshed/stdlib/zlib.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom typing_extensions import Literal\n\nDEFLATED: Literal[8]\nDEF_MEM_LEVEL: int  # can change\nDEF_BUF_SIZE: Literal[16384]\nMAX_WBITS: int\nZLIB_VERSION: str  # can change\nZLIB_RUNTIME_VERSION: str  # can change\nZ_NO_COMPRESSION: Literal[0]\nZ_PARTIAL_FLUSH: Literal[1]\nZ_BEST_COMPRESSION: Literal[9]\nZ_BEST_SPEED: Literal[1]\nZ_BLOCK: Literal[5]\nZ_DEFAULT_COMPRESSION: Literal[-1]\nZ_DEFAULT_STRATEGY: Literal[0]\nZ_FILTERED: Literal[1]\nZ_FINISH: Literal[4]\nZ_FIXED: Literal[4]\nZ_FULL_FLUSH: Literal[3]\nZ_HUFFMAN_ONLY: Literal[2]\nZ_NO_FLUSH: Literal[0]\nZ_RLE: Literal[3]\nZ_SYNC_FLUSH: Literal[2]\nZ_TREES: Literal[6]\n\nclass error(Exception): ...\n\nclass _Compress:\n    def compress(self, data: ReadableBuffer) -> bytes: ...\n    def flush(self, mode: int = ...) -> bytes: ...\n    def copy(self) -> _Compress: ...\n\nclass _Decompress:\n    unused_data: bytes\n    unconsumed_tail: bytes\n    eof: bool\n    def decompress(self, data: ReadableBuffer, max_length: int = ...) -> bytes: ...\n    def flush(self, length: int = ...) -> bytes: ...\n    def copy(self) -> _Decompress: ...\n\ndef adler32(__data: ReadableBuffer, __value: int = 1) -> int: ...\n\nif sys.version_info >= (3, 11):\n    def compress(__data: ReadableBuffer, level: int = -1, wbits: int = 15) -> bytes: ...\n\nelse:\n    def compress(__data: ReadableBuffer, level: int = -1) -> bytes: ...\n\ndef compressobj(\n    level: int = -1, method: int = 8, wbits: int = 15, memLevel: int = 8, strategy: int = 0, zdict: ReadableBuffer | None = None\n) -> _Compress: ...\ndef crc32(__data: ReadableBuffer, __value: int = 0) -> int: ...\ndef decompress(__data: ReadableBuffer, wbits: int = 15, bufsize: int = 16384) -> bytes: ...\ndef decompressobj(wbits: int = 15, zdict: ReadableBuffer = b\"\") -> _Decompress: ...\n",
  "/typeshed/stdlib/_typeshed/README.md": "# Utility types for typeshed\n\nThis package and its submodules contains various common types used by\ntypeshed. It can also be used by packages outside typeshed, but beware\nthe API stability guarantees below.\n\n## Usage\n\nThe `_typeshed` package and its types do not exist at runtime, but can be\nused freely in stubs (`.pyi`) files. To import the types from this package in\nimplementation (`.py`) files, use the following construct:\n\n```python\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from _typeshed import ...\n```\n\nTypes can then be used in annotations by either quoting them or\nusing:\n\n```python\nfrom __future__ import annotations\n```\n\n## API Stability\n\nYou can use this package and its submodules outside of typeshed, but we\nguarantee only limited API stability. Items marked as \"stable\" will not be\nremoved or changed in an incompatible way for at least one year.\nBefore making such a change, the \"stable\" moniker will be removed\nand we will mark the type in question as deprecated. No guarantees\nare made about unmarked types.\n",
  "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport ctypes\nimport mmap\nimport pickle\nimport sys\nfrom collections.abc import Awaitable, Callable, Iterable, Set as AbstractSet\nfrom dataclasses import Field\nfrom os import PathLike\nfrom types import FrameType, TracebackType\nfrom typing import Any, AnyStr, ClassVar, Generic, Protocol, TypeVar\nfrom typing_extensions import Final, Literal, LiteralString, TypeAlias, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa: Y001\n\n# covariant version of typing.AnyStr, useful for protocols\nAnyStr_co = TypeVar(\"AnyStr_co\", str, bytes, covariant=True)  # noqa: Y001\n\n# For partially known annotations. Usually, fields where type annotations\n# haven't been added are left unannotated, but in some situations this\n# isn't possible or a type is already partially known. In cases like these,\n# use Incomplete instead of Any as a marker. For example, use\n# \"Incomplete | None\" instead of \"Any | None\".\nIncomplete: TypeAlias = Any\n\n# To describe a function parameter that is unused and will work with anything.\nUnused: TypeAlias = object\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\n# stable\nclass SupportsNext(Protocol[_T_co]):\n    def __next__(self) -> _T_co: ...\n\n# stable\nclass SupportsAnext(Protocol[_T_co]):\n    def __anext__(self) -> Awaitable[_T_co]: ...\n\n# Comparison protocols\n\nclass SupportsDunderLT(Protocol[_T_contra]):\n    def __lt__(self, __other: _T_contra) -> bool: ...\n\nclass SupportsDunderGT(Protocol[_T_contra]):\n    def __gt__(self, __other: _T_contra) -> bool: ...\n\nclass SupportsDunderLE(Protocol[_T_contra]):\n    def __le__(self, __other: _T_contra) -> bool: ...\n\nclass SupportsDunderGE(Protocol[_T_contra]):\n    def __ge__(self, __other: _T_contra) -> bool: ...\n\nclass SupportsAllComparisons(\n    SupportsDunderLT[Any], SupportsDunderGT[Any], SupportsDunderLE[Any], SupportsDunderGE[Any], Protocol\n): ...\n\nSupportsRichComparison: TypeAlias = SupportsDunderLT[Any] | SupportsDunderGT[Any]\nSupportsRichComparisonT = TypeVar(\"SupportsRichComparisonT\", bound=SupportsRichComparison)  # noqa: Y001\n\n# Dunder protocols\n\nclass SupportsAdd(Protocol[_T_contra, _T_co]):\n    def __add__(self, __x: _T_contra) -> _T_co: ...\n\nclass SupportsRAdd(Protocol[_T_contra, _T_co]):\n    def __radd__(self, __x: _T_contra) -> _T_co: ...\n\nclass SupportsSub(Protocol[_T_contra, _T_co]):\n    def __sub__(self, __x: _T_contra) -> _T_co: ...\n\nclass SupportsRSub(Protocol[_T_contra, _T_co]):\n    def __rsub__(self, __x: _T_contra) -> _T_co: ...\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\n# This protocol is generic over the iterator type, while Iterable is\n# generic over the type that is iterated over.\nclass SupportsIter(Protocol[_T_co]):\n    def __iter__(self) -> _T_co: ...\n\n# This protocol is generic over the iterator type, while AsyncIterable is\n# generic over the type that is iterated over.\nclass SupportsAiter(Protocol[_T_co]):\n    def __aiter__(self) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\nclass SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __key: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Protocol[_KT_contra, _VT_co]):\n    def __contains__(self, __x: Any) -> bool: ...\n    def __getitem__(self, __key: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __key: _KT_contra, __value: _VT) -> None: ...\n    def __delitem__(self, __key: _KT_contra) -> None: ...\n\nStrPath: TypeAlias = str | PathLike[str]  # stable\nBytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\nGenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\nStrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  # stable\n\nOpenTextModeUpdating: TypeAlias = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting: TypeAlias = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading: TypeAlias = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode: TypeAlias = OpenTextModeUpdating | OpenTextModeWriting | OpenTextModeReading\nOpenBinaryModeUpdating: TypeAlias = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting: TypeAlias = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading: TypeAlias = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode: TypeAlias = OpenBinaryModeUpdating | OpenBinaryModeReading | OpenBinaryModeWriting\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor: TypeAlias = int  # stable\nFileDescriptorLike: TypeAlias = int | HasFileno  # stable\nFileDescriptorOrPath: TypeAlias = int | StrOrBytesPath\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> object: ...\n\nReadOnlyBuffer: TypeAlias = bytes  # stable\n# Anything that implements the read-write buffer interface.\n# The buffer interface is defined purely on the C level, so we cannot define a normal Protocol\n# for it (until PEP 688 is implemented). Instead we have to list the most common stdlib buffer classes in a Union.\nif sys.version_info >= (3, 8):\n    WriteableBuffer: TypeAlias = (\n        bytearray | memoryview | array.array[Any] | mmap.mmap | ctypes._CData | pickle.PickleBuffer\n    )  # stable\nelse:\n    WriteableBuffer: TypeAlias = bytearray | memoryview | array.array[Any] | mmap.mmap | ctypes._CData  # stable\n# Same as _WriteableBuffer, but also includes read-only buffer types (like bytes).\nReadableBuffer: TypeAlias = ReadOnlyBuffer | WriteableBuffer  # stable\n_BufferWithLen: TypeAlias = ReadableBuffer  # not stable  # noqa: Y047\n\n# Anything that implements the read-write buffer interface, and can be sliced/indexed.\nSliceableBuffer: TypeAlias = bytes | bytearray | memoryview | array.array[Any] | mmap.mmap\nIndexableBuffer: TypeAlias = bytes | bytearray | memoryview | array.array[Any] | mmap.mmap\n# https://github.com/python/typeshed/pull/9115#issuecomment-1304905864\n# Post PEP 688, they should be rewritten as such:\n# from collections.abc import Sequence\n# from typing import Sized, overload\n# class SliceableBuffer(Protocol):\n#     def __buffer__(self, __flags: int) -> memoryview: ...\n#     def __getitem__(self, __slice: slice) -> Sequence[int]: ...\n# class IndexableBuffer(Protocol):\n#     def __buffer__(self, __flags: int) -> memoryview: ...\n#     def __getitem__(self, __i: int) -> int: ...\n# class SupportsGetItemBuffer(SliceableBuffer, IndexableBuffer, Protocol):\n#     def __buffer__(self, __flags: int) -> memoryview: ...\n#     def __contains__(self, __x: Any) -> bool: ...\n#     @overload\n#     def __getitem__(self, __slice: slice) -> Sequence[int]: ...\n#     @overload\n#     def __getitem__(self, __i: int) -> int: ...\n# class SizedBuffer(Sized, Protocol):  # instead of _BufferWithLen\n#     def __buffer__(self, __flags: int) -> memoryview: ...\n\nExcInfo: TypeAlias = tuple[type[BaseException], BaseException, TracebackType]\nOptExcInfo: TypeAlias = ExcInfo | tuple[None, None, None]\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n\n# This is an internal CPython type that is like, but subtly different from, a NamedTuple\n# Subclasses of this type are found in multiple modules.\n# In typeshed, `structseq` is only ever used as a mixin in combination with a fixed-length `Tuple`\n# See discussion at #6546 & #6560\n# `structseq` classes are unsubclassable, so are all decorated with `@final`.\nclass structseq(Generic[_T_co]):\n    n_fields: Final[int]\n    n_unnamed_fields: Final[int]\n    n_sequence_fields: Final[int]\n    # The first parameter will generally only take an iterable of a specific length.\n    # E.g. `os.uname_result` takes any iterable of length exactly 5.\n    #\n    # The second parameter will accept a dict of any kind without raising an exception,\n    # but only has any meaning if you supply it a dict where the keys are strings.\n    # https://github.com/python/typeshed/pull/6560#discussion_r767149830\n    def __new__(cls: type[Self], sequence: Iterable[_T_co], dict: dict[str, Any] = ...) -> Self: ...\n\n# Superset of typing.AnyStr that also includes LiteralString\nAnyOrLiteralStr = TypeVar(\"AnyOrLiteralStr\", str, bytes, LiteralString)  # noqa: Y001\n\n# Represents when str or LiteralStr is acceptable. Useful for string processing\n# APIs where literalness of return value depends on literalness of inputs\nStrOrLiteralStr = TypeVar(\"StrOrLiteralStr\", LiteralString, str)  # noqa: Y001\n\n# Objects suitable to be passed to sys.setprofile, threading.setprofile, and similar\nProfileFunction: TypeAlias = Callable[[FrameType, str, Any], object]\n\n# Objects suitable to be passed to sys.settrace, threading.settrace, and similar\nTraceFunction: TypeAlias = Callable[[FrameType, str, Any], TraceFunction | None]\n\n# experimental\n# Might not work as expected for pyright, see\n#   https://github.com/python/typeshed/pull/9362\n#   https://github.com/microsoft/pyright/issues/4339\nclass DataclassInstance(Protocol):\n    __dataclass_fields__: ClassVar[dict[str, Field[Any]]]\n",
  "/typeshed/stdlib/_typeshed/dbapi.pyi": "# PEP 249 Database API 2.0 Types\n# https://www.python.org/dev/peps/pep-0249/\n\nfrom collections.abc import Mapping, Sequence\nfrom typing import Any, Protocol\nfrom typing_extensions import TypeAlias\n\nDBAPITypeCode: TypeAlias = Any | None\n# Strictly speaking, this should be a Sequence, but the type system does\n# not support fixed-length sequences.\nDBAPIColumnDescription: TypeAlias = tuple[str, DBAPITypeCode, int | None, int | None, int | None, int | None, bool | None]\n\nclass DBAPIConnection(Protocol):\n    def close(self) -> object: ...\n    def commit(self) -> object: ...\n    # optional:\n    # def rollback(self) -> Any: ...\n    def cursor(self) -> DBAPICursor: ...\n\nclass DBAPICursor(Protocol):\n    @property\n    def description(self) -> Sequence[DBAPIColumnDescription] | None: ...\n    @property\n    def rowcount(self) -> int: ...\n    # optional:\n    # def callproc(self, __procname: str, __parameters: Sequence[Any] = ...) -> Sequence[Any]: ...\n    def close(self) -> object: ...\n    def execute(self, __operation: str, __parameters: Sequence[Any] | Mapping[str, Any] = ...) -> object: ...\n    def executemany(self, __operation: str, __seq_of_parameters: Sequence[Sequence[Any]]) -> object: ...\n    def fetchone(self) -> Sequence[Any] | None: ...\n    def fetchmany(self, __size: int = ...) -> Sequence[Sequence[Any]]: ...\n    def fetchall(self) -> Sequence[Sequence[Any]]: ...\n    # optional:\n    # def nextset(self) -> None | Literal[True]: ...\n    arraysize: int\n    def setinputsizes(self, __sizes: Sequence[DBAPITypeCode | int | None]) -> object: ...\n    def setoutputsize(self, __size: int, __column: int = ...) -> object: ...\n",
  "/typeshed/stdlib/_typeshed/wsgi.pyi": "# Types to support PEP 3333 (WSGI)\n#\n# Obsolete since Python 3.11: Use wsgiref.types instead.\n#\n# See the README.md file in this directory for more information.\n\nimport sys\nfrom _typeshed import OptExcInfo\nfrom collections.abc import Callable, Iterable, Iterator\nfrom typing import Any, Protocol\nfrom typing_extensions import TypeAlias\n\nclass _Readable(Protocol):\n    def read(self, size: int = ...) -> bytes: ...\n    # Optional: def close(self) -> object: ...\n\nif sys.version_info >= (3, 11):\n    from wsgiref.types import *\nelse:\n    # stable\n    class StartResponse(Protocol):\n        def __call__(\n            self, __status: str, __headers: list[tuple[str, str]], __exc_info: OptExcInfo | None = ...\n        ) -> Callable[[bytes], object]: ...\n\n    WSGIEnvironment: TypeAlias = dict[str, Any]  # stable\n    WSGIApplication: TypeAlias = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]  # stable\n\n    # WSGI input streams per PEP 3333, stable\n    class InputStream(Protocol):\n        def read(self, __size: int = ...) -> bytes: ...\n        def readline(self, __size: int = ...) -> bytes: ...\n        def readlines(self, __hint: int = ...) -> list[bytes]: ...\n        def __iter__(self) -> Iterator[bytes]: ...\n\n    # WSGI error streams per PEP 3333, stable\n    class ErrorStream(Protocol):\n        def flush(self) -> object: ...\n        def write(self, __s: str) -> object: ...\n        def writelines(self, __seq: list[str]) -> object: ...\n\n    # Optional file wrapper in wsgi.file_wrapper\n    class FileWrapper(Protocol):\n        def __call__(self, __file: _Readable, __block_size: int = ...) -> Iterable[bytes]: ...\n",
  "/typeshed/stdlib/_typeshed/xml.pyi": "# See the README.md file in this directory for more information.\n\nfrom typing import Any, Protocol\n\n# As defined https://docs.python.org/3/library/xml.dom.html#domimplementation-objects\nclass DOMImplementation(Protocol):\n    def hasFeature(self, feature: str, version: str | None) -> bool: ...\n    def createDocument(self, namespaceUri: str, qualifiedName: str, doctype: Any | None) -> Any: ...\n    def createDocumentType(self, qualifiedName: str, publicId: str, systemId: str) -> Any: ...\n",
  "/typeshed/stdlib/asyncio/__init__.pyi": "import sys\n\n# As at runtime, this depends on all submodules defining __all__ accurately.\nfrom .base_events import *\nfrom .coroutines import *\nfrom .events import *\nfrom .futures import *\nfrom .locks import *\nfrom .protocols import *\nfrom .queues import *\nfrom .runners import *\nfrom .streams import *\nfrom .subprocess import *\nfrom .tasks import *\nfrom .transports import *\n\nif sys.version_info >= (3, 8):\n    from .exceptions import *\n\nif sys.version_info >= (3, 9):\n    from .threads import *\n\nif sys.version_info >= (3, 11):\n    from .taskgroups import *\n    from .timeouts import *\n\nif sys.platform == \"win32\":\n    from .windows_events import *\nelse:\n    from .unix_events import *\n",
  "/typeshed/stdlib/asyncio/base_events.pyi": "import ssl\nimport sys\nfrom _typeshed import FileDescriptorLike, ReadableBuffer, WriteableBuffer\nfrom asyncio.events import AbstractEventLoop, AbstractServer, Handle, TimerHandle, _TaskFactory\nfrom asyncio.futures import Future\nfrom asyncio.protocols import BaseProtocol\nfrom asyncio.tasks import Task\nfrom asyncio.transports import BaseTransport, DatagramTransport, ReadTransport, SubprocessTransport, Transport, WriteTransport\nfrom collections.abc import Awaitable, Callable, Coroutine, Generator, Iterable, Sequence\nfrom contextvars import Context\nfrom socket import AddressFamily, SocketKind, _Address, _RetAddress, socket\nfrom typing import IO, Any, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias\n\nif sys.version_info >= (3, 9):\n    __all__ = (\"BaseEventLoop\", \"Server\")\nelse:\n    __all__ = (\"BaseEventLoop\",)\n\n_T = TypeVar(\"_T\")\n_ProtocolT = TypeVar(\"_ProtocolT\", bound=BaseProtocol)\n_Context: TypeAlias = dict[str, Any]\n_ExceptionHandler: TypeAlias = Callable[[AbstractEventLoop, _Context], object]\n_ProtocolFactory: TypeAlias = Callable[[], BaseProtocol]\n_SSLContext: TypeAlias = bool | None | ssl.SSLContext\n\nclass Server(AbstractServer):\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            loop: AbstractEventLoop,\n            sockets: Iterable[socket],\n            protocol_factory: _ProtocolFactory,\n            ssl_context: _SSLContext,\n            backlog: int,\n            ssl_handshake_timeout: float | None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            loop: AbstractEventLoop,\n            sockets: Iterable[socket],\n            protocol_factory: _ProtocolFactory,\n            ssl_context: _SSLContext,\n            backlog: int,\n            ssl_handshake_timeout: float | None,\n        ) -> None: ...\n\n    def get_loop(self) -> AbstractEventLoop: ...\n    def is_serving(self) -> bool: ...\n    async def start_serving(self) -> None: ...\n    async def serve_forever(self) -> None: ...\n    if sys.version_info >= (3, 8):\n        @property\n        def sockets(self) -> tuple[socket, ...]: ...\n    else:\n        @property\n        def sockets(self) -> list[socket]: ...\n\n    def close(self) -> None: ...\n    async def wait_closed(self) -> None: ...\n\nclass BaseEventLoop(AbstractEventLoop):\n    def run_forever(self) -> None: ...\n    # Can't use a union, see mypy issue  # 1873.\n    @overload\n    def run_until_complete(self, future: Generator[Any, None, _T]) -> _T: ...\n    @overload\n    def run_until_complete(self, future: Awaitable[_T]) -> _T: ...\n    def stop(self) -> None: ...\n    def is_running(self) -> bool: ...\n    def is_closed(self) -> bool: ...\n    def close(self) -> None: ...\n    async def shutdown_asyncgens(self) -> None: ...\n    # Methods scheduling callbacks.  All these return Handles.\n    def call_soon(self, callback: Callable[..., object], *args: Any, context: Context | None = None) -> Handle: ...\n    def call_later(\n        self, delay: float, callback: Callable[..., object], *args: Any, context: Context | None = None\n    ) -> TimerHandle: ...\n    def call_at(\n        self, when: float, callback: Callable[..., object], *args: Any, context: Context | None = None\n    ) -> TimerHandle: ...\n    def time(self) -> float: ...\n    # Future methods\n    def create_future(self) -> Future[Any]: ...\n    # Tasks methods\n    if sys.version_info >= (3, 11):\n        def create_task(\n            self, coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T], *, name: object = None, context: Context | None = None\n        ) -> Task[_T]: ...\n    elif sys.version_info >= (3, 8):\n        def create_task(self, coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T], *, name: object = None) -> Task[_T]: ...\n    else:\n        def create_task(self, coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T]) -> Task[_T]: ...\n\n    def set_task_factory(self, factory: _TaskFactory | None) -> None: ...\n    def get_task_factory(self) -> _TaskFactory | None: ...\n    # Methods for interacting with threads\n    def call_soon_threadsafe(self, callback: Callable[..., object], *args: Any, context: Context | None = None) -> Handle: ...\n    def run_in_executor(self, executor: Any, func: Callable[..., _T], *args: Any) -> Future[_T]: ...\n    def set_default_executor(self, executor: Any) -> None: ...\n    # Network I/O methods returning Futures.\n    async def getaddrinfo(\n        self,\n        host: bytes | str | None,\n        port: bytes | str | int | None,\n        *,\n        family: int = 0,\n        type: int = 0,\n        proto: int = 0,\n        flags: int = 0,\n    ) -> list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int] | tuple[str, int, int, int]]]: ...\n    async def getnameinfo(self, sockaddr: tuple[str, int] | tuple[str, int, int, int], flags: int = 0) -> tuple[str, str]: ...\n    if sys.version_info >= (3, 11):\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    elif sys.version_info >= (3, 8):\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    else:\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    if sys.version_info >= (3, 11):\n        @overload\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: str | Sequence[str] | None = None,\n            port: int = ...,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @overload\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: None = None,\n            port: None = None,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: socket = ...,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        async def start_tls(\n            self,\n            transport: BaseTransport,\n            protocol: BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            *,\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> Transport: ...\n        async def connect_accepted_socket(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            sock: socket,\n            *,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    else:\n        @overload\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: str | Sequence[str] | None = None,\n            port: int = ...,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @overload\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: None = None,\n            port: None = None,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: socket = ...,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        async def start_tls(\n            self,\n            transport: BaseTransport,\n            protocol: BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            *,\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> Transport: ...\n        async def connect_accepted_socket(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            sock: socket,\n            *,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n\n    async def sock_sendfile(\n        self, sock: socket, file: IO[bytes], offset: int = 0, count: int | None = None, *, fallback: bool | None = True\n    ) -> int: ...\n    async def sendfile(\n        self, transport: WriteTransport, file: IO[bytes], offset: int = 0, count: int | None = None, *, fallback: bool = True\n    ) -> int: ...\n    if sys.version_info >= (3, 11):\n        async def create_datagram_endpoint(  # type: ignore[override]\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            local_addr: tuple[str, int] | str | None = None,\n            remote_addr: tuple[str, int] | str | None = None,\n            *,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            reuse_port: bool | None = None,\n            allow_broadcast: bool | None = None,\n            sock: socket | None = None,\n        ) -> tuple[DatagramTransport, _ProtocolT]: ...\n    else:\n        async def create_datagram_endpoint(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            local_addr: tuple[str, int] | str | None = None,\n            remote_addr: tuple[str, int] | str | None = None,\n            *,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            reuse_address: bool | None = ...,\n            reuse_port: bool | None = None,\n            allow_broadcast: bool | None = None,\n            sock: socket | None = None,\n        ) -> tuple[DatagramTransport, _ProtocolT]: ...\n    # Pipes and subprocesses.\n    async def connect_read_pipe(\n        self, protocol_factory: Callable[[], _ProtocolT], pipe: Any\n    ) -> tuple[ReadTransport, _ProtocolT]: ...\n    async def connect_write_pipe(\n        self, protocol_factory: Callable[[], _ProtocolT], pipe: Any\n    ) -> tuple[WriteTransport, _ProtocolT]: ...\n    async def subprocess_shell(\n        self,\n        protocol_factory: Callable[[], _ProtocolT],\n        cmd: bytes | str,\n        *,\n        stdin: int | IO[Any] | None = -1,\n        stdout: int | IO[Any] | None = -1,\n        stderr: int | IO[Any] | None = -1,\n        universal_newlines: Literal[False] = False,\n        shell: Literal[True] = True,\n        bufsize: Literal[0] = 0,\n        encoding: None = None,\n        errors: None = None,\n        text: Literal[False, None] = None,\n        **kwargs: Any,\n    ) -> tuple[SubprocessTransport, _ProtocolT]: ...\n    async def subprocess_exec(\n        self,\n        protocol_factory: Callable[[], _ProtocolT],\n        program: Any,\n        *args: Any,\n        stdin: int | IO[Any] | None = -1,\n        stdout: int | IO[Any] | None = -1,\n        stderr: int | IO[Any] | None = -1,\n        universal_newlines: Literal[False] = False,\n        shell: Literal[False] = False,\n        bufsize: Literal[0] = 0,\n        encoding: None = None,\n        errors: None = None,\n        **kwargs: Any,\n    ) -> tuple[SubprocessTransport, _ProtocolT]: ...\n    def add_reader(self, fd: FileDescriptorLike, callback: Callable[..., Any], *args: Any) -> None: ...\n    def remove_reader(self, fd: FileDescriptorLike) -> bool: ...\n    def add_writer(self, fd: FileDescriptorLike, callback: Callable[..., Any], *args: Any) -> None: ...\n    def remove_writer(self, fd: FileDescriptorLike) -> bool: ...\n    # The sock_* methods (and probably some others) are not actually implemented on\n    # BaseEventLoop, only on subclasses. We list them here for now for convenience.\n    async def sock_recv(self, sock: socket, nbytes: int) -> bytes: ...\n    async def sock_recv_into(self, sock: socket, buf: WriteableBuffer) -> int: ...\n    async def sock_sendall(self, sock: socket, data: ReadableBuffer) -> None: ...\n    async def sock_connect(self, sock: socket, address: _Address) -> None: ...\n    async def sock_accept(self, sock: socket) -> tuple[socket, _RetAddress]: ...\n    if sys.version_info >= (3, 11):\n        async def sock_recvfrom(self, sock: socket, bufsize: int) -> tuple[bytes, _RetAddress]: ...\n        async def sock_recvfrom_into(self, sock: socket, buf: WriteableBuffer, nbytes: int = 0) -> tuple[int, _RetAddress]: ...\n        async def sock_sendto(self, sock: socket, data: ReadableBuffer, address: _Address) -> int: ...\n    # Signal handling.\n    def add_signal_handler(self, sig: int, callback: Callable[..., Any], *args: Any) -> None: ...\n    def remove_signal_handler(self, sig: int) -> bool: ...\n    # Error handlers.\n    def set_exception_handler(self, handler: _ExceptionHandler | None) -> None: ...\n    def get_exception_handler(self) -> _ExceptionHandler | None: ...\n    def default_exception_handler(self, context: _Context) -> None: ...\n    def call_exception_handler(self, context: _Context) -> None: ...\n    # Debug flag management.\n    def get_debug(self) -> bool: ...\n    def set_debug(self, enabled: bool) -> None: ...\n    if sys.version_info >= (3, 9):\n        async def shutdown_default_executor(self) -> None: ...\n",
  "/typeshed/stdlib/asyncio/base_futures.pyi": "from collections.abc import Callable, Sequence\nfrom contextvars import Context\nfrom typing import Any\nfrom typing_extensions import Literal\n\nfrom . import futures\n\n__all__ = ()\n\n# asyncio defines 'isfuture()' in base_futures.py and re-imports it in futures.py\n# but it leads to circular import error in pytype tool.\n# That's why the import order is reversed.\nfrom .futures import isfuture as isfuture\n\n_PENDING: Literal[\"PENDING\"]  # undocumented\n_CANCELLED: Literal[\"CANCELLED\"]  # undocumented\n_FINISHED: Literal[\"FINISHED\"]  # undocumented\n\ndef _format_callbacks(cb: Sequence[tuple[Callable[[futures.Future[Any]], None], Context]]) -> str: ...  # undocumented\ndef _future_repr_info(future: futures.Future[Any]) -> list[str]: ...  # undocumented\n",
  "/typeshed/stdlib/asyncio/base_subprocess.pyi": "import subprocess\nfrom collections import deque\nfrom collections.abc import Callable, Sequence\nfrom typing import IO, Any\nfrom typing_extensions import TypeAlias\n\nfrom . import events, futures, protocols, transports\n\n_File: TypeAlias = int | IO[Any] | None\n\nclass BaseSubprocessTransport(transports.SubprocessTransport):\n    _closed: bool  # undocumented\n    _protocol: protocols.SubprocessProtocol  # undocumented\n    _loop: events.AbstractEventLoop  # undocumented\n    _proc: subprocess.Popen[Any] | None  # undocumented\n    _pid: int | None  # undocumented\n    _returncode: int | None  # undocumented\n    _exit_waiters: list[futures.Future[Any]]  # undocumented\n    _pending_calls: deque[tuple[Callable[..., Any], tuple[Any, ...]]]  # undocumented\n    _pipes: dict[int, _File]  # undocumented\n    _finished: bool  # undocumented\n    def __init__(\n        self,\n        loop: events.AbstractEventLoop,\n        protocol: protocols.SubprocessProtocol,\n        args: str | bytes | Sequence[str | bytes],\n        shell: bool,\n        stdin: _File,\n        stdout: _File,\n        stderr: _File,\n        bufsize: int,\n        waiter: futures.Future[Any] | None = None,\n        extra: Any | None = None,\n        **kwargs: Any,\n    ) -> None: ...\n    def _start(\n        self,\n        args: str | bytes | Sequence[str | bytes],\n        shell: bool,\n        stdin: _File,\n        stdout: _File,\n        stderr: _File,\n        bufsize: int,\n        **kwargs: Any,\n    ) -> None: ...  # undocumented\n    def get_pid(self) -> int | None: ...  # type: ignore[override]\n    def get_pipe_transport(self, fd: int) -> _File: ...  # type: ignore[override]\n    def _check_proc(self) -> None: ...  # undocumented\n    def send_signal(self, signal: int) -> None: ...\n    async def _connect_pipes(self, waiter: futures.Future[Any] | None) -> None: ...  # undocumented\n    def _call(self, cb: Callable[..., object], *data: Any) -> None: ...  # undocumented\n    def _pipe_connection_lost(self, fd: int, exc: BaseException | None) -> None: ...  # undocumented\n    def _pipe_data_received(self, fd: int, data: bytes) -> None: ...  # undocumented\n    def _process_exited(self, returncode: int) -> None: ...  # undocumented\n    async def _wait(self) -> int: ...  # undocumented\n    def _try_finish(self) -> None: ...  # undocumented\n    def _call_connection_lost(self, exc: BaseException | None) -> None: ...  # undocumented\n\nclass WriteSubprocessPipeProto(protocols.BaseProtocol):  # undocumented\n    def __init__(self, proc: BaseSubprocessTransport, fd: int) -> None: ...\n\nclass ReadSubprocessPipeProto(WriteSubprocessPipeProto, protocols.Protocol): ...  # undocumented\n",
  "/typeshed/stdlib/asyncio/base_tasks.pyi": "from _typeshed import StrOrBytesPath\nfrom types import FrameType\nfrom typing import Any\n\nfrom . import tasks\n\ndef _task_repr_info(task: tasks.Task[Any]) -> list[str]: ...  # undocumented\ndef _task_get_stack(task: tasks.Task[Any], limit: int | None) -> list[FrameType]: ...  # undocumented\ndef _task_print_stack(task: tasks.Task[Any], limit: int | None, file: StrOrBytesPath) -> None: ...  # undocumented\n",
  "/typeshed/stdlib/asyncio/constants.pyi": "import enum\nimport sys\nfrom typing_extensions import Literal\n\nLOG_THRESHOLD_FOR_CONNLOST_WRITES: Literal[5]\nACCEPT_RETRY_DELAY: Literal[1]\nDEBUG_STACK_DEPTH: Literal[10]\nSSL_HANDSHAKE_TIMEOUT: float\nSENDFILE_FALLBACK_READBUFFER_SIZE: Literal[262144]\nif sys.version_info >= (3, 11):\n    SSL_SHUTDOWN_TIMEOUT: float\n    FLOW_CONTROL_HIGH_WATER_SSL_READ: Literal[256]\n    FLOW_CONTROL_HIGH_WATER_SSL_WRITE: Literal[512]\n\nclass _SendfileMode(enum.Enum):\n    UNSUPPORTED: int\n    TRY_NATIVE: int\n    FALLBACK: int\n",
  "/typeshed/stdlib/asyncio/coroutines.pyi": "import sys\nfrom collections.abc import Awaitable, Callable, Coroutine\nfrom typing import Any, TypeVar, overload\nfrom typing_extensions import ParamSpec, TypeGuard\n\nif sys.version_info >= (3, 11):\n    __all__ = (\"iscoroutinefunction\", \"iscoroutine\")\nelse:\n    __all__ = (\"coroutine\", \"iscoroutinefunction\", \"iscoroutine\")\n\n_T = TypeVar(\"_T\")\n_FunctionT = TypeVar(\"_FunctionT\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\nif sys.version_info < (3, 11):\n    def coroutine(func: _FunctionT) -> _FunctionT: ...\n\n@overload\ndef iscoroutinefunction(func: Callable[..., Coroutine[Any, Any, Any]]) -> bool: ...\n@overload\ndef iscoroutinefunction(func: Callable[_P, Awaitable[_T]]) -> TypeGuard[Callable[_P, Coroutine[Any, Any, _T]]]: ...\n@overload\ndef iscoroutinefunction(func: Callable[_P, object]) -> TypeGuard[Callable[_P, Coroutine[Any, Any, Any]]]: ...\n@overload\ndef iscoroutinefunction(func: object) -> TypeGuard[Callable[..., Coroutine[Any, Any, Any]]]: ...\n\n# Can actually be a generator-style coroutine on Python 3.7\ndef iscoroutine(obj: object) -> TypeGuard[Coroutine[Any, Any, Any]]: ...\n",
  "/typeshed/stdlib/asyncio/events.pyi": "import ssl\nimport sys\nfrom _typeshed import FileDescriptorLike, ReadableBuffer, StrPath, Unused, WriteableBuffer\nfrom abc import ABCMeta, abstractmethod\nfrom collections.abc import Awaitable, Callable, Coroutine, Generator, Sequence\nfrom contextvars import Context\nfrom socket import AddressFamily, SocketKind, _Address, _RetAddress, socket\nfrom typing import IO, Any, Protocol, TypeVar, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nfrom .base_events import Server\nfrom .futures import Future\nfrom .protocols import BaseProtocol\nfrom .tasks import Task\nfrom .transports import BaseTransport, DatagramTransport, ReadTransport, SubprocessTransport, Transport, WriteTransport\nfrom .unix_events import AbstractChildWatcher\n\nif sys.version_info >= (3, 8):\n    __all__ = (\n        \"AbstractEventLoopPolicy\",\n        \"AbstractEventLoop\",\n        \"AbstractServer\",\n        \"Handle\",\n        \"TimerHandle\",\n        \"get_event_loop_policy\",\n        \"set_event_loop_policy\",\n        \"get_event_loop\",\n        \"set_event_loop\",\n        \"new_event_loop\",\n        \"get_child_watcher\",\n        \"set_child_watcher\",\n        \"_set_running_loop\",\n        \"get_running_loop\",\n        \"_get_running_loop\",\n    )\n\nelse:\n    __all__ = (\n        \"AbstractEventLoopPolicy\",\n        \"AbstractEventLoop\",\n        \"AbstractServer\",\n        \"Handle\",\n        \"TimerHandle\",\n        \"SendfileNotAvailableError\",\n        \"get_event_loop_policy\",\n        \"set_event_loop_policy\",\n        \"get_event_loop\",\n        \"set_event_loop\",\n        \"new_event_loop\",\n        \"get_child_watcher\",\n        \"set_child_watcher\",\n        \"_set_running_loop\",\n        \"get_running_loop\",\n        \"_get_running_loop\",\n    )\n\n_T = TypeVar(\"_T\")\n_ProtocolT = TypeVar(\"_ProtocolT\", bound=BaseProtocol)\n_Context: TypeAlias = dict[str, Any]\n_ExceptionHandler: TypeAlias = Callable[[AbstractEventLoop, _Context], object]\n_ProtocolFactory: TypeAlias = Callable[[], BaseProtocol]\n_SSLContext: TypeAlias = bool | None | ssl.SSLContext\n\nclass _TaskFactory(Protocol):\n    def __call__(\n        self, __loop: AbstractEventLoop, __factory: Coroutine[Any, Any, _T] | Generator[Any, None, _T]\n    ) -> Future[_T]: ...\n\nclass Handle:\n    _cancelled: bool\n    _args: Sequence[Any]\n    def __init__(\n        self, callback: Callable[..., object], args: Sequence[Any], loop: AbstractEventLoop, context: Context | None = None\n    ) -> None: ...\n    def cancel(self) -> None: ...\n    def _run(self) -> None: ...\n    def cancelled(self) -> bool: ...\n\nclass TimerHandle(Handle):\n    def __init__(\n        self,\n        when: float,\n        callback: Callable[..., object],\n        args: Sequence[Any],\n        loop: AbstractEventLoop,\n        context: Context | None = None,\n    ) -> None: ...\n    def when(self) -> float: ...\n    def __lt__(self, other: TimerHandle) -> bool: ...\n    def __le__(self, other: TimerHandle) -> bool: ...\n    def __gt__(self, other: TimerHandle) -> bool: ...\n    def __ge__(self, other: TimerHandle) -> bool: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass AbstractServer:\n    @abstractmethod\n    def close(self) -> None: ...\n    async def __aenter__(self) -> Self: ...\n    async def __aexit__(self, *exc: Unused) -> None: ...\n    @abstractmethod\n    def get_loop(self) -> AbstractEventLoop: ...\n    @abstractmethod\n    def is_serving(self) -> bool: ...\n    @abstractmethod\n    async def start_serving(self) -> None: ...\n    @abstractmethod\n    async def serve_forever(self) -> None: ...\n    @abstractmethod\n    async def wait_closed(self) -> None: ...\n\nclass AbstractEventLoop:\n    slow_callback_duration: float\n    @abstractmethod\n    def run_forever(self) -> None: ...\n    # Can't use a union, see mypy issue  # 1873.\n    @overload\n    @abstractmethod\n    def run_until_complete(self, future: Generator[Any, None, _T]) -> _T: ...\n    @overload\n    @abstractmethod\n    def run_until_complete(self, future: Awaitable[_T]) -> _T: ...\n    @abstractmethod\n    def stop(self) -> None: ...\n    @abstractmethod\n    def is_running(self) -> bool: ...\n    @abstractmethod\n    def is_closed(self) -> bool: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @abstractmethod\n    async def shutdown_asyncgens(self) -> None: ...\n    # Methods scheduling callbacks.  All these return Handles.\n    if sys.version_info >= (3, 9):  # \"context\" added in 3.9.10/3.10.2\n        @abstractmethod\n        def call_soon(self, callback: Callable[..., object], *args: Any, context: Context | None = None) -> Handle: ...\n        @abstractmethod\n        def call_later(\n            self, delay: float, callback: Callable[..., object], *args: Any, context: Context | None = None\n        ) -> TimerHandle: ...\n        @abstractmethod\n        def call_at(\n            self, when: float, callback: Callable[..., object], *args: Any, context: Context | None = None\n        ) -> TimerHandle: ...\n    else:\n        @abstractmethod\n        def call_soon(self, callback: Callable[..., object], *args: Any) -> Handle: ...\n        @abstractmethod\n        def call_later(self, delay: float, callback: Callable[..., object], *args: Any) -> TimerHandle: ...\n        @abstractmethod\n        def call_at(self, when: float, callback: Callable[..., object], *args: Any) -> TimerHandle: ...\n\n    @abstractmethod\n    def time(self) -> float: ...\n    # Future methods\n    @abstractmethod\n    def create_future(self) -> Future[Any]: ...\n    # Tasks methods\n    if sys.version_info >= (3, 11):\n        @abstractmethod\n        def create_task(\n            self,\n            coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T],\n            *,\n            name: str | None = None,\n            context: Context | None = None,\n        ) -> Task[_T]: ...\n    elif sys.version_info >= (3, 8):\n        @abstractmethod\n        def create_task(\n            self, coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T], *, name: str | None = None\n        ) -> Task[_T]: ...\n    else:\n        @abstractmethod\n        def create_task(self, coro: Coroutine[Any, Any, _T] | Generator[Any, None, _T]) -> Task[_T]: ...\n\n    @abstractmethod\n    def set_task_factory(self, factory: _TaskFactory | None) -> None: ...\n    @abstractmethod\n    def get_task_factory(self) -> _TaskFactory | None: ...\n    # Methods for interacting with threads\n    if sys.version_info >= (3, 9):  # \"context\" added in 3.9.10/3.10.2\n        @abstractmethod\n        def call_soon_threadsafe(self, callback: Callable[..., object], *args: Any, context: Context | None = None) -> Handle: ...\n    else:\n        @abstractmethod\n        def call_soon_threadsafe(self, callback: Callable[..., object], *args: Any) -> Handle: ...\n\n    @abstractmethod\n    def run_in_executor(self, executor: Any, func: Callable[..., _T], *args: Any) -> Future[_T]: ...\n    @abstractmethod\n    def set_default_executor(self, executor: Any) -> None: ...\n    # Network I/O methods returning Futures.\n    @abstractmethod\n    async def getaddrinfo(\n        self,\n        host: bytes | str | None,\n        port: bytes | str | int | None,\n        *,\n        family: int = 0,\n        type: int = 0,\n        proto: int = 0,\n        flags: int = 0,\n    ) -> list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int] | tuple[str, int, int, int]]]: ...\n    @abstractmethod\n    async def getnameinfo(self, sockaddr: tuple[str, int] | tuple[str, int, int, int], flags: int = 0) -> tuple[str, str]: ...\n    if sys.version_info >= (3, 11):\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    elif sys.version_info >= (3, 8):\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            happy_eyeballs_delay: float | None = None,\n            interleave: int | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    else:\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: str = ...,\n            port: int = ...,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: None = None,\n            local_addr: tuple[str, int] | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n        @overload\n        @abstractmethod\n        async def create_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            host: None = None,\n            port: None = None,\n            *,\n            ssl: _SSLContext = None,\n            family: int = 0,\n            proto: int = 0,\n            flags: int = 0,\n            sock: socket,\n            local_addr: None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    if sys.version_info >= (3, 11):\n        @overload\n        @abstractmethod\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: str | Sequence[str] | None = None,\n            port: int = ...,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @overload\n        @abstractmethod\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: None = None,\n            port: None = None,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: socket = ...,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @abstractmethod\n        async def start_tls(\n            self,\n            transport: WriteTransport,\n            protocol: BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            *,\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> Transport: ...\n        async def create_unix_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            path: StrPath | None = None,\n            *,\n            sock: socket | None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n    else:\n        @overload\n        @abstractmethod\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: str | Sequence[str] | None = None,\n            port: int = ...,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @overload\n        @abstractmethod\n        async def create_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            host: None = None,\n            port: None = None,\n            *,\n            family: int = ...,\n            flags: int = ...,\n            sock: socket = ...,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            reuse_address: bool | None = None,\n            reuse_port: bool | None = None,\n            ssl_handshake_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n        @abstractmethod\n        async def start_tls(\n            self,\n            transport: BaseTransport,\n            protocol: BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            *,\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> Transport: ...\n        async def create_unix_server(\n            self,\n            protocol_factory: _ProtocolFactory,\n            path: StrPath | None = None,\n            *,\n            sock: socket | None = None,\n            backlog: int = 100,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n            start_serving: bool = True,\n        ) -> Server: ...\n    if sys.version_info >= (3, 11):\n        async def connect_accepted_socket(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            sock: socket,\n            *,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    elif sys.version_info >= (3, 10):\n        async def connect_accepted_socket(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            sock: socket,\n            *,\n            ssl: _SSLContext = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    if sys.version_info >= (3, 11):\n        async def create_unix_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            path: str | None = None,\n            *,\n            ssl: _SSLContext = None,\n            sock: socket | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n    else:\n        async def create_unix_connection(\n            self,\n            protocol_factory: Callable[[], _ProtocolT],\n            path: str | None = None,\n            *,\n            ssl: _SSLContext = None,\n            sock: socket | None = None,\n            server_hostname: str | None = None,\n            ssl_handshake_timeout: float | None = None,\n        ) -> tuple[Transport, _ProtocolT]: ...\n\n    @abstractmethod\n    async def sock_sendfile(\n        self, sock: socket, file: IO[bytes], offset: int = 0, count: int | None = None, *, fallback: bool | None = None\n    ) -> int: ...\n    @abstractmethod\n    async def sendfile(\n        self, transport: WriteTransport, file: IO[bytes], offset: int = 0, count: int | None = None, *, fallback: bool = True\n    ) -> int: ...\n    @abstractmethod\n    async def create_datagram_endpoint(\n        self,\n        protocol_factory: Callable[[], _ProtocolT],\n        local_addr: tuple[str, int] | str | None = None,\n        remote_addr: tuple[str, int] | str | None = None,\n        *,\n        family: int = 0,\n        proto: int = 0,\n        flags: int = 0,\n        reuse_address: bool | None = None,\n        reuse_port: bool | None = None,\n        allow_broadcast: bool | None = None,\n        sock: socket | None = None,\n    ) -> tuple[DatagramTransport, _ProtocolT]: ...\n    # Pipes and subprocesses.\n    @abstractmethod\n    async def connect_read_pipe(\n        self, protocol_factory: Callable[[], _ProtocolT], pipe: Any\n    ) -> tuple[ReadTransport, _ProtocolT]: ...\n    @abstractmethod\n    async def connect_write_pipe(\n        self, protocol_factory: Callable[[], _ProtocolT], pipe: Any\n    ) -> tuple[WriteTransport, _ProtocolT]: ...\n    @abstractmethod\n    async def subprocess_shell(\n        self,\n        protocol_factory: Callable[[], _ProtocolT],\n        cmd: bytes | str,\n        *,\n        stdin: int | IO[Any] | None = -1,\n        stdout: int | IO[Any] | None = -1,\n        stderr: int | IO[Any] | None = -1,\n        universal_newlines: Literal[False] = False,\n        shell: Literal[True] = True,\n        bufsize: Literal[0] = 0,\n        encoding: None = None,\n        errors: None = None,\n        text: Literal[False, None] = ...,\n        **kwargs: Any,\n    ) -> tuple[SubprocessTransport, _ProtocolT]: ...\n    @abstractmethod\n    async def subprocess_exec(\n        self,\n        protocol_factory: Callable[[], _ProtocolT],\n        program: Any,\n        *args: Any,\n        stdin: int | IO[Any] | None = -1,\n        stdout: int | IO[Any] | None = -1,\n        stderr: int | IO[Any] | None = -1,\n        universal_newlines: Literal[False] = False,\n        shell: Literal[False] = False,\n        bufsize: Literal[0] = 0,\n        encoding: None = None,\n        errors: None = None,\n        **kwargs: Any,\n    ) -> tuple[SubprocessTransport, _ProtocolT]: ...\n    @abstractmethod\n    def add_reader(self, fd: FileDescriptorLike, callback: Callable[..., Any], *args: Any) -> None: ...\n    @abstractmethod\n    def remove_reader(self, fd: FileDescriptorLike) -> bool: ...\n    @abstractmethod\n    def add_writer(self, fd: FileDescriptorLike, callback: Callable[..., Any], *args: Any) -> None: ...\n    @abstractmethod\n    def remove_writer(self, fd: FileDescriptorLike) -> bool: ...\n    # Completion based I/O methods returning Futures prior to 3.7\n    @abstractmethod\n    async def sock_recv(self, sock: socket, nbytes: int) -> bytes: ...\n    @abstractmethod\n    async def sock_recv_into(self, sock: socket, buf: WriteableBuffer) -> int: ...\n    @abstractmethod\n    async def sock_sendall(self, sock: socket, data: ReadableBuffer) -> None: ...\n    @abstractmethod\n    async def sock_connect(self, sock: socket, address: _Address) -> None: ...\n    @abstractmethod\n    async def sock_accept(self, sock: socket) -> tuple[socket, _RetAddress]: ...\n    if sys.version_info >= (3, 11):\n        @abstractmethod\n        async def sock_recvfrom(self, sock: socket, bufsize: int) -> tuple[bytes, _RetAddress]: ...\n        @abstractmethod\n        async def sock_recvfrom_into(self, sock: socket, buf: WriteableBuffer, nbytes: int = 0) -> tuple[int, _RetAddress]: ...\n        @abstractmethod\n        async def sock_sendto(self, sock: socket, data: ReadableBuffer, address: _Address) -> int: ...\n    # Signal handling.\n    @abstractmethod\n    def add_signal_handler(self, sig: int, callback: Callable[..., object], *args: Any) -> None: ...\n    @abstractmethod\n    def remove_signal_handler(self, sig: int) -> bool: ...\n    # Error handlers.\n    @abstractmethod\n    def set_exception_handler(self, handler: _ExceptionHandler | None) -> None: ...\n    @abstractmethod\n    def get_exception_handler(self) -> _ExceptionHandler | None: ...\n    @abstractmethod\n    def default_exception_handler(self, context: _Context) -> None: ...\n    @abstractmethod\n    def call_exception_handler(self, context: _Context) -> None: ...\n    # Debug flag management.\n    @abstractmethod\n    def get_debug(self) -> bool: ...\n    @abstractmethod\n    def set_debug(self, enabled: bool) -> None: ...\n    if sys.version_info >= (3, 9):\n        @abstractmethod\n        async def shutdown_default_executor(self) -> None: ...\n\nclass AbstractEventLoopPolicy:\n    @abstractmethod\n    def get_event_loop(self) -> AbstractEventLoop: ...\n    @abstractmethod\n    def set_event_loop(self, loop: AbstractEventLoop | None) -> None: ...\n    @abstractmethod\n    def new_event_loop(self) -> AbstractEventLoop: ...\n    # Child processes handling (Unix only).\n    @abstractmethod\n    def get_child_watcher(self) -> AbstractChildWatcher: ...\n    @abstractmethod\n    def set_child_watcher(self, watcher: AbstractChildWatcher) -> None: ...\n\nclass BaseDefaultEventLoopPolicy(AbstractEventLoopPolicy, metaclass=ABCMeta):\n    def get_event_loop(self) -> AbstractEventLoop: ...\n    def set_event_loop(self, loop: AbstractEventLoop | None) -> None: ...\n    def new_event_loop(self) -> AbstractEventLoop: ...\n\ndef get_event_loop_policy() -> AbstractEventLoopPolicy: ...\ndef set_event_loop_policy(policy: AbstractEventLoopPolicy | None) -> None: ...\ndef get_event_loop() -> AbstractEventLoop: ...\ndef set_event_loop(loop: AbstractEventLoop | None) -> None: ...\ndef new_event_loop() -> AbstractEventLoop: ...\ndef get_child_watcher() -> AbstractChildWatcher: ...\ndef set_child_watcher(watcher: AbstractChildWatcher) -> None: ...\ndef _set_running_loop(__loop: AbstractEventLoop | None) -> None: ...\ndef _get_running_loop() -> AbstractEventLoop: ...\ndef get_running_loop() -> AbstractEventLoop: ...\n\nif sys.version_info < (3, 8):\n    class SendfileNotAvailableError(RuntimeError): ...\n",
  "/typeshed/stdlib/asyncio/exceptions.pyi": "import sys\n\nif sys.version_info >= (3, 11):\n    __all__ = (\n        \"BrokenBarrierError\",\n        \"CancelledError\",\n        \"InvalidStateError\",\n        \"TimeoutError\",\n        \"IncompleteReadError\",\n        \"LimitOverrunError\",\n        \"SendfileNotAvailableError\",\n    )\nelse:\n    __all__ = (\n        \"CancelledError\",\n        \"InvalidStateError\",\n        \"TimeoutError\",\n        \"IncompleteReadError\",\n        \"LimitOverrunError\",\n        \"SendfileNotAvailableError\",\n    )\n\nclass CancelledError(BaseException): ...\nclass TimeoutError(Exception): ...\nclass InvalidStateError(Exception): ...\nclass SendfileNotAvailableError(RuntimeError): ...\n\nclass IncompleteReadError(EOFError):\n    expected: int | None\n    partial: bytes\n    def __init__(self, partial: bytes, expected: int | None) -> None: ...\n\nclass LimitOverrunError(Exception):\n    consumed: int\n    def __init__(self, message: str, consumed: int) -> None: ...\n\nif sys.version_info >= (3, 11):\n    class BrokenBarrierError(RuntimeError): ...\n",
  "/typeshed/stdlib/asyncio/format_helpers.pyi": "import functools\nimport traceback\nfrom collections.abc import Iterable\nfrom types import FrameType, FunctionType\nfrom typing import Any, overload\nfrom typing_extensions import TypeAlias\n\nclass _HasWrapper:\n    __wrapper__: _HasWrapper | FunctionType\n\n_FuncType: TypeAlias = FunctionType | _HasWrapper | functools.partial[Any] | functools.partialmethod[Any]\n\n@overload\ndef _get_function_source(func: _FuncType) -> tuple[str, int]: ...\n@overload\ndef _get_function_source(func: object) -> tuple[str, int] | None: ...\ndef _format_callback_source(func: object, args: Iterable[Any]) -> str: ...\ndef _format_args_and_kwargs(args: Iterable[Any], kwargs: dict[str, Any]) -> str: ...\ndef _format_callback(func: object, args: Iterable[Any], kwargs: dict[str, Any], suffix: str = \"\") -> str: ...\ndef extract_stack(f: FrameType | None = None, limit: int | None = None) -> traceback.StackSummary: ...\n",
  "/typeshed/stdlib/asyncio/futures.pyi": "import sys\nfrom collections.abc import Awaitable, Callable, Generator, Iterable\nfrom concurrent.futures._base import Error, Future as _ConcurrentFuture\nfrom typing import Any, TypeVar\nfrom typing_extensions import Literal, Self, TypeGuard\n\nfrom .events import AbstractEventLoop\n\nif sys.version_info < (3, 8):\n    from concurrent.futures import CancelledError as CancelledError, TimeoutError as TimeoutError\n\n    class InvalidStateError(Error): ...\n\nfrom contextvars import Context\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nif sys.version_info >= (3, 8):\n    __all__ = (\"Future\", \"wrap_future\", \"isfuture\")\nelse:\n    __all__ = (\"CancelledError\", \"TimeoutError\", \"InvalidStateError\", \"Future\", \"wrap_future\", \"isfuture\")\n\n_T = TypeVar(\"_T\")\n\n# asyncio defines 'isfuture()' in base_futures.py and re-imports it in futures.py\n# but it leads to circular import error in pytype tool.\n# That's why the import order is reversed.\ndef isfuture(obj: object) -> TypeGuard[Future[Any]]: ...\n\nclass Future(Awaitable[_T], Iterable[_T]):\n    _state: str\n    @property\n    def _exception(self) -> BaseException: ...\n    _blocking: bool\n    @property\n    def _log_traceback(self) -> bool: ...\n    @_log_traceback.setter\n    def _log_traceback(self, val: Literal[False]) -> None: ...\n    _asyncio_future_blocking: bool  # is a part of duck-typing contract for `Future`\n    def __init__(self, *, loop: AbstractEventLoop | None = ...) -> None: ...\n    def __del__(self) -> None: ...\n    def get_loop(self) -> AbstractEventLoop: ...\n    @property\n    def _callbacks(self) -> list[tuple[Callable[[Self], Any], Context]]: ...\n    def add_done_callback(self, __fn: Callable[[Self], object], *, context: Context | None = None) -> None: ...\n    if sys.version_info >= (3, 9):\n        def cancel(self, msg: Any | None = None) -> bool: ...\n    else:\n        def cancel(self) -> bool: ...\n\n    def cancelled(self) -> bool: ...\n    def done(self) -> bool: ...\n    def result(self) -> _T: ...\n    def exception(self) -> BaseException | None: ...\n    def remove_done_callback(self, __fn: Callable[[Self], object]) -> int: ...\n    def set_result(self, __result: _T) -> None: ...\n    def set_exception(self, __exception: type | BaseException) -> None: ...\n    def __iter__(self) -> Generator[Any, None, _T]: ...\n    def __await__(self) -> Generator[Any, None, _T]: ...\n    @property\n    def _loop(self) -> AbstractEventLoop: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef wrap_future(future: _ConcurrentFuture[_T] | Future[_T], *, loop: AbstractEventLoop | None = None) -> Future[_T]: ...\n",
  "/typeshed/stdlib/asyncio/locks.pyi": "import enum\nimport sys\nfrom _typeshed import Unused\nfrom collections import deque\nfrom collections.abc import Callable, Generator\nfrom types import TracebackType\nfrom typing import Any, TypeVar\nfrom typing_extensions import Literal, Self\n\nfrom .events import AbstractEventLoop\nfrom .futures import Future\n\nif sys.version_info >= (3, 11):\n    from .mixins import _LoopBoundMixin\n\nif sys.version_info >= (3, 11):\n    __all__ = (\"Lock\", \"Event\", \"Condition\", \"Semaphore\", \"BoundedSemaphore\", \"Barrier\")\nelse:\n    __all__ = (\"Lock\", \"Event\", \"Condition\", \"Semaphore\", \"BoundedSemaphore\")\n\n_T = TypeVar(\"_T\")\n\nif sys.version_info >= (3, 9):\n    class _ContextManagerMixin:\n        async def __aenter__(self) -> None: ...\n        async def __aexit__(\n            self, exc_type: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None\n        ) -> None: ...\n\nelse:\n    class _ContextManager:\n        def __init__(self, lock: Lock | Semaphore) -> None: ...\n        def __enter__(self) -> None: ...\n        def __exit__(self, *args: Unused) -> None: ...\n\n    class _ContextManagerMixin:\n        # Apparently this exists to *prohibit* use as a context manager.\n        # def __enter__(self) -> NoReturn: ... see: https://github.com/python/typing/issues/1043\n        # def __exit__(self, *args: Any) -> None: ...\n        def __iter__(self) -> Generator[Any, None, _ContextManager]: ...\n        def __await__(self) -> Generator[Any, None, _ContextManager]: ...\n        async def __aenter__(self) -> None: ...\n        async def __aexit__(\n            self, exc_type: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None\n        ) -> None: ...\n\nclass Lock(_ContextManagerMixin):\n    if sys.version_info >= (3, 10):\n        def __init__(self) -> None: ...\n    else:\n        def __init__(self, *, loop: AbstractEventLoop | None = None) -> None: ...\n\n    def locked(self) -> bool: ...\n    async def acquire(self) -> Literal[True]: ...\n    def release(self) -> None: ...\n\nclass Event:\n    if sys.version_info >= (3, 10):\n        def __init__(self) -> None: ...\n    else:\n        def __init__(self, *, loop: AbstractEventLoop | None = None) -> None: ...\n\n    def is_set(self) -> bool: ...\n    def set(self) -> None: ...\n    def clear(self) -> None: ...\n    async def wait(self) -> Literal[True]: ...\n\nclass Condition(_ContextManagerMixin):\n    if sys.version_info >= (3, 10):\n        def __init__(self, lock: Lock | None = None) -> None: ...\n    else:\n        def __init__(self, lock: Lock | None = None, *, loop: AbstractEventLoop | None = None) -> None: ...\n\n    def locked(self) -> bool: ...\n    async def acquire(self) -> Literal[True]: ...\n    def release(self) -> None: ...\n    async def wait(self) -> Literal[True]: ...\n    async def wait_for(self, predicate: Callable[[], _T]) -> _T: ...\n    def notify(self, n: int = 1) -> None: ...\n    def notify_all(self) -> None: ...\n\nclass Semaphore(_ContextManagerMixin):\n    _value: int\n    _waiters: deque[Future[Any]]\n    if sys.version_info >= (3, 10):\n        def __init__(self, value: int = 1) -> None: ...\n    else:\n        def __init__(self, value: int = 1, *, loop: AbstractEventLoop | None = None) -> None: ...\n\n    def locked(self) -> bool: ...\n    async def acquire(self) -> Literal[True]: ...\n    def release(self) -> None: ...\n    def _wake_up_next(self) -> None: ...\n\nclass BoundedSemaphore(Semaphore): ...\n\nif sys.version_info >= (3, 11):\n    class _BarrierState(enum.Enum):  # undocumented\n        FILLING: str\n        DRAINING: str\n        RESETTING: str\n        BROKEN: str\n\n    class Barrier(_LoopBoundMixin):\n        def __init__(self, parties: int) -> None: ...\n        async def __aenter__(self) -> Self: ...\n        async def __aexit__(self, *args: Unused) -> None: ...\n        async def wait(self) -> int: ...\n        async def abort(self) -> None: ...\n        async def reset(self) -> None: ...\n        @property\n        def parties(self) -> int: ...\n        @property\n        def n_waiting(self) -> int: ...\n        @property\n        def broken(self) -> bool: ...\n",
  "/typeshed/stdlib/asyncio/log.pyi": "import logging\n\nlogger: logging.Logger\n",
  "/typeshed/stdlib/asyncio/mixins.pyi": "import sys\nimport threading\nfrom typing_extensions import Never\n\n_global_lock: threading.Lock\n\nclass _LoopBoundMixin:\n    if sys.version_info < (3, 11):\n        def __init__(self, *, loop: Never = ...) -> None: ...\n",
  "/typeshed/stdlib/asyncio/proactor_events.pyi": "import sys\nfrom collections.abc import Mapping\nfrom socket import socket\nfrom typing import Any, ClassVar, Protocol\nfrom typing_extensions import Literal\n\nfrom . import base_events, constants, events, futures, streams, transports\n\n__all__ = (\"BaseProactorEventLoop\",)\n\nif sys.version_info >= (3, 8):\n    class _WarnCallbackProtocol(Protocol):\n        def __call__(\n            self, message: str, category: type[Warning] | None = ..., stacklevel: int = ..., source: Any | None = ...\n        ) -> object: ...\n\nclass _ProactorBasePipeTransport(transports._FlowControlMixin, transports.BaseTransport):\n    def __init__(\n        self,\n        loop: events.AbstractEventLoop,\n        sock: socket,\n        protocol: streams.StreamReaderProtocol,\n        waiter: futures.Future[Any] | None = None,\n        extra: Mapping[Any, Any] | None = None,\n        server: events.AbstractServer | None = None,\n    ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def __del__(self, _warn: _WarnCallbackProtocol = ...) -> None: ...\n    else:\n        def __del__(self) -> None: ...\n\nclass _ProactorReadPipeTransport(_ProactorBasePipeTransport, transports.ReadTransport):\n    if sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            loop: events.AbstractEventLoop,\n            sock: socket,\n            protocol: streams.StreamReaderProtocol,\n            waiter: futures.Future[Any] | None = None,\n            extra: Mapping[Any, Any] | None = None,\n            server: events.AbstractServer | None = None,\n            buffer_size: int = 65536,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            loop: events.AbstractEventLoop,\n            sock: socket,\n            protocol: streams.StreamReaderProtocol,\n            waiter: futures.Future[Any] | None = None,\n            extra: Mapping[Any, Any] | None = None,\n            server: events.AbstractServer | None = None,\n        ) -> None: ...\n\nclass _ProactorBaseWritePipeTransport(_ProactorBasePipeTransport, transports.WriteTransport): ...\nclass _ProactorWritePipeTransport(_ProactorBaseWritePipeTransport): ...\nclass _ProactorDuplexPipeTransport(_ProactorReadPipeTransport, _ProactorBaseWritePipeTransport, transports.Transport): ...\n\nclass _ProactorSocketTransport(_ProactorReadPipeTransport, _ProactorBaseWritePipeTransport, transports.Transport):\n    _sendfile_compatible: ClassVar[constants._SendfileMode]\n    def __init__(\n        self,\n        loop: events.AbstractEventLoop,\n        sock: socket,\n        protocol: streams.StreamReaderProtocol,\n        waiter: futures.Future[Any] | None = None,\n        extra: Mapping[Any, Any] | None = None,\n        server: events.AbstractServer | None = None,\n    ) -> None: ...\n    def _set_extra(self, sock: socket) -> None: ...\n    def can_write_eof(self) -> Literal[True]: ...\n\nclass BaseProactorEventLoop(base_events.BaseEventLoop):\n    def __init__(self, proactor: Any) -> None: ...\n",
  "/typeshed/stdlib/asyncio/protocols.pyi": "from _typeshed import ReadableBuffer\nfrom asyncio import transports\nfrom typing import Any\n\n__all__ = (\"BaseProtocol\", \"Protocol\", \"DatagramProtocol\", \"SubprocessProtocol\", \"BufferedProtocol\")\n\nclass BaseProtocol:\n    def connection_made(self, transport: transports.BaseTransport) -> None: ...\n    def connection_lost(self, exc: Exception | None) -> None: ...\n    def pause_writing(self) -> None: ...\n    def resume_writing(self) -> None: ...\n\nclass Protocol(BaseProtocol):\n    def data_received(self, data: bytes) -> None: ...\n    def eof_received(self) -> bool | None: ...\n\nclass BufferedProtocol(BaseProtocol):\n    def get_buffer(self, sizehint: int) -> ReadableBuffer: ...\n    def buffer_updated(self, nbytes: int) -> None: ...\n    def eof_received(self) -> bool | None: ...\n\nclass DatagramProtocol(BaseProtocol):\n    def connection_made(self, transport: transports.DatagramTransport) -> None: ...  # type: ignore[override]\n    # addr can be a tuple[int, int] for some unusual protocols like socket.AF_NETLINK.\n    # Use tuple[str | Any, int] to not cause typechecking issues on most usual cases.\n    # This could be improved by using tuple[AnyOf[str, int], int] if the AnyOf feature is accepted.\n    # See https://github.com/python/typing/issues/566\n    def datagram_received(self, data: bytes, addr: tuple[str | Any, int]) -> None: ...\n    def error_received(self, exc: Exception) -> None: ...\n\nclass SubprocessProtocol(BaseProtocol):\n    def pipe_data_received(self, fd: int, data: bytes) -> None: ...\n    def pipe_connection_lost(self, fd: int, exc: Exception | None) -> None: ...\n    def process_exited(self) -> None: ...\n",
  "/typeshed/stdlib/asyncio/queues.pyi": "import sys\nfrom asyncio.events import AbstractEventLoop\nfrom typing import Any, Generic, TypeVar\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = (\"Queue\", \"PriorityQueue\", \"LifoQueue\", \"QueueFull\", \"QueueEmpty\")\n\nclass QueueEmpty(Exception): ...\nclass QueueFull(Exception): ...\n\n_T = TypeVar(\"_T\")\n\nclass Queue(Generic[_T]):\n    if sys.version_info >= (3, 10):\n        def __init__(self, maxsize: int = 0) -> None: ...\n    else:\n        def __init__(self, maxsize: int = 0, *, loop: AbstractEventLoop | None = None) -> None: ...\n\n    def _init(self, maxsize: int) -> None: ...\n    def _get(self) -> _T: ...\n    def _put(self, item: _T) -> None: ...\n    def _format(self) -> str: ...\n    def qsize(self) -> int: ...\n    @property\n    def maxsize(self) -> int: ...\n    def empty(self) -> bool: ...\n    def full(self) -> bool: ...\n    async def put(self, item: _T) -> None: ...\n    def put_nowait(self, item: _T) -> None: ...\n    async def get(self) -> _T: ...\n    def get_nowait(self) -> _T: ...\n    async def join(self) -> None: ...\n    def task_done(self) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, type: Any) -> GenericAlias: ...\n\nclass PriorityQueue(Queue[_T]): ...\nclass LifoQueue(Queue[_T]): ...\n",
  "/typeshed/stdlib/asyncio/runners.pyi": "import sys\nfrom _typeshed import Unused\nfrom collections.abc import Callable, Coroutine\nfrom contextvars import Context\nfrom typing import Any, TypeVar\nfrom typing_extensions import Self, final\n\nfrom .events import AbstractEventLoop\n\nif sys.version_info >= (3, 11):\n    __all__ = (\"Runner\", \"run\")\nelse:\n    __all__ = (\"run\",)\n_T = TypeVar(\"_T\")\n\nif sys.version_info >= (3, 11):\n    @final\n    class Runner:\n        def __init__(self, *, debug: bool | None = None, loop_factory: Callable[[], AbstractEventLoop] | None = None) -> None: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(self, exc_type: Unused, exc_val: Unused, exc_tb: Unused) -> None: ...\n        def close(self) -> None: ...\n        def get_loop(self) -> AbstractEventLoop: ...\n        def run(self, coro: Coroutine[Any, Any, _T], *, context: Context | None = None) -> _T: ...\n\nif sys.version_info >= (3, 12):\n    def run(\n        main: Coroutine[Any, Any, _T], *, debug: bool | None = ..., loop_factory: Callable[[], AbstractEventLoop] | None = ...\n    ) -> _T: ...\n\nelif sys.version_info >= (3, 8):\n    def run(main: Coroutine[Any, Any, _T], *, debug: bool | None = None) -> _T: ...\n\nelse:\n    def run(main: Coroutine[Any, Any, _T], *, debug: bool = False) -> _T: ...\n",
  "/typeshed/stdlib/asyncio/selector_events.pyi": "import selectors\n\nfrom . import base_events\n\n__all__ = (\"BaseSelectorEventLoop\",)\n\nclass BaseSelectorEventLoop(base_events.BaseEventLoop):\n    def __init__(self, selector: selectors.BaseSelector | None = None) -> None: ...\n",
  "/typeshed/stdlib/asyncio/sslproto.pyi": "import ssl\nimport sys\nfrom collections import deque\nfrom collections.abc import Callable\nfrom enum import Enum\nfrom typing import Any, ClassVar\nfrom typing_extensions import Literal, TypeAlias\n\nfrom . import constants, events, futures, protocols, transports\n\ndef _create_transport_context(server_side: bool, server_hostname: str | None) -> ssl.SSLContext: ...\n\nif sys.version_info >= (3, 11):\n    SSLAgainErrors: tuple[type[ssl.SSLWantReadError], type[ssl.SSLSyscallError]]\n\n    class SSLProtocolState(Enum):\n        UNWRAPPED: str\n        DO_HANDSHAKE: str\n        WRAPPED: str\n        FLUSHING: str\n        SHUTDOWN: str\n\n    class AppProtocolState(Enum):\n        STATE_INIT: str\n        STATE_CON_MADE: str\n        STATE_EOF: str\n        STATE_CON_LOST: str\n    def add_flowcontrol_defaults(high: int | None, low: int | None, kb: int) -> tuple[int, int]: ...\n\nelse:\n    _UNWRAPPED: Literal[\"UNWRAPPED\"]\n    _DO_HANDSHAKE: Literal[\"DO_HANDSHAKE\"]\n    _WRAPPED: Literal[\"WRAPPED\"]\n    _SHUTDOWN: Literal[\"SHUTDOWN\"]\n\nif sys.version_info < (3, 11):\n    class _SSLPipe:\n        max_size: ClassVar[int]\n\n        _context: ssl.SSLContext\n        _server_side: bool\n        _server_hostname: str | None\n        _state: str\n        _incoming: ssl.MemoryBIO\n        _outgoing: ssl.MemoryBIO\n        _sslobj: ssl.SSLObject | None\n        _need_ssldata: bool\n        _handshake_cb: Callable[[BaseException | None], None] | None\n        _shutdown_cb: Callable[[], None] | None\n        def __init__(self, context: ssl.SSLContext, server_side: bool, server_hostname: str | None = None) -> None: ...\n        @property\n        def context(self) -> ssl.SSLContext: ...\n        @property\n        def ssl_object(self) -> ssl.SSLObject | None: ...\n        @property\n        def need_ssldata(self) -> bool: ...\n        @property\n        def wrapped(self) -> bool: ...\n        def do_handshake(self, callback: Callable[[BaseException | None], object] | None = None) -> list[bytes]: ...\n        def shutdown(self, callback: Callable[[], object] | None = None) -> list[bytes]: ...\n        def feed_eof(self) -> None: ...\n        def feed_ssldata(self, data: bytes, only_handshake: bool = False) -> tuple[list[bytes], list[bytes]]: ...\n        def feed_appdata(self, data: bytes, offset: int = 0) -> tuple[list[bytes], int]: ...\n\nclass _SSLProtocolTransport(transports._FlowControlMixin, transports.Transport):\n    _sendfile_compatible: ClassVar[constants._SendfileMode]\n\n    _loop: events.AbstractEventLoop\n    _ssl_protocol: SSLProtocol\n    _closed: bool\n    def __init__(self, loop: events.AbstractEventLoop, ssl_protocol: SSLProtocol) -> None: ...\n    def get_extra_info(self, name: str, default: Any | None = None) -> dict[str, Any]: ...\n    @property\n    def _protocol_paused(self) -> bool: ...\n    def write(self, data: bytes | bytearray | memoryview) -> None: ...\n    def can_write_eof(self) -> Literal[False]: ...\n    if sys.version_info >= (3, 11):\n        def get_write_buffer_limits(self) -> tuple[int, int]: ...\n        def get_read_buffer_limits(self) -> tuple[int, int]: ...\n        def set_read_buffer_limits(self, high: int | None = None, low: int | None = None) -> None: ...\n        def get_read_buffer_size(self) -> int: ...\n\nif sys.version_info >= (3, 11):\n    _SSLProtocolBase: TypeAlias = protocols.BufferedProtocol\nelse:\n    _SSLProtocolBase: TypeAlias = protocols.Protocol\n\nclass SSLProtocol(_SSLProtocolBase):\n    _server_side: bool\n    _server_hostname: str | None\n    _sslcontext: ssl.SSLContext\n    _extra: dict[str, Any]\n    _write_backlog: deque[tuple[bytes, int]]\n    _write_buffer_size: int\n    _waiter: futures.Future[Any]\n    _loop: events.AbstractEventLoop\n    _app_transport: _SSLProtocolTransport\n    _transport: transports.BaseTransport | None\n    _ssl_handshake_timeout: int | None\n    _app_protocol: protocols.BaseProtocol\n    _app_protocol_is_buffer: bool\n\n    if sys.version_info >= (3, 11):\n        max_size: ClassVar[int]\n    else:\n        _sslpipe: _SSLPipe | None\n        _session_established: bool\n        _call_connection_made: bool\n        _in_handshake: bool\n        _in_shutdown: bool\n\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            loop: events.AbstractEventLoop,\n            app_protocol: protocols.BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            waiter: futures.Future[Any],\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            call_connection_made: bool = True,\n            ssl_handshake_timeout: int | None = None,\n            ssl_shutdown_timeout: float | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            loop: events.AbstractEventLoop,\n            app_protocol: protocols.BaseProtocol,\n            sslcontext: ssl.SSLContext,\n            waiter: futures.Future[Any],\n            server_side: bool = False,\n            server_hostname: str | None = None,\n            call_connection_made: bool = True,\n            ssl_handshake_timeout: int | None = None,\n        ) -> None: ...\n\n    def _set_app_protocol(self, app_protocol: protocols.BaseProtocol) -> None: ...\n    def _wakeup_waiter(self, exc: BaseException | None = None) -> None: ...\n    def connection_lost(self, exc: BaseException | None) -> None: ...\n    def eof_received(self) -> None: ...\n    def _get_extra_info(self, name: str, default: Any | None = None) -> Any: ...\n    def _start_shutdown(self) -> None: ...\n    if sys.version_info >= (3, 11):\n        def _write_appdata(self, list_of_data: list[bytes]) -> None: ...\n    else:\n        def _write_appdata(self, data: bytes) -> None: ...\n\n    def _start_handshake(self) -> None: ...\n    def _check_handshake_timeout(self) -> None: ...\n    def _on_handshake_complete(self, handshake_exc: BaseException | None) -> None: ...\n    def _fatal_error(self, exc: BaseException, message: str = \"Fatal error on transport\") -> None: ...\n    def _abort(self) -> None: ...\n    if sys.version_info >= (3, 11):\n        def get_buffer(self, n: int) -> memoryview: ...\n    else:\n        def _finalize(self) -> None: ...\n        def _process_write_backlog(self) -> None: ...\n",
  "/typeshed/stdlib/asyncio/staggered.pyi": "from collections.abc import Awaitable, Callable, Iterable\nfrom typing import Any\n\nfrom . import events\n\n__all__ = (\"staggered_race\",)\n\nasync def staggered_race(\n    coro_fns: Iterable[Callable[[], Awaitable[Any]]], delay: float | None, *, loop: events.AbstractEventLoop | None = None\n) -> tuple[Any, int | None, list[Exception | None]]: ...\n",
  "/typeshed/stdlib/asyncio/streams.pyi": "import ssl\nimport sys\nfrom _typeshed import StrPath\nfrom collections.abc import AsyncIterator, Awaitable, Callable, Iterable, Sequence\nfrom typing import Any\nfrom typing_extensions import Self, SupportsIndex, TypeAlias\n\nfrom . import events, protocols, transports\nfrom .base_events import Server\n\nif sys.platform == \"win32\":\n    if sys.version_info >= (3, 8):\n        __all__ = (\"StreamReader\", \"StreamWriter\", \"StreamReaderProtocol\", \"open_connection\", \"start_server\")\n    else:\n        __all__ = (\n            \"StreamReader\",\n            \"StreamWriter\",\n            \"StreamReaderProtocol\",\n            \"open_connection\",\n            \"start_server\",\n            \"IncompleteReadError\",\n            \"LimitOverrunError\",\n        )\nelse:\n    if sys.version_info >= (3, 8):\n        __all__ = (\n            \"StreamReader\",\n            \"StreamWriter\",\n            \"StreamReaderProtocol\",\n            \"open_connection\",\n            \"start_server\",\n            \"open_unix_connection\",\n            \"start_unix_server\",\n        )\n    else:\n        __all__ = (\n            \"StreamReader\",\n            \"StreamWriter\",\n            \"StreamReaderProtocol\",\n            \"open_connection\",\n            \"start_server\",\n            \"IncompleteReadError\",\n            \"LimitOverrunError\",\n            \"open_unix_connection\",\n            \"start_unix_server\",\n        )\n\n_ClientConnectedCallback: TypeAlias = Callable[[StreamReader, StreamWriter], Awaitable[None] | None]\n\nif sys.version_info < (3, 8):\n    class IncompleteReadError(EOFError):\n        expected: int | None\n        partial: bytes\n        def __init__(self, partial: bytes, expected: int | None) -> None: ...\n\n    class LimitOverrunError(Exception):\n        consumed: int\n        def __init__(self, message: str, consumed: int) -> None: ...\n\nif sys.version_info >= (3, 10):\n    async def open_connection(\n        host: str | None = None,\n        port: int | str | None = None,\n        *,\n        limit: int = 65536,\n        ssl_handshake_timeout: float | None = ...,\n        **kwds: Any,\n    ) -> tuple[StreamReader, StreamWriter]: ...\n    async def start_server(\n        client_connected_cb: _ClientConnectedCallback,\n        host: str | Sequence[str] | None = None,\n        port: int | str | None = None,\n        *,\n        limit: int = 65536,\n        ssl_handshake_timeout: float | None = ...,\n        **kwds: Any,\n    ) -> Server: ...\n\nelse:\n    async def open_connection(\n        host: str | None = None,\n        port: int | str | None = None,\n        *,\n        loop: events.AbstractEventLoop | None = None,\n        limit: int = 65536,\n        ssl_handshake_timeout: float | None = ...,\n        **kwds: Any,\n    ) -> tuple[StreamReader, StreamWriter]: ...\n    async def start_server(\n        client_connected_cb: _ClientConnectedCallback,\n        host: str | None = None,\n        port: int | str | None = None,\n        *,\n        loop: events.AbstractEventLoop | None = None,\n        limit: int = 65536,\n        ssl_handshake_timeout: float | None = ...,\n        **kwds: Any,\n    ) -> Server: ...\n\nif sys.platform != \"win32\":\n    if sys.version_info >= (3, 10):\n        async def open_unix_connection(\n            path: StrPath | None = None, *, limit: int = 65536, **kwds: Any\n        ) -> tuple[StreamReader, StreamWriter]: ...\n        async def start_unix_server(\n            client_connected_cb: _ClientConnectedCallback, path: StrPath | None = None, *, limit: int = 65536, **kwds: Any\n        ) -> Server: ...\n    else:\n        async def open_unix_connection(\n            path: StrPath | None = None, *, loop: events.AbstractEventLoop | None = None, limit: int = 65536, **kwds: Any\n        ) -> tuple[StreamReader, StreamWriter]: ...\n        async def start_unix_server(\n            client_connected_cb: _ClientConnectedCallback,\n            path: StrPath | None = None,\n            *,\n            loop: events.AbstractEventLoop | None = None,\n            limit: int = 65536,\n            **kwds: Any,\n        ) -> Server: ...\n\nclass FlowControlMixin(protocols.Protocol):\n    def __init__(self, loop: events.AbstractEventLoop | None = None) -> None: ...\n\nclass StreamReaderProtocol(FlowControlMixin, protocols.Protocol):\n    def __init__(\n        self,\n        stream_reader: StreamReader,\n        client_connected_cb: _ClientConnectedCallback | None = None,\n        loop: events.AbstractEventLoop | None = None,\n    ) -> None: ...\n\nclass StreamWriter:\n    def __init__(\n        self,\n        transport: transports.WriteTransport,\n        protocol: protocols.BaseProtocol,\n        reader: StreamReader | None,\n        loop: events.AbstractEventLoop,\n    ) -> None: ...\n    @property\n    def transport(self) -> transports.WriteTransport: ...\n    def write(self, data: bytes | bytearray | memoryview) -> None: ...\n    def writelines(self, data: Iterable[bytes | bytearray | memoryview]) -> None: ...\n    def write_eof(self) -> None: ...\n    def can_write_eof(self) -> bool: ...\n    def close(self) -> None: ...\n    def is_closing(self) -> bool: ...\n    async def wait_closed(self) -> None: ...\n    def get_extra_info(self, name: str, default: Any = None) -> Any: ...\n    async def drain(self) -> None: ...\n    if sys.version_info >= (3, 11):\n        async def start_tls(\n            self, sslcontext: ssl.SSLContext, *, server_hostname: str | None = None, ssl_handshake_timeout: float | None = None\n        ) -> None: ...\n\nclass StreamReader(AsyncIterator[bytes]):\n    def __init__(self, limit: int = 65536, loop: events.AbstractEventLoop | None = None) -> None: ...\n    def exception(self) -> Exception: ...\n    def set_exception(self, exc: Exception) -> None: ...\n    def set_transport(self, transport: transports.BaseTransport) -> None: ...\n    def feed_eof(self) -> None: ...\n    def at_eof(self) -> bool: ...\n    def feed_data(self, data: Iterable[SupportsIndex]) -> None: ...\n    async def readline(self) -> bytes: ...\n    # Can be any buffer that supports len(); consider changing to a Protocol if PEP 688 is accepted\n    async def readuntil(self, separator: bytes | bytearray | memoryview = b\"\\n\") -> bytes: ...\n    async def read(self, n: int = -1) -> bytes: ...\n    async def readexactly(self, n: int) -> bytes: ...\n    def __aiter__(self) -> Self: ...\n    async def __anext__(self) -> bytes: ...\n",
  "/typeshed/stdlib/asyncio/taskgroups.pyi": "# This only exists in 3.11+. See VERSIONS.\n\nfrom collections.abc import Coroutine, Generator\nfrom contextvars import Context\nfrom types import TracebackType\nfrom typing import Any, TypeVar\nfrom typing_extensions import Self\n\nfrom .tasks import Task\n\n__all__ = [\"TaskGroup\"]\n\n_T = TypeVar(\"_T\")\n\nclass TaskGroup:\n    async def __aenter__(self) -> Self: ...\n    async def __aexit__(self, et: type[BaseException] | None, exc: BaseException | None, tb: TracebackType | None) -> None: ...\n    def create_task(\n        self, coro: Generator[Any, None, _T] | Coroutine[Any, Any, _T], *, name: str | None = None, context: Context | None = None\n    ) -> Task[_T]: ...\n",
  "/typeshed/stdlib/asyncio/tasks.pyi": "import concurrent.futures\nimport sys\nfrom collections.abc import Awaitable, Coroutine, Generator, Iterable, Iterator\nfrom types import FrameType\nfrom typing import Any, Generic, TextIO, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias\n\nfrom .events import AbstractEventLoop\nfrom .futures import Future\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\nif sys.version_info >= (3, 11):\n    from contextvars import Context\n\n__all__ = (\n    \"Task\",\n    \"create_task\",\n    \"FIRST_COMPLETED\",\n    \"FIRST_EXCEPTION\",\n    \"ALL_COMPLETED\",\n    \"wait\",\n    \"wait_for\",\n    \"as_completed\",\n    \"sleep\",\n    \"gather\",\n    \"shield\",\n    \"ensure_future\",\n    \"run_coroutine_threadsafe\",\n    \"current_task\",\n    \"all_tasks\",\n    \"_register_task\",\n    \"_unregister_task\",\n    \"_enter_task\",\n    \"_leave_task\",\n)\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_FT = TypeVar(\"_FT\", bound=Future[Any])\n_FutureLike: TypeAlias = Future[_T] | Generator[Any, None, _T] | Awaitable[_T]\n_TaskYieldType: TypeAlias = Future[object] | None\n\nFIRST_COMPLETED = concurrent.futures.FIRST_COMPLETED\nFIRST_EXCEPTION = concurrent.futures.FIRST_EXCEPTION\nALL_COMPLETED = concurrent.futures.ALL_COMPLETED\n\nif sys.version_info >= (3, 10):\n    def as_completed(fs: Iterable[_FutureLike[_T]], *, timeout: float | None = None) -> Iterator[Future[_T]]: ...\n\nelse:\n    def as_completed(\n        fs: Iterable[_FutureLike[_T]], *, loop: AbstractEventLoop | None = None, timeout: float | None = None\n    ) -> Iterator[Future[_T]]: ...\n\n@overload\ndef ensure_future(coro_or_future: _FT, *, loop: AbstractEventLoop | None = None) -> _FT: ...  # type: ignore[misc]\n@overload\ndef ensure_future(coro_or_future: Awaitable[_T], *, loop: AbstractEventLoop | None = None) -> Task[_T]: ...\n\n# `gather()` actually returns a list with length equal to the number\n# of tasks passed; however, Tuple is used similar to the annotation for\n# zip() because typing does not support variadic type variables.  See\n# typing PR #1550 for discussion.\n#\n# The many type: ignores here are because the overloads overlap,\n# but having overlapping overloads is the only way to get acceptable type inference in all edge cases.\nif sys.version_info >= (3, 10):\n    @overload\n    def gather(__coro_or_future1: _FutureLike[_T1], *, return_exceptions: Literal[False] = False) -> Future[tuple[_T1]]: ...  # type: ignore[misc]\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1], __coro_or_future2: _FutureLike[_T2], *, return_exceptions: Literal[False] = False\n    ) -> Future[tuple[_T1, _T2]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        *,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        *,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        __coro_or_future5: _FutureLike[_T5],\n        *,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def gather(__coro_or_future1: _FutureLike[_T1], *, return_exceptions: bool) -> Future[tuple[_T1 | BaseException]]: ...  # type: ignore[misc]\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1], __coro_or_future2: _FutureLike[_T2], *, return_exceptions: bool\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        *,\n        return_exceptions: bool,\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        *,\n        return_exceptions: bool,\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        __coro_or_future5: _FutureLike[_T5],\n        *,\n        return_exceptions: bool,\n    ) -> Future[\n        tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException, _T5 | BaseException]\n    ]: ...\n    @overload\n    def gather(*coros_or_futures: _FutureLike[Any], return_exceptions: bool = False) -> Future[list[Any]]: ...\n\nelse:\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1], *, loop: AbstractEventLoop | None = None, return_exceptions: Literal[False] = False\n    ) -> Future[tuple[_T1]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        __coro_or_future5: _FutureLike[_T5],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: Literal[False] = False,\n    ) -> Future[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1], *, loop: AbstractEventLoop | None = None, return_exceptions: bool\n    ) -> Future[tuple[_T1 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: bool,\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: bool,\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: bool,\n    ) -> Future[tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException]]: ...\n    @overload\n    def gather(  # type: ignore[misc]\n        __coro_or_future1: _FutureLike[_T1],\n        __coro_or_future2: _FutureLike[_T2],\n        __coro_or_future3: _FutureLike[_T3],\n        __coro_or_future4: _FutureLike[_T4],\n        __coro_or_future5: _FutureLike[_T5],\n        *,\n        loop: AbstractEventLoop | None = None,\n        return_exceptions: bool,\n    ) -> Future[\n        tuple[_T1 | BaseException, _T2 | BaseException, _T3 | BaseException, _T4 | BaseException, _T5 | BaseException]\n    ]: ...\n    @overload\n    def gather(\n        *coros_or_futures: _FutureLike[Any], loop: AbstractEventLoop | None = None, return_exceptions: bool = False\n    ) -> Future[list[Any]]: ...\n\ndef run_coroutine_threadsafe(coro: _FutureLike[_T], loop: AbstractEventLoop) -> concurrent.futures.Future[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def shield(arg: _FutureLike[_T]) -> Future[_T]: ...\n    @overload\n    async def sleep(delay: float) -> None: ...\n    @overload\n    async def sleep(delay: float, result: _T) -> _T: ...\n    @overload\n    async def wait(fs: Iterable[_FT], *, timeout: float | None = None, return_when: str = \"ALL_COMPLETED\") -> tuple[set[_FT], set[_FT]]: ...  # type: ignore[misc]\n    @overload\n    async def wait(\n        fs: Iterable[Awaitable[_T]], *, timeout: float | None = None, return_when: str = \"ALL_COMPLETED\"\n    ) -> tuple[set[Task[_T]], set[Task[_T]]]: ...\n    async def wait_for(fut: _FutureLike[_T], timeout: float | None) -> _T: ...\n\nelse:\n    def shield(arg: _FutureLike[_T], *, loop: AbstractEventLoop | None = None) -> Future[_T]: ...\n    @overload\n    async def sleep(delay: float, *, loop: AbstractEventLoop | None = None) -> None: ...\n    @overload\n    async def sleep(delay: float, result: _T, *, loop: AbstractEventLoop | None = None) -> _T: ...\n    @overload\n    async def wait(  # type: ignore[misc]\n        fs: Iterable[_FT],\n        *,\n        loop: AbstractEventLoop | None = None,\n        timeout: float | None = None,\n        return_when: str = \"ALL_COMPLETED\",\n    ) -> tuple[set[_FT], set[_FT]]: ...\n    @overload\n    async def wait(\n        fs: Iterable[Awaitable[_T]],\n        *,\n        loop: AbstractEventLoop | None = None,\n        timeout: float | None = None,\n        return_when: str = \"ALL_COMPLETED\",\n    ) -> tuple[set[Task[_T]], set[Task[_T]]]: ...\n    async def wait_for(fut: _FutureLike[_T], timeout: float | None, *, loop: AbstractEventLoop | None = None) -> _T: ...\n\n# mypy and pyright complain that a subclass of an invariant class shouldn't be covariant.\n# While this is true in general, here it's sort-of okay to have a covariant subclass,\n# since the only reason why `asyncio.Future` is invariant is the `set_result()` method,\n# and `asyncio.Task.set_result()` always raises.\nclass Task(Future[_T_co], Generic[_T_co]):  # type: ignore[type-var]  # pyright: ignore[reportGeneralTypeIssues]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            coro: Generator[_TaskYieldType, None, _T_co] | Awaitable[_T_co],\n            *,\n            loop: AbstractEventLoop = ...,\n            name: str | None = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self, coro: Generator[_TaskYieldType, None, _T_co] | Awaitable[_T_co], *, loop: AbstractEventLoop = ...\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def get_coro(self) -> Generator[_TaskYieldType, None, _T_co] | Awaitable[_T_co]: ...\n        def get_name(self) -> str: ...\n        def set_name(self, __value: object) -> None: ...\n\n    def get_stack(self, *, limit: int | None = None) -> list[FrameType]: ...\n    def print_stack(self, *, limit: int | None = None, file: TextIO | None = None) -> None: ...\n    if sys.version_info >= (3, 11):\n        def cancelling(self) -> int: ...\n        def uncancel(self) -> int: ...\n    if sys.version_info < (3, 9):\n        @classmethod\n        def current_task(cls, loop: AbstractEventLoop | None = None) -> Task[Any] | None: ...\n        @classmethod\n        def all_tasks(cls, loop: AbstractEventLoop | None = None) -> set[Task[Any]]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef all_tasks(loop: AbstractEventLoop | None = None) -> set[Task[Any]]: ...\n\nif sys.version_info >= (3, 11):\n    def create_task(\n        coro: Generator[Any, None, _T] | Coroutine[Any, Any, _T], *, name: str | None = None, context: Context | None = None\n    ) -> Task[_T]: ...\n\nelif sys.version_info >= (3, 8):\n    def create_task(coro: Generator[Any, None, _T] | Coroutine[Any, Any, _T], *, name: str | None = None) -> Task[_T]: ...\n\nelse:\n    def create_task(coro: Generator[Any, None, _T] | Coroutine[Any, Any, _T]) -> Task[_T]: ...\n\ndef current_task(loop: AbstractEventLoop | None = None) -> Task[Any] | None: ...\ndef _enter_task(loop: AbstractEventLoop, task: Task[Any]) -> None: ...\ndef _leave_task(loop: AbstractEventLoop, task: Task[Any]) -> None: ...\ndef _register_task(task: Task[Any]) -> None: ...\ndef _unregister_task(task: Task[Any]) -> None: ...\n",
  "/typeshed/stdlib/asyncio/threads.pyi": "from collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\n\n__all__ = (\"to_thread\",)\n_P = ParamSpec(\"_P\")\n_R = TypeVar(\"_R\")\n\nasync def to_thread(__func: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R: ...\n",
  "/typeshed/stdlib/asyncio/timeouts.pyi": "from types import TracebackType\nfrom typing_extensions import Self, final\n\n__all__ = (\"Timeout\", \"timeout\", \"timeout_at\")\n\n@final\nclass Timeout:\n    def __init__(self, when: float | None) -> None: ...\n    def when(self) -> float | None: ...\n    def reschedule(self, when: float | None) -> None: ...\n    def expired(self) -> bool: ...\n    async def __aenter__(self) -> Self: ...\n    async def __aexit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n\ndef timeout(delay: float | None) -> Timeout: ...\ndef timeout_at(when: float | None) -> Timeout: ...\n",
  "/typeshed/stdlib/asyncio/transports.pyi": "from asyncio.events import AbstractEventLoop\nfrom asyncio.protocols import BaseProtocol\nfrom collections.abc import Iterable, Mapping\nfrom socket import _Address\nfrom typing import Any\n\n__all__ = (\"BaseTransport\", \"ReadTransport\", \"WriteTransport\", \"Transport\", \"DatagramTransport\", \"SubprocessTransport\")\n\nclass BaseTransport:\n    def __init__(self, extra: Mapping[str, Any] | None = None) -> None: ...\n    def get_extra_info(self, name: str, default: Any = None) -> Any: ...\n    def is_closing(self) -> bool: ...\n    def close(self) -> None: ...\n    def set_protocol(self, protocol: BaseProtocol) -> None: ...\n    def get_protocol(self) -> BaseProtocol: ...\n\nclass ReadTransport(BaseTransport):\n    def is_reading(self) -> bool: ...\n    def pause_reading(self) -> None: ...\n    def resume_reading(self) -> None: ...\n\nclass WriteTransport(BaseTransport):\n    def set_write_buffer_limits(self, high: int | None = None, low: int | None = None) -> None: ...\n    def get_write_buffer_size(self) -> int: ...\n    def get_write_buffer_limits(self) -> tuple[int, int]: ...\n    def write(self, data: bytes | bytearray | memoryview) -> None: ...\n    def writelines(self, list_of_data: Iterable[bytes | bytearray | memoryview]) -> None: ...\n    def write_eof(self) -> None: ...\n    def can_write_eof(self) -> bool: ...\n    def abort(self) -> None: ...\n\nclass Transport(ReadTransport, WriteTransport): ...\n\nclass DatagramTransport(BaseTransport):\n    def sendto(self, data: bytes | bytearray | memoryview, addr: _Address | None = None) -> None: ...\n    def abort(self) -> None: ...\n\nclass SubprocessTransport(BaseTransport):\n    def get_pid(self) -> int: ...\n    def get_returncode(self) -> int | None: ...\n    def get_pipe_transport(self, fd: int) -> BaseTransport | None: ...\n    def send_signal(self, signal: int) -> None: ...\n    def terminate(self) -> None: ...\n    def kill(self) -> None: ...\n\nclass _FlowControlMixin(Transport):\n    def __init__(self, extra: Mapping[str, Any] | None = None, loop: AbstractEventLoop | None = None) -> None: ...\n",
  "/typeshed/stdlib/asyncio/trsock.pyi": "import socket\nimport sys\nfrom _typeshed import ReadableBuffer\nfrom builtins import type as Type  # alias to avoid name clashes with property named \"type\"\nfrom collections.abc import Iterable\nfrom types import TracebackType\nfrom typing import Any, BinaryIO, NoReturn, overload\nfrom typing_extensions import TypeAlias\n\n# These are based in socket, maybe move them out into _typeshed.pyi or such\n_Address: TypeAlias = socket._Address\n_RetAddress: TypeAlias = Any\n_WriteBuffer: TypeAlias = bytearray | memoryview\n_CMSG: TypeAlias = tuple[int, int, bytes]\n\nclass TransportSocket:\n    def __init__(self, sock: socket.socket) -> None: ...\n    @property\n    def family(self) -> int: ...\n    @property\n    def type(self) -> int: ...\n    @property\n    def proto(self) -> int: ...\n    def __getstate__(self) -> NoReturn: ...\n    def fileno(self) -> int: ...\n    def dup(self) -> socket.socket: ...\n    def get_inheritable(self) -> bool: ...\n    def shutdown(self, how: int) -> None: ...\n    @overload\n    def getsockopt(self, level: int, optname: int) -> int: ...\n    @overload\n    def getsockopt(self, level: int, optname: int, buflen: int) -> bytes: ...\n    @overload\n    def setsockopt(self, level: int, optname: int, value: int | ReadableBuffer) -> None: ...\n    @overload\n    def setsockopt(self, level: int, optname: int, value: None, optlen: int) -> None: ...\n    def getpeername(self) -> _RetAddress: ...\n    def getsockname(self) -> _RetAddress: ...\n    def getsockbyname(self) -> NoReturn: ...  # This method doesn't exist on socket, yet is passed through?\n    def settimeout(self, value: float | None) -> None: ...\n    def gettimeout(self) -> float | None: ...\n    def setblocking(self, flag: bool) -> None: ...\n    if sys.version_info < (3, 11):\n        def _na(self, what: str) -> None: ...\n        def accept(self) -> tuple[socket.socket, _RetAddress]: ...\n        def connect(self, address: _Address) -> None: ...\n        def connect_ex(self, address: _Address) -> int: ...\n        def bind(self, address: _Address) -> None: ...\n        if sys.platform == \"win32\":\n            def ioctl(self, control: int, option: int | tuple[int, int, int] | bool) -> None: ...\n        else:\n            def ioctl(self, control: int, option: int | tuple[int, int, int] | bool) -> NoReturn: ...\n\n        def listen(self, __backlog: int = ...) -> None: ...\n        def makefile(self) -> BinaryIO: ...\n        def sendfile(self, file: BinaryIO, offset: int = ..., count: int | None = ...) -> int: ...\n        def close(self) -> None: ...\n        def detach(self) -> int: ...\n        if sys.platform == \"linux\":\n            def sendmsg_afalg(\n                self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...\n            ) -> int: ...\n        else:\n            def sendmsg_afalg(\n                self, msg: Iterable[ReadableBuffer] = ..., *, op: int, iv: Any = ..., assoclen: int = ..., flags: int = ...\n            ) -> NoReturn: ...\n\n        def sendmsg(\n            self,\n            __buffers: Iterable[ReadableBuffer],\n            __ancdata: Iterable[_CMSG] = ...,\n            __flags: int = ...,\n            __address: _Address = ...,\n        ) -> int: ...\n        @overload\n        def sendto(self, data: ReadableBuffer, address: _Address) -> int: ...\n        @overload\n        def sendto(self, data: ReadableBuffer, flags: int, address: _Address) -> int: ...\n        def send(self, data: ReadableBuffer, flags: int = ...) -> int: ...\n        def sendall(self, data: ReadableBuffer, flags: int = ...) -> None: ...\n        def set_inheritable(self, inheritable: bool) -> None: ...\n        if sys.platform == \"win32\":\n            def share(self, process_id: int) -> bytes: ...\n        else:\n            def share(self, process_id: int) -> NoReturn: ...\n\n        def recv_into(self, buffer: _WriteBuffer, nbytes: int = ..., flags: int = ...) -> int: ...\n        def recvfrom_into(self, buffer: _WriteBuffer, nbytes: int = ..., flags: int = ...) -> tuple[int, _RetAddress]: ...\n        def recvmsg_into(\n            self, __buffers: Iterable[_WriteBuffer], __ancbufsize: int = ..., __flags: int = ...\n        ) -> tuple[int, list[_CMSG], int, Any]: ...\n        def recvmsg(self, __bufsize: int, __ancbufsize: int = ..., __flags: int = ...) -> tuple[bytes, list[_CMSG], int, Any]: ...\n        def recvfrom(self, bufsize: int, flags: int = ...) -> tuple[bytes, _RetAddress]: ...\n        def recv(self, bufsize: int, flags: int = ...) -> bytes: ...\n        def __enter__(self) -> socket.socket: ...\n        def __exit__(\n            self, exc_type: Type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n        ) -> None: ...\n",
  "/typeshed/stdlib/asyncio/unix_events.pyi": "import sys\nimport types\nfrom abc import ABCMeta, abstractmethod\nfrom collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import Literal, Self\n\nfrom .events import AbstractEventLoop, BaseDefaultEventLoopPolicy\nfrom .selector_events import BaseSelectorEventLoop\n\n# This is also technically not available on Win,\n# but other parts of typeshed need this definition.\n# So, it is special cased.\nclass AbstractChildWatcher:\n    @abstractmethod\n    def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n    @abstractmethod\n    def remove_child_handler(self, pid: int) -> bool: ...\n    @abstractmethod\n    def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @abstractmethod\n    def __enter__(self) -> Self: ...\n    @abstractmethod\n    def __exit__(self, typ: type[BaseException] | None, exc: BaseException | None, tb: types.TracebackType | None) -> None: ...\n    if sys.version_info >= (3, 8):\n        @abstractmethod\n        def is_active(self) -> bool: ...\n\nif sys.platform != \"win32\":\n    if sys.version_info >= (3, 9):\n        __all__ = (\n            \"SelectorEventLoop\",\n            \"AbstractChildWatcher\",\n            \"SafeChildWatcher\",\n            \"FastChildWatcher\",\n            \"PidfdChildWatcher\",\n            \"MultiLoopChildWatcher\",\n            \"ThreadedChildWatcher\",\n            \"DefaultEventLoopPolicy\",\n        )\n    elif sys.version_info >= (3, 8):\n        __all__ = (\n            \"SelectorEventLoop\",\n            \"AbstractChildWatcher\",\n            \"SafeChildWatcher\",\n            \"FastChildWatcher\",\n            \"MultiLoopChildWatcher\",\n            \"ThreadedChildWatcher\",\n            \"DefaultEventLoopPolicy\",\n        )\n    else:\n        __all__ = (\"SelectorEventLoop\", \"AbstractChildWatcher\", \"SafeChildWatcher\", \"FastChildWatcher\", \"DefaultEventLoopPolicy\")\n\n    # Doesn't actually have ABCMeta metaclass at runtime, but mypy complains if we don't have it in the stub.\n    # See discussion in #7412\n    class BaseChildWatcher(AbstractChildWatcher, metaclass=ABCMeta):\n        def close(self) -> None: ...\n        if sys.version_info >= (3, 8):\n            def is_active(self) -> bool: ...\n\n        def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...\n\n    class SafeChildWatcher(BaseChildWatcher):\n        def __enter__(self) -> Self: ...\n        def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...\n        def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n        def remove_child_handler(self, pid: int) -> bool: ...\n\n    class FastChildWatcher(BaseChildWatcher):\n        def __enter__(self) -> Self: ...\n        def __exit__(self, a: type[BaseException] | None, b: BaseException | None, c: types.TracebackType | None) -> None: ...\n        def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n        def remove_child_handler(self, pid: int) -> bool: ...\n\n    class _UnixSelectorEventLoop(BaseSelectorEventLoop): ...\n\n    class _UnixDefaultEventLoopPolicy(BaseDefaultEventLoopPolicy):\n        def get_child_watcher(self) -> AbstractChildWatcher: ...\n        def set_child_watcher(self, watcher: AbstractChildWatcher | None) -> None: ...\n    SelectorEventLoop = _UnixSelectorEventLoop\n\n    DefaultEventLoopPolicy = _UnixDefaultEventLoopPolicy\n\n    if sys.version_info >= (3, 8):\n        from typing import Protocol\n\n        class _Warn(Protocol):\n            def __call__(\n                self, message: str, category: type[Warning] | None = ..., stacklevel: int = ..., source: Any | None = ...\n            ) -> object: ...\n\n        class MultiLoopChildWatcher(AbstractChildWatcher):\n            def is_active(self) -> bool: ...\n            def close(self) -> None: ...\n            def __enter__(self) -> Self: ...\n            def __exit__(\n                self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n            ) -> None: ...\n            def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n            def remove_child_handler(self, pid: int) -> bool: ...\n            def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...\n\n        class ThreadedChildWatcher(AbstractChildWatcher):\n            def is_active(self) -> Literal[True]: ...\n            def close(self) -> None: ...\n            def __enter__(self) -> Self: ...\n            def __exit__(\n                self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n            ) -> None: ...\n            def __del__(self, _warn: _Warn = ...) -> None: ...\n            def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n            def remove_child_handler(self, pid: int) -> bool: ...\n            def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...\n\n    if sys.version_info >= (3, 9):\n        class PidfdChildWatcher(AbstractChildWatcher):\n            def __enter__(self) -> Self: ...\n            def __exit__(\n                self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n            ) -> None: ...\n            def is_active(self) -> bool: ...\n            def close(self) -> None: ...\n            def attach_loop(self, loop: AbstractEventLoop | None) -> None: ...\n            def add_child_handler(self, pid: int, callback: Callable[..., object], *args: Any) -> None: ...\n            def remove_child_handler(self, pid: int) -> bool: ...\n",
  "/typeshed/stdlib/asyncio/windows_events.pyi": "import socket\nimport sys\nfrom _typeshed import Incomplete, WriteableBuffer\nfrom collections.abc import Callable\nfrom typing import IO, Any, ClassVar, NoReturn\nfrom typing_extensions import Literal\n\nfrom . import events, futures, proactor_events, selector_events, streams, windows_utils\n\nif sys.platform == \"win32\":\n    __all__ = (\n        \"SelectorEventLoop\",\n        \"ProactorEventLoop\",\n        \"IocpProactor\",\n        \"DefaultEventLoopPolicy\",\n        \"WindowsSelectorEventLoopPolicy\",\n        \"WindowsProactorEventLoopPolicy\",\n    )\n\n    NULL: Literal[0]\n    INFINITE: Literal[0xFFFFFFFF]\n    ERROR_CONNECTION_REFUSED: Literal[1225]\n    ERROR_CONNECTION_ABORTED: Literal[1236]\n    CONNECT_PIPE_INIT_DELAY: float\n    CONNECT_PIPE_MAX_DELAY: float\n\n    class PipeServer:\n        def __init__(self, address: str) -> None: ...\n        def __del__(self) -> None: ...\n        def closed(self) -> bool: ...\n        def close(self) -> None: ...\n\n    class _WindowsSelectorEventLoop(selector_events.BaseSelectorEventLoop): ...\n\n    class ProactorEventLoop(proactor_events.BaseProactorEventLoop):\n        def __init__(self, proactor: IocpProactor | None = None) -> None: ...\n        async def create_pipe_connection(\n            self, protocol_factory: Callable[[], streams.StreamReaderProtocol], address: str\n        ) -> tuple[proactor_events._ProactorDuplexPipeTransport, streams.StreamReaderProtocol]: ...\n        async def start_serving_pipe(\n            self, protocol_factory: Callable[[], streams.StreamReaderProtocol], address: str\n        ) -> list[PipeServer]: ...\n\n    class IocpProactor:\n        def __init__(self, concurrency: int = 0xFFFFFFFF) -> None: ...\n        def __del__(self) -> None: ...\n        def set_loop(self, loop: events.AbstractEventLoop) -> None: ...\n        def select(self, timeout: int | None = None) -> list[futures.Future[Any]]: ...\n        def recv(self, conn: socket.socket, nbytes: int, flags: int = 0) -> futures.Future[bytes]: ...\n        def recv_into(self, conn: socket.socket, buf: WriteableBuffer, flags: int = 0) -> futures.Future[Any]: ...\n        def send(self, conn: socket.socket, buf: WriteableBuffer, flags: int = 0) -> futures.Future[Any]: ...\n        def accept(self, listener: socket.socket) -> futures.Future[Any]: ...\n        def connect(\n            self,\n            conn: socket.socket,\n            address: tuple[Incomplete, Incomplete] | tuple[Incomplete, Incomplete, Incomplete, Incomplete],\n        ) -> futures.Future[Any]: ...\n        def sendfile(self, sock: socket.socket, file: IO[bytes], offset: int, count: int) -> futures.Future[Any]: ...\n        def accept_pipe(self, pipe: socket.socket) -> futures.Future[Any]: ...\n        async def connect_pipe(self, address: str) -> windows_utils.PipeHandle: ...\n        def wait_for_handle(self, handle: windows_utils.PipeHandle, timeout: int | None = None) -> bool: ...\n        def close(self) -> None: ...\n    SelectorEventLoop = _WindowsSelectorEventLoop\n\n    class WindowsSelectorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n        _loop_factory: ClassVar[type[SelectorEventLoop]]\n        def get_child_watcher(self) -> NoReturn: ...\n        def set_child_watcher(self, watcher: Any) -> NoReturn: ...\n\n    class WindowsProactorEventLoopPolicy(events.BaseDefaultEventLoopPolicy):\n        _loop_factory: ClassVar[type[ProactorEventLoop]]\n        def get_child_watcher(self) -> NoReturn: ...\n        def set_child_watcher(self, watcher: Any) -> NoReturn: ...\n    DefaultEventLoopPolicy = WindowsSelectorEventLoopPolicy\n",
  "/typeshed/stdlib/asyncio/windows_utils.pyi": "import subprocess\nimport sys\nfrom collections.abc import Callable\nfrom types import TracebackType\nfrom typing import Any, AnyStr, Protocol\nfrom typing_extensions import Literal, Self\n\nif sys.platform == \"win32\":\n    __all__ = (\"pipe\", \"Popen\", \"PIPE\", \"PipeHandle\")\n\n    class _WarnFunction(Protocol):\n        def __call__(\n            self, message: str, category: type[Warning] = ..., stacklevel: int = ..., source: PipeHandle = ...\n        ) -> object: ...\n    BUFSIZE: Literal[8192]\n    PIPE = subprocess.PIPE\n    STDOUT = subprocess.STDOUT\n    def pipe(*, duplex: bool = False, overlapped: tuple[bool, bool] = (True, True), bufsize: int = 8192) -> tuple[int, int]: ...\n\n    class PipeHandle:\n        def __init__(self, handle: int) -> None: ...\n        if sys.version_info >= (3, 8):\n            def __del__(self, _warn: _WarnFunction = ...) -> None: ...\n        else:\n            def __del__(self) -> None: ...\n\n        def __enter__(self) -> Self: ...\n        def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n        @property\n        def handle(self) -> int: ...\n        def fileno(self) -> int: ...\n        def close(self, *, CloseHandle: Callable[[int], object] = ...) -> None: ...\n\n    class Popen(subprocess.Popen[AnyStr]):\n        stdin: PipeHandle | None  # type: ignore[assignment]\n        stdout: PipeHandle | None  # type: ignore[assignment]\n        stderr: PipeHandle | None  # type: ignore[assignment]\n        # For simplicity we omit the full overloaded __new__ signature of\n        # subprocess.Popen. The arguments are mostly the same, but\n        # subprocess.Popen takes other positional-or-keyword arguments before\n        # stdin.\n        def __new__(\n            cls,\n            args: subprocess._CMD,\n            stdin: subprocess._FILE | None = ...,\n            stdout: subprocess._FILE | None = ...,\n            stderr: subprocess._FILE | None = ...,\n            **kwds: Any,\n        ) -> Self: ...\n        def __init__(\n            self,\n            args: subprocess._CMD,\n            stdin: subprocess._FILE | None = None,\n            stdout: subprocess._FILE | None = None,\n            stderr: subprocess._FILE | None = None,\n            **kwds: Any,\n        ) -> None: ...\n",
  "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import SupportsKeysAndGetItem, SupportsRichComparison, SupportsRichComparisonT\nfrom typing import Any, Generic, NoReturn, TypeVar, overload\nfrom typing_extensions import Self, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nif sys.version_info >= (3, 10):\n    from collections.abc import (\n        Callable,\n        ItemsView,\n        Iterable,\n        Iterator,\n        KeysView,\n        Mapping,\n        MutableMapping,\n        MutableSequence,\n        Reversible,\n        Sequence,\n        ValuesView,\n    )\nelse:\n    from _collections_abc import *\n\n__all__ = [\"ChainMap\", \"Counter\", \"OrderedDict\", \"UserDict\", \"UserList\", \"UserString\", \"defaultdict\", \"deque\", \"namedtuple\"]\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n\n# namedtuple is special-cased in the type checker; the initializer is ignored.\ndef namedtuple(\n    typename: str,\n    field_names: str | Iterable[str],\n    *,\n    rename: bool = False,\n    module: str | None = None,\n    defaults: Iterable[Any] | None = None,\n) -> type[tuple[Any, ...]]: ...\n\nclass UserDict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    data: dict[_KT, _VT]\n    # __init__ should be kept roughly in line with `dict.__init__`, which has the same semantics\n    @overload\n    def __init__(self, __dict: None = None) -> None: ...\n    @overload\n    def __init__(self: UserDict[str, _VT], __dict: None = None, **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __dict: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: UserDict[str, _VT], __dict: SupportsKeysAndGetItem[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...\n    @overload\n    def __init__(self: UserDict[str, _VT], __iterable: Iterable[tuple[str, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self: UserDict[str, str], __iterable: Iterable[list[str]]) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, item: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def copy(self) -> Self: ...\n    def __copy__(self) -> Self: ...\n\n    # `UserDict.fromkeys` has the same semantics as `dict.fromkeys`, so should be kept in line with `dict.fromkeys`.\n    # TODO: Much like `dict.fromkeys`, the true signature of `UserDict.fromkeys` is inexpressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: None = None) -> UserDict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> UserDict[_T, _S]: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]\n        # UserDict.__ior__ should be kept roughly in line with MutableMapping.update()\n        @overload  # type: ignore[misc]\n        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n        @overload\n        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass UserList(MutableSequence[_T]):\n    data: list[_T]\n    @overload\n    def __init__(self, initlist: None = None) -> None: ...\n    @overload\n    def __init__(self, initlist: Iterable[_T]) -> None: ...\n    def __lt__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __le__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __gt__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __ge__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __contains__(self, item: object) -> bool: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, i: slice) -> Self: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, item: _T) -> None: ...\n    @overload\n    def __setitem__(self, i: slice, item: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, other: Iterable[_T]) -> Self: ...\n    def __radd__(self, other: Iterable[_T]) -> Self: ...\n    def __iadd__(self, other: Iterable[_T]) -> Self: ...\n    def __mul__(self, n: int) -> Self: ...\n    def __rmul__(self, n: int) -> Self: ...\n    def __imul__(self, n: int) -> Self: ...\n    def append(self, item: _T) -> None: ...\n    def insert(self, i: int, item: _T) -> None: ...\n    def pop(self, i: int = -1) -> _T: ...\n    def remove(self, item: _T) -> None: ...\n    def copy(self) -> Self: ...\n    def __copy__(self) -> Self: ...\n    def count(self, item: _T) -> int: ...\n    # All arguments are passed to `list.index` at runtime, so the signature should be kept in line with `list.index`.\n    def index(self, item: _T, __start: SupportsIndex = 0, __stop: SupportsIndex = sys.maxsize) -> int: ...\n    # All arguments are passed to `list.sort` at runtime, so the signature should be kept in line with `list.sort`.\n    @overload\n    def sort(self: UserList[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...\n    @overload\n    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...\n    def extend(self, other: Iterable[_T]) -> None: ...\n\nclass UserString(Sequence[UserString]):\n    data: str\n    def __init__(self, seq: object) -> None: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __complex__(self) -> complex: ...\n    def __getnewargs__(self) -> tuple[str]: ...\n    def __lt__(self, string: str | UserString) -> bool: ...\n    def __le__(self, string: str | UserString) -> bool: ...\n    def __gt__(self, string: str | UserString) -> bool: ...\n    def __ge__(self, string: str | UserString) -> bool: ...\n    def __eq__(self, string: object) -> bool: ...\n    def __contains__(self, char: object) -> bool: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, index: SupportsIndex | slice) -> Self: ...\n    def __iter__(self) -> Iterator[Self]: ...\n    def __reversed__(self) -> Iterator[Self]: ...\n    def __add__(self, other: object) -> Self: ...\n    def __radd__(self, other: object) -> Self: ...\n    def __mul__(self, n: int) -> Self: ...\n    def __rmul__(self, n: int) -> Self: ...\n    def __mod__(self, args: Any) -> Self: ...\n    if sys.version_info >= (3, 8):\n        def __rmod__(self, template: object) -> Self: ...\n    else:\n        def __rmod__(self, format: Any) -> Self: ...\n\n    def capitalize(self) -> Self: ...\n    def casefold(self) -> Self: ...\n    def center(self, width: int, *args: Any) -> Self: ...\n    def count(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    if sys.version_info >= (3, 8):\n        def encode(self: UserString, encoding: str | None = \"utf-8\", errors: str | None = \"strict\") -> bytes: ...\n    else:\n        def encode(self, encoding: str | None = None, errors: str | None = None) -> Self: ...\n\n    def endswith(self, suffix: str | tuple[str, ...], start: int | None = 0, end: int | None = sys.maxsize) -> bool: ...\n    def expandtabs(self, tabsize: int = 8) -> Self: ...\n    def find(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def format(self, *args: Any, **kwds: Any) -> str: ...\n    def format_map(self, mapping: Mapping[str, Any]) -> str: ...\n    def index(self, sub: str, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isalnum(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def join(self, seq: Iterable[str]) -> str: ...\n    def ljust(self, width: int, *args: Any) -> Self: ...\n    def lower(self) -> Self: ...\n    def lstrip(self, chars: str | None = None) -> Self: ...\n    maketrans = str.maketrans\n    def partition(self, sep: str) -> tuple[str, str, str]: ...\n    if sys.version_info >= (3, 9):\n        def removeprefix(self, __prefix: str | UserString) -> Self: ...\n        def removesuffix(self, __suffix: str | UserString) -> Self: ...\n\n    def replace(self, old: str | UserString, new: str | UserString, maxsplit: int = -1) -> Self: ...\n    def rfind(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def rindex(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def rjust(self, width: int, *args: Any) -> Self: ...\n    def rpartition(self, sep: str) -> tuple[str, str, str]: ...\n    def rstrip(self, chars: str | None = None) -> Self: ...\n    def split(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...\n    def rsplit(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...\n    def splitlines(self, keepends: bool = False) -> list[str]: ...\n    def startswith(self, prefix: str | tuple[str, ...], start: int | None = 0, end: int | None = sys.maxsize) -> bool: ...\n    def strip(self, chars: str | None = None) -> Self: ...\n    def swapcase(self) -> Self: ...\n    def title(self) -> Self: ...\n    def translate(self, *args: Any) -> Self: ...\n    def upper(self) -> Self: ...\n    def zfill(self, width: int) -> Self: ...\n\nclass deque(MutableSequence[_T], Generic[_T]):\n    @property\n    def maxlen(self) -> int | None: ...\n    @overload\n    def __init__(self, *, maxlen: int | None = None) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T], maxlen: int | None = None) -> None: ...\n    def append(self, __x: _T) -> None: ...\n    def appendleft(self, __x: _T) -> None: ...\n    def copy(self) -> Self: ...\n    def count(self, __x: _T) -> int: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def extendleft(self, __iterable: Iterable[_T]) -> None: ...\n    def insert(self, __i: int, __x: _T) -> None: ...\n    def index(self, __x: _T, __start: int = 0, __stop: int = ...) -> int: ...\n    def pop(self) -> _T: ...  # type: ignore[override]\n    def popleft(self) -> _T: ...\n    def remove(self, __value: _T) -> None: ...\n    def rotate(self, __n: int = 1) -> None: ...\n    def __copy__(self) -> Self: ...\n    def __len__(self) -> int: ...\n    # These methods of deque don't take slices, unlike MutableSequence, hence the type: ignores\n    def __getitem__(self, __key: SupportsIndex) -> _T: ...  # type: ignore[override]\n    def __setitem__(self, __key: SupportsIndex, __value: _T) -> None: ...  # type: ignore[override]\n    def __delitem__(self, __key: SupportsIndex) -> None: ...  # type: ignore[override]\n    def __contains__(self, __key: object) -> bool: ...\n    def __reduce__(self) -> tuple[type[Self], tuple[()], None, Iterator[_T]]: ...\n    def __iadd__(self, __value: Iterable[_T]) -> Self: ...\n    def __add__(self, __value: Self) -> Self: ...\n    def __mul__(self, __value: int) -> Self: ...\n    def __imul__(self, __value: int) -> Self: ...\n    def __lt__(self, __value: deque[_T]) -> bool: ...\n    def __le__(self, __value: deque[_T]) -> bool: ...\n    def __gt__(self, __value: deque[_T]) -> bool: ...\n    def __ge__(self, __value: deque[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, __item: Any) -> GenericAlias: ...\n\nclass Counter(dict[_T, int], Generic[_T]):\n    @overload\n    def __init__(self, __iterable: None = None) -> None: ...\n    @overload\n    def __init__(self: Counter[str], __iterable: None = None, **kwargs: int) -> None: ...\n    @overload\n    def __init__(self, __mapping: SupportsKeysAndGetItem[_T, int]) -> None: ...\n    @overload\n    def __init__(self, __iterable: Iterable[_T]) -> None: ...\n    def copy(self) -> Self: ...\n    def elements(self) -> Iterator[_T]: ...\n    def most_common(self, n: int | None = None) -> list[tuple[_T, int]]: ...\n    @classmethod\n    def fromkeys(cls, iterable: Any, v: int | None = None) -> NoReturn: ...  # type: ignore[override]\n    @overload\n    def subtract(self, __iterable: None = None) -> None: ...\n    @overload\n    def subtract(self, __mapping: Mapping[_T, int]) -> None: ...\n    @overload\n    def subtract(self, __iterable: Iterable[_T]) -> None: ...\n    # Unlike dict.update(), use Mapping instead of SupportsKeysAndGetItem for the first overload\n    # (source code does an `isinstance(other, Mapping)` check)\n    #\n    # The second overload is also deliberately different to dict.update()\n    # (if it were `Iterable[_T] | Iterable[tuple[_T, int]]`,\n    # the tuples would be added as keys, breaking type safety)\n    @overload  # type: ignore[override]\n    def update(self, __m: Mapping[_T, int], **kwargs: int) -> None: ...\n    @overload\n    def update(self, __iterable: Iterable[_T], **kwargs: int) -> None: ...\n    @overload\n    def update(self, __iterable: None = None, **kwargs: int) -> None: ...\n    def __missing__(self, key: _T) -> int: ...\n    def __delitem__(self, elem: object) -> None: ...\n    if sys.version_info >= (3, 10):\n        def __eq__(self, other: object) -> bool: ...\n        def __ne__(self, other: object) -> bool: ...\n\n    def __add__(self, other: Counter[_S]) -> Counter[_T | _S]: ...\n    def __sub__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __and__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __or__(self, other: Counter[_S]) -> Counter[_T | _S]: ...  # type: ignore[override]\n    def __pos__(self) -> Counter[_T]: ...\n    def __neg__(self) -> Counter[_T]: ...\n    # several type: ignores because __iadd__ is supposedly incompatible with __add__, etc.\n    def __iadd__(self, other: Counter[_T]) -> Self: ...  # type: ignore[misc]\n    def __isub__(self, other: Counter[_T]) -> Self: ...\n    def __iand__(self, other: Counter[_T]) -> Self: ...\n    def __ior__(self, other: Counter[_T]) -> Self: ...  # type: ignore[override,misc]\n    if sys.version_info >= (3, 10):\n        def total(self) -> int: ...\n        def __le__(self, other: Counter[Any]) -> bool: ...\n        def __lt__(self, other: Counter[Any]) -> bool: ...\n        def __ge__(self, other: Counter[Any]) -> bool: ...\n        def __gt__(self, other: Counter[Any]) -> bool: ...\n\n# The pure-Python implementations of the \"views\" classes\n# These are exposed at runtime in `collections/__init__.py`\nclass _OrderedDictKeysView(KeysView[_KT_co], Reversible[_KT_co]):\n    def __reversed__(self) -> Iterator[_KT_co]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT_co, _VT_co], Reversible[tuple[_KT_co, _VT_co]]):\n    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT_co], Reversible[_VT_co]):\n    def __reversed__(self) -> Iterator[_VT_co]: ...\n\n# The C implementations of the \"views\" classes\n# (At runtime, these are called `odict_keys`, `odict_items` and `odict_values`,\n# but they are not exposed anywhere)\n# pyright doesn't have a specific error code for subclassing error!\n@final\nclass _odict_keys(dict_keys[_KT_co, _VT_co], Reversible[_KT_co]):  # type: ignore[misc]  # pyright: ignore\n    def __reversed__(self) -> Iterator[_KT_co]: ...\n\n@final\nclass _odict_items(dict_items[_KT_co, _VT_co], Reversible[tuple[_KT_co, _VT_co]]):  # type: ignore[misc]  # pyright: ignore\n    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n\n@final\nclass _odict_values(dict_values[_KT_co, _VT_co], Reversible[_VT_co], Generic[_KT_co, _VT_co]):  # type: ignore[misc]  # pyright: ignore\n    def __reversed__(self) -> Iterator[_VT_co]: ...\n\nclass OrderedDict(dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = True) -> tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = True) -> None: ...\n    def copy(self) -> Self: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _odict_keys[_KT, _VT]: ...\n    def items(self) -> _odict_items[_KT, _VT]: ...\n    def values(self) -> _odict_values[_KT, _VT]: ...\n    # The signature of OrderedDict.fromkeys should be kept in line with `dict.fromkeys`, modulo positional-only differences.\n    # Like dict.fromkeys, its true signature is not expressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: None = None) -> OrderedDict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> OrderedDict[_T, _S]: ...\n    # Keep OrderedDict.setdefault in line with MutableMapping.setdefault, modulo positional-only differences.\n    @overload\n    def setdefault(self: OrderedDict[_KT, _T | None], key: _KT, default: None = None) -> _T | None: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n\nclass defaultdict(dict[_KT, _VT], Generic[_KT, _VT]):\n    default_factory: Callable[[], _VT] | None\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self: defaultdict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __default_factory: Callable[[], _VT] | None) -> None: ...\n    @overload\n    def __init__(self: defaultdict[str, _VT], __default_factory: Callable[[], _VT] | None, **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(self, __default_factory: Callable[[], _VT] | None, __map: SupportsKeysAndGetItem[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(\n        self: defaultdict[str, _VT],\n        __default_factory: Callable[[], _VT] | None,\n        __map: SupportsKeysAndGetItem[str, _VT],\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self, __default_factory: Callable[[], _VT] | None, __iterable: Iterable[tuple[_KT, _VT]]) -> None: ...\n    @overload\n    def __init__(\n        self: defaultdict[str, _VT],\n        __default_factory: Callable[[], _VT] | None,\n        __iterable: Iterable[tuple[str, _VT]],\n        **kwargs: _VT,\n    ) -> None: ...\n    def __missing__(self, __key: _KT) -> _VT: ...\n    def __copy__(self) -> Self: ...\n    def copy(self) -> Self: ...\n\nclass ChainMap(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    maps: list[MutableMapping[_KT, _VT]]\n    def __init__(self, *maps: MutableMapping[_KT, _VT]) -> None: ...\n    def new_child(self, m: MutableMapping[_KT, _VT] | None = None) -> Self: ...\n    @property\n    def parents(self) -> Self: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __missing__(self, key: _KT) -> _VT: ...  # undocumented\n    def __bool__(self) -> bool: ...\n    # Keep ChainMap.setdefault in line with MutableMapping.setdefault, modulo positional-only differences.\n    @overload\n    def setdefault(self: ChainMap[_KT, _T | None], key: _KT, default: None = None) -> _T | None: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT | _T) -> _VT | _T: ...\n    def copy(self) -> Self: ...\n    __copy__ = copy\n    # All arguments to `fromkeys` are passed to `dict.fromkeys` at runtime, so the signature should be kept in line with `dict.fromkeys`.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], __value: None = None) -> ChainMap[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> ChainMap[_T, _S]: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]: ...\n        # ChainMap.__ior__ should be kept roughly in line with MutableMapping.update()\n        @overload  # type: ignore[misc]\n        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n        @overload\n        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n",
  "/typeshed/stdlib/collections/abc.pyi": "from _collections_abc import *\nfrom _collections_abc import __all__ as __all__\n",
  "/typeshed/stdlib/concurrent/__init__.pyi": "",
  "/typeshed/stdlib/concurrent/futures/__init__.pyi": "import sys\n\nfrom ._base import (\n    ALL_COMPLETED as ALL_COMPLETED,\n    FIRST_COMPLETED as FIRST_COMPLETED,\n    FIRST_EXCEPTION as FIRST_EXCEPTION,\n    BrokenExecutor as BrokenExecutor,\n    CancelledError as CancelledError,\n    Executor as Executor,\n    Future as Future,\n    TimeoutError as TimeoutError,\n    as_completed as as_completed,\n    wait as wait,\n)\nfrom .process import ProcessPoolExecutor as ProcessPoolExecutor\nfrom .thread import ThreadPoolExecutor as ThreadPoolExecutor\n\nif sys.version_info >= (3, 8):\n    from ._base import InvalidStateError as InvalidStateError\n\n__all__ = (\n    \"FIRST_COMPLETED\",\n    \"FIRST_EXCEPTION\",\n    \"ALL_COMPLETED\",\n    \"CancelledError\",\n    \"TimeoutError\",\n    \"BrokenExecutor\",\n    \"Future\",\n    \"Executor\",\n    \"wait\",\n    \"as_completed\",\n    \"ProcessPoolExecutor\",\n    \"ThreadPoolExecutor\",\n)\n\ndef __dir__() -> tuple[str, ...]: ...\n",
  "/typeshed/stdlib/concurrent/futures/_base.pyi": "import sys\nimport threading\nfrom _typeshed import Unused\nfrom collections.abc import Callable, Iterable, Iterator\nfrom logging import Logger\nfrom types import TracebackType\nfrom typing import Any, Generic, NamedTuple, TypeVar\nfrom typing_extensions import Literal, ParamSpec, Self\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nFIRST_COMPLETED: Literal[\"FIRST_COMPLETED\"]\nFIRST_EXCEPTION: Literal[\"FIRST_EXCEPTION\"]\nALL_COMPLETED: Literal[\"ALL_COMPLETED\"]\nPENDING: Literal[\"PENDING\"]\nRUNNING: Literal[\"RUNNING\"]\nCANCELLED: Literal[\"CANCELLED\"]\nCANCELLED_AND_NOTIFIED: Literal[\"CANCELLED_AND_NOTIFIED\"]\nFINISHED: Literal[\"FINISHED\"]\n_FUTURE_STATES: list[str]\n_STATE_TO_DESCRIPTION_MAP: dict[str, str]\nLOGGER: Logger\n\nclass Error(Exception): ...\nclass CancelledError(Error): ...\nclass TimeoutError(Error): ...\n\nif sys.version_info >= (3, 8):\n    class InvalidStateError(Error): ...\n\nclass BrokenExecutor(RuntimeError): ...\n\n_T = TypeVar(\"_T\")\n_P = ParamSpec(\"_P\")\n\nclass Future(Generic[_T]):\n    def cancel(self) -> bool: ...\n    def cancelled(self) -> bool: ...\n    def running(self) -> bool: ...\n    def done(self) -> bool: ...\n    def add_done_callback(self, fn: Callable[[Future[_T]], object]) -> None: ...\n    def result(self, timeout: float | None = None) -> _T: ...\n    def set_running_or_notify_cancel(self) -> bool: ...\n    def set_result(self, result: _T) -> None: ...\n    def exception(self, timeout: float | None = None) -> BaseException | None: ...\n    def set_exception(self, exception: BaseException | None) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Executor:\n    if sys.version_info >= (3, 9):\n        def submit(self, __fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...\n    else:\n        def submit(self, fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...\n\n    def map(\n        self, fn: Callable[..., _T], *iterables: Iterable[Any], timeout: float | None = None, chunksize: int = 1\n    ) -> Iterator[_T]: ...\n    if sys.version_info >= (3, 9):\n        def shutdown(self, wait: bool = True, *, cancel_futures: bool = False) -> None: ...\n    else:\n        def shutdown(self, wait: bool = True) -> None: ...\n\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> bool | None: ...\n\ndef as_completed(fs: Iterable[Future[_T]], timeout: float | None = None) -> Iterator[Future[_T]]: ...\n\nclass DoneAndNotDoneFutures(NamedTuple, Generic[_T]):\n    done: set[Future[_T]]\n    not_done: set[Future[_T]]\n\ndef wait(\n    fs: Iterable[Future[_T]], timeout: float | None = None, return_when: str = \"ALL_COMPLETED\"\n) -> DoneAndNotDoneFutures[_T]: ...\n\nclass _Waiter:\n    event: threading.Event\n    finished_futures: list[Future[Any]]\n    def add_result(self, future: Future[Any]) -> None: ...\n    def add_exception(self, future: Future[Any]) -> None: ...\n    def add_cancelled(self, future: Future[Any]) -> None: ...\n\nclass _AsCompletedWaiter(_Waiter):\n    lock: threading.Lock\n\nclass _FirstCompletedWaiter(_Waiter): ...\n\nclass _AllCompletedWaiter(_Waiter):\n    num_pending_calls: int\n    stop_on_exception: bool\n    lock: threading.Lock\n    def __init__(self, num_pending_calls: int, stop_on_exception: bool) -> None: ...\n\nclass _AcquireFutures:\n    futures: Iterable[Future[Any]]\n    def __init__(self, futures: Iterable[Future[Any]]) -> None: ...\n    def __enter__(self) -> None: ...\n    def __exit__(self, *args: Unused) -> None: ...\n",
  "/typeshed/stdlib/concurrent/futures/process.pyi": "import sys\nfrom collections.abc import Callable, Generator, Iterable, Mapping, MutableMapping, MutableSequence\nfrom multiprocessing.connection import Connection\nfrom multiprocessing.context import BaseContext, Process\nfrom multiprocessing.queues import Queue, SimpleQueue\nfrom threading import Lock, Semaphore, Thread\nfrom types import TracebackType\nfrom typing import Any, Generic, TypeVar\nfrom weakref import ref\n\nfrom ._base import BrokenExecutor, Executor, Future\n\n_T = TypeVar(\"_T\")\n\n_threads_wakeups: MutableMapping[Any, Any]\n_global_shutdown: bool\n\nclass _ThreadWakeup:\n    _closed: bool\n    _reader: Connection\n    _writer: Connection\n    def close(self) -> None: ...\n    def wakeup(self) -> None: ...\n    def clear(self) -> None: ...\n\ndef _python_exit() -> None: ...\n\nEXTRA_QUEUED_CALLS: int\n\n_MAX_WINDOWS_WORKERS: int\n\nclass _RemoteTraceback(Exception):\n    tb: str\n    def __init__(self, tb: TracebackType) -> None: ...\n\nclass _ExceptionWithTraceback:\n    exc: BaseException\n    tb: TracebackType\n    def __init__(self, exc: BaseException, tb: TracebackType) -> None: ...\n    def __reduce__(self) -> str | tuple[Any, ...]: ...\n\ndef _rebuild_exc(exc: Exception, tb: str) -> Exception: ...\n\nclass _WorkItem(Generic[_T]):\n    future: Future[_T]\n    fn: Callable[..., _T]\n    args: Iterable[Any]\n    kwargs: Mapping[str, Any]\n    def __init__(self, future: Future[_T], fn: Callable[..., _T], args: Iterable[Any], kwargs: Mapping[str, Any]) -> None: ...\n\nclass _ResultItem:\n    work_id: int\n    exception: Exception\n    result: Any\n    if sys.version_info >= (3, 11):\n        exit_pid: int | None\n        def __init__(\n            self, work_id: int, exception: Exception | None = None, result: Any | None = None, exit_pid: int | None = None\n        ) -> None: ...\n    else:\n        def __init__(self, work_id: int, exception: Exception | None = None, result: Any | None = None) -> None: ...\n\nclass _CallItem:\n    work_id: int\n    fn: Callable[..., Any]\n    args: Iterable[Any]\n    kwargs: Mapping[str, Any]\n    def __init__(self, work_id: int, fn: Callable[..., Any], args: Iterable[Any], kwargs: Mapping[str, Any]) -> None: ...\n\nclass _SafeQueue(Queue[Future[Any]]):\n    pending_work_items: dict[int, _WorkItem[Any]]\n    shutdown_lock: Lock\n    thread_wakeup: _ThreadWakeup\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            max_size: int | None = 0,\n            *,\n            ctx: BaseContext,\n            pending_work_items: dict[int, _WorkItem[Any]],\n            shutdown_lock: Lock,\n            thread_wakeup: _ThreadWakeup,\n        ) -> None: ...\n    else:\n        def __init__(\n            self, max_size: int | None = 0, *, ctx: BaseContext, pending_work_items: dict[int, _WorkItem[Any]]\n        ) -> None: ...\n\n    def _on_queue_feeder_error(self, e: Exception, obj: _CallItem) -> None: ...\n\ndef _get_chunks(*iterables: Any, chunksize: int) -> Generator[tuple[Any, ...], None, None]: ...\ndef _process_chunk(fn: Callable[..., _T], chunk: Iterable[tuple[Any, ...]]) -> list[_T]: ...\n\nif sys.version_info >= (3, 11):\n    def _sendback_result(\n        result_queue: SimpleQueue[_WorkItem[Any]],\n        work_id: int,\n        result: Any | None = None,\n        exception: Exception | None = None,\n        exit_pid: int | None = None,\n    ) -> None: ...\n\nelse:\n    def _sendback_result(\n        result_queue: SimpleQueue[_WorkItem[Any]], work_id: int, result: Any | None = None, exception: Exception | None = None\n    ) -> None: ...\n\nif sys.version_info >= (3, 11):\n    def _process_worker(\n        call_queue: Queue[_CallItem],\n        result_queue: SimpleQueue[_ResultItem],\n        initializer: Callable[..., object] | None,\n        initargs: tuple[Any, ...],\n        max_tasks: int | None = None,\n    ) -> None: ...\n\nelse:\n    def _process_worker(\n        call_queue: Queue[_CallItem],\n        result_queue: SimpleQueue[_ResultItem],\n        initializer: Callable[..., object] | None,\n        initargs: tuple[Any, ...],\n    ) -> None: ...\n\nif sys.version_info >= (3, 9):\n    class _ExecutorManagerThread(Thread):\n        thread_wakeup: _ThreadWakeup\n        shutdown_lock: Lock\n        executor_reference: ref[Any]\n        processes: MutableMapping[int, Process]\n        call_queue: Queue[_CallItem]\n        result_queue: SimpleQueue[_ResultItem]\n        work_ids_queue: Queue[int]\n        pending_work_items: dict[int, _WorkItem[Any]]\n        def __init__(self, executor: ProcessPoolExecutor) -> None: ...\n        def run(self) -> None: ...\n        def add_call_item_to_queue(self) -> None: ...\n        def wait_result_broken_or_wakeup(self) -> tuple[Any, bool, str]: ...\n        def process_result_item(self, result_item: int | _ResultItem) -> None: ...\n        def is_shutting_down(self) -> bool: ...\n        def terminate_broken(self, cause: str) -> None: ...\n        def flag_executor_shutting_down(self) -> None: ...\n        def shutdown_workers(self) -> None: ...\n        def join_executor_internals(self) -> None: ...\n        def get_n_children_alive(self) -> int: ...\n\n_system_limits_checked: bool\n_system_limited: bool | None\n\ndef _check_system_limits() -> None: ...\ndef _chain_from_iterable_of_lists(iterable: Iterable[MutableSequence[Any]]) -> Any: ...\n\nclass BrokenProcessPool(BrokenExecutor): ...\n\nclass ProcessPoolExecutor(Executor):\n    _mp_context: BaseContext | None\n    _initializer: Callable[..., None] | None\n    _initargs: tuple[Any, ...]\n    _executor_manager_thread: _ThreadWakeup\n    _processes: MutableMapping[int, Process]\n    _shutdown_thread: bool\n    _shutdown_lock: Lock\n    _idle_worker_semaphore: Semaphore\n    _broken: bool\n    _queue_count: int\n    _pending_work_items: dict[int, _WorkItem[Any]]\n    _cancel_pending_futures: bool\n    _executor_manager_thread_wakeup: _ThreadWakeup\n    _result_queue: SimpleQueue[Any]\n    _work_ids: Queue[Any]\n    if sys.version_info >= (3, 11):\n        def __init__(\n            self,\n            max_workers: int | None = None,\n            mp_context: BaseContext | None = None,\n            initializer: Callable[..., object] | None = None,\n            initargs: tuple[Any, ...] = (),\n            *,\n            max_tasks_per_child: int | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            max_workers: int | None = None,\n            mp_context: BaseContext | None = None,\n            initializer: Callable[..., object] | None = None,\n            initargs: tuple[Any, ...] = (),\n        ) -> None: ...\n    if sys.version_info >= (3, 9):\n        def _start_executor_manager_thread(self) -> None: ...\n\n    def _adjust_process_count(self) -> None: ...\n",
  "/typeshed/stdlib/concurrent/futures/thread.pyi": "import queue\nimport sys\nfrom collections.abc import Callable, Iterable, Mapping, Set as AbstractSet\nfrom threading import Lock, Semaphore, Thread\nfrom typing import Any, Generic, TypeVar\nfrom weakref import ref\n\nfrom ._base import BrokenExecutor, Executor, Future\n\n_threads_queues: Mapping[Any, Any]\n_shutdown: bool\n_global_shutdown_lock: Lock\n\ndef _python_exit() -> None: ...\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_S = TypeVar(\"_S\")\n\nclass _WorkItem(Generic[_S]):\n    future: Future[_S]\n    fn: Callable[..., _S]\n    args: Iterable[Any]\n    kwargs: Mapping[str, Any]\n    def __init__(self, future: Future[_S], fn: Callable[..., _S], args: Iterable[Any], kwargs: Mapping[str, Any]) -> None: ...\n    def run(self) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef _worker(\n    executor_reference: ref[Any],\n    work_queue: queue.SimpleQueue[Any],\n    initializer: Callable[..., object],\n    initargs: tuple[Any, ...],\n) -> None: ...\n\nclass BrokenThreadPool(BrokenExecutor): ...\n\nclass ThreadPoolExecutor(Executor):\n    _max_workers: int\n    _idle_semaphore: Semaphore\n    _threads: AbstractSet[Thread]\n    _broken: bool\n    _shutdown: bool\n    _shutdown_lock: Lock\n    _thread_name_prefix: str | None\n    _initializer: Callable[..., None] | None\n    _initargs: tuple[Any, ...]\n    _work_queue: queue.SimpleQueue[_WorkItem[Any]]\n    def __init__(\n        self,\n        max_workers: int | None = None,\n        thread_name_prefix: str = \"\",\n        initializer: Callable[..., object] | None = None,\n        initargs: tuple[Any, ...] = (),\n    ) -> None: ...\n    def _adjust_thread_count(self) -> None: ...\n    def _initializer_failed(self) -> None: ...\n",
  "/typeshed/stdlib/ctypes/__init__.pyi": "import sys\nfrom _ctypes import RTLD_GLOBAL as RTLD_GLOBAL, RTLD_LOCAL as RTLD_LOCAL\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom abc import abstractmethod\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, Sequence\nfrom typing import Any, ClassVar, Generic, TypeVar, overload\nfrom typing_extensions import Self, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n_T = TypeVar(\"_T\")\n_DLLT = TypeVar(\"_DLLT\", bound=CDLL)\n_CT = TypeVar(\"_CT\", bound=_CData)\n\nDEFAULT_MODE: int\n\nclass CDLL:\n    _func_flags_: ClassVar[int]\n    _func_restype_: ClassVar[_CData]\n    _name: str\n    _handle: int\n    _FuncPtr: type[_FuncPointer]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            name: str | None,\n            mode: int = ...,\n            handle: int | None = None,\n            use_errno: bool = False,\n            use_last_error: bool = False,\n            winmode: int | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            name: str | None,\n            mode: int = ...,\n            handle: int | None = None,\n            use_errno: bool = False,\n            use_last_error: bool = False,\n        ) -> None: ...\n\n    def __getattr__(self, name: str) -> _NamedFuncPointer: ...\n    def __getitem__(self, name_or_ordinal: str) -> _NamedFuncPointer: ...\n\nif sys.platform == \"win32\":\n    class OleDLL(CDLL): ...\n    class WinDLL(CDLL): ...\n\nclass PyDLL(CDLL): ...\n\nclass LibraryLoader(Generic[_DLLT]):\n    def __init__(self, dlltype: type[_DLLT]) -> None: ...\n    def __getattr__(self, name: str) -> _DLLT: ...\n    def __getitem__(self, name: str) -> _DLLT: ...\n    def LoadLibrary(self, name: str) -> _DLLT: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ncdll: LibraryLoader[CDLL]\nif sys.platform == \"win32\":\n    windll: LibraryLoader[WinDLL]\n    oledll: LibraryLoader[OleDLL]\npydll: LibraryLoader[PyDLL]\npythonapi: PyDLL\n\nclass _CDataMeta(type):\n    # By default mypy complains about the following two methods, because strictly speaking cls\n    # might not be a Type[_CT]. However this can never actually happen, because the only class that\n    # uses _CDataMeta as its metaclass is _CData. So it's safe to ignore the errors here.\n    def __mul__(cls: type[_CT], other: int) -> type[Array[_CT]]: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __rmul__(cls: type[_CT], other: int) -> type[Array[_CT]]: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n\nclass _CData(metaclass=_CDataMeta):\n    _b_base_: int\n    _b_needsfree_: bool\n    _objects: Mapping[Any, int] | None\n    @classmethod\n    def from_buffer(cls, source: WriteableBuffer, offset: int = ...) -> Self: ...\n    @classmethod\n    def from_buffer_copy(cls, source: ReadableBuffer, offset: int = ...) -> Self: ...\n    @classmethod\n    def from_address(cls, address: int) -> Self: ...\n    @classmethod\n    def from_param(cls, obj: Any) -> Self | _CArgObject: ...\n    @classmethod\n    def in_dll(cls, library: CDLL, name: str) -> Self: ...\n\nclass _CanCastTo(_CData): ...\nclass _PointerLike(_CanCastTo): ...\n\n_ECT: TypeAlias = Callable[[type[_CData] | None, _FuncPointer, tuple[_CData, ...]], _CData]\n_PF: TypeAlias = tuple[int] | tuple[int, str] | tuple[int, str, Any]\n\nclass _FuncPointer(_PointerLike, _CData):\n    restype: type[_CData] | Callable[[int], Any] | None\n    argtypes: Sequence[type[_CData]]\n    errcheck: _ECT\n    @overload\n    def __init__(self, address: int) -> None: ...\n    @overload\n    def __init__(self, callable: Callable[..., Any]) -> None: ...\n    @overload\n    def __init__(self, func_spec: tuple[str | int, CDLL], paramflags: tuple[_PF, ...] = ...) -> None: ...\n    @overload\n    def __init__(self, vtlb_index: int, name: str, paramflags: tuple[_PF, ...] = ..., iid: _Pointer[c_int] = ...) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nclass _NamedFuncPointer(_FuncPointer):\n    __name__: str\n\nclass ArgumentError(Exception): ...\n\ndef CFUNCTYPE(\n    restype: type[_CData] | None, *argtypes: type[_CData], use_errno: bool = ..., use_last_error: bool = ...\n) -> type[_FuncPointer]: ...\n\nif sys.platform == \"win32\":\n    def WINFUNCTYPE(\n        restype: type[_CData] | None, *argtypes: type[_CData], use_errno: bool = ..., use_last_error: bool = ...\n    ) -> type[_FuncPointer]: ...\n\ndef PYFUNCTYPE(restype: type[_CData] | None, *argtypes: type[_CData]) -> type[_FuncPointer]: ...\n\nclass _CArgObject: ...\n\n# Any type that can be implicitly converted to c_void_p when passed as a C function argument.\n# (bytes is not included here, see below.)\n_CVoidPLike: TypeAlias = _PointerLike | Array[Any] | _CArgObject | int\n# Same as above, but including types known to be read-only (i. e. bytes).\n# This distinction is not strictly necessary (ctypes doesn't differentiate between const\n# and non-const pointers), but it catches errors like memmove(b'foo', buf, 4)\n# when memmove(buf, b'foo', 4) was intended.\n_CVoidConstPLike: TypeAlias = _CVoidPLike | bytes\n\ndef addressof(obj: _CData) -> int: ...\ndef alignment(obj_or_type: _CData | type[_CData]) -> int: ...\ndef byref(obj: _CData, offset: int = ...) -> _CArgObject: ...\n\n_CastT = TypeVar(\"_CastT\", bound=_CanCastTo)\n\ndef cast(obj: _CData | _CArgObject | int, typ: type[_CastT]) -> _CastT: ...\ndef create_string_buffer(init: int | bytes, size: int | None = None) -> Array[c_char]: ...\n\nc_buffer = create_string_buffer\n\ndef create_unicode_buffer(init: int | str, size: int | None = None) -> Array[c_wchar]: ...\n\nif sys.platform == \"win32\":\n    def DllCanUnloadNow() -> int: ...\n    def DllGetClassObject(rclsid: Any, riid: Any, ppv: Any) -> int: ...  # TODO not documented\n    def FormatError(code: int = ...) -> str: ...\n    def GetLastError() -> int: ...\n\ndef get_errno() -> int: ...\n\nif sys.platform == \"win32\":\n    def get_last_error() -> int: ...\n\ndef memmove(dst: _CVoidPLike, src: _CVoidConstPLike, count: int) -> int: ...\ndef memset(dst: _CVoidPLike, c: int, count: int) -> int: ...\ndef POINTER(type: type[_CT]) -> type[_Pointer[_CT]]: ...\n\nclass _Pointer(Generic[_CT], _PointerLike, _CData):\n    _type_: type[_CT]\n    contents: _CT\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, arg: _CT) -> None: ...\n    @overload\n    def __getitem__(self, __key: int) -> Any: ...\n    @overload\n    def __getitem__(self, __key: slice) -> list[Any]: ...\n    def __setitem__(self, __key: int, __value: Any) -> None: ...\n\ndef pointer(__arg: _CT) -> _Pointer[_CT]: ...\ndef resize(obj: _CData, size: int) -> None: ...\ndef set_errno(value: int) -> int: ...\n\nif sys.platform == \"win32\":\n    def set_last_error(value: int) -> int: ...\n\ndef sizeof(obj_or_type: _CData | type[_CData]) -> int: ...\ndef string_at(address: _CVoidConstPLike, size: int = -1) -> bytes: ...\n\nif sys.platform == \"win32\":\n    def WinError(code: int | None = None, descr: str | None = None) -> OSError: ...\n\ndef wstring_at(address: _CVoidConstPLike, size: int = -1) -> str: ...\n\nclass _SimpleCData(Generic[_T], _CData):\n    value: _T\n    # The TypeVar can be unsolved here,\n    # but we can't use overloads without creating many, many mypy false-positive errors\n    def __init__(self, value: _T = ...) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]\n\nclass c_byte(_SimpleCData[int]): ...\n\nclass c_char(_SimpleCData[bytes]):\n    def __init__(self, value: int | bytes | bytearray = ...) -> None: ...\n\nclass c_char_p(_PointerLike, _SimpleCData[bytes | None]):\n    def __init__(self, value: int | bytes | None = ...) -> None: ...\n\nclass c_double(_SimpleCData[float]): ...\nclass c_longdouble(_SimpleCData[float]): ...\nclass c_float(_SimpleCData[float]): ...\nclass c_int(_SimpleCData[int]): ...\nclass c_int8(_SimpleCData[int]): ...\nclass c_int16(_SimpleCData[int]): ...\nclass c_int32(_SimpleCData[int]): ...\nclass c_int64(_SimpleCData[int]): ...\nclass c_long(_SimpleCData[int]): ...\nclass c_longlong(_SimpleCData[int]): ...\nclass c_short(_SimpleCData[int]): ...\nclass c_size_t(_SimpleCData[int]): ...\nclass c_ssize_t(_SimpleCData[int]): ...\nclass c_ubyte(_SimpleCData[int]): ...\nclass c_uint(_SimpleCData[int]): ...\nclass c_uint8(_SimpleCData[int]): ...\nclass c_uint16(_SimpleCData[int]): ...\nclass c_uint32(_SimpleCData[int]): ...\nclass c_uint64(_SimpleCData[int]): ...\nclass c_ulong(_SimpleCData[int]): ...\nclass c_ulonglong(_SimpleCData[int]): ...\nclass c_ushort(_SimpleCData[int]): ...\nclass c_void_p(_PointerLike, _SimpleCData[int | None]): ...\nclass c_wchar(_SimpleCData[str]): ...\n\nclass c_wchar_p(_PointerLike, _SimpleCData[str | None]):\n    def __init__(self, value: int | str | None = ...) -> None: ...\n\nclass c_bool(_SimpleCData[bool]):\n    def __init__(self, value: bool = ...) -> None: ...\n\nif sys.platform == \"win32\":\n    class HRESULT(_SimpleCData[int]): ...  # TODO undocumented\n\nclass py_object(_CanCastTo, _SimpleCData[_T]): ...\n\nclass _CField:\n    offset: int\n    size: int\n\nclass _StructUnionMeta(_CDataMeta):\n    _fields_: Sequence[tuple[str, type[_CData]] | tuple[str, type[_CData], int]]\n    _pack_: int\n    _anonymous_: Sequence[str]\n    def __getattr__(self, name: str) -> _CField: ...\n\nclass _StructUnionBase(_CData, metaclass=_StructUnionMeta):\n    def __init__(self, *args: Any, **kw: Any) -> None: ...\n    def __getattr__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n\nclass Union(_StructUnionBase): ...\nclass Structure(_StructUnionBase): ...\nclass BigEndianStructure(Structure): ...\nclass LittleEndianStructure(Structure): ...\n\nclass Array(Generic[_CT], _CData):\n    @property\n    @abstractmethod\n    def _length_(self) -> int: ...\n    @_length_.setter\n    def _length_(self, value: int) -> None: ...\n    @property\n    @abstractmethod\n    def _type_(self) -> type[_CT]: ...\n    @_type_.setter\n    def _type_(self, value: type[_CT]) -> None: ...\n    # Note: only available if _CT == c_char\n    @property\n    def raw(self) -> bytes: ...\n    @raw.setter\n    def raw(self, value: ReadableBuffer) -> None: ...\n    value: Any  # Note: bytes if _CT == c_char, str if _CT == c_wchar, unavailable otherwise\n    # TODO These methods cannot be annotated correctly at the moment.\n    # All of these \"Any\"s stand for the array's element type, but it's not possible to use _CT\n    # here, because of a special feature of ctypes.\n    # By default, when accessing an element of an Array[_CT], the returned object has type _CT.\n    # However, when _CT is a \"simple type\" like c_int, ctypes automatically \"unboxes\" the object\n    # and converts it to the corresponding Python primitive. For example, when accessing an element\n    # of an Array[c_int], a Python int object is returned, not a c_int.\n    # This behavior does *not* apply to subclasses of \"simple types\".\n    # If MyInt is a subclass of c_int, then accessing an element of an Array[MyInt] returns\n    # a MyInt, not an int.\n    # This special behavior is not easy to model in a stub, so for now all places where\n    # the array element type would belong are annotated with Any instead.\n    def __init__(self, *args: Any) -> None: ...\n    @overload\n    def __getitem__(self, __key: int) -> Any: ...\n    @overload\n    def __getitem__(self, __key: slice) -> list[Any]: ...\n    @overload\n    def __setitem__(self, __key: int, __value: Any) -> None: ...\n    @overload\n    def __setitem__(self, __key: slice, __value: Iterable[Any]) -> None: ...\n    def __iter__(self) -> Iterator[Any]: ...\n    # Can't inherit from Sized because the metaclass conflict between\n    # Sized and _CData prevents using _CDataMeta.\n    def __len__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n",
  "/typeshed/stdlib/ctypes/util.pyi": "import sys\n\ndef find_library(name: str) -> str | None: ...\n\nif sys.platform == \"win32\":\n    def find_msvcrt() -> str | None: ...\n",
  "/typeshed/stdlib/ctypes/wintypes.pyi": "from ctypes import (\n    Array,\n    Structure,\n    _Pointer,\n    _SimpleCData,\n    c_byte,\n    c_char,\n    c_char_p,\n    c_double,\n    c_float,\n    c_int,\n    c_long,\n    c_longlong,\n    c_short,\n    c_uint,\n    c_ulong,\n    c_ulonglong,\n    c_ushort,\n    c_void_p,\n    c_wchar,\n    c_wchar_p,\n)\nfrom typing_extensions import TypeAlias\n\nBYTE = c_byte\nWORD = c_ushort\nDWORD = c_ulong\nCHAR = c_char\nWCHAR = c_wchar\nUINT = c_uint\nINT = c_int\nDOUBLE = c_double\nFLOAT = c_float\nBOOLEAN = BYTE\nBOOL = c_long\n\nclass VARIANT_BOOL(_SimpleCData[bool]): ...\n\nULONG = c_ulong\nLONG = c_long\nUSHORT = c_ushort\nSHORT = c_short\nLARGE_INTEGER = c_longlong\n_LARGE_INTEGER = c_longlong\nULARGE_INTEGER = c_ulonglong\n_ULARGE_INTEGER = c_ulonglong\n\nOLESTR = c_wchar_p\nLPOLESTR = c_wchar_p\nLPCOLESTR = c_wchar_p\nLPWSTR = c_wchar_p\nLPCWSTR = c_wchar_p\nLPSTR = c_char_p\nLPCSTR = c_char_p\nLPVOID = c_void_p\nLPCVOID = c_void_p\n\n# These two types are pointer-sized unsigned and signed ints, respectively.\n# At runtime, they are either c_[u]long or c_[u]longlong, depending on the host's pointer size\n# (they are not really separate classes).\nclass WPARAM(_SimpleCData[int]): ...\nclass LPARAM(_SimpleCData[int]): ...\n\nATOM = WORD\nLANGID = WORD\nCOLORREF = DWORD\nLGRPID = DWORD\nLCTYPE = DWORD\nLCID = DWORD\n\nHANDLE = c_void_p\nHACCEL = HANDLE\nHBITMAP = HANDLE\nHBRUSH = HANDLE\nHCOLORSPACE = HANDLE\nHDC = HANDLE\nHDESK = HANDLE\nHDWP = HANDLE\nHENHMETAFILE = HANDLE\nHFONT = HANDLE\nHGDIOBJ = HANDLE\nHGLOBAL = HANDLE\nHHOOK = HANDLE\nHICON = HANDLE\nHINSTANCE = HANDLE\nHKEY = HANDLE\nHKL = HANDLE\nHLOCAL = HANDLE\nHMENU = HANDLE\nHMETAFILE = HANDLE\nHMODULE = HANDLE\nHMONITOR = HANDLE\nHPALETTE = HANDLE\nHPEN = HANDLE\nHRGN = HANDLE\nHRSRC = HANDLE\nHSTR = HANDLE\nHTASK = HANDLE\nHWINSTA = HANDLE\nHWND = HANDLE\nSC_HANDLE = HANDLE\nSERVICE_STATUS_HANDLE = HANDLE\n\nclass RECT(Structure):\n    left: LONG\n    top: LONG\n    right: LONG\n    bottom: LONG\n\nRECTL = RECT\n_RECTL = RECT\ntagRECT = RECT\n\nclass _SMALL_RECT(Structure):\n    Left: SHORT\n    Top: SHORT\n    Right: SHORT\n    Bottom: SHORT\n\nSMALL_RECT = _SMALL_RECT\n\nclass _COORD(Structure):\n    X: SHORT\n    Y: SHORT\n\nclass POINT(Structure):\n    x: LONG\n    y: LONG\n\nPOINTL = POINT\n_POINTL = POINT\ntagPOINT = POINT\n\nclass SIZE(Structure):\n    cx: LONG\n    cy: LONG\n\nSIZEL = SIZE\ntagSIZE = SIZE\n\ndef RGB(red: int, green: int, blue: int) -> int: ...\n\nclass FILETIME(Structure):\n    dwLowDateTime: DWORD\n    dwHighDateTime: DWORD\n\n_FILETIME = FILETIME\n\nclass MSG(Structure):\n    hWnd: HWND\n    message: UINT\n    wParam: WPARAM\n    lParam: LPARAM\n    time: DWORD\n    pt: POINT\n\ntagMSG = MSG\nMAX_PATH: int\n\nclass WIN32_FIND_DATAA(Structure):\n    dwFileAttributes: DWORD\n    ftCreationTime: FILETIME\n    ftLastAccessTime: FILETIME\n    ftLastWriteTime: FILETIME\n    nFileSizeHigh: DWORD\n    nFileSizeLow: DWORD\n    dwReserved0: DWORD\n    dwReserved1: DWORD\n    cFileName: Array[CHAR]\n    cAlternateFileName: Array[CHAR]\n\nclass WIN32_FIND_DATAW(Structure):\n    dwFileAttributes: DWORD\n    ftCreationTime: FILETIME\n    ftLastAccessTime: FILETIME\n    ftLastWriteTime: FILETIME\n    nFileSizeHigh: DWORD\n    nFileSizeLow: DWORD\n    dwReserved0: DWORD\n    dwReserved1: DWORD\n    cFileName: Array[WCHAR]\n    cAlternateFileName: Array[WCHAR]\n\n# These pointer type definitions use _Pointer[...] instead of POINTER(...), to allow them\n# to be used in type annotations.\nPBOOL: TypeAlias = _Pointer[BOOL]\nLPBOOL: TypeAlias = _Pointer[BOOL]\nPBOOLEAN: TypeAlias = _Pointer[BOOLEAN]\nPBYTE: TypeAlias = _Pointer[BYTE]\nLPBYTE: TypeAlias = _Pointer[BYTE]\nPCHAR: TypeAlias = _Pointer[CHAR]\nLPCOLORREF: TypeAlias = _Pointer[COLORREF]\nPDWORD: TypeAlias = _Pointer[DWORD]\nLPDWORD: TypeAlias = _Pointer[DWORD]\nPFILETIME: TypeAlias = _Pointer[FILETIME]\nLPFILETIME: TypeAlias = _Pointer[FILETIME]\nPFLOAT: TypeAlias = _Pointer[FLOAT]\nPHANDLE: TypeAlias = _Pointer[HANDLE]\nLPHANDLE: TypeAlias = _Pointer[HANDLE]\nPHKEY: TypeAlias = _Pointer[HKEY]\nLPHKL: TypeAlias = _Pointer[HKL]\nPINT: TypeAlias = _Pointer[INT]\nLPINT: TypeAlias = _Pointer[INT]\nPLARGE_INTEGER: TypeAlias = _Pointer[LARGE_INTEGER]\nPLCID: TypeAlias = _Pointer[LCID]\nPLONG: TypeAlias = _Pointer[LONG]\nLPLONG: TypeAlias = _Pointer[LONG]\nPMSG: TypeAlias = _Pointer[MSG]\nLPMSG: TypeAlias = _Pointer[MSG]\nPPOINT: TypeAlias = _Pointer[POINT]\nLPPOINT: TypeAlias = _Pointer[POINT]\nPPOINTL: TypeAlias = _Pointer[POINTL]\nPRECT: TypeAlias = _Pointer[RECT]\nLPRECT: TypeAlias = _Pointer[RECT]\nPRECTL: TypeAlias = _Pointer[RECTL]\nLPRECTL: TypeAlias = _Pointer[RECTL]\nLPSC_HANDLE: TypeAlias = _Pointer[SC_HANDLE]\nPSHORT: TypeAlias = _Pointer[SHORT]\nPSIZE: TypeAlias = _Pointer[SIZE]\nLPSIZE: TypeAlias = _Pointer[SIZE]\nPSIZEL: TypeAlias = _Pointer[SIZEL]\nLPSIZEL: TypeAlias = _Pointer[SIZEL]\nPSMALL_RECT: TypeAlias = _Pointer[SMALL_RECT]\nPUINT: TypeAlias = _Pointer[UINT]\nLPUINT: TypeAlias = _Pointer[UINT]\nPULARGE_INTEGER: TypeAlias = _Pointer[ULARGE_INTEGER]\nPULONG: TypeAlias = _Pointer[ULONG]\nPUSHORT: TypeAlias = _Pointer[USHORT]\nPWCHAR: TypeAlias = _Pointer[WCHAR]\nPWIN32_FIND_DATAA: TypeAlias = _Pointer[WIN32_FIND_DATAA]\nLPWIN32_FIND_DATAA: TypeAlias = _Pointer[WIN32_FIND_DATAA]\nPWIN32_FIND_DATAW: TypeAlias = _Pointer[WIN32_FIND_DATAW]\nLPWIN32_FIND_DATAW: TypeAlias = _Pointer[WIN32_FIND_DATAW]\nPWORD: TypeAlias = _Pointer[WORD]\nLPWORD: TypeAlias = _Pointer[WORD]\n",
  "/typeshed/stdlib/curses/__init__.pyi": "import sys\nfrom collections.abc import Callable\nfrom typing import TypeVar\nfrom typing_extensions import Concatenate, ParamSpec\n\nif sys.platform != \"win32\":\n    from _curses import *\n    from _curses import _CursesWindow as _CursesWindow\n\n    _T = TypeVar(\"_T\")\n    _P = ParamSpec(\"_P\")\n\n    # available after calling `curses.initscr()`\n    LINES: int\n    COLS: int\n\n    # available after calling `curses.start_color()`\n    COLORS: int\n    COLOR_PAIRS: int\n\n    def wrapper(__func: Callable[Concatenate[_CursesWindow, _P], _T], *arg: _P.args, **kwds: _P.kwargs) -> _T: ...\n",
  "/typeshed/stdlib/curses/ascii.pyi": "import sys\nfrom typing import TypeVar\n\nif sys.platform != \"win32\":\n    _CharT = TypeVar(\"_CharT\", str, int)\n\n    NUL: int\n    SOH: int\n    STX: int\n    ETX: int\n    EOT: int\n    ENQ: int\n    ACK: int\n    BEL: int\n    BS: int\n    TAB: int\n    HT: int\n    LF: int\n    NL: int\n    VT: int\n    FF: int\n    CR: int\n    SO: int\n    SI: int\n    DLE: int\n    DC1: int\n    DC2: int\n    DC3: int\n    DC4: int\n    NAK: int\n    SYN: int\n    ETB: int\n    CAN: int\n    EM: int\n    SUB: int\n    ESC: int\n    FS: int\n    GS: int\n    RS: int\n    US: int\n    SP: int\n    DEL: int\n\n    controlnames: list[int]\n    def isalnum(c: str | int) -> bool: ...\n    def isalpha(c: str | int) -> bool: ...\n    def isascii(c: str | int) -> bool: ...\n    def isblank(c: str | int) -> bool: ...\n    def iscntrl(c: str | int) -> bool: ...\n    def isdigit(c: str | int) -> bool: ...\n    def isgraph(c: str | int) -> bool: ...\n    def islower(c: str | int) -> bool: ...\n    def isprint(c: str | int) -> bool: ...\n    def ispunct(c: str | int) -> bool: ...\n    def isspace(c: str | int) -> bool: ...\n    def isupper(c: str | int) -> bool: ...\n    def isxdigit(c: str | int) -> bool: ...\n    def isctrl(c: str | int) -> bool: ...\n    def ismeta(c: str | int) -> bool: ...\n    def ascii(c: _CharT) -> _CharT: ...\n    def ctrl(c: _CharT) -> _CharT: ...\n    def alt(c: _CharT) -> _CharT: ...\n    def unctrl(c: str | int) -> str: ...\n",
  "/typeshed/stdlib/curses/has_key.pyi": "import sys\n\nif sys.platform != \"win32\":\n    def has_key(ch: int | str) -> bool: ...\n",
  "/typeshed/stdlib/curses/panel.pyi": "import sys\n\nif sys.platform != \"win32\":\n    from _curses import _CursesWindow\n\n    version: str\n\n    class _Curses_Panel:  # type is <class '_curses_panel.curses panel'> (note the space in the class name)\n        def above(self) -> _Curses_Panel: ...\n        def below(self) -> _Curses_Panel: ...\n        def bottom(self) -> None: ...\n        def hidden(self) -> bool: ...\n        def hide(self) -> None: ...\n        def move(self, y: int, x: int) -> None: ...\n        def replace(self, win: _CursesWindow) -> None: ...\n        def set_userptr(self, obj: object) -> None: ...\n        def show(self) -> None: ...\n        def top(self) -> None: ...\n        def userptr(self) -> object: ...\n        def window(self) -> _CursesWindow: ...\n\n    def bottom_panel() -> _Curses_Panel: ...\n    def new_panel(__win: _CursesWindow) -> _Curses_Panel: ...\n    def top_panel() -> _Curses_Panel: ...\n    def update_panels() -> _Curses_Panel: ...\n",
  "/typeshed/stdlib/curses/textpad.pyi": "import sys\nfrom collections.abc import Callable\n\nif sys.platform != \"win32\":\n    from _curses import _CursesWindow\n    def rectangle(win: _CursesWindow, uly: int, ulx: int, lry: int, lrx: int) -> None: ...\n\n    class Textbox:\n        stripspaces: bool\n        def __init__(self, win: _CursesWindow, insert_mode: bool = False) -> None: ...\n        def edit(self, validate: Callable[[int], int] | None = None) -> str: ...\n        def do_command(self, ch: str | int) -> None: ...\n        def gather(self) -> str: ...\n",
  "/typeshed/stdlib/dbm/__init__.pyi": "from collections.abc import Iterator, MutableMapping\nfrom types import TracebackType\nfrom typing_extensions import Literal, Self, TypeAlias\n\n__all__ = [\"open\", \"whichdb\", \"error\"]\n\n_KeyType: TypeAlias = str | bytes\n_ValueType: TypeAlias = str | bytes | bytearray\n_TFlags: TypeAlias = Literal[\n    \"r\",\n    \"w\",\n    \"c\",\n    \"n\",\n    \"rf\",\n    \"wf\",\n    \"cf\",\n    \"nf\",\n    \"rs\",\n    \"ws\",\n    \"cs\",\n    \"ns\",\n    \"ru\",\n    \"wu\",\n    \"cu\",\n    \"nu\",\n    \"rfs\",\n    \"wfs\",\n    \"cfs\",\n    \"nfs\",\n    \"rfu\",\n    \"wfu\",\n    \"cfu\",\n    \"nfu\",\n    \"rsf\",\n    \"wsf\",\n    \"csf\",\n    \"nsf\",\n    \"rsu\",\n    \"wsu\",\n    \"csu\",\n    \"nsu\",\n    \"ruf\",\n    \"wuf\",\n    \"cuf\",\n    \"nuf\",\n    \"rus\",\n    \"wus\",\n    \"cus\",\n    \"nus\",\n    \"rfsu\",\n    \"wfsu\",\n    \"cfsu\",\n    \"nfsu\",\n    \"rfus\",\n    \"wfus\",\n    \"cfus\",\n    \"nfus\",\n    \"rsfu\",\n    \"wsfu\",\n    \"csfu\",\n    \"nsfu\",\n    \"rsuf\",\n    \"wsuf\",\n    \"csuf\",\n    \"nsuf\",\n    \"rufs\",\n    \"wufs\",\n    \"cufs\",\n    \"nufs\",\n    \"rusf\",\n    \"wusf\",\n    \"cusf\",\n    \"nusf\",\n]\n\nclass _Database(MutableMapping[_KeyType, bytes]):\n    def close(self) -> None: ...\n    def __getitem__(self, key: _KeyType) -> bytes: ...\n    def __setitem__(self, key: _KeyType, value: _ValueType) -> None: ...\n    def __delitem__(self, key: _KeyType) -> None: ...\n    def __iter__(self) -> Iterator[bytes]: ...\n    def __len__(self) -> int: ...\n    def __del__(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n\nclass _error(Exception): ...\n\nerror: tuple[type[_error], type[OSError]]\n\ndef whichdb(filename: str) -> str: ...\ndef open(file: str, flag: _TFlags = \"r\", mode: int = 0o666) -> _Database: ...\n",
  "/typeshed/stdlib/dbm/dumb.pyi": "from collections.abc import Iterator, MutableMapping\nfrom types import TracebackType\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\"error\", \"open\"]\n\n_KeyType: TypeAlias = str | bytes\n_ValueType: TypeAlias = str | bytes\n\nerror = OSError\n\n# This class doesn't exist at runtime. open() can return an instance of\n# any of the three implementations of dbm (dumb, gnu, ndbm), and this\n# class is intended to represent the common interface supported by all three.\nclass _Database(MutableMapping[_KeyType, bytes]):\n    def __init__(self, filebasename: str, mode: str, flag: str = \"c\") -> None: ...\n    def sync(self) -> None: ...\n    def iterkeys(self) -> Iterator[bytes]: ...  # undocumented\n    def close(self) -> None: ...\n    def __getitem__(self, key: _KeyType) -> bytes: ...\n    def __setitem__(self, key: _KeyType, val: _ValueType) -> None: ...\n    def __delitem__(self, key: _KeyType) -> None: ...\n    def __iter__(self) -> Iterator[bytes]: ...\n    def __len__(self) -> int: ...\n    def __del__(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n\ndef open(file: str, flag: str = \"c\", mode: int = 0o666) -> _Database: ...\n",
  "/typeshed/stdlib/dbm/gnu.pyi": "import sys\nfrom _typeshed import ReadOnlyBuffer\nfrom types import TracebackType\nfrom typing import TypeVar, overload\nfrom typing_extensions import Self, TypeAlias\n\nif sys.platform != \"win32\":\n    _T = TypeVar(\"_T\")\n    _KeyType: TypeAlias = str | ReadOnlyBuffer\n    _ValueType: TypeAlias = str | ReadOnlyBuffer\n\n    open_flags: str\n\n    class error(OSError): ...\n    # Actual typename gdbm, not exposed by the implementation\n    class _gdbm:\n        def firstkey(self) -> bytes | None: ...\n        def nextkey(self, key: _KeyType) -> bytes | None: ...\n        def reorganize(self) -> None: ...\n        def sync(self) -> None: ...\n        def close(self) -> None: ...\n        def __getitem__(self, item: _KeyType) -> bytes: ...\n        def __setitem__(self, key: _KeyType, value: _ValueType) -> None: ...\n        def __delitem__(self, key: _KeyType) -> None: ...\n        def __contains__(self, key: _KeyType) -> bool: ...\n        def __len__(self) -> int: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(\n            self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n        ) -> None: ...\n        @overload\n        def get(self, k: _KeyType) -> bytes | None: ...\n        @overload\n        def get(self, k: _KeyType, default: _T) -> bytes | _T: ...\n        def keys(self) -> list[bytes]: ...\n        def setdefault(self, k: _KeyType, default: _ValueType = ...) -> bytes: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n    def open(__filename: str, __flags: str = \"r\", __mode: int = 0o666) -> _gdbm: ...\n",
  "/typeshed/stdlib/dbm/ndbm.pyi": "import sys\nfrom _typeshed import ReadOnlyBuffer\nfrom types import TracebackType\nfrom typing import TypeVar, overload\nfrom typing_extensions import Self, TypeAlias\n\nif sys.platform != \"win32\":\n    _T = TypeVar(\"_T\")\n    _KeyType: TypeAlias = str | ReadOnlyBuffer\n    _ValueType: TypeAlias = str | ReadOnlyBuffer\n\n    class error(OSError): ...\n    library: str\n\n    # Actual typename dbm, not exposed by the implementation\n    class _dbm:\n        def close(self) -> None: ...\n        def __getitem__(self, item: _KeyType) -> bytes: ...\n        def __setitem__(self, key: _KeyType, value: _ValueType) -> None: ...\n        def __delitem__(self, key: _KeyType) -> None: ...\n        def __len__(self) -> int: ...\n        def __del__(self) -> None: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(\n            self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n        ) -> None: ...\n        @overload\n        def get(self, k: _KeyType) -> bytes | None: ...\n        @overload\n        def get(self, k: _KeyType, default: _T) -> bytes | _T: ...\n        def keys(self) -> list[bytes]: ...\n        def setdefault(self, k: _KeyType, default: _ValueType = ...) -> bytes: ...\n        # Don't exist at runtime\n        __new__: None  # type: ignore[assignment]\n        __init__: None  # type: ignore[assignment]\n    def open(__filename: str, __flags: str = \"r\", __mode: int = 0o666) -> _dbm: ...\n",
  "/typeshed/stdlib/distutils/__init__.pyi": "",
  "/typeshed/stdlib/distutils/archive_util.pyi": "def make_archive(\n    base_name: str,\n    format: str,\n    root_dir: str | None = None,\n    base_dir: str | None = None,\n    verbose: int = 0,\n    dry_run: int = 0,\n    owner: str | None = None,\n    group: str | None = None,\n) -> str: ...\ndef make_tarball(\n    base_name: str,\n    base_dir: str,\n    compress: str | None = \"gzip\",\n    verbose: int = 0,\n    dry_run: int = 0,\n    owner: str | None = None,\n    group: str | None = None,\n) -> str: ...\ndef make_zipfile(base_name: str, base_dir: str, verbose: int = 0, dry_run: int = 0) -> str: ...\n",
  "/typeshed/stdlib/distutils/bcppcompiler.pyi": "from distutils.ccompiler import CCompiler\n\nclass BCPPCompiler(CCompiler): ...\n",
  "/typeshed/stdlib/distutils/ccompiler.pyi": "from collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\n_Macro: TypeAlias = tuple[str] | tuple[str, str | None]\n\ndef gen_lib_options(\n    compiler: CCompiler, library_dirs: list[str], runtime_library_dirs: list[str], libraries: list[str]\n) -> list[str]: ...\ndef gen_preprocess_options(macros: list[_Macro], include_dirs: list[str]) -> list[str]: ...\ndef get_default_compiler(osname: str | None = None, platform: str | None = None) -> str: ...\ndef new_compiler(\n    plat: str | None = None, compiler: str | None = None, verbose: int = 0, dry_run: int = 0, force: int = 0\n) -> CCompiler: ...\ndef show_compilers() -> None: ...\n\nclass CCompiler:\n    dry_run: bool\n    force: bool\n    verbose: bool\n    output_dir: str | None\n    macros: list[_Macro]\n    include_dirs: list[str]\n    libraries: list[str]\n    library_dirs: list[str]\n    runtime_library_dirs: list[str]\n    objects: list[str]\n    def __init__(self, verbose: int = 0, dry_run: int = 0, force: int = 0) -> None: ...\n    def add_include_dir(self, dir: str) -> None: ...\n    def set_include_dirs(self, dirs: list[str]) -> None: ...\n    def add_library(self, libname: str) -> None: ...\n    def set_libraries(self, libnames: list[str]) -> None: ...\n    def add_library_dir(self, dir: str) -> None: ...\n    def set_library_dirs(self, dirs: list[str]) -> None: ...\n    def add_runtime_library_dir(self, dir: str) -> None: ...\n    def set_runtime_library_dirs(self, dirs: list[str]) -> None: ...\n    def define_macro(self, name: str, value: str | None = None) -> None: ...\n    def undefine_macro(self, name: str) -> None: ...\n    def add_link_object(self, object: str) -> None: ...\n    def set_link_objects(self, objects: list[str]) -> None: ...\n    def detect_language(self, sources: str | list[str]) -> str | None: ...\n    def find_library_file(self, dirs: list[str], lib: str, debug: bool = ...) -> str | None: ...\n    def has_function(\n        self,\n        funcname: str,\n        includes: list[str] | None = None,\n        include_dirs: list[str] | None = None,\n        libraries: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n    ) -> bool: ...\n    def library_dir_option(self, dir: str) -> str: ...\n    def library_option(self, lib: str) -> str: ...\n    def runtime_library_dir_option(self, dir: str) -> str: ...\n    def set_executables(self, **args: str) -> None: ...\n    def compile(\n        self,\n        sources: list[str],\n        output_dir: str | None = None,\n        macros: _Macro | None = None,\n        include_dirs: list[str] | None = None,\n        debug: bool = ...,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n        depends: list[str] | None = None,\n    ) -> list[str]: ...\n    def create_static_lib(\n        self,\n        objects: list[str],\n        output_libname: str,\n        output_dir: str | None = None,\n        debug: bool = ...,\n        target_lang: str | None = None,\n    ) -> None: ...\n    def link(\n        self,\n        target_desc: str,\n        objects: list[str],\n        output_filename: str,\n        output_dir: str | None = None,\n        libraries: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n        runtime_library_dirs: list[str] | None = None,\n        export_symbols: list[str] | None = None,\n        debug: bool = ...,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n        build_temp: str | None = None,\n        target_lang: str | None = None,\n    ) -> None: ...\n    def link_executable(\n        self,\n        objects: list[str],\n        output_progname: str,\n        output_dir: str | None = None,\n        libraries: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n        runtime_library_dirs: list[str] | None = None,\n        debug: bool = ...,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n        target_lang: str | None = None,\n    ) -> None: ...\n    def link_shared_lib(\n        self,\n        objects: list[str],\n        output_libname: str,\n        output_dir: str | None = None,\n        libraries: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n        runtime_library_dirs: list[str] | None = None,\n        export_symbols: list[str] | None = None,\n        debug: bool = ...,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n        build_temp: str | None = None,\n        target_lang: str | None = None,\n    ) -> None: ...\n    def link_shared_object(\n        self,\n        objects: list[str],\n        output_filename: str,\n        output_dir: str | None = None,\n        libraries: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n        runtime_library_dirs: list[str] | None = None,\n        export_symbols: list[str] | None = None,\n        debug: bool = ...,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n        build_temp: str | None = None,\n        target_lang: str | None = None,\n    ) -> None: ...\n    def preprocess(\n        self,\n        source: str,\n        output_file: str | None = None,\n        macros: list[_Macro] | None = None,\n        include_dirs: list[str] | None = None,\n        extra_preargs: list[str] | None = None,\n        extra_postargs: list[str] | None = None,\n    ) -> None: ...\n    def executable_filename(self, basename: str, strip_dir: int = 0, output_dir: str = \"\") -> str: ...\n    def library_filename(self, libname: str, lib_type: str = \"static\", strip_dir: int = 0, output_dir: str = \"\") -> str: ...\n    def object_filenames(self, source_filenames: list[str], strip_dir: int = 0, output_dir: str = \"\") -> list[str]: ...\n    def shared_object_filename(self, basename: str, strip_dir: int = 0, output_dir: str = \"\") -> str: ...\n    def execute(self, func: Callable[..., object], args: tuple[Any, ...], msg: str | None = None, level: int = 1) -> None: ...\n    def spawn(self, cmd: list[str]) -> None: ...\n    def mkpath(self, name: str, mode: int = 0o777) -> None: ...\n    def move_file(self, src: str, dst: str) -> str: ...\n    def announce(self, msg: str, level: int = 1) -> None: ...\n    def warn(self, msg: str) -> None: ...\n    def debug_print(self, msg: str) -> None: ...\n",
  "/typeshed/stdlib/distutils/cmd.pyi": "from _typeshed import Incomplete\nfrom abc import abstractmethod\nfrom collections.abc import Callable, Iterable\nfrom distutils.dist import Distribution\nfrom typing import Any\n\nclass Command:\n    distribution: Distribution\n    sub_commands: list[tuple[str, Callable[[Command], bool] | None]]\n    def __init__(self, dist: Distribution) -> None: ...\n    @abstractmethod\n    def initialize_options(self) -> None: ...\n    @abstractmethod\n    def finalize_options(self) -> None: ...\n    @abstractmethod\n    def run(self) -> None: ...\n    def announce(self, msg: str, level: int = 1) -> None: ...\n    def debug_print(self, msg: str) -> None: ...\n    def ensure_string(self, option: str, default: str | None = None) -> None: ...\n    def ensure_string_list(self, option: str | list[str]) -> None: ...\n    def ensure_filename(self, option: str) -> None: ...\n    def ensure_dirname(self, option: str) -> None: ...\n    def get_command_name(self) -> str: ...\n    def set_undefined_options(self, src_cmd: str, *option_pairs: tuple[str, str]) -> None: ...\n    def get_finalized_command(self, command: str, create: int = 1) -> Command: ...\n    def reinitialize_command(self, command: Command | str, reinit_subcommands: int = 0) -> Command: ...\n    def run_command(self, command: str) -> None: ...\n    def get_sub_commands(self) -> list[str]: ...\n    def warn(self, msg: str) -> None: ...\n    def execute(self, func: Callable[..., object], args: Iterable[Any], msg: str | None = None, level: int = 1) -> None: ...\n    def mkpath(self, name: str, mode: int = 0o777) -> None: ...\n    def copy_file(\n        self, infile: str, outfile: str, preserve_mode: int = 1, preserve_times: int = 1, link: str | None = None, level: Any = 1\n    ) -> tuple[str, bool]: ...  # level is not used\n    def copy_tree(\n        self,\n        infile: str,\n        outfile: str,\n        preserve_mode: int = 1,\n        preserve_times: int = 1,\n        preserve_symlinks: int = 0,\n        level: Any = 1,\n    ) -> list[str]: ...  # level is not used\n    def move_file(self, src: str, dst: str, level: Any = 1) -> str: ...  # level is not used\n    def spawn(self, cmd: Iterable[str], search_path: int = 1, level: Any = 1) -> None: ...  # level is not used\n    def make_archive(\n        self,\n        base_name: str,\n        format: str,\n        root_dir: str | None = None,\n        base_dir: str | None = None,\n        owner: str | None = None,\n        group: str | None = None,\n    ) -> str: ...\n    def make_file(\n        self,\n        infiles: str | list[str] | tuple[str, ...],\n        outfile: str,\n        func: Callable[..., object],\n        args: list[Any],\n        exec_msg: str | None = None,\n        skip_msg: str | None = None,\n        level: Any = 1,\n    ) -> None: ...  # level is not used\n    def ensure_finalized(self) -> None: ...\n    def dump_options(self, header: Incomplete | None = None, indent: str = \"\") -> None: ...\n",
  "/typeshed/stdlib/distutils/config.pyi": "from abc import abstractmethod\nfrom distutils.cmd import Command\nfrom typing import ClassVar\n\nDEFAULT_PYPIRC: str\n\nclass PyPIRCCommand(Command):\n    DEFAULT_REPOSITORY: ClassVar[str]\n    DEFAULT_REALM: ClassVar[str]\n    repository: None\n    realm: None\n    user_options: ClassVar[list[tuple[str, str | None, str]]]\n    boolean_options: ClassVar[list[str]]\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    @abstractmethod\n    def run(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/core.pyi": "from _typeshed import StrOrBytesPath\nfrom collections.abc import Mapping\nfrom distutils.cmd import Command as Command\nfrom distutils.dist import Distribution as Distribution\nfrom distutils.extension import Extension as Extension\nfrom typing import Any\n\nUSAGE: str\n\ndef gen_usage(script_name: StrOrBytesPath) -> str: ...\n\nsetup_keywords: tuple[str, ...]\nextension_keywords: tuple[str, ...]\n\ndef setup(\n    *,\n    name: str = ...,\n    version: str = ...,\n    description: str = ...,\n    long_description: str = ...,\n    author: str = ...,\n    author_email: str = ...,\n    maintainer: str = ...,\n    maintainer_email: str = ...,\n    url: str = ...,\n    download_url: str = ...,\n    packages: list[str] = ...,\n    py_modules: list[str] = ...,\n    scripts: list[str] = ...,\n    ext_modules: list[Extension] = ...,\n    classifiers: list[str] = ...,\n    distclass: type[Distribution] = ...,\n    script_name: str = ...,\n    script_args: list[str] = ...,\n    options: Mapping[str, Any] = ...,\n    license: str = ...,\n    keywords: list[str] | str = ...,\n    platforms: list[str] | str = ...,\n    cmdclass: Mapping[str, type[Command]] = ...,\n    data_files: list[tuple[str, list[str]]] = ...,\n    package_dir: Mapping[str, str] = ...,\n    obsoletes: list[str] = ...,\n    provides: list[str] = ...,\n    requires: list[str] = ...,\n    command_packages: list[str] = ...,\n    command_options: Mapping[str, Mapping[str, tuple[Any, Any]]] = ...,\n    package_data: Mapping[str, list[str]] = ...,\n    include_package_data: bool = ...,\n    libraries: list[str] = ...,\n    headers: list[str] = ...,\n    ext_package: str = ...,\n    include_dirs: list[str] = ...,\n    password: str = ...,\n    fullname: str = ...,\n    **attrs: Any,\n) -> None: ...\ndef run_setup(script_name: str, script_args: list[str] | None = None, stop_after: str = \"run\") -> Distribution: ...\n",
  "/typeshed/stdlib/distutils/cygwinccompiler.pyi": "from distutils.unixccompiler import UnixCCompiler\nfrom distutils.version import LooseVersion\nfrom re import Pattern\nfrom typing_extensions import Literal\n\ndef get_msvcr() -> list[str] | None: ...\n\nclass CygwinCCompiler(UnixCCompiler): ...\nclass Mingw32CCompiler(CygwinCCompiler): ...\n\nCONFIG_H_OK: str\nCONFIG_H_NOTOK: str\nCONFIG_H_UNCERTAIN: str\n\ndef check_config_h() -> tuple[Literal[\"ok\", \"not ok\", \"uncertain\"], str]: ...\n\nRE_VERSION: Pattern[bytes]\n\ndef get_versions() -> tuple[LooseVersion | None, ...]: ...\ndef is_cygwingcc() -> bool: ...\n",
  "/typeshed/stdlib/distutils/debug.pyi": "DEBUG: bool | None\n",
  "/typeshed/stdlib/distutils/dep_util.pyi": "def newer(source: str, target: str) -> bool: ...\ndef newer_pairwise(sources: list[str], targets: list[str]) -> list[tuple[str, str]]: ...\ndef newer_group(sources: list[str], target: str, missing: str = \"error\") -> bool: ...\n",
  "/typeshed/stdlib/distutils/dir_util.pyi": "def mkpath(name: str, mode: int = 0o777, verbose: int = 1, dry_run: int = 0) -> list[str]: ...\ndef create_tree(base_dir: str, files: list[str], mode: int = 0o777, verbose: int = 1, dry_run: int = 0) -> None: ...\ndef copy_tree(\n    src: str,\n    dst: str,\n    preserve_mode: int = 1,\n    preserve_times: int = 1,\n    preserve_symlinks: int = 0,\n    update: int = 0,\n    verbose: int = 1,\n    dry_run: int = 0,\n) -> list[str]: ...\ndef remove_tree(directory: str, verbose: int = 1, dry_run: int = 0) -> None: ...\n",
  "/typeshed/stdlib/distutils/dist.pyi": "from _typeshed import FileDescriptorOrPath, Incomplete, SupportsWrite\nfrom collections.abc import Iterable, Mapping\nfrom distutils.cmd import Command\nfrom re import Pattern\nfrom typing import IO, Any, ClassVar, TypeVar, overload\nfrom typing_extensions import TypeAlias\n\ncommand_re: Pattern[str]\n\n_OptionsList: TypeAlias = list[tuple[str, str | None, str, int] | tuple[str, str | None, str]]\n_CommandT = TypeVar(\"_CommandT\", bound=Command)\n\nclass DistributionMetadata:\n    def __init__(self, path: FileDescriptorOrPath | None = None) -> None: ...\n    name: str | None\n    version: str | None\n    author: str | None\n    author_email: str | None\n    maintainer: str | None\n    maintainer_email: str | None\n    url: str | None\n    license: str | None\n    description: str | None\n    long_description: str | None\n    keywords: str | list[str] | None\n    platforms: str | list[str] | None\n    classifiers: str | list[str] | None\n    download_url: str | None\n    provides: list[str] | None\n    requires: list[str] | None\n    obsoletes: list[str] | None\n    def read_pkg_file(self, file: IO[str]) -> None: ...\n    def write_pkg_info(self, base_dir: str) -> None: ...\n    def write_pkg_file(self, file: SupportsWrite[str]) -> None: ...\n    def get_name(self) -> str: ...\n    def get_version(self) -> str: ...\n    def get_fullname(self) -> str: ...\n    def get_author(self) -> str: ...\n    def get_author_email(self) -> str: ...\n    def get_maintainer(self) -> str: ...\n    def get_maintainer_email(self) -> str: ...\n    def get_contact(self) -> str: ...\n    def get_contact_email(self) -> str: ...\n    def get_url(self) -> str: ...\n    def get_license(self) -> str: ...\n    def get_licence(self) -> str: ...\n    def get_description(self) -> str: ...\n    def get_long_description(self) -> str: ...\n    def get_keywords(self) -> str | list[str]: ...\n    def get_platforms(self) -> str | list[str]: ...\n    def get_classifiers(self) -> str | list[str]: ...\n    def get_download_url(self) -> str: ...\n    def get_requires(self) -> list[str]: ...\n    def set_requires(self, value: Iterable[str]) -> None: ...\n    def get_provides(self) -> list[str]: ...\n    def set_provides(self, value: Iterable[str]) -> None: ...\n    def get_obsoletes(self) -> list[str]: ...\n    def set_obsoletes(self, value: Iterable[str]) -> None: ...\n\nclass Distribution:\n    cmdclass: dict[str, type[Command]]\n    metadata: DistributionMetadata\n    def __init__(self, attrs: Mapping[str, Any] | None = None) -> None: ...\n    def get_option_dict(self, command: str) -> dict[str, tuple[str, str]]: ...\n    def parse_config_files(self, filenames: Iterable[str] | None = None) -> None: ...\n    def get_command_obj(self, command: str, create: bool = True) -> Command | None: ...\n    global_options: ClassVar[_OptionsList]\n    common_usage: ClassVar[str]\n    display_options: ClassVar[_OptionsList]\n    display_option_names: ClassVar[list[str]]\n    negative_opt: ClassVar[dict[str, str]]\n    verbose: int\n    dry_run: int\n    help: int\n    command_packages: list[str] | None\n    script_name: str | None\n    script_args: list[str] | None\n    command_options: dict[str, dict[str, tuple[str, str]]]\n    dist_files: list[tuple[str, str, str]]\n    packages: Incomplete\n    package_data: dict[str, list[str]]\n    package_dir: Incomplete\n    py_modules: Incomplete\n    libraries: Incomplete\n    headers: Incomplete\n    ext_modules: Incomplete\n    ext_package: Incomplete\n    include_dirs: Incomplete\n    extra_path: Incomplete\n    scripts: Incomplete\n    data_files: Incomplete\n    password: str\n    command_obj: Incomplete\n    have_run: Incomplete\n    want_user_cfg: bool\n    def dump_option_dicts(\n        self, header: Incomplete | None = None, commands: Incomplete | None = None, indent: str = \"\"\n    ) -> None: ...\n    def find_config_files(self): ...\n    commands: Incomplete\n    def parse_command_line(self): ...\n    def finalize_options(self) -> None: ...\n    def handle_display_options(self, option_order): ...\n    def print_command_list(self, commands, header, max_length) -> None: ...\n    def print_commands(self) -> None: ...\n    def get_command_list(self): ...\n    def get_command_packages(self): ...\n    def get_command_class(self, command: str) -> type[Command]: ...\n    @overload\n    def reinitialize_command(self, command: str, reinit_subcommands: bool = False) -> Command: ...\n    @overload\n    def reinitialize_command(self, command: _CommandT, reinit_subcommands: bool = False) -> _CommandT: ...\n    def announce(self, msg, level: int = 2) -> None: ...\n    def run_commands(self) -> None: ...\n    def run_command(self, command: str) -> None: ...\n    def has_pure_modules(self) -> bool: ...\n    def has_ext_modules(self) -> bool: ...\n    def has_c_libraries(self) -> bool: ...\n    def has_modules(self) -> bool: ...\n    def has_headers(self) -> bool: ...\n    def has_scripts(self) -> bool: ...\n    def has_data_files(self) -> bool: ...\n    def is_pure(self) -> bool: ...\n\n    # Getter methods generated in __init__\n    def get_name(self) -> str: ...\n    def get_version(self) -> str: ...\n    def get_fullname(self) -> str: ...\n    def get_author(self) -> str: ...\n    def get_author_email(self) -> str: ...\n    def get_maintainer(self) -> str: ...\n    def get_maintainer_email(self) -> str: ...\n    def get_contact(self) -> str: ...\n    def get_contact_email(self) -> str: ...\n    def get_url(self) -> str: ...\n    def get_license(self) -> str: ...\n    def get_licence(self) -> str: ...\n    def get_description(self) -> str: ...\n    def get_long_description(self) -> str: ...\n    def get_keywords(self) -> str | list[str]: ...\n    def get_platforms(self) -> str | list[str]: ...\n    def get_classifiers(self) -> str | list[str]: ...\n    def get_download_url(self) -> str: ...\n    def get_requires(self) -> list[str]: ...\n    def get_provides(self) -> list[str]: ...\n    def get_obsoletes(self) -> list[str]: ...\n",
  "/typeshed/stdlib/distutils/errors.pyi": "class DistutilsError(Exception): ...\nclass DistutilsModuleError(DistutilsError): ...\nclass DistutilsClassError(DistutilsError): ...\nclass DistutilsGetoptError(DistutilsError): ...\nclass DistutilsArgError(DistutilsError): ...\nclass DistutilsFileError(DistutilsError): ...\nclass DistutilsOptionError(DistutilsError): ...\nclass DistutilsSetupError(DistutilsError): ...\nclass DistutilsPlatformError(DistutilsError): ...\nclass DistutilsExecError(DistutilsError): ...\nclass DistutilsInternalError(DistutilsError): ...\nclass DistutilsTemplateError(DistutilsError): ...\nclass DistutilsByteCompileError(DistutilsError): ...\nclass CCompilerError(Exception): ...\nclass PreprocessError(CCompilerError): ...\nclass CompileError(CCompilerError): ...\nclass LibError(CCompilerError): ...\nclass LinkError(CCompilerError): ...\nclass UnknownFileError(CCompilerError): ...\n",
  "/typeshed/stdlib/distutils/extension.pyi": "class Extension:\n    name: str\n    sources: list[str]\n    include_dirs: list[str]\n    define_macros: list[tuple[str, str | None]]\n    undef_macros: list[str]\n    library_dirs: list[str]\n    libraries: list[str]\n    runtime_library_dirs: list[str]\n    extra_objects: list[str]\n    extra_compile_args: list[str]\n    extra_link_args: list[str]\n    export_symbols: list[str]\n    swig_opts: list[str]\n    depends: list[str]\n    language: str | None\n    optional: bool | None\n    def __init__(\n        self,\n        name: str,\n        sources: list[str],\n        include_dirs: list[str] | None = None,\n        define_macros: list[tuple[str, str | None]] | None = None,\n        undef_macros: list[str] | None = None,\n        library_dirs: list[str] | None = None,\n        libraries: list[str] | None = None,\n        runtime_library_dirs: list[str] | None = None,\n        extra_objects: list[str] | None = None,\n        extra_compile_args: list[str] | None = None,\n        extra_link_args: list[str] | None = None,\n        export_symbols: list[str] | None = None,\n        swig_opts: list[str] | None = None,\n        depends: list[str] | None = None,\n        language: str | None = None,\n        optional: bool | None = None,\n    ) -> None: ...\n",
  "/typeshed/stdlib/distutils/fancy_getopt.pyi": "from collections.abc import Iterable, Mapping\nfrom re import Pattern\nfrom typing import Any, overload\nfrom typing_extensions import TypeAlias\n\n_Option: TypeAlias = tuple[str, str | None, str]\n_GR: TypeAlias = tuple[list[str], OptionDummy]\n\nlongopt_pat: str\nlongopt_re: Pattern[str]\nneg_alias_re: Pattern[str]\nlongopt_xlate: dict[int, int]\n\nclass FancyGetopt:\n    def __init__(self, option_table: list[_Option] | None = None) -> None: ...\n    # TODO kinda wrong, `getopt(object=object())` is invalid\n    @overload\n    def getopt(self, args: list[str] | None = None) -> _GR: ...\n    @overload\n    def getopt(self, args: list[str] | None, object: Any) -> list[str]: ...\n    def get_option_order(self) -> list[tuple[str, str]]: ...\n    def generate_help(self, header: str | None = None) -> list[str]: ...\n\ndef fancy_getopt(\n    options: list[_Option], negative_opt: Mapping[_Option, _Option], object: Any, args: list[str] | None\n) -> list[str] | _GR: ...\n\nWS_TRANS: dict[int, str]\n\ndef wrap_text(text: str, width: int) -> list[str]: ...\ndef translate_longopt(opt: str) -> str: ...\n\nclass OptionDummy:\n    def __init__(self, options: Iterable[str] = []) -> None: ...\n",
  "/typeshed/stdlib/distutils/file_util.pyi": "from collections.abc import Sequence\n\ndef copy_file(\n    src: str,\n    dst: str,\n    preserve_mode: bool = ...,\n    preserve_times: bool = ...,\n    update: bool = ...,\n    link: str | None = None,\n    verbose: bool = ...,\n    dry_run: bool = ...,\n) -> tuple[str, str]: ...\ndef move_file(src: str, dst: str, verbose: bool = ..., dry_run: bool = ...) -> str: ...\ndef write_file(filename: str, contents: Sequence[str]) -> None: ...\n",
  "/typeshed/stdlib/distutils/filelist.pyi": "from collections.abc import Iterable\nfrom re import Pattern\nfrom typing import overload\nfrom typing_extensions import Literal\n\n# class is entirely undocumented\nclass FileList:\n    allfiles: Iterable[str] | None\n    files: list[str]\n    def __init__(self, warn: None = None, debug_print: None = None) -> None: ...\n    def set_allfiles(self, allfiles: Iterable[str]) -> None: ...\n    def findall(self, dir: str = \".\") -> None: ...\n    def debug_print(self, msg: str) -> None: ...\n    def append(self, item: str) -> None: ...\n    def extend(self, items: Iterable[str]) -> None: ...\n    def sort(self) -> None: ...\n    def remove_duplicates(self) -> None: ...\n    def process_template_line(self, line: str) -> None: ...\n    @overload\n    def include_pattern(\n        self, pattern: str, anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: Literal[0, False] = 0\n    ) -> bool: ...\n    @overload\n    def include_pattern(self, pattern: str | Pattern[str], *, is_regex: Literal[True, 1]) -> bool: ...\n    @overload\n    def include_pattern(\n        self, pattern: str | Pattern[str], anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: int = 0\n    ) -> bool: ...\n    @overload\n    def exclude_pattern(\n        self, pattern: str, anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: Literal[0, False] = 0\n    ) -> bool: ...\n    @overload\n    def exclude_pattern(self, pattern: str | Pattern[str], *, is_regex: Literal[True, 1]) -> bool: ...\n    @overload\n    def exclude_pattern(\n        self, pattern: str | Pattern[str], anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: int = 0\n    ) -> bool: ...\n\ndef findall(dir: str = \".\") -> list[str]: ...\ndef glob_to_re(pattern: str) -> str: ...\n@overload\ndef translate_pattern(\n    pattern: str, anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: Literal[False, 0] = 0\n) -> Pattern[str]: ...\n@overload\ndef translate_pattern(pattern: str | Pattern[str], *, is_regex: Literal[True, 1]) -> Pattern[str]: ...\n@overload\ndef translate_pattern(\n    pattern: str | Pattern[str], anchor: bool | Literal[0, 1] = 1, prefix: str | None = None, is_regex: int = 0\n) -> Pattern[str]: ...\n",
  "/typeshed/stdlib/distutils/log.pyi": "from typing import Any\n\nDEBUG: int\nINFO: int\nWARN: int\nERROR: int\nFATAL: int\n\nclass Log:\n    def __init__(self, threshold: int = 3) -> None: ...\n    def log(self, level: int, msg: str, *args: Any) -> None: ...\n    def debug(self, msg: str, *args: Any) -> None: ...\n    def info(self, msg: str, *args: Any) -> None: ...\n    def warn(self, msg: str, *args: Any) -> None: ...\n    def error(self, msg: str, *args: Any) -> None: ...\n    def fatal(self, msg: str, *args: Any) -> None: ...\n\ndef log(level: int, msg: str, *args: Any) -> None: ...\ndef debug(msg: str, *args: Any) -> None: ...\ndef info(msg: str, *args: Any) -> None: ...\ndef warn(msg: str, *args: Any) -> None: ...\ndef error(msg: str, *args: Any) -> None: ...\ndef fatal(msg: str, *args: Any) -> None: ...\ndef set_threshold(level: int) -> int: ...\ndef set_verbosity(v: int) -> None: ...\n",
  "/typeshed/stdlib/distutils/msvccompiler.pyi": "from distutils.ccompiler import CCompiler\n\nclass MSVCCompiler(CCompiler): ...\n",
  "/typeshed/stdlib/distutils/spawn.pyi": "def spawn(cmd: list[str], search_path: bool = ..., verbose: bool = ..., dry_run: bool = ...) -> None: ...\ndef find_executable(executable: str, path: str | None = None) -> str | None: ...\n",
  "/typeshed/stdlib/distutils/sysconfig.pyi": "import sys\nfrom collections.abc import Mapping\nfrom distutils.ccompiler import CCompiler\n\nPREFIX: str\nEXEC_PREFIX: str\nBASE_PREFIX: str\nBASE_EXEC_PREFIX: str\nproject_base: str\npython_build: bool\n\ndef expand_makefile_vars(s: str, vars: Mapping[str, str]) -> str: ...\ndef get_config_var(name: str) -> int | str | None: ...\ndef get_config_vars(*args: str) -> Mapping[str, int | str]: ...\ndef get_config_h_filename() -> str: ...\ndef get_makefile_filename() -> str: ...\ndef get_python_inc(plat_specific: bool = ..., prefix: str | None = None) -> str: ...\ndef get_python_lib(plat_specific: bool = ..., standard_lib: bool = ..., prefix: str | None = None) -> str: ...\ndef customize_compiler(compiler: CCompiler) -> None: ...\n\nif sys.version_info < (3, 10):\n    def get_python_version() -> str: ...\n",
  "/typeshed/stdlib/distutils/text_file.pyi": "from typing import IO\n\nclass TextFile:\n    def __init__(\n        self,\n        filename: str | None = None,\n        file: IO[str] | None = None,\n        *,\n        strip_comments: bool = ...,\n        lstrip_ws: bool = ...,\n        rstrip_ws: bool = ...,\n        skip_blanks: bool = ...,\n        join_lines: bool = ...,\n        collapse_join: bool = ...,\n    ) -> None: ...\n    def open(self, filename: str) -> None: ...\n    def close(self) -> None: ...\n    def warn(self, msg: str, line: list[int] | tuple[int, int] | int | None = None) -> None: ...\n    def readline(self) -> str | None: ...\n    def readlines(self) -> list[str]: ...\n    def unreadline(self, line: str) -> str: ...\n",
  "/typeshed/stdlib/distutils/unixccompiler.pyi": "from distutils.ccompiler import CCompiler\n\nclass UnixCCompiler(CCompiler): ...\n",
  "/typeshed/stdlib/distutils/util.pyi": "import sys\nfrom _typeshed import StrPath, Unused\nfrom collections.abc import Callable, Container, Iterable, Mapping\nfrom typing import Any\nfrom typing_extensions import Literal\n\nif sys.version_info >= (3, 8):\n    def get_host_platform() -> str: ...\n\ndef get_platform() -> str: ...\ndef convert_path(pathname: str) -> str: ...\ndef change_root(new_root: str, pathname: str) -> str: ...\ndef check_environ() -> None: ...\ndef subst_vars(s: str, local_vars: Mapping[str, str]) -> None: ...\ndef split_quoted(s: str) -> list[str]: ...\ndef execute(\n    func: Callable[..., object], args: tuple[Any, ...], msg: str | None = None, verbose: bool = ..., dry_run: bool = ...\n) -> None: ...\ndef strtobool(val: str) -> Literal[0, 1]: ...\ndef byte_compile(\n    py_files: list[str],\n    optimize: int = 0,\n    force: bool = ...,\n    prefix: str | None = None,\n    base_dir: str | None = None,\n    verbose: bool = ...,\n    dry_run: bool = ...,\n    direct: bool | None = None,\n) -> None: ...\ndef rfc822_escape(header: str) -> str: ...\ndef run_2to3(\n    files: Iterable[str],\n    fixer_names: Iterable[str] | None = None,\n    options: Mapping[str, Any] | None = None,\n    explicit: Unused = None,\n) -> None: ...\ndef copydir_run_2to3(\n    src: StrPath,\n    dest: StrPath,\n    template: str | None = None,\n    fixer_names: Iterable[str] | None = None,\n    options: Mapping[str, Any] | None = None,\n    explicit: Container[str] | None = None,\n) -> list[str]: ...\n\nclass Mixin2to3:\n    fixer_names: Iterable[str] | None\n    options: Mapping[str, Any] | None\n    explicit: Container[str] | None\n    def run_2to3(self, files: Iterable[str]) -> None: ...\n",
  "/typeshed/stdlib/distutils/version.pyi": "from abc import abstractmethod\nfrom re import Pattern\nfrom typing_extensions import Self\n\nclass Version:\n    def __eq__(self, other: object) -> bool: ...\n    def __lt__(self, other: Self | str) -> bool: ...\n    def __le__(self, other: Self | str) -> bool: ...\n    def __gt__(self, other: Self | str) -> bool: ...\n    def __ge__(self, other: Self | str) -> bool: ...\n    @abstractmethod\n    def __init__(self, vstring: str | None = None) -> None: ...\n    @abstractmethod\n    def parse(self, vstring: str) -> Self: ...\n    @abstractmethod\n    def __str__(self) -> str: ...\n    @abstractmethod\n    def _cmp(self, other: Self | str) -> bool: ...\n\nclass StrictVersion(Version):\n    version_re: Pattern[str]\n    version: tuple[int, int, int]\n    prerelease: tuple[str, int] | None\n    def __init__(self, vstring: str | None = None) -> None: ...\n    def parse(self, vstring: str) -> Self: ...\n    def __str__(self) -> str: ...  # noqa: Y029\n    def _cmp(self, other: Self | str) -> bool: ...\n\nclass LooseVersion(Version):\n    component_re: Pattern[str]\n    vstring: str\n    version: tuple[str | int, ...]\n    def __init__(self, vstring: str | None = None) -> None: ...\n    def parse(self, vstring: str) -> Self: ...\n    def __str__(self) -> str: ...  # noqa: Y029\n    def _cmp(self, other: Self | str) -> bool: ...\n",
  "/typeshed/stdlib/distutils/command/__init__.pyi": "",
  "/typeshed/stdlib/distutils/command/bdist.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\ndef show_formats() -> None: ...\n\nclass bdist(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    help_options: Any\n    no_format_option: Any\n    default_format: Any\n    format_commands: Any\n    format_command: Any\n    bdist_base: Any\n    plat_name: Any\n    formats: Any\n    dist_dir: Any\n    skip_build: int\n    group: Any\n    owner: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/bdist_dumb.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass bdist_dumb(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    default_format: Any\n    bdist_dir: Any\n    plat_name: Any\n    format: Any\n    keep_temp: int\n    dist_dir: Any\n    skip_build: Any\n    relative: int\n    owner: Any\n    group: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/bdist_msi.pyi": "import sys\nfrom typing import Any\n\nfrom ..cmd import Command\n\nif sys.platform == \"win32\":\n    from msilib import Dialog\n\n    class PyDialog(Dialog):\n        def __init__(self, *args, **kw) -> None: ...\n        def title(self, title) -> None: ...\n        def back(self, title, next, name: str = \"Back\", active: int = 1): ...\n        def cancel(self, title, next, name: str = \"Cancel\", active: int = 1): ...\n        def next(self, title, next, name: str = \"Next\", active: int = 1): ...\n        def xbutton(self, name, title, next, xpos): ...\n\n    class bdist_msi(Command):\n        description: str\n        user_options: Any\n        boolean_options: Any\n        all_versions: Any\n        other_version: str\n        if sys.version_info >= (3, 9):\n            def __init__(self, *args, **kw) -> None: ...\n        bdist_dir: Any\n        plat_name: Any\n        keep_temp: int\n        no_target_compile: int\n        no_target_optimize: int\n        target_version: Any\n        dist_dir: Any\n        skip_build: Any\n        install_script: Any\n        pre_install_script: Any\n        versions: Any\n        def initialize_options(self) -> None: ...\n        install_script_key: Any\n        def finalize_options(self) -> None: ...\n        db: Any\n        def run(self) -> None: ...\n        def add_files(self) -> None: ...\n        def add_find_python(self) -> None: ...\n        def add_scripts(self) -> None: ...\n        def add_ui(self) -> None: ...\n        def get_installer_filename(self, fullname): ...\n",
  "/typeshed/stdlib/distutils/command/bdist_packager.pyi": "",
  "/typeshed/stdlib/distutils/command/bdist_rpm.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass bdist_rpm(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    negative_opt: Any\n    bdist_base: Any\n    rpm_base: Any\n    dist_dir: Any\n    python: Any\n    fix_python: Any\n    spec_only: Any\n    binary_only: Any\n    source_only: Any\n    use_bzip2: Any\n    distribution_name: Any\n    group: Any\n    release: Any\n    serial: Any\n    vendor: Any\n    packager: Any\n    doc_files: Any\n    changelog: Any\n    icon: Any\n    prep_script: Any\n    build_script: Any\n    install_script: Any\n    clean_script: Any\n    verify_script: Any\n    pre_install: Any\n    post_install: Any\n    pre_uninstall: Any\n    post_uninstall: Any\n    prep: Any\n    provides: Any\n    requires: Any\n    conflicts: Any\n    build_requires: Any\n    obsoletes: Any\n    keep_temp: int\n    use_rpm_opt_flags: int\n    rpm3_mode: int\n    no_autoreq: int\n    force_arch: Any\n    quiet: int\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def finalize_package_data(self) -> None: ...\n    def run(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/bdist_wininst.pyi": "from _typeshed import StrOrBytesPath\nfrom distutils.cmd import Command\nfrom typing import Any, ClassVar\n\nclass bdist_wininst(Command):\n    description: ClassVar[str]\n    user_options: ClassVar[list[tuple[Any, ...]]]\n    boolean_options: ClassVar[list[str]]\n\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def get_inidata(self) -> str: ...\n    def create_exe(self, arcname: StrOrBytesPath, fullname: str, bitmap: StrOrBytesPath | None = None) -> None: ...\n    def get_installer_filename(self, fullname: str) -> str: ...\n    def get_exe_bytes(self) -> bytes: ...\n",
  "/typeshed/stdlib/distutils/command/build.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\ndef show_compilers() -> None: ...\n\nclass build(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    help_options: Any\n    build_base: str\n    build_purelib: Any\n    build_platlib: Any\n    build_lib: Any\n    build_temp: Any\n    build_scripts: Any\n    compiler: Any\n    plat_name: Any\n    debug: Any\n    force: int\n    executable: Any\n    parallel: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def has_pure_modules(self): ...\n    def has_c_libraries(self): ...\n    def has_ext_modules(self): ...\n    def has_scripts(self): ...\n    sub_commands: Any\n",
  "/typeshed/stdlib/distutils/command/build_clib.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\ndef show_compilers() -> None: ...\n\nclass build_clib(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    help_options: Any\n    build_clib: Any\n    build_temp: Any\n    libraries: Any\n    include_dirs: Any\n    define: Any\n    undef: Any\n    debug: Any\n    force: int\n    compiler: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def check_library_list(self, libraries) -> None: ...\n    def get_library_names(self): ...\n    def get_source_files(self): ...\n    def build_libraries(self, libraries) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/build_ext.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nextension_name_re: Any\n\ndef show_compilers() -> None: ...\n\nclass build_ext(Command):\n    description: str\n    sep_by: Any\n    user_options: Any\n    boolean_options: Any\n    help_options: Any\n    extensions: Any\n    build_lib: Any\n    plat_name: Any\n    build_temp: Any\n    inplace: int\n    package: Any\n    include_dirs: Any\n    define: Any\n    undef: Any\n    libraries: Any\n    library_dirs: Any\n    rpath: Any\n    link_objects: Any\n    debug: Any\n    force: Any\n    compiler: Any\n    swig: Any\n    swig_cpp: Any\n    swig_opts: Any\n    user: Any\n    parallel: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def check_extensions_list(self, extensions) -> None: ...\n    def get_source_files(self): ...\n    def get_outputs(self): ...\n    def build_extensions(self) -> None: ...\n    def build_extension(self, ext) -> None: ...\n    def swig_sources(self, sources, extension): ...\n    def find_swig(self): ...\n    def get_ext_fullpath(self, ext_name: str) -> str: ...\n    def get_ext_fullname(self, ext_name: str) -> str: ...\n    def get_ext_filename(self, ext_name: str) -> str: ...\n    def get_export_symbols(self, ext): ...\n    def get_libraries(self, ext): ...\n",
  "/typeshed/stdlib/distutils/command/build_py.pyi": "from typing import Any\n\nfrom ..cmd import Command\nfrom ..util import Mixin2to3 as Mixin2to3\n\nclass build_py(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    negative_opt: Any\n    build_lib: Any\n    py_modules: Any\n    package: Any\n    package_data: Any\n    package_dir: Any\n    compile: int\n    optimize: int\n    force: Any\n    def initialize_options(self) -> None: ...\n    packages: Any\n    data_files: Any\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def get_data_files(self): ...\n    def find_data_files(self, package, src_dir): ...\n    def build_package_data(self) -> None: ...\n    def get_package_dir(self, package): ...\n    def check_package(self, package, package_dir): ...\n    def check_module(self, module, module_file): ...\n    def find_package_modules(self, package, package_dir): ...\n    def find_modules(self): ...\n    def find_all_modules(self): ...\n    def get_source_files(self): ...\n    def get_module_outfile(self, build_dir, package, module): ...\n    def get_outputs(self, include_bytecode: int = 1): ...\n    def build_module(self, module, module_file, package): ...\n    def build_modules(self) -> None: ...\n    def build_packages(self) -> None: ...\n    def byte_compile(self, files) -> None: ...\n\nclass build_py_2to3(build_py, Mixin2to3):\n    updated_files: Any\n    def run(self) -> None: ...\n    def build_module(self, module, module_file, package): ...\n",
  "/typeshed/stdlib/distutils/command/build_scripts.pyi": "from typing import Any\n\nfrom ..cmd import Command\nfrom ..util import Mixin2to3 as Mixin2to3\n\nfirst_line_re: Any\n\nclass build_scripts(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    build_dir: Any\n    scripts: Any\n    force: Any\n    executable: Any\n    outfiles: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def get_source_files(self): ...\n    def run(self) -> None: ...\n    def copy_scripts(self): ...\n\nclass build_scripts_2to3(build_scripts, Mixin2to3):\n    def copy_scripts(self): ...\n",
  "/typeshed/stdlib/distutils/command/check.pyi": "from typing import Any\nfrom typing_extensions import TypeAlias\n\nfrom ..cmd import Command\n\n_Reporter: TypeAlias = Any  # really docutils.utils.Reporter\n\n# Only defined if docutils is installed.\n# Depends on a third-party stub. Since distutils is deprecated anyway,\n# it's easier to just suppress the \"any subclassing\" error.\nclass SilentReporter(_Reporter):\n    messages: Any\n    def __init__(\n        self,\n        source,\n        report_level,\n        halt_level,\n        stream: Any | None = ...,\n        debug: int = ...,\n        encoding: str = ...,\n        error_handler: str = ...,\n    ) -> None: ...\n    def system_message(self, level, message, *children, **kwargs): ...\n\nHAS_DOCUTILS: bool\n\nclass check(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    restructuredtext: int\n    metadata: int\n    strict: int\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def warn(self, msg): ...\n    def run(self) -> None: ...\n    def check_metadata(self) -> None: ...\n    def check_restructuredtext(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/clean.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass clean(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    build_base: Any\n    build_lib: Any\n    build_temp: Any\n    build_scripts: Any\n    bdist_base: Any\n    all: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/config.pyi": "from collections.abc import Sequence\nfrom re import Pattern\nfrom typing import Any\n\nfrom ..ccompiler import CCompiler\nfrom ..cmd import Command\n\nLANG_EXT: dict[str, str]\n\nclass config(Command):\n    description: str\n    # Tuple is full name, short name, description\n    user_options: Sequence[tuple[str, str | None, str]]\n    compiler: str | CCompiler\n    cc: str | None\n    include_dirs: Sequence[str] | None\n    libraries: Sequence[str] | None\n    library_dirs: Sequence[str] | None\n    noisy: int\n    dump_source: int\n    temp_files: Sequence[str]\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def try_cpp(\n        self,\n        body: str | None = None,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        lang: str = \"c\",\n    ) -> bool: ...\n    def search_cpp(\n        self,\n        pattern: Pattern[str] | str,\n        body: str | None = None,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        lang: str = \"c\",\n    ) -> bool: ...\n    def try_compile(\n        self, body: str, headers: Sequence[str] | None = None, include_dirs: Sequence[str] | None = None, lang: str = \"c\"\n    ) -> bool: ...\n    def try_link(\n        self,\n        body: str,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        libraries: Sequence[str] | None = None,\n        library_dirs: Sequence[str] | None = None,\n        lang: str = \"c\",\n    ) -> bool: ...\n    def try_run(\n        self,\n        body: str,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        libraries: Sequence[str] | None = None,\n        library_dirs: Sequence[str] | None = None,\n        lang: str = \"c\",\n    ) -> bool: ...\n    def check_func(\n        self,\n        func: str,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        libraries: Sequence[str] | None = None,\n        library_dirs: Sequence[str] | None = None,\n        decl: int = 0,\n        call: int = 0,\n    ) -> bool: ...\n    def check_lib(\n        self,\n        library: str,\n        library_dirs: Sequence[str] | None = None,\n        headers: Sequence[str] | None = None,\n        include_dirs: Sequence[str] | None = None,\n        other_libraries: list[str] = [],\n    ) -> bool: ...\n    def check_header(\n        self, header: str, include_dirs: Sequence[str] | None = None, library_dirs: Sequence[str] | None = None, lang: str = \"c\"\n    ) -> bool: ...\n\ndef dump_file(filename: str, head: Any | None = None) -> None: ...\n",
  "/typeshed/stdlib/distutils/command/install.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nHAS_USER_SITE: bool\nSCHEME_KEYS: tuple[str, ...]\nINSTALL_SCHEMES: dict[str, dict[Any, Any]]\n\nclass install(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    negative_opt: Any\n    prefix: str | None\n    exec_prefix: Any\n    home: str | None\n    user: bool\n    install_base: Any\n    install_platbase: Any\n    root: str | None\n    install_purelib: Any\n    install_platlib: Any\n    install_headers: Any\n    install_lib: str | None\n    install_scripts: Any\n    install_data: Any\n    install_userbase: Any\n    install_usersite: Any\n    compile: Any\n    optimize: Any\n    extra_path: Any\n    install_path_file: int\n    force: int\n    skip_build: int\n    warn_dir: int\n    build_base: Any\n    build_lib: Any\n    record: Any\n    def initialize_options(self) -> None: ...\n    config_vars: Any\n    install_libbase: Any\n    def finalize_options(self) -> None: ...\n    def dump_dirs(self, msg) -> None: ...\n    def finalize_unix(self) -> None: ...\n    def finalize_other(self) -> None: ...\n    def select_scheme(self, name) -> None: ...\n    def expand_basedirs(self) -> None: ...\n    def expand_dirs(self) -> None: ...\n    def convert_paths(self, *names) -> None: ...\n    path_file: Any\n    extra_dirs: Any\n    def handle_extra_path(self) -> None: ...\n    def change_roots(self, *names) -> None: ...\n    def create_home_path(self) -> None: ...\n    def run(self) -> None: ...\n    def create_path_file(self) -> None: ...\n    def get_outputs(self): ...\n    def get_inputs(self): ...\n    def has_lib(self): ...\n    def has_headers(self): ...\n    def has_scripts(self): ...\n    def has_data(self): ...\n    sub_commands: Any\n",
  "/typeshed/stdlib/distutils/command/install_data.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass install_data(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    install_dir: Any\n    outfiles: Any\n    root: Any\n    force: int\n    data_files: Any\n    warn_dir: int\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def get_inputs(self): ...\n    def get_outputs(self): ...\n",
  "/typeshed/stdlib/distutils/command/install_egg_info.pyi": "from typing import Any, ClassVar\n\nfrom ..cmd import Command\n\nclass install_egg_info(Command):\n    description: ClassVar[str]\n    user_options: ClassVar[list[tuple[str, str | None, str]]]\n    install_dir: Any\n    def initialize_options(self) -> None: ...\n    target: Any\n    outputs: Any\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def get_outputs(self) -> list[str]: ...\n\ndef safe_name(name): ...\ndef safe_version(version): ...\ndef to_filename(name): ...\n",
  "/typeshed/stdlib/distutils/command/install_headers.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass install_headers(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    install_dir: Any\n    force: int\n    outfiles: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def get_inputs(self): ...\n    def get_outputs(self): ...\n",
  "/typeshed/stdlib/distutils/command/install_lib.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nPYTHON_SOURCE_EXTENSION: str\n\nclass install_lib(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    negative_opt: Any\n    install_dir: Any\n    build_dir: Any\n    force: int\n    compile: Any\n    optimize: Any\n    skip_build: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def build(self) -> None: ...\n    def install(self): ...\n    def byte_compile(self, files) -> None: ...\n    def get_outputs(self): ...\n    def get_inputs(self): ...\n",
  "/typeshed/stdlib/distutils/command/install_scripts.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\nclass install_scripts(Command):\n    description: str\n    user_options: Any\n    boolean_options: Any\n    install_dir: Any\n    force: int\n    build_dir: Any\n    skip_build: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    outfiles: Any\n    def run(self) -> None: ...\n    def get_inputs(self): ...\n    def get_outputs(self): ...\n",
  "/typeshed/stdlib/distutils/command/register.pyi": "from typing import Any\n\nfrom ..config import PyPIRCCommand\n\nclass register(PyPIRCCommand):\n    description: str\n    sub_commands: Any\n    list_classifiers: int\n    strict: int\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def check_metadata(self) -> None: ...\n    def classifiers(self) -> None: ...\n    def verify_metadata(self) -> None: ...\n    def send_metadata(self) -> None: ...\n    def build_post_data(self, action): ...\n    def post_to_server(self, data, auth: Any | None = None): ...\n",
  "/typeshed/stdlib/distutils/command/sdist.pyi": "from typing import Any\n\nfrom ..cmd import Command\n\ndef show_formats() -> None: ...\n\nclass sdist(Command):\n    description: str\n    def checking_metadata(self): ...\n    user_options: Any\n    boolean_options: Any\n    help_options: Any\n    negative_opt: Any\n    sub_commands: Any\n    READMES: Any\n    template: Any\n    manifest: Any\n    use_defaults: int\n    prune: int\n    manifest_only: int\n    force_manifest: int\n    formats: Any\n    keep_temp: int\n    dist_dir: Any\n    archive_files: Any\n    metadata_check: int\n    owner: Any\n    group: Any\n    def initialize_options(self) -> None: ...\n    def finalize_options(self) -> None: ...\n    filelist: Any\n    def run(self) -> None: ...\n    def check_metadata(self) -> None: ...\n    def get_file_list(self) -> None: ...\n    def add_defaults(self) -> None: ...\n    def read_template(self) -> None: ...\n    def prune_file_list(self) -> None: ...\n    def write_manifest(self) -> None: ...\n    def read_manifest(self) -> None: ...\n    def make_release_tree(self, base_dir, files) -> None: ...\n    def make_distribution(self) -> None: ...\n    def get_archive_files(self): ...\n",
  "/typeshed/stdlib/distutils/command/upload.pyi": "from typing import Any, ClassVar\n\nfrom ..config import PyPIRCCommand\n\nclass upload(PyPIRCCommand):\n    description: ClassVar[str]\n    username: str\n    password: str\n    show_response: int\n    sign: bool\n    identity: Any\n    def initialize_options(self) -> None: ...\n    repository: Any\n    realm: Any\n    def finalize_options(self) -> None: ...\n    def run(self) -> None: ...\n    def upload_file(self, command: str, pyversion: str, filename: str) -> None: ...\n",
  "/typeshed/stdlib/email/__init__.pyi": "from collections.abc import Callable\nfrom email.message import Message\nfrom email.policy import Policy\nfrom typing import IO\nfrom typing_extensions import TypeAlias\n\n# Definitions imported by multiple submodules in typeshed\n_ParamType: TypeAlias = str | tuple[str | None, str | None, str]  # noqa: Y047\n_ParamsType: TypeAlias = str | None | tuple[str, str | None, str]  # noqa: Y047\n\ndef message_from_string(s: str, _class: Callable[[], Message] = ..., *, policy: Policy = ...) -> Message: ...\ndef message_from_bytes(s: bytes | bytearray, _class: Callable[[], Message] = ..., *, policy: Policy = ...) -> Message: ...\ndef message_from_file(fp: IO[str], _class: Callable[[], Message] = ..., *, policy: Policy = ...) -> Message: ...\ndef message_from_binary_file(fp: IO[bytes], _class: Callable[[], Message] = ..., *, policy: Policy = ...) -> Message: ...\n\n# Names in __all__ with no definition:\n#   base64mime\n#   charset\n#   encoders\n#   errors\n#   feedparser\n#   generator\n#   header\n#   iterators\n#   message\n#   mime\n#   parser\n#   quoprimime\n#   utils\n",
  "/typeshed/stdlib/email/_header_value_parser.pyi": "import sys\nfrom collections.abc import Iterable, Iterator\nfrom email.errors import HeaderParseError, MessageDefect\nfrom email.policy import Policy\nfrom re import Pattern\nfrom typing import Any\nfrom typing_extensions import Final, Self\n\nWSP: Final[set[str]]\nCFWS_LEADER: Final[set[str]]\nSPECIALS: Final[set[str]]\nATOM_ENDS: Final[set[str]]\nDOT_ATOM_ENDS: Final[set[str]]\nPHRASE_ENDS: Final[set[str]]\nTSPECIALS: Final[set[str]]\nTOKEN_ENDS: Final[set[str]]\nASPECIALS: Final[set[str]]\nATTRIBUTE_ENDS: Final[set[str]]\nEXTENDED_ATTRIBUTE_ENDS: Final[set[str]]\n\ndef quote_string(value: Any) -> str: ...\n\nrfc2047_matcher: Pattern[str]\n\nclass TokenList(list[TokenList | Terminal]):\n    token_type: str | None\n    syntactic_break: bool\n    ew_combine_allowed: bool\n    defects: list[MessageDefect]\n    def __init__(self, *args: Any, **kw: Any) -> None: ...\n    @property\n    def value(self) -> str: ...\n    @property\n    def all_defects(self) -> list[MessageDefect]: ...\n    def startswith_fws(self) -> bool: ...\n    @property\n    def as_ew_allowed(self) -> bool: ...\n    @property\n    def comments(self) -> list[str]: ...\n    def fold(self, *, policy: Policy) -> str: ...\n    def pprint(self, indent: str = \"\") -> None: ...\n    def ppstr(self, indent: str = \"\") -> str: ...\n\nclass WhiteSpaceTokenList(TokenList): ...\n\nclass UnstructuredTokenList(TokenList):\n    token_type: str\n\nclass Phrase(TokenList):\n    token_type: str\n\nclass Word(TokenList):\n    token_type: str\n\nclass CFWSList(WhiteSpaceTokenList):\n    token_type: str\n\nclass Atom(TokenList):\n    token_type: str\n\nclass Token(TokenList):\n    token_type: str\n    encode_as_ew: bool\n\nclass EncodedWord(TokenList):\n    token_type: str\n    cte: str | None\n    charset: str | None\n    lang: str | None\n\nclass QuotedString(TokenList):\n    token_type: str\n    @property\n    def content(self) -> str: ...\n    @property\n    def quoted_value(self) -> str: ...\n    @property\n    def stripped_value(self) -> str: ...\n\nclass BareQuotedString(QuotedString):\n    token_type: str\n\nclass Comment(WhiteSpaceTokenList):\n    token_type: str\n    def quote(self, value: Any) -> str: ...\n    @property\n    def content(self) -> str: ...\n\nclass AddressList(TokenList):\n    token_type: str\n    @property\n    def addresses(self) -> list[Address]: ...\n    @property\n    def mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def all_mailboxes(self) -> list[Mailbox]: ...\n\nclass Address(TokenList):\n    token_type: str\n    @property\n    def display_name(self) -> str: ...\n    @property\n    def mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def all_mailboxes(self) -> list[Mailbox]: ...\n\nclass MailboxList(TokenList):\n    token_type: str\n    @property\n    def mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def all_mailboxes(self) -> list[Mailbox]: ...\n\nclass GroupList(TokenList):\n    token_type: str\n    @property\n    def mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def all_mailboxes(self) -> list[Mailbox]: ...\n\nclass Group(TokenList):\n    token_type: str\n    @property\n    def mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def all_mailboxes(self) -> list[Mailbox]: ...\n    @property\n    def display_name(self) -> str: ...\n\nclass NameAddr(TokenList):\n    token_type: str\n    @property\n    def display_name(self) -> str: ...\n    @property\n    def local_part(self) -> str: ...\n    @property\n    def domain(self) -> str: ...\n    @property\n    def route(self) -> list[Domain] | None: ...\n    @property\n    def addr_spec(self) -> str: ...\n\nclass AngleAddr(TokenList):\n    token_type: str\n    @property\n    def local_part(self) -> str: ...\n    @property\n    def domain(self) -> str: ...\n    @property\n    def route(self) -> list[Domain] | None: ...\n    @property\n    def addr_spec(self) -> str: ...\n\nclass ObsRoute(TokenList):\n    token_type: str\n    @property\n    def domains(self) -> list[Domain]: ...\n\nclass Mailbox(TokenList):\n    token_type: str\n    @property\n    def display_name(self) -> str: ...\n    @property\n    def local_part(self) -> str: ...\n    @property\n    def domain(self) -> str: ...\n    @property\n    def route(self) -> list[str]: ...\n    @property\n    def addr_spec(self) -> str: ...\n\nclass InvalidMailbox(TokenList):\n    token_type: str\n    @property\n    def display_name(self) -> None: ...\n    @property\n    def local_part(self) -> None: ...\n    @property\n    def domain(self) -> None: ...\n    @property\n    def route(self) -> None: ...\n    @property\n    def addr_spec(self) -> None: ...\n\nclass Domain(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n    @property\n    def domain(self) -> str: ...\n\nclass DotAtom(TokenList):\n    token_type: str\n\nclass DotAtomText(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n\nif sys.version_info >= (3, 8):\n    class NoFoldLiteral(TokenList):\n        token_type: str\n        as_ew_allowed: bool\n\nclass AddrSpec(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n    @property\n    def local_part(self) -> str: ...\n    @property\n    def domain(self) -> str: ...\n    @property\n    def addr_spec(self) -> str: ...\n\nclass ObsLocalPart(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n\nclass DisplayName(Phrase):\n    token_type: str\n    @property\n    def display_name(self) -> str: ...\n\nclass LocalPart(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n    @property\n    def local_part(self) -> str: ...\n\nclass DomainLiteral(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n    @property\n    def domain(self) -> str: ...\n    @property\n    def ip(self) -> str: ...\n\nclass MIMEVersion(TokenList):\n    token_type: str\n    major: int | None\n    minor: int | None\n\nclass Parameter(TokenList):\n    token_type: str\n    sectioned: bool\n    extended: bool\n    charset: str\n    @property\n    def section_number(self) -> int: ...\n    @property\n    def param_value(self) -> str: ...\n\nclass InvalidParameter(Parameter):\n    token_type: str\n\nclass Attribute(TokenList):\n    token_type: str\n    @property\n    def stripped_value(self) -> str: ...\n\nclass Section(TokenList):\n    token_type: str\n    number: int | None\n\nclass Value(TokenList):\n    token_type: str\n    @property\n    def stripped_value(self) -> str: ...\n\nclass MimeParameters(TokenList):\n    token_type: str\n    syntactic_break: bool\n    @property\n    def params(self) -> Iterator[tuple[str, str]]: ...\n\nclass ParameterizedHeaderValue(TokenList):\n    syntactic_break: bool\n    @property\n    def params(self) -> Iterable[tuple[str, str]]: ...\n\nclass ContentType(ParameterizedHeaderValue):\n    token_type: str\n    as_ew_allowed: bool\n    maintype: str\n    subtype: str\n\nclass ContentDisposition(ParameterizedHeaderValue):\n    token_type: str\n    as_ew_allowed: bool\n    content_disposition: Any\n\nclass ContentTransferEncoding(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n    cte: str\n\nclass HeaderLabel(TokenList):\n    token_type: str\n    as_ew_allowed: bool\n\nif sys.version_info >= (3, 8):\n    class MsgID(TokenList):\n        token_type: str\n        as_ew_allowed: bool\n        def fold(self, policy: Policy) -> str: ...\n\n    class MessageID(MsgID):\n        token_type: str\n\n    class InvalidMessageID(MessageID):\n        token_type: str\n\nclass Header(TokenList):\n    token_type: str\n\nclass Terminal(str):\n    as_ew_allowed: bool\n    ew_combine_allowed: bool\n    syntactic_break: bool\n    token_type: str\n    defects: list[MessageDefect]\n    def __new__(cls, value: str, token_type: str) -> Self: ...\n    def pprint(self) -> None: ...\n    @property\n    def all_defects(self) -> list[MessageDefect]: ...\n    def pop_trailing_ws(self) -> None: ...\n    @property\n    def comments(self) -> list[str]: ...\n    def __getnewargs__(self) -> tuple[str, str]: ...  # type: ignore[override]\n\nclass WhiteSpaceTerminal(Terminal):\n    @property\n    def value(self) -> str: ...\n    def startswith_fws(self) -> bool: ...\n\nclass ValueTerminal(Terminal):\n    @property\n    def value(self) -> ValueTerminal: ...\n    def startswith_fws(self) -> bool: ...\n\nclass EWWhiteSpaceTerminal(WhiteSpaceTerminal): ...\nclass _InvalidEwError(HeaderParseError): ...\n\nDOT: Final[ValueTerminal]\nListSeparator: Final[ValueTerminal]\nRouteComponentMarker: Final[ValueTerminal]\n\ndef get_fws(value: str) -> tuple[WhiteSpaceTerminal, str]: ...\ndef get_encoded_word(value: str) -> tuple[EncodedWord, str]: ...\ndef get_unstructured(value: str) -> UnstructuredTokenList: ...\ndef get_qp_ctext(value: str) -> tuple[WhiteSpaceTerminal, str]: ...\ndef get_qcontent(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_atext(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_bare_quoted_string(value: str) -> tuple[BareQuotedString, str]: ...\ndef get_comment(value: str) -> tuple[Comment, str]: ...\ndef get_cfws(value: str) -> tuple[CFWSList, str]: ...\ndef get_quoted_string(value: str) -> tuple[QuotedString, str]: ...\ndef get_atom(value: str) -> tuple[Atom, str]: ...\ndef get_dot_atom_text(value: str) -> tuple[DotAtomText, str]: ...\ndef get_dot_atom(value: str) -> tuple[DotAtom, str]: ...\ndef get_word(value: str) -> tuple[Any, str]: ...\ndef get_phrase(value: str) -> tuple[Phrase, str]: ...\ndef get_local_part(value: str) -> tuple[LocalPart, str]: ...\ndef get_obs_local_part(value: str) -> tuple[ObsLocalPart, str]: ...\ndef get_dtext(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_domain_literal(value: str) -> tuple[DomainLiteral, str]: ...\ndef get_domain(value: str) -> tuple[Domain, str]: ...\ndef get_addr_spec(value: str) -> tuple[AddrSpec, str]: ...\ndef get_obs_route(value: str) -> tuple[ObsRoute, str]: ...\ndef get_angle_addr(value: str) -> tuple[AngleAddr, str]: ...\ndef get_display_name(value: str) -> tuple[DisplayName, str]: ...\ndef get_name_addr(value: str) -> tuple[NameAddr, str]: ...\ndef get_mailbox(value: str) -> tuple[Mailbox, str]: ...\ndef get_invalid_mailbox(value: str, endchars: str) -> tuple[InvalidMailbox, str]: ...\ndef get_mailbox_list(value: str) -> tuple[MailboxList, str]: ...\ndef get_group_list(value: str) -> tuple[GroupList, str]: ...\ndef get_group(value: str) -> tuple[Group, str]: ...\ndef get_address(value: str) -> tuple[Address, str]: ...\ndef get_address_list(value: str) -> tuple[AddressList, str]: ...\n\nif sys.version_info >= (3, 8):\n    def get_no_fold_literal(value: str) -> tuple[NoFoldLiteral, str]: ...\n    def get_msg_id(value: str) -> tuple[MsgID, str]: ...\n    def parse_message_id(value: str) -> MessageID: ...\n\ndef parse_mime_version(value: str) -> MIMEVersion: ...\ndef get_invalid_parameter(value: str) -> tuple[InvalidParameter, str]: ...\ndef get_ttext(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_token(value: str) -> tuple[Token, str]: ...\ndef get_attrtext(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_attribute(value: str) -> tuple[Attribute, str]: ...\ndef get_extended_attrtext(value: str) -> tuple[ValueTerminal, str]: ...\ndef get_extended_attribute(value: str) -> tuple[Attribute, str]: ...\ndef get_section(value: str) -> tuple[Section, str]: ...\ndef get_value(value: str) -> tuple[Value, str]: ...\ndef get_parameter(value: str) -> tuple[Parameter, str]: ...\ndef parse_mime_parameters(value: str) -> MimeParameters: ...\ndef parse_content_type_header(value: str) -> ContentType: ...\ndef parse_content_disposition_header(value: str) -> ContentDisposition: ...\ndef parse_content_transfer_encoding_header(value: str) -> ContentTransferEncoding: ...\n",
  "/typeshed/stdlib/email/base64mime.pyi": "__all__ = [\"body_decode\", \"body_encode\", \"decode\", \"decodestring\", \"header_encode\", \"header_length\"]\n\nfrom _typeshed import ReadableBuffer\n\ndef header_length(bytearray: str | bytes | bytearray) -> int: ...\ndef header_encode(header_bytes: str | ReadableBuffer, charset: str = \"iso-8859-1\") -> str: ...\n\n# First argument should be a buffer that supports slicing and len().\ndef body_encode(s: bytes | bytearray, maxlinelen: int = 76, eol: str = \"\\n\") -> str: ...\ndef decode(string: str | ReadableBuffer) -> bytes: ...\n\nbody_decode = decode\ndecodestring = decode\n",
  "/typeshed/stdlib/email/charset.pyi": "from collections.abc import Iterator\n\n__all__ = [\"Charset\", \"add_alias\", \"add_charset\", \"add_codec\"]\n\nQP: int  # undocumented\nBASE64: int  # undocumented\nSHORTEST: int  # undocumented\n\nclass Charset:\n    input_charset: str\n    header_encoding: int\n    body_encoding: int\n    output_charset: str | None\n    input_codec: str | None\n    output_codec: str | None\n    def __init__(self, input_charset: str = \"us-ascii\") -> None: ...\n    def get_body_encoding(self) -> str: ...\n    def get_output_charset(self) -> str | None: ...\n    def header_encode(self, string: str) -> str: ...\n    def header_encode_lines(self, string: str, maxlengths: Iterator[int]) -> list[str]: ...\n    def body_encode(self, string: str) -> str: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n\ndef add_charset(\n    charset: str, header_enc: int | None = None, body_enc: int | None = None, output_charset: str | None = None\n) -> None: ...\ndef add_alias(alias: str, canonical: str) -> None: ...\ndef add_codec(charset: str, codecname: str) -> None: ...\n",
  "/typeshed/stdlib/email/contentmanager.pyi": "from collections.abc import Callable\nfrom email.message import Message\nfrom typing import Any\n\nclass ContentManager:\n    def get_content(self, msg: Message, *args: Any, **kw: Any) -> Any: ...\n    def set_content(self, msg: Message, obj: Any, *args: Any, **kw: Any) -> Any: ...\n    def add_get_handler(self, key: str, handler: Callable[..., Any]) -> None: ...\n    def add_set_handler(self, typekey: type, handler: Callable[..., Any]) -> None: ...\n\nraw_data_manager: ContentManager\n",
  "/typeshed/stdlib/email/encoders.pyi": "from email.message import Message\n\n__all__ = [\"encode_7or8bit\", \"encode_base64\", \"encode_noop\", \"encode_quopri\"]\n\ndef encode_base64(msg: Message) -> None: ...\ndef encode_quopri(msg: Message) -> None: ...\ndef encode_7or8bit(msg: Message) -> None: ...\ndef encode_noop(msg: Message) -> None: ...\n",
  "/typeshed/stdlib/email/errors.pyi": "import sys\n\nclass MessageError(Exception): ...\nclass MessageParseError(MessageError): ...\nclass HeaderParseError(MessageParseError): ...\nclass BoundaryError(MessageParseError): ...\nclass MultipartConversionError(MessageError, TypeError): ...\nclass CharsetError(MessageError): ...\n\nclass MessageDefect(ValueError):\n    def __init__(self, line: str | None = None) -> None: ...\n\nclass NoBoundaryInMultipartDefect(MessageDefect): ...\nclass StartBoundaryNotFoundDefect(MessageDefect): ...\nclass FirstHeaderLineIsContinuationDefect(MessageDefect): ...\nclass MisplacedEnvelopeHeaderDefect(MessageDefect): ...\nclass MultipartInvariantViolationDefect(MessageDefect): ...\nclass InvalidMultipartContentTransferEncodingDefect(MessageDefect): ...\nclass UndecodableBytesDefect(MessageDefect): ...\nclass InvalidBase64PaddingDefect(MessageDefect): ...\nclass InvalidBase64CharactersDefect(MessageDefect): ...\nclass InvalidBase64LengthDefect(MessageDefect): ...\nclass CloseBoundaryNotFoundDefect(MessageDefect): ...\nclass MissingHeaderBodySeparatorDefect(MessageDefect): ...\n\nMalformedHeaderDefect = MissingHeaderBodySeparatorDefect\n\nclass HeaderDefect(MessageDefect): ...\nclass InvalidHeaderDefect(HeaderDefect): ...\nclass HeaderMissingRequiredValue(HeaderDefect): ...\n\nclass NonPrintableDefect(HeaderDefect):\n    def __init__(self, non_printables: str | None) -> None: ...\n\nclass ObsoleteHeaderDefect(HeaderDefect): ...\nclass NonASCIILocalPartDefect(HeaderDefect): ...\n\nif sys.version_info >= (3, 10):\n    class InvalidDateDefect(HeaderDefect): ...\n",
  "/typeshed/stdlib/email/feedparser.pyi": "from collections.abc import Callable\nfrom email.message import Message\nfrom email.policy import Policy\nfrom typing import Generic, TypeVar, overload\n\n__all__ = [\"FeedParser\", \"BytesFeedParser\"]\n\n_MessageT = TypeVar(\"_MessageT\", bound=Message)\n\nclass FeedParser(Generic[_MessageT]):\n    @overload\n    def __init__(self: FeedParser[Message], _factory: None = None, *, policy: Policy = ...) -> None: ...\n    @overload\n    def __init__(self, _factory: Callable[[], _MessageT], *, policy: Policy = ...) -> None: ...\n    def feed(self, data: str) -> None: ...\n    def close(self) -> _MessageT: ...\n\nclass BytesFeedParser(Generic[_MessageT]):\n    @overload\n    def __init__(self: BytesFeedParser[Message], _factory: None = None, *, policy: Policy = ...) -> None: ...\n    @overload\n    def __init__(self, _factory: Callable[[], _MessageT], *, policy: Policy = ...) -> None: ...\n    def feed(self, data: bytes | bytearray) -> None: ...\n    def close(self) -> _MessageT: ...\n",
  "/typeshed/stdlib/email/generator.pyi": "from _typeshed import SupportsWrite\nfrom email.message import Message\nfrom email.policy import Policy\n\n__all__ = [\"Generator\", \"DecodedGenerator\", \"BytesGenerator\"]\n\nclass Generator:\n    def clone(self, fp: SupportsWrite[str]) -> Generator: ...\n    def write(self, s: str) -> None: ...\n    def __init__(\n        self,\n        outfp: SupportsWrite[str],\n        mangle_from_: bool | None = None,\n        maxheaderlen: int | None = None,\n        *,\n        policy: Policy | None = None,\n    ) -> None: ...\n    def flatten(self, msg: Message, unixfrom: bool = False, linesep: str | None = None) -> None: ...\n\nclass BytesGenerator:\n    def clone(self, fp: SupportsWrite[bytes]) -> BytesGenerator: ...\n    def write(self, s: str) -> None: ...\n    def __init__(\n        self,\n        outfp: SupportsWrite[bytes],\n        mangle_from_: bool | None = None,\n        maxheaderlen: int | None = None,\n        *,\n        policy: Policy | None = None,\n    ) -> None: ...\n    def flatten(self, msg: Message, unixfrom: bool = False, linesep: str | None = None) -> None: ...\n\nclass DecodedGenerator(Generator):\n    def __init__(\n        self,\n        outfp: SupportsWrite[str],\n        mangle_from_: bool | None = None,\n        maxheaderlen: int | None = None,\n        fmt: str | None = None,\n        *,\n        policy: Policy | None = None,\n    ) -> None: ...\n",
  "/typeshed/stdlib/email/header.pyi": "from collections.abc import Iterable\nfrom email.charset import Charset\nfrom typing import Any\n\n__all__ = [\"Header\", \"decode_header\", \"make_header\"]\n\nclass Header:\n    def __init__(\n        self,\n        s: bytes | bytearray | str | None = None,\n        charset: Charset | str | None = None,\n        maxlinelen: int | None = None,\n        header_name: str | None = None,\n        continuation_ws: str = \" \",\n        errors: str = \"strict\",\n    ) -> None: ...\n    def append(self, s: bytes | bytearray | str, charset: Charset | str | None = None, errors: str = \"strict\") -> None: ...\n    def encode(self, splitchars: str = \";, \\t\", maxlinelen: int | None = None, linesep: str = \"\\n\") -> str: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n\n# decode_header() either returns list[tuple[str, None]] if the header\n# contains no encoded parts, or list[tuple[bytes, str | None]] if the header\n# contains at least one encoded part.\ndef decode_header(header: Header | str) -> list[tuple[Any, Any | None]]: ...\ndef make_header(\n    decoded_seq: Iterable[tuple[bytes | bytearray | str, str | None]],\n    maxlinelen: int | None = None,\n    header_name: str | None = None,\n    continuation_ws: str = \" \",\n) -> Header: ...\n",
  "/typeshed/stdlib/email/headerregistry.pyi": "import sys\nimport types\nfrom collections.abc import Iterable, Mapping\nfrom datetime import datetime as _datetime\nfrom email._header_value_parser import (\n    AddressList,\n    ContentDisposition,\n    ContentTransferEncoding,\n    ContentType,\n    MIMEVersion,\n    TokenList,\n    UnstructuredTokenList,\n)\nfrom email.errors import MessageDefect\nfrom email.policy import Policy\nfrom typing import Any, ClassVar, Protocol\nfrom typing_extensions import Literal, Self\n\nclass BaseHeader(str):\n    # max_count is actually more of an abstract ClassVar (not defined on the base class, but expected to be defined in subclasses)\n    max_count: ClassVar[Literal[1] | None]\n    @property\n    def name(self) -> str: ...\n    @property\n    def defects(self) -> tuple[MessageDefect, ...]: ...\n    def __new__(cls, name: str, value: Any) -> Self: ...\n    def init(self, name: str, *, parse_tree: TokenList, defects: Iterable[MessageDefect]) -> None: ...\n    def fold(self, *, policy: Policy) -> str: ...\n\nclass UnstructuredHeader:\n    max_count: ClassVar[Literal[1] | None]\n    @staticmethod\n    def value_parser(value: str) -> UnstructuredTokenList: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n\nclass UniqueUnstructuredHeader(UnstructuredHeader):\n    max_count: ClassVar[Literal[1]]\n\nclass DateHeader:\n    max_count: ClassVar[Literal[1] | None]\n    def init(self, name: str, *, parse_tree: TokenList, defects: Iterable[MessageDefect], datetime: _datetime) -> None: ...\n    @property\n    def datetime(self) -> _datetime: ...\n    @staticmethod\n    def value_parser(value: str) -> UnstructuredTokenList: ...\n    @classmethod\n    def parse(cls, value: str | _datetime, kwds: dict[str, Any]) -> None: ...\n\nclass UniqueDateHeader(DateHeader):\n    max_count: ClassVar[Literal[1]]\n\nclass AddressHeader:\n    max_count: ClassVar[Literal[1] | None]\n    def init(self, name: str, *, parse_tree: TokenList, defects: Iterable[MessageDefect], groups: Iterable[Group]) -> None: ...\n    @property\n    def groups(self) -> tuple[Group, ...]: ...\n    @property\n    def addresses(self) -> tuple[Address, ...]: ...\n    @staticmethod\n    def value_parser(value: str) -> AddressList: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n\nclass UniqueAddressHeader(AddressHeader):\n    max_count: ClassVar[Literal[1]]\n\nclass SingleAddressHeader(AddressHeader):\n    @property\n    def address(self) -> Address: ...\n\nclass UniqueSingleAddressHeader(SingleAddressHeader):\n    max_count: ClassVar[Literal[1]]\n\nclass MIMEVersionHeader:\n    max_count: ClassVar[Literal[1]]\n    def init(\n        self,\n        name: str,\n        *,\n        parse_tree: TokenList,\n        defects: Iterable[MessageDefect],\n        version: str | None,\n        major: int | None,\n        minor: int | None,\n    ) -> None: ...\n    @property\n    def version(self) -> str | None: ...\n    @property\n    def major(self) -> int | None: ...\n    @property\n    def minor(self) -> int | None: ...\n    @staticmethod\n    def value_parser(value: str) -> MIMEVersion: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n\nclass ParameterizedMIMEHeader:\n    max_count: ClassVar[Literal[1]]\n    def init(self, name: str, *, parse_tree: TokenList, defects: Iterable[MessageDefect], params: Mapping[str, Any]) -> None: ...\n    @property\n    def params(self) -> types.MappingProxyType[str, Any]: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n\nclass ContentTypeHeader(ParameterizedMIMEHeader):\n    @property\n    def content_type(self) -> str: ...\n    @property\n    def maintype(self) -> str: ...\n    @property\n    def subtype(self) -> str: ...\n    @staticmethod\n    def value_parser(value: str) -> ContentType: ...\n\nclass ContentDispositionHeader(ParameterizedMIMEHeader):\n    # init is redefined but has the same signature as parent class, so is omitted from the stub\n    @property\n    def content_disposition(self) -> str | None: ...\n    @staticmethod\n    def value_parser(value: str) -> ContentDisposition: ...\n\nclass ContentTransferEncodingHeader:\n    max_count: ClassVar[Literal[1]]\n    def init(self, name: str, *, parse_tree: TokenList, defects: Iterable[MessageDefect]) -> None: ...\n    @property\n    def cte(self) -> str: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n    @staticmethod\n    def value_parser(value: str) -> ContentTransferEncoding: ...\n\nif sys.version_info >= (3, 8):\n    from email._header_value_parser import MessageID\n\n    class MessageIDHeader:\n        max_count: ClassVar[Literal[1]]\n        @classmethod\n        def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n        @staticmethod\n        def value_parser(value: str) -> MessageID: ...\n\nclass _HeaderParser(Protocol):\n    max_count: ClassVar[Literal[1] | None]\n    @staticmethod\n    def value_parser(value: str) -> TokenList: ...\n    @classmethod\n    def parse(cls, value: str, kwds: dict[str, Any]) -> None: ...\n\nclass HeaderRegistry:\n    registry: dict[str, type[_HeaderParser]]\n    base_class: type[BaseHeader]\n    default_class: type[_HeaderParser]\n    def __init__(\n        self, base_class: type[BaseHeader] = ..., default_class: type[_HeaderParser] = ..., use_default_map: bool = True\n    ) -> None: ...\n    def map_to_type(self, name: str, cls: type[BaseHeader]) -> None: ...\n    def __getitem__(self, name: str) -> type[BaseHeader]: ...\n    def __call__(self, name: str, value: Any) -> BaseHeader: ...\n\nclass Address:\n    @property\n    def display_name(self) -> str: ...\n    @property\n    def username(self) -> str: ...\n    @property\n    def domain(self) -> str: ...\n    @property\n    def addr_spec(self) -> str: ...\n    def __init__(\n        self, display_name: str = \"\", username: str | None = \"\", domain: str | None = \"\", addr_spec: str | None = None\n    ) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n\nclass Group:\n    @property\n    def display_name(self) -> str | None: ...\n    @property\n    def addresses(self) -> tuple[Address, ...]: ...\n    def __init__(self, display_name: str | None = None, addresses: Iterable[Address] | None = None) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n",
  "/typeshed/stdlib/email/iterators.pyi": "from _typeshed import SupportsWrite\nfrom collections.abc import Iterator\nfrom email.message import Message\n\n__all__ = [\"body_line_iterator\", \"typed_subpart_iterator\", \"walk\"]\n\ndef body_line_iterator(msg: Message, decode: bool = False) -> Iterator[str]: ...\ndef typed_subpart_iterator(msg: Message, maintype: str = \"text\", subtype: str | None = None) -> Iterator[str]: ...\ndef walk(self: Message) -> Iterator[Message]: ...\n\n# We include the seemingly private function because it is documented in the stdlib documentation.\ndef _structure(msg: Message, fp: SupportsWrite[str] | None = None, level: int = 0, include_default: bool = False) -> None: ...\n",
  "/typeshed/stdlib/email/message.pyi": "from collections.abc import Generator, Iterator, Sequence\nfrom email import _ParamsType, _ParamType\nfrom email.charset import Charset\nfrom email.contentmanager import ContentManager\nfrom email.errors import MessageDefect\nfrom email.policy import Policy\nfrom typing import Any, TypeVar, overload\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\"Message\", \"EmailMessage\"]\n\n_T = TypeVar(\"_T\")\n\n_PayloadType: TypeAlias = list[Message] | str | bytes | bytearray\n_CharsetType: TypeAlias = Charset | str | None\n_HeaderType: TypeAlias = Any\n\nclass Message:\n    policy: Policy  # undocumented\n    preamble: str | None\n    epilogue: str | None\n    defects: list[MessageDefect]\n    def is_multipart(self) -> bool: ...\n    def set_unixfrom(self, unixfrom: str) -> None: ...\n    def get_unixfrom(self) -> str | None: ...\n    def attach(self, payload: Message) -> None: ...\n    def get_payload(self, i: int | None = None, decode: bool = False) -> Any: ...  # returns _PayloadType | None\n    def set_payload(self, payload: _PayloadType, charset: _CharsetType = None) -> None: ...\n    def set_charset(self, charset: _CharsetType) -> None: ...\n    def get_charset(self) -> _CharsetType: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, name: str) -> bool: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __getitem__(self, name: str) -> _HeaderType: ...\n    def __setitem__(self, name: str, val: _HeaderType) -> None: ...\n    def __delitem__(self, name: str) -> None: ...\n    def keys(self) -> list[str]: ...\n    def values(self) -> list[_HeaderType]: ...\n    def items(self) -> list[tuple[str, _HeaderType]]: ...\n    @overload\n    def get(self, name: str, failobj: None = None) -> _HeaderType | None: ...\n    @overload\n    def get(self, name: str, failobj: _T) -> _HeaderType | _T: ...\n    @overload\n    def get_all(self, name: str, failobj: None = None) -> list[_HeaderType] | None: ...\n    @overload\n    def get_all(self, name: str, failobj: _T) -> list[_HeaderType] | _T: ...\n    def add_header(self, _name: str, _value: str, **_params: _ParamsType) -> None: ...\n    def replace_header(self, _name: str, _value: _HeaderType) -> None: ...\n    def get_content_type(self) -> str: ...\n    def get_content_maintype(self) -> str: ...\n    def get_content_subtype(self) -> str: ...\n    def get_default_type(self) -> str: ...\n    def set_default_type(self, ctype: str) -> None: ...\n    @overload\n    def get_params(\n        self, failobj: None = None, header: str = \"content-type\", unquote: bool = True\n    ) -> list[tuple[str, str]] | None: ...\n    @overload\n    def get_params(self, failobj: _T, header: str = \"content-type\", unquote: bool = True) -> list[tuple[str, str]] | _T: ...\n    @overload\n    def get_param(\n        self, param: str, failobj: None = None, header: str = \"content-type\", unquote: bool = True\n    ) -> _ParamType | None: ...\n    @overload\n    def get_param(self, param: str, failobj: _T, header: str = \"content-type\", unquote: bool = True) -> _ParamType | _T: ...\n    def del_param(self, param: str, header: str = \"content-type\", requote: bool = True) -> None: ...\n    def set_type(self, type: str, header: str = \"Content-Type\", requote: bool = True) -> None: ...\n    @overload\n    def get_filename(self, failobj: None = None) -> str | None: ...\n    @overload\n    def get_filename(self, failobj: _T) -> str | _T: ...\n    @overload\n    def get_boundary(self, failobj: None = None) -> str | None: ...\n    @overload\n    def get_boundary(self, failobj: _T) -> str | _T: ...\n    def set_boundary(self, boundary: str) -> None: ...\n    @overload\n    def get_content_charset(self) -> str | None: ...\n    @overload\n    def get_content_charset(self, failobj: _T) -> str | _T: ...\n    @overload\n    def get_charsets(self, failobj: None = None) -> list[str | None]: ...\n    @overload\n    def get_charsets(self, failobj: _T) -> list[str | _T]: ...\n    def walk(self) -> Generator[Self, None, None]: ...\n    def get_content_disposition(self) -> str | None: ...\n    def as_string(self, unixfrom: bool = False, maxheaderlen: int = 0, policy: Policy | None = None) -> str: ...\n    def as_bytes(self, unixfrom: bool = False, policy: Policy | None = None) -> bytes: ...\n    def __bytes__(self) -> bytes: ...\n    def set_param(\n        self,\n        param: str,\n        value: str,\n        header: str = \"Content-Type\",\n        requote: bool = True,\n        charset: str | None = None,\n        language: str = \"\",\n        replace: bool = False,\n    ) -> None: ...\n    def __init__(self, policy: Policy = ...) -> None: ...\n    # The following two methods are undocumented, but a source code comment states that they are public API\n    def set_raw(self, name: str, value: _HeaderType) -> None: ...\n    def raw_items(self) -> Iterator[tuple[str, _HeaderType]]: ...\n\nclass MIMEPart(Message):\n    def __init__(self, policy: Policy | None = None) -> None: ...\n    def get_body(self, preferencelist: Sequence[str] = (\"related\", \"html\", \"plain\")) -> Message | None: ...\n    def iter_attachments(self) -> Iterator[Message]: ...\n    def iter_parts(self) -> Iterator[Message]: ...\n    def get_content(self, *args: Any, content_manager: ContentManager | None = None, **kw: Any) -> Any: ...\n    def set_content(self, *args: Any, content_manager: ContentManager | None = None, **kw: Any) -> None: ...\n    def make_related(self, boundary: str | None = None) -> None: ...\n    def make_alternative(self, boundary: str | None = None) -> None: ...\n    def make_mixed(self, boundary: str | None = None) -> None: ...\n    def add_related(self, *args: Any, content_manager: ContentManager | None = ..., **kw: Any) -> None: ...\n    def add_alternative(self, *args: Any, content_manager: ContentManager | None = ..., **kw: Any) -> None: ...\n    def add_attachment(self, *args: Any, content_manager: ContentManager | None = ..., **kw: Any) -> None: ...\n    def clear(self) -> None: ...\n    def clear_content(self) -> None: ...\n    def as_string(self, unixfrom: bool = False, maxheaderlen: int | None = None, policy: Policy | None = None) -> str: ...\n    def is_attachment(self) -> bool: ...\n\nclass EmailMessage(MIMEPart): ...\n",
  "/typeshed/stdlib/email/parser.pyi": "from _typeshed import SupportsRead\nfrom collections.abc import Callable\nfrom email.feedparser import BytesFeedParser as BytesFeedParser, FeedParser as FeedParser\nfrom email.message import Message\nfrom email.policy import Policy\nfrom typing import IO\n\n__all__ = [\"Parser\", \"HeaderParser\", \"BytesParser\", \"BytesHeaderParser\", \"FeedParser\", \"BytesFeedParser\"]\n\nclass Parser:\n    def __init__(self, _class: Callable[[], Message] | None = None, *, policy: Policy = ...) -> None: ...\n    def parse(self, fp: SupportsRead[str], headersonly: bool = False) -> Message: ...\n    def parsestr(self, text: str, headersonly: bool = False) -> Message: ...\n\nclass HeaderParser(Parser):\n    def parse(self, fp: SupportsRead[str], headersonly: bool = True) -> Message: ...\n    def parsestr(self, text: str, headersonly: bool = True) -> Message: ...\n\nclass BytesParser:\n    def __init__(self, _class: Callable[[], Message] = ..., *, policy: Policy = ...) -> None: ...\n    def parse(self, fp: IO[bytes], headersonly: bool = False) -> Message: ...\n    def parsebytes(self, text: bytes | bytearray, headersonly: bool = False) -> Message: ...\n\nclass BytesHeaderParser(BytesParser):\n    def parse(self, fp: IO[bytes], headersonly: bool = True) -> Message: ...\n    def parsebytes(self, text: bytes | bytearray, headersonly: bool = True) -> Message: ...\n",
  "/typeshed/stdlib/email/policy.pyi": "from abc import ABCMeta, abstractmethod\nfrom collections.abc import Callable\nfrom email.contentmanager import ContentManager\nfrom email.errors import MessageDefect\nfrom email.header import Header\nfrom email.message import Message\nfrom typing import Any\n\n__all__ = [\"Compat32\", \"compat32\", \"Policy\", \"EmailPolicy\", \"default\", \"strict\", \"SMTP\", \"HTTP\"]\n\nclass Policy(metaclass=ABCMeta):\n    max_line_length: int | None\n    linesep: str\n    cte_type: str\n    raise_on_defect: bool\n    mangle_from_: bool\n    message_factory: Callable[[Policy], Message] | None\n    def __init__(\n        self,\n        *,\n        max_line_length: int | None = ...,\n        linesep: str = ...,\n        cte_type: str = ...,\n        raise_on_defect: bool = ...,\n        mangle_from_: bool = ...,\n        message_factory: Callable[[Policy], Message] | None = ...,\n    ) -> None: ...\n    def clone(self, **kw: Any) -> Policy: ...\n    def handle_defect(self, obj: Message, defect: MessageDefect) -> None: ...\n    def register_defect(self, obj: Message, defect: MessageDefect) -> None: ...\n    def header_max_count(self, name: str) -> int | None: ...\n    @abstractmethod\n    def header_source_parse(self, sourcelines: list[str]) -> tuple[str, str]: ...\n    @abstractmethod\n    def header_store_parse(self, name: str, value: str) -> tuple[str, str]: ...\n    @abstractmethod\n    def header_fetch_parse(self, name: str, value: str) -> str: ...\n    @abstractmethod\n    def fold(self, name: str, value: str) -> str: ...\n    @abstractmethod\n    def fold_binary(self, name: str, value: str) -> bytes: ...\n\nclass Compat32(Policy):\n    def header_source_parse(self, sourcelines: list[str]) -> tuple[str, str]: ...\n    def header_store_parse(self, name: str, value: str) -> tuple[str, str]: ...\n    def header_fetch_parse(self, name: str, value: str) -> str | Header: ...  # type: ignore[override]\n    def fold(self, name: str, value: str) -> str: ...\n    def fold_binary(self, name: str, value: str) -> bytes: ...\n\ncompat32: Compat32\n\nclass EmailPolicy(Policy):\n    utf8: bool\n    refold_source: str\n    header_factory: Callable[[str, str], str]\n    content_manager: ContentManager\n    def __init__(\n        self,\n        *,\n        max_line_length: int | None = ...,\n        linesep: str = ...,\n        cte_type: str = ...,\n        raise_on_defect: bool = ...,\n        mangle_from_: bool = ...,\n        message_factory: Callable[[Policy], Message] | None = ...,\n        utf8: bool = ...,\n        refold_source: str = ...,\n        header_factory: Callable[[str, str], str] = ...,\n        content_manager: ContentManager = ...,\n    ) -> None: ...\n    def header_source_parse(self, sourcelines: list[str]) -> tuple[str, str]: ...\n    def header_store_parse(self, name: str, value: str) -> tuple[str, str]: ...\n    def header_fetch_parse(self, name: str, value: str) -> str: ...\n    def fold(self, name: str, value: str) -> str: ...\n    def fold_binary(self, name: str, value: str) -> bytes: ...\n\ndefault: EmailPolicy\nSMTP: EmailPolicy\nSMTPUTF8: EmailPolicy\nHTTP: EmailPolicy\nstrict: EmailPolicy\n",
  "/typeshed/stdlib/email/quoprimime.pyi": "from collections.abc import Iterable\n\n__all__ = [\n    \"body_decode\",\n    \"body_encode\",\n    \"body_length\",\n    \"decode\",\n    \"decodestring\",\n    \"header_decode\",\n    \"header_encode\",\n    \"header_length\",\n    \"quote\",\n    \"unquote\",\n]\n\ndef header_check(octet: int) -> bool: ...\ndef body_check(octet: int) -> bool: ...\ndef header_length(bytearray: Iterable[int]) -> int: ...\ndef body_length(bytearray: Iterable[int]) -> int: ...\ndef unquote(s: str | bytes | bytearray) -> str: ...\ndef quote(c: str | bytes | bytearray) -> str: ...\ndef header_encode(header_bytes: bytes | bytearray, charset: str = \"iso-8859-1\") -> str: ...\ndef body_encode(body: str, maxlinelen: int = 76, eol: str = \"\\n\") -> str: ...\ndef decode(encoded: str, eol: str = \"\\n\") -> str: ...\ndef header_decode(s: str) -> str: ...\n\nbody_decode = decode\ndecodestring = decode\n",
  "/typeshed/stdlib/email/utils.pyi": "import datetime\nimport sys\nfrom email import _ParamType\nfrom email.charset import Charset\nfrom typing import overload\nfrom typing_extensions import TypeAlias\n\n__all__ = [\n    \"collapse_rfc2231_value\",\n    \"decode_params\",\n    \"decode_rfc2231\",\n    \"encode_rfc2231\",\n    \"formataddr\",\n    \"formatdate\",\n    \"format_datetime\",\n    \"getaddresses\",\n    \"make_msgid\",\n    \"mktime_tz\",\n    \"parseaddr\",\n    \"parsedate\",\n    \"parsedate_tz\",\n    \"parsedate_to_datetime\",\n    \"unquote\",\n]\n\n_PDTZ: TypeAlias = tuple[int, int, int, int, int, int, int, int, int, int | None]\n\ndef quote(str: str) -> str: ...\ndef unquote(str: str) -> str: ...\ndef parseaddr(addr: str | None) -> tuple[str, str]: ...\ndef formataddr(pair: tuple[str | None, str], charset: str | Charset = \"utf-8\") -> str: ...\ndef getaddresses(fieldvalues: list[str]) -> list[tuple[str, str]]: ...\n@overload\ndef parsedate(data: None) -> None: ...\n@overload\ndef parsedate(data: str) -> tuple[int, int, int, int, int, int, int, int, int] | None: ...\n@overload\ndef parsedate_tz(data: None) -> None: ...\n@overload\ndef parsedate_tz(data: str) -> _PDTZ | None: ...\n\nif sys.version_info >= (3, 10):\n    @overload\n    def parsedate_to_datetime(data: None) -> None: ...\n    @overload\n    def parsedate_to_datetime(data: str) -> datetime.datetime: ...\n\nelse:\n    def parsedate_to_datetime(data: str) -> datetime.datetime: ...\n\ndef mktime_tz(data: _PDTZ) -> int: ...\ndef formatdate(timeval: float | None = None, localtime: bool = False, usegmt: bool = False) -> str: ...\ndef format_datetime(dt: datetime.datetime, usegmt: bool = False) -> str: ...\ndef localtime(dt: datetime.datetime | None = None, isdst: int = -1) -> datetime.datetime: ...\ndef make_msgid(idstring: str | None = None, domain: str | None = None) -> str: ...\ndef decode_rfc2231(s: str) -> tuple[str | None, str | None, str]: ...\ndef encode_rfc2231(s: str, charset: str | None = None, language: str | None = None) -> str: ...\ndef collapse_rfc2231_value(value: _ParamType, errors: str = \"replace\", fallback_charset: str = \"us-ascii\") -> str: ...\ndef decode_params(params: list[tuple[str, str]]) -> list[tuple[str, _ParamType]]: ...\n",
  "/typeshed/stdlib/email/mime/__init__.pyi": "",
  "/typeshed/stdlib/email/mime/application.pyi": "from collections.abc import Callable\nfrom email import _ParamsType\nfrom email.mime.nonmultipart import MIMENonMultipart\nfrom email.policy import Policy\n\n__all__ = [\"MIMEApplication\"]\n\nclass MIMEApplication(MIMENonMultipart):\n    def __init__(\n        self,\n        _data: str | bytes | bytearray,\n        _subtype: str = \"octet-stream\",\n        _encoder: Callable[[MIMEApplication], object] = ...,\n        *,\n        policy: Policy | None = None,\n        **_params: _ParamsType,\n    ) -> None: ...\n",
  "/typeshed/stdlib/email/mime/audio.pyi": "from collections.abc import Callable\nfrom email import _ParamsType\nfrom email.mime.nonmultipart import MIMENonMultipart\nfrom email.policy import Policy\n\n__all__ = [\"MIMEAudio\"]\n\nclass MIMEAudio(MIMENonMultipart):\n    def __init__(\n        self,\n        _audiodata: str | bytes | bytearray,\n        _subtype: str | None = None,\n        _encoder: Callable[[MIMEAudio], object] = ...,\n        *,\n        policy: Policy | None = None,\n        **_params: _ParamsType,\n    ) -> None: ...\n",
  "/typeshed/stdlib/email/mime/base.pyi": "import email.message\nfrom email import _ParamsType\nfrom email.policy import Policy\n\n__all__ = [\"MIMEBase\"]\n\nclass MIMEBase(email.message.Message):\n    def __init__(self, _maintype: str, _subtype: str, *, policy: Policy | None = None, **_params: _ParamsType) -> None: ...\n",
  "/typeshed/stdlib/email/mime/image.pyi": "from collections.abc import Callable\nfrom email import _ParamsType\nfrom email.mime.nonmultipart import MIMENonMultipart\nfrom email.policy import Policy\n\n__all__ = [\"MIMEImage\"]\n\nclass MIMEImage(MIMENonMultipart):\n    def __init__(\n        self,\n        _imagedata: str | bytes | bytearray,\n        _subtype: str | None = None,\n        _encoder: Callable[[MIMEImage], object] = ...,\n        *,\n        policy: Policy | None = None,\n        **_params: _ParamsType,\n    ) -> None: ...\n",
  "/typeshed/stdlib/email/mime/message.pyi": "from email.message import Message\nfrom email.mime.nonmultipart import MIMENonMultipart\nfrom email.policy import Policy\n\n__all__ = [\"MIMEMessage\"]\n\nclass MIMEMessage(MIMENonMultipart):\n    def __init__(self, _msg: Message, _subtype: str = \"rfc822\", *, policy: Policy | None = None) -> None: ...\n",
  "/typeshed/stdlib/email/mime/multipart.pyi": "from collections.abc import Sequence\nfrom email import _ParamsType\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.policy import Policy\n\n__all__ = [\"MIMEMultipart\"]\n\nclass MIMEMultipart(MIMEBase):\n    def __init__(\n        self,\n        _subtype: str = \"mixed\",\n        boundary: str | None = None,\n        _subparts: Sequence[Message] | None = None,\n        *,\n        policy: Policy | None = None,\n        **_params: _ParamsType,\n    ) -> None: ...\n",
  "/typeshed/stdlib/email/mime/nonmultipart.pyi": "from email.mime.base import MIMEBase\n\n__all__ = [\"MIMENonMultipart\"]\n\nclass MIMENonMultipart(MIMEBase): ...\n",
  "/typeshed/stdlib/email/mime/text.pyi": "from email.mime.nonmultipart import MIMENonMultipart\nfrom email.policy import Policy\n\n__all__ = [\"MIMEText\"]\n\nclass MIMEText(MIMENonMultipart):\n    def __init__(\n        self, _text: str, _subtype: str = \"plain\", _charset: str | None = None, *, policy: Policy | None = None\n    ) -> None: ...\n",
  "/typeshed/stdlib/encodings/__init__.pyi": "from _typeshed import Incomplete\nfrom codecs import CodecInfo\n\nclass CodecRegistryError(LookupError, SystemError): ...\n\ndef normalize_encoding(encoding: str | bytes) -> str: ...\ndef search_function(encoding: str) -> CodecInfo | None: ...\n\n# Needed for submodules\ndef __getattr__(name: str) -> Incomplete: ...\n",
  "/typeshed/stdlib/encodings/utf_8.pyi": "import codecs\nfrom _typeshed import ReadableBuffer\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input: str, final: bool = False) -> bytes: ...\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    @staticmethod\n    def _buffer_decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\n\nclass StreamWriter(codecs.StreamWriter):\n    @staticmethod\n    def encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\n\nclass StreamReader(codecs.StreamReader):\n    @staticmethod\n    def decode(__data: ReadableBuffer, __errors: str | None = None, __final: bool = False) -> tuple[str, int]: ...\n\ndef getregentry() -> codecs.CodecInfo: ...\ndef encode(__str: str, __errors: str | None = None) -> tuple[bytes, int]: ...\ndef decode(input: ReadableBuffer, errors: str | None = \"strict\") -> tuple[str, int]: ...\n",
  "/typeshed/stdlib/encodings/utf_8_sig.pyi": "import codecs\nfrom _typeshed import ReadableBuffer\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    def encode(self, input: str, final: bool = False) -> bytes: ...\n    def getstate(self) -> int: ...\n    def setstate(self, state: int) -> None: ...  # type: ignore[override]\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def __init__(self, errors: str = \"strict\") -> None: ...\n    def _buffer_decode(self, input: ReadableBuffer, errors: str | None, final: bool) -> tuple[str, int]: ...\n\nclass StreamWriter(codecs.StreamWriter):\n    def encode(self, input: str, errors: str | None = \"strict\") -> tuple[bytes, int]: ...\n\nclass StreamReader(codecs.StreamReader):\n    def decode(self, input: ReadableBuffer, errors: str | None = \"strict\") -> tuple[str, int]: ...\n\ndef getregentry() -> codecs.CodecInfo: ...\ndef encode(input: str, errors: str | None = \"strict\") -> tuple[bytes, int]: ...\ndef decode(input: ReadableBuffer, errors: str | None = \"strict\") -> tuple[str, int]: ...\n",
  "/typeshed/stdlib/ensurepip/__init__.pyi": "__all__ = [\"version\", \"bootstrap\"]\n\ndef version() -> str: ...\ndef bootstrap(\n    *,\n    root: str | None = None,\n    upgrade: bool = False,\n    user: bool = False,\n    altinstall: bool = False,\n    default_pip: bool = False,\n    verbosity: int = 0,\n) -> None: ...\n",
  "/typeshed/stdlib/html/__init__.pyi": "from typing import AnyStr\n\n__all__ = [\"escape\", \"unescape\"]\n\ndef escape(s: AnyStr, quote: bool = True) -> AnyStr: ...\ndef unescape(s: AnyStr) -> AnyStr: ...\n",
  "/typeshed/stdlib/html/entities.pyi": "__all__ = [\"html5\", \"name2codepoint\", \"codepoint2name\", \"entitydefs\"]\n\nname2codepoint: dict[str, int]\nhtml5: dict[str, str]\ncodepoint2name: dict[int, str]\nentitydefs: dict[str, str]\n",
  "/typeshed/stdlib/html/parser.pyi": "from _markupbase import ParserBase\nfrom re import Pattern\n\n__all__ = [\"HTMLParser\"]\n\nclass HTMLParser(ParserBase):\n    def __init__(self, *, convert_charrefs: bool = True) -> None: ...\n    def feed(self, data: str) -> None: ...\n    def close(self) -> None: ...\n    def get_starttag_text(self) -> str | None: ...\n    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None: ...\n    def handle_endtag(self, tag: str) -> None: ...\n    def handle_startendtag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None: ...\n    def handle_data(self, data: str) -> None: ...\n    def handle_entityref(self, name: str) -> None: ...\n    def handle_charref(self, name: str) -> None: ...\n    def handle_comment(self, data: str) -> None: ...\n    def handle_decl(self, decl: str) -> None: ...\n    def handle_pi(self, data: str) -> None: ...\n    CDATA_CONTENT_ELEMENTS: tuple[str, ...]\n    def check_for_whole_start_tag(self, i: int) -> int: ...  # undocumented\n    def clear_cdata_mode(self) -> None: ...  # undocumented\n    def goahead(self, end: bool) -> None: ...  # undocumented\n    def parse_bogus_comment(self, i: int, report: bool = ...) -> int: ...  # undocumented\n    def parse_endtag(self, i: int) -> int: ...  # undocumented\n    def parse_html_declaration(self, i: int) -> int: ...  # undocumented\n    def parse_pi(self, i: int) -> int: ...  # undocumented\n    def parse_starttag(self, i: int) -> int: ...  # undocumented\n    def set_cdata_mode(self, elem: str) -> None: ...  # undocumented\n    rawdata: str  # undocumented\n    cdata_elem: str | None  # undocumented\n    convert_charrefs: bool  # undocumented\n    interesting: Pattern[str]  # undocumented\n    lasttag: str  # undocumented\n",
  "/typeshed/stdlib/http/__init__.pyi": "import sys\nfrom enum import IntEnum\nfrom typing_extensions import Literal\n\nif sys.version_info >= (3, 11):\n    from enum import StrEnum\n\nif sys.version_info >= (3, 11):\n    __all__ = [\"HTTPStatus\", \"HTTPMethod\"]\nelse:\n    __all__ = [\"HTTPStatus\"]\n\nclass HTTPStatus(IntEnum):\n    @property\n    def phrase(self) -> str: ...\n    @property\n    def description(self) -> str: ...\n    CONTINUE: int\n    SWITCHING_PROTOCOLS: int\n    PROCESSING: int\n    OK: int\n    CREATED: int\n    ACCEPTED: int\n    NON_AUTHORITATIVE_INFORMATION: int\n    NO_CONTENT: int\n    RESET_CONTENT: int\n    PARTIAL_CONTENT: int\n    MULTI_STATUS: int\n    ALREADY_REPORTED: int\n    IM_USED: int\n    MULTIPLE_CHOICES: int\n    MOVED_PERMANENTLY: int\n    FOUND: int\n    SEE_OTHER: int\n    NOT_MODIFIED: int\n    USE_PROXY: int\n    TEMPORARY_REDIRECT: int\n    PERMANENT_REDIRECT: int\n    BAD_REQUEST: int\n    UNAUTHORIZED: int\n    PAYMENT_REQUIRED: int\n    FORBIDDEN: int\n    NOT_FOUND: int\n    METHOD_NOT_ALLOWED: int\n    NOT_ACCEPTABLE: int\n    PROXY_AUTHENTICATION_REQUIRED: int\n    REQUEST_TIMEOUT: int\n    CONFLICT: int\n    GONE: int\n    LENGTH_REQUIRED: int\n    PRECONDITION_FAILED: int\n    REQUEST_ENTITY_TOO_LARGE: int\n    REQUEST_URI_TOO_LONG: int\n    UNSUPPORTED_MEDIA_TYPE: int\n    REQUESTED_RANGE_NOT_SATISFIABLE: int\n    EXPECTATION_FAILED: int\n    UNPROCESSABLE_ENTITY: int\n    LOCKED: int\n    FAILED_DEPENDENCY: int\n    UPGRADE_REQUIRED: int\n    PRECONDITION_REQUIRED: int\n    TOO_MANY_REQUESTS: int\n    REQUEST_HEADER_FIELDS_TOO_LARGE: int\n    INTERNAL_SERVER_ERROR: int\n    NOT_IMPLEMENTED: int\n    BAD_GATEWAY: int\n    SERVICE_UNAVAILABLE: int\n    GATEWAY_TIMEOUT: int\n    HTTP_VERSION_NOT_SUPPORTED: int\n    VARIANT_ALSO_NEGOTIATES: int\n    INSUFFICIENT_STORAGE: int\n    LOOP_DETECTED: int\n    NOT_EXTENDED: int\n    NETWORK_AUTHENTICATION_REQUIRED: int\n    MISDIRECTED_REQUEST: int\n    if sys.version_info >= (3, 8):\n        UNAVAILABLE_FOR_LEGAL_REASONS: int\n    if sys.version_info >= (3, 9):\n        EARLY_HINTS: Literal[103]\n        IM_A_TEAPOT: Literal[418]\n        TOO_EARLY: Literal[425]\n\nif sys.version_info >= (3, 11):\n    class HTTPMethod(StrEnum):\n        @property\n        def description(self) -> str: ...\n        CONNECT: str\n        DELETE: str\n        GET: str\n        HEAD: str\n        OPTIONS: str\n        PATCH: str\n        POST: str\n        PUT: str\n        TRACE: str\n",
  "/typeshed/stdlib/http/client.pyi": "import email.message\nimport io\nimport ssl\nimport types\nfrom _typeshed import ReadableBuffer, SupportsRead, WriteableBuffer\nfrom collections.abc import Callable, Iterable, Iterator, Mapping\nfrom socket import socket\nfrom typing import Any, BinaryIO, TypeVar, overload\nfrom typing_extensions import Self, TypeAlias\n\n__all__ = [\n    \"HTTPResponse\",\n    \"HTTPConnection\",\n    \"HTTPException\",\n    \"NotConnected\",\n    \"UnknownProtocol\",\n    \"UnknownTransferEncoding\",\n    \"UnimplementedFileMode\",\n    \"IncompleteRead\",\n    \"InvalidURL\",\n    \"ImproperConnectionState\",\n    \"CannotSendRequest\",\n    \"CannotSendHeader\",\n    \"ResponseNotReady\",\n    \"BadStatusLine\",\n    \"LineTooLong\",\n    \"RemoteDisconnected\",\n    \"error\",\n    \"responses\",\n    \"HTTPSConnection\",\n]\n\n_DataType: TypeAlias = SupportsRead[bytes] | Iterable[ReadableBuffer] | ReadableBuffer\n_T = TypeVar(\"_T\")\n\nHTTP_PORT: int\nHTTPS_PORT: int\n\nCONTINUE: int\nSWITCHING_PROTOCOLS: int\nPROCESSING: int\n\nOK: int\nCREATED: int\nACCEPTED: int\nNON_AUTHORITATIVE_INFORMATION: int\nNO_CONTENT: int\nRESET_CONTENT: int\nPARTIAL_CONTENT: int\nMULTI_STATUS: int\nIM_USED: int\n\nMULTIPLE_CHOICES: int\nMOVED_PERMANENTLY: int\nFOUND: int\nSEE_OTHER: int\nNOT_MODIFIED: int\nUSE_PROXY: int\nTEMPORARY_REDIRECT: int\n\nBAD_REQUEST: int\nUNAUTHORIZED: int\nPAYMENT_REQUIRED: int\nFORBIDDEN: int\nNOT_FOUND: int\nMETHOD_NOT_ALLOWED: int\nNOT_ACCEPTABLE: int\nPROXY_AUTHENTICATION_REQUIRED: int\nREQUEST_TIMEOUT: int\nCONFLICT: int\nGONE: int\nLENGTH_REQUIRED: int\nPRECONDITION_FAILED: int\nREQUEST_ENTITY_TOO_LARGE: int\nREQUEST_URI_TOO_LONG: int\nUNSUPPORTED_MEDIA_TYPE: int\nREQUESTED_RANGE_NOT_SATISFIABLE: int\nEXPECTATION_FAILED: int\nUNPROCESSABLE_ENTITY: int\nLOCKED: int\nFAILED_DEPENDENCY: int\nUPGRADE_REQUIRED: int\nPRECONDITION_REQUIRED: int\nTOO_MANY_REQUESTS: int\nREQUEST_HEADER_FIELDS_TOO_LARGE: int\n\nINTERNAL_SERVER_ERROR: int\nNOT_IMPLEMENTED: int\nBAD_GATEWAY: int\nSERVICE_UNAVAILABLE: int\nGATEWAY_TIMEOUT: int\nHTTP_VERSION_NOT_SUPPORTED: int\nINSUFFICIENT_STORAGE: int\nNOT_EXTENDED: int\nNETWORK_AUTHENTICATION_REQUIRED: int\n\nresponses: dict[int, str]\n\nclass HTTPMessage(email.message.Message):\n    def getallmatchingheaders(self, name: str) -> list[str]: ...  # undocumented\n\ndef parse_headers(fp: io.BufferedIOBase, _class: Callable[[], email.message.Message] = ...) -> HTTPMessage: ...\n\nclass HTTPResponse(io.BufferedIOBase, BinaryIO):  # type: ignore[misc]  # incompatible method definitions in the base classes\n    msg: HTTPMessage\n    headers: HTTPMessage\n    version: int\n    debuglevel: int\n    fp: io.BufferedReader\n    closed: bool\n    status: int\n    reason: str\n    chunked: bool\n    chunk_left: int | None\n    length: int | None\n    will_close: bool\n    def __init__(self, sock: socket, debuglevel: int = 0, method: str | None = None, url: str | None = None) -> None: ...\n    def peek(self, n: int = -1) -> bytes: ...\n    def read(self, amt: int | None = None) -> bytes: ...\n    def read1(self, n: int = -1) -> bytes: ...\n    def readinto(self, b: WriteableBuffer) -> int: ...\n    def readline(self, limit: int = -1) -> bytes: ...  # type: ignore[override]\n    @overload\n    def getheader(self, name: str) -> str | None: ...\n    @overload\n    def getheader(self, name: str, default: _T) -> str | _T: ...\n    def getheaders(self) -> list[tuple[str, str]]: ...\n    def isclosed(self) -> bool: ...\n    def __iter__(self) -> Iterator[bytes]: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None\n    ) -> None: ...\n    def info(self) -> email.message.Message: ...\n    def geturl(self) -> str: ...\n    def getcode(self) -> int: ...\n    def begin(self) -> None: ...\n\nclass HTTPConnection:\n    auto_open: int  # undocumented\n    debuglevel: int\n    default_port: int  # undocumented\n    response_class: type[HTTPResponse]  # undocumented\n    timeout: float | None\n    host: str\n    port: int\n    sock: socket | Any  # can be `None` if `.connect()` was not called\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        timeout: float | None = ...,\n        source_address: tuple[str, int] | None = None,\n        blocksize: int = 8192,\n    ) -> None: ...\n    def request(\n        self,\n        method: str,\n        url: str,\n        body: _DataType | str | None = None,\n        headers: Mapping[str, str] = {},\n        *,\n        encode_chunked: bool = False,\n    ) -> None: ...\n    def getresponse(self) -> HTTPResponse: ...\n    def set_debuglevel(self, level: int) -> None: ...\n    def set_tunnel(self, host: str, port: int | None = None, headers: Mapping[str, str] | None = None) -> None: ...\n    def connect(self) -> None: ...\n    def close(self) -> None: ...\n    def putrequest(self, method: str, url: str, skip_host: bool = False, skip_accept_encoding: bool = False) -> None: ...\n    def putheader(self, header: str, *argument: str) -> None: ...\n    def endheaders(self, message_body: _DataType | None = None, *, encode_chunked: bool = False) -> None: ...\n    def send(self, data: _DataType | str) -> None: ...\n\nclass HTTPSConnection(HTTPConnection):\n    # Can be `None` if `.connect()` was not called:\n    sock: ssl.SSLSocket | Any\n    def __init__(\n        self,\n        host: str,\n        port: int | None = None,\n        key_file: str | None = None,\n        cert_file: str | None = None,\n        timeout: float | None = ...,\n        source_address: tuple[str, int] | None = None,\n        *,\n        context: ssl.SSLContext | None = None,\n        check_hostname: bool | None = None,\n        blocksize: int = 8192,\n    ) -> None: ...\n\nclass HTTPException(Exception): ...\n\nerror = HTTPException\n\nclass NotConnected(HTTPException): ...\nclass InvalidURL(HTTPException): ...\n\nclass UnknownProtocol(HTTPException):\n    def __init__(self, version: str) -> None: ...\n\nclass UnknownTransferEncoding(HTTPException): ...\nclass UnimplementedFileMode(HTTPException): ...\n\nclass IncompleteRead(HTTPException):\n    def __init__(self, partial: bytes, expected: int | None = None) -> None: ...\n    partial: bytes\n    expected: int | None\n\nclass ImproperConnectionState(HTTPException): ...\nclass CannotSendRequest(ImproperConnectionState): ...\nclass CannotSendHeader(ImproperConnectionState): ...\nclass ResponseNotReady(ImproperConnectionState): ...\n\nclass BadStatusLine(HTTPException):\n    def __init__(self, line: str) -> None: ...\n\nclass LineTooLong(HTTPException):\n    def __init__(self, line_type: str) -> None: ...\n\nclass RemoteDisconnected(ConnectionResetError, BadStatusLine): ...\n",
  "/typeshed/stdlib/http/cookiejar.pyi": "import sys\nfrom _typeshed import StrPath\nfrom collections.abc import Iterable, Iterator, Sequence\nfrom http.client import HTTPResponse\nfrom re import Pattern\nfrom typing import ClassVar, TypeVar, overload\nfrom urllib.request import Request\n\n__all__ = [\n    \"Cookie\",\n    \"CookieJar\",\n    \"CookiePolicy\",\n    \"DefaultCookiePolicy\",\n    \"FileCookieJar\",\n    \"LWPCookieJar\",\n    \"LoadError\",\n    \"MozillaCookieJar\",\n]\n\n_T = TypeVar(\"_T\")\n\nclass LoadError(OSError): ...\n\nclass CookieJar(Iterable[Cookie]):\n    non_word_re: ClassVar[Pattern[str]]  # undocumented\n    quote_re: ClassVar[Pattern[str]]  # undocumented\n    strict_domain_re: ClassVar[Pattern[str]]  # undocumented\n    domain_re: ClassVar[Pattern[str]]  # undocumented\n    dots_re: ClassVar[Pattern[str]]  # undocumented\n    magic_re: ClassVar[Pattern[str]]  # undocumented\n    def __init__(self, policy: CookiePolicy | None = None) -> None: ...\n    def add_cookie_header(self, request: Request) -> None: ...\n    def extract_cookies(self, response: HTTPResponse, request: Request) -> None: ...\n    def set_policy(self, policy: CookiePolicy) -> None: ...\n    def make_cookies(self, response: HTTPResponse, request: Request) -> Sequence[Cookie]: ...\n    def set_cookie(self, cookie: Cookie) -> None: ...\n    def set_cookie_if_ok(self, cookie: Cookie, request: Request) -> None: ...\n    def clear(self, domain: str | None = None, path: str | None = None, name: str | None = None) -> None: ...\n    def clear_session_cookies(self) -> None: ...\n    def clear_expired_cookies(self) -> None: ...  # undocumented\n    def __iter__(self) -> Iterator[Cookie]: ...\n    def __len__(self) -> int: ...\n\nclass FileCookieJar(CookieJar):\n    filename: str\n    delayload: bool\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self, filename: StrPath | None = None, delayload: bool = False, policy: CookiePolicy | None = None\n        ) -> None: ...\n    else:\n        def __init__(self, filename: str | None = None, delayload: bool = False, policy: CookiePolicy | None = None) -> None: ...\n\n    def save(self, filename: str | None = None, ignore_discard: bool = False, ignore_expires: bool = False) -> None: ...\n    def load(self, filename: str | None = None, ignore_discard: bool = False, ignore_expires: bool = False) -> None: ...\n    def revert(self, filename: str | None = None, ignore_discard: bool = False, ignore_expires: bool = False) -> None: ...\n\nclass MozillaCookieJar(FileCookieJar):\n    if sys.version_info < (3, 10):\n        header: ClassVar[str]  # undocumented\n\nclass LWPCookieJar(FileCookieJar):\n    def as_lwp_str(self, ignore_discard: bool = True, ignore_expires: bool = True) -> str: ...  # undocumented\n\nclass CookiePolicy:\n    netscape: bool\n    rfc2965: bool\n    hide_cookie2: bool\n    def set_ok(self, cookie: Cookie, request: Request) -> bool: ...\n    def return_ok(self, cookie: Cookie, request: Request) -> bool: ...\n    def domain_return_ok(self, domain: str, request: Request) -> bool: ...\n    def path_return_ok(self, path: str, request: Request) -> bool: ...\n\nclass DefaultCookiePolicy(CookiePolicy):\n    rfc2109_as_netscape: bool\n    strict_domain: bool\n    strict_rfc2965_unverifiable: bool\n    strict_ns_unverifiable: bool\n    strict_ns_domain: int\n    strict_ns_set_initial_dollar: bool\n    strict_ns_set_path: bool\n    DomainStrictNoDots: ClassVar[int]\n    DomainStrictNonDomain: ClassVar[int]\n    DomainRFC2965Match: ClassVar[int]\n    DomainLiberal: ClassVar[int]\n    DomainStrict: ClassVar[int]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            blocked_domains: Sequence[str] | None = None,\n            allowed_domains: Sequence[str] | None = None,\n            netscape: bool = True,\n            rfc2965: bool = False,\n            rfc2109_as_netscape: bool | None = None,\n            hide_cookie2: bool = False,\n            strict_domain: bool = False,\n            strict_rfc2965_unverifiable: bool = True,\n            strict_ns_unverifiable: bool = False,\n            strict_ns_domain: int = 0,\n            strict_ns_set_initial_dollar: bool = False,\n            strict_ns_set_path: bool = False,\n            secure_protocols: Sequence[str] = (\"https\", \"wss\"),\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            blocked_domains: Sequence[str] | None = None,\n            allowed_domains: Sequence[str] | None = None,\n            netscape: bool = True,\n            rfc2965: bool = False,\n            rfc2109_as_netscape: bool | None = None,\n            hide_cookie2: bool = False,\n            strict_domain: bool = False,\n            strict_rfc2965_unverifiable: bool = True,\n            strict_ns_unverifiable: bool = False,\n            strict_ns_domain: int = 0,\n            strict_ns_set_initial_dollar: bool = False,\n            strict_ns_set_path: bool = False,\n        ) -> None: ...\n\n    def blocked_domains(self) -> tuple[str, ...]: ...\n    def set_blocked_domains(self, blocked_domains: Sequence[str]) -> None: ...\n    def is_blocked(self, domain: str) -> bool: ...\n    def allowed_domains(self) -> tuple[str, ...] | None: ...\n    def set_allowed_domains(self, allowed_domains: Sequence[str] | None) -> None: ...\n    def is_not_allowed(self, domain: str) -> bool: ...\n    def set_ok_version(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def set_ok_verifiability(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def set_ok_name(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def set_ok_path(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def set_ok_domain(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def set_ok_port(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_version(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_verifiability(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_secure(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_expires(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_port(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n    def return_ok_domain(self, cookie: Cookie, request: Request) -> bool: ...  # undocumented\n\nclass Cookie:\n    version: int | None\n    name: str\n    value: str | None\n    port: str | None\n    path: str\n    path_specified: bool\n    secure: bool\n    expires: int | None\n    discard: bool\n    comment: str | None\n    comment_url: str | None\n    rfc2109: bool\n    port_specified: bool\n    domain: str  # undocumented\n    domain_specified: bool\n    domain_initial_dot: bool\n    def __init__(\n        self,\n        version: int | None,\n        name: str,\n        value: str | None,  # undocumented\n        port: str | None,\n        port_specified: bool,\n        domain: str,\n        domain_specified: bool,\n        domain_initial_dot: bool,\n        path: str,\n        path_specified: bool,\n        secure: bool,\n        expires: int | None,\n        discard: bool,\n        comment: str | None,\n        comment_url: str | None,\n        rest: dict[str, str],\n        rfc2109: bool = False,\n    ) -> None: ...\n    def has_nonstandard_attr(self, name: str) -> bool: ...\n    @overload\n    def get_nonstandard_attr(self, name: str) -> str | None: ...\n    @overload\n    def get_nonstandard_attr(self, name: str, default: _T) -> str | _T: ...\n    def set_nonstandard_attr(self, name: str, value: str) -> None: ...\n    def is_expired(self, now: int | None = None) -> bool: ...\n",
  "/typeshed/stdlib/http/cookies.pyi": "import sys\nfrom collections.abc import Iterable, Mapping\nfrom typing import Any, Generic, TypeVar, overload\nfrom typing_extensions import TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\"CookieError\", \"BaseCookie\", \"SimpleCookie\"]\n\n_DataType: TypeAlias = str | Mapping[str, str | Morsel[Any]]\n_T = TypeVar(\"_T\")\n\n@overload\ndef _quote(str: None) -> None: ...\n@overload\ndef _quote(str: str) -> str: ...\n@overload\ndef _unquote(str: None) -> None: ...\n@overload\ndef _unquote(str: str) -> str: ...\n\nclass CookieError(Exception): ...\n\nclass Morsel(dict[str, Any], Generic[_T]):\n    @property\n    def value(self) -> str: ...\n    @property\n    def coded_value(self) -> _T: ...\n    @property\n    def key(self) -> str: ...\n    def __init__(self) -> None: ...\n    def set(self, key: str, val: str, coded_val: _T) -> None: ...\n    def setdefault(self, key: str, val: str | None = None) -> str: ...\n    # The dict update can also get a keywords argument so this is incompatible\n    @overload  # type: ignore[override]\n    def update(self, values: Mapping[str, str]) -> None: ...\n    @overload\n    def update(self, values: Iterable[tuple[str, str]]) -> None: ...\n    def isReservedKey(self, K: str) -> bool: ...\n    def output(self, attrs: list[str] | None = None, header: str = \"Set-Cookie:\") -> str: ...\n    __str__ = output\n    def js_output(self, attrs: list[str] | None = None) -> str: ...\n    def OutputString(self, attrs: list[str] | None = None) -> str: ...\n    def __eq__(self, morsel: object) -> bool: ...\n    def __setitem__(self, K: str, V: Any) -> None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass BaseCookie(dict[str, Morsel[_T]], Generic[_T]):\n    def __init__(self, input: _DataType | None = None) -> None: ...\n    def value_decode(self, val: str) -> _T: ...\n    def value_encode(self, val: _T) -> str: ...\n    def output(self, attrs: list[str] | None = None, header: str = \"Set-Cookie:\", sep: str = \"\\r\\n\") -> str: ...\n    __str__ = output\n    def js_output(self, attrs: list[str] | None = None) -> str: ...\n    def load(self, rawdata: _DataType) -> None: ...\n    def __setitem__(self, key: str, value: str | Morsel[_T]) -> None: ...\n\nclass SimpleCookie(BaseCookie[_T], Generic[_T]): ...\n",
  "/typeshed/stdlib/http/server.pyi": "import _socket\nimport email.message\nimport io\nimport socketserver\nimport sys\nfrom _typeshed import StrPath, SupportsRead, SupportsWrite\nfrom collections.abc import Mapping, Sequence\nfrom typing import Any, AnyStr, BinaryIO, ClassVar\n\n__all__ = [\"HTTPServer\", \"ThreadingHTTPServer\", \"BaseHTTPRequestHandler\", \"SimpleHTTPRequestHandler\", \"CGIHTTPRequestHandler\"]\n\nclass HTTPServer(socketserver.TCPServer):\n    server_name: str\n    server_port: int\n\nclass ThreadingHTTPServer(socketserver.ThreadingMixIn, HTTPServer): ...\n\nclass BaseHTTPRequestHandler(socketserver.StreamRequestHandler):\n    client_address: tuple[str, int]\n    close_connection: bool\n    requestline: str\n    command: str\n    path: str\n    request_version: str\n    headers: email.message.Message\n    server_version: str\n    sys_version: str\n    error_message_format: str\n    error_content_type: str\n    protocol_version: str\n    MessageClass: type\n    responses: Mapping[int, tuple[str, str]]\n    default_request_version: str  # undocumented\n    weekdayname: ClassVar[Sequence[str]]  # undocumented\n    monthname: ClassVar[Sequence[str | None]]  # undocumented\n    def handle_one_request(self) -> None: ...\n    def handle_expect_100(self) -> bool: ...\n    def send_error(self, code: int, message: str | None = None, explain: str | None = None) -> None: ...\n    def send_response(self, code: int, message: str | None = None) -> None: ...\n    def send_header(self, keyword: str, value: str) -> None: ...\n    def send_response_only(self, code: int, message: str | None = None) -> None: ...\n    def end_headers(self) -> None: ...\n    def flush_headers(self) -> None: ...\n    def log_request(self, code: int | str = \"-\", size: int | str = \"-\") -> None: ...\n    def log_error(self, format: str, *args: Any) -> None: ...\n    def log_message(self, format: str, *args: Any) -> None: ...\n    def version_string(self) -> str: ...\n    def date_time_string(self, timestamp: int | None = None) -> str: ...\n    def log_date_time_string(self) -> str: ...\n    def address_string(self) -> str: ...\n    def parse_request(self) -> bool: ...  # undocumented\n\nclass SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n    extensions_map: dict[str, str]\n    if sys.version_info >= (3, 12):\n        index_pages: ClassVar[tuple[str, ...]]\n    def __init__(\n        self,\n        request: socketserver._RequestType,\n        client_address: _socket._RetAddress,\n        server: socketserver.BaseServer,\n        *,\n        directory: str | None = None,\n    ) -> None: ...\n    def do_GET(self) -> None: ...\n    def do_HEAD(self) -> None: ...\n    def send_head(self) -> io.BytesIO | BinaryIO | None: ...  # undocumented\n    def list_directory(self, path: StrPath) -> io.BytesIO | None: ...  # undocumented\n    def translate_path(self, path: str) -> str: ...  # undocumented\n    def copyfile(self, source: SupportsRead[AnyStr], outputfile: SupportsWrite[AnyStr]) -> None: ...  # undocumented\n    def guess_type(self, path: StrPath) -> str: ...  # undocumented\n\ndef executable(path: StrPath) -> bool: ...  # undocumented\n\nclass CGIHTTPRequestHandler(SimpleHTTPRequestHandler):\n    cgi_directories: list[str]\n    have_fork: bool  # undocumented\n    def do_POST(self) -> None: ...\n    def is_cgi(self) -> bool: ...  # undocumented\n    def is_executable(self, path: StrPath) -> bool: ...  # undocumented\n    def is_python(self, path: StrPath) -> bool: ...  # undocumented\n    def run_cgi(self) -> None: ...  # undocumented\n",
  "/typeshed/stdlib/importlib/__init__.pyi": "from collections.abc import Mapping, Sequence\nfrom importlib.abc import Loader\nfrom types import ModuleType\n\n__all__ = [\"__import__\", \"import_module\", \"invalidate_caches\", \"reload\"]\n\n# Signature of `builtins.__import__` should be kept identical to `importlib.__import__`\ndef __import__(\n    name: str,\n    globals: Mapping[str, object] | None = None,\n    locals: Mapping[str, object] | None = None,\n    fromlist: Sequence[str] = (),\n    level: int = 0,\n) -> ModuleType: ...\n\n# `importlib.import_module` return type should be kept the same as `builtins.__import__`\ndef import_module(name: str, package: str | None = None) -> ModuleType: ...\ndef find_loader(name: str, path: str | None = None) -> Loader | None: ...\ndef invalidate_caches() -> None: ...\ndef reload(module: ModuleType) -> ModuleType: ...\n",
  "/typeshed/stdlib/importlib/abc.pyi": "import _ast\nimport sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    StrPath,\n)\nfrom abc import ABCMeta, abstractmethod\nfrom collections.abc import Iterator, Mapping, Sequence\nfrom importlib.machinery import ModuleSpec\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom typing import IO, Any, BinaryIO, NoReturn, Protocol, overload, runtime_checkable\nfrom typing_extensions import Literal\n\nif sys.version_info >= (3, 11):\n    __all__ = [\n        \"Loader\",\n        \"Finder\",\n        \"MetaPathFinder\",\n        \"PathEntryFinder\",\n        \"ResourceLoader\",\n        \"InspectLoader\",\n        \"ExecutionLoader\",\n        \"FileLoader\",\n        \"SourceLoader\",\n        \"ResourceReader\",\n        \"Traversable\",\n        \"TraversableResources\",\n    ]\n\nclass Finder(metaclass=ABCMeta): ...\n\nclass Loader(metaclass=ABCMeta):\n    def load_module(self, fullname: str) -> types.ModuleType: ...\n    def module_repr(self, module: types.ModuleType) -> str: ...\n    def create_module(self, spec: ModuleSpec) -> types.ModuleType | None: ...\n    # Not defined on the actual class for backwards-compatibility reasons,\n    # but expected in new code.\n    def exec_module(self, module: types.ModuleType) -> None: ...\n\nclass ResourceLoader(Loader):\n    @abstractmethod\n    def get_data(self, path: str) -> bytes: ...\n\nclass InspectLoader(Loader):\n    def is_package(self, fullname: str) -> bool: ...\n    def get_code(self, fullname: str) -> types.CodeType | None: ...\n    @abstractmethod\n    def get_source(self, fullname: str) -> str | None: ...\n    def exec_module(self, module: types.ModuleType) -> None: ...\n    @staticmethod\n    def source_to_code(\n        data: ReadableBuffer | str | _ast.Module | _ast.Expression | _ast.Interactive, path: ReadableBuffer | StrPath = \"<string>\"\n    ) -> types.CodeType: ...\n\nclass ExecutionLoader(InspectLoader):\n    @abstractmethod\n    def get_filename(self, fullname: str) -> str: ...\n\nclass SourceLoader(ResourceLoader, ExecutionLoader, metaclass=ABCMeta):\n    def path_mtime(self, path: str) -> float: ...\n    def set_data(self, path: str, data: bytes) -> None: ...\n    def get_source(self, fullname: str) -> str | None: ...\n    def path_stats(self, path: str) -> Mapping[str, Any]: ...\n\n# Please keep in sync with sys._MetaPathFinder\nclass MetaPathFinder(Finder):\n    def find_module(self, fullname: str, path: Sequence[str] | None) -> Loader | None: ...\n    def invalidate_caches(self) -> None: ...\n    # Not defined on the actual class, but expected to exist.\n    def find_spec(\n        self, fullname: str, path: Sequence[str] | None, target: types.ModuleType | None = ...\n    ) -> ModuleSpec | None: ...\n\nclass PathEntryFinder(Finder):\n    def find_module(self, fullname: str) -> Loader | None: ...\n    def find_loader(self, fullname: str) -> tuple[Loader | None, Sequence[str]]: ...\n    def invalidate_caches(self) -> None: ...\n    # Not defined on the actual class, but expected to exist.\n    def find_spec(self, fullname: str, target: types.ModuleType | None = ...) -> ModuleSpec | None: ...\n\nclass FileLoader(ResourceLoader, ExecutionLoader, metaclass=ABCMeta):\n    name: str\n    path: str\n    def __init__(self, fullname: str, path: str) -> None: ...\n    def get_data(self, path: str) -> bytes: ...\n    def get_filename(self, name: str | None = None) -> str: ...\n    def load_module(self, name: str | None = None) -> types.ModuleType: ...\n\nclass ResourceReader(metaclass=ABCMeta):\n    @abstractmethod\n    def open_resource(self, resource: str) -> IO[bytes]: ...\n    @abstractmethod\n    def resource_path(self, resource: str) -> str: ...\n    if sys.version_info >= (3, 10):\n        @abstractmethod\n        def is_resource(self, path: str) -> bool: ...\n    else:\n        @abstractmethod\n        def is_resource(self, name: str) -> bool: ...\n\n    @abstractmethod\n    def contents(self) -> Iterator[str]: ...\n\nif sys.version_info >= (3, 9):\n    @runtime_checkable\n    class Traversable(Protocol):\n        @abstractmethod\n        def is_dir(self) -> bool: ...\n        @abstractmethod\n        def is_file(self) -> bool: ...\n        @abstractmethod\n        def iterdir(self) -> Iterator[Traversable]: ...\n        if sys.version_info >= (3, 11):\n            @abstractmethod\n            def joinpath(self, *descendants: str) -> Traversable: ...\n        else:\n            @abstractmethod\n            def joinpath(self, child: str) -> Traversable: ...\n        # The .open method comes from pathlib.pyi and should be kept in sync.\n        @overload\n        @abstractmethod\n        def open(\n            self,\n            mode: OpenTextMode = \"r\",\n            buffering: int = ...,\n            encoding: str | None = ...,\n            errors: str | None = ...,\n            newline: str | None = ...,\n        ) -> TextIOWrapper: ...\n        # Unbuffered binary mode: returns a FileIO\n        @overload\n        @abstractmethod\n        def open(\n            self, mode: OpenBinaryMode, buffering: Literal[0], encoding: None = None, errors: None = None, newline: None = None\n        ) -> FileIO: ...\n        # Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n        @overload\n        @abstractmethod\n        def open(\n            self,\n            mode: OpenBinaryModeUpdating,\n            buffering: Literal[-1, 1] = ...,\n            encoding: None = None,\n            errors: None = None,\n            newline: None = None,\n        ) -> BufferedRandom: ...\n        @overload\n        @abstractmethod\n        def open(\n            self,\n            mode: OpenBinaryModeWriting,\n            buffering: Literal[-1, 1] = ...,\n            encoding: None = None,\n            errors: None = None,\n            newline: None = None,\n        ) -> BufferedWriter: ...\n        @overload\n        @abstractmethod\n        def open(\n            self,\n            mode: OpenBinaryModeReading,\n            buffering: Literal[-1, 1] = ...,\n            encoding: None = None,\n            errors: None = None,\n            newline: None = None,\n        ) -> BufferedReader: ...\n        # Buffering cannot be determined: fall back to BinaryIO\n        @overload\n        @abstractmethod\n        def open(\n            self, mode: OpenBinaryMode, buffering: int = ..., encoding: None = None, errors: None = None, newline: None = None\n        ) -> BinaryIO: ...\n        # Fallback if mode is not specified\n        @overload\n        @abstractmethod\n        def open(\n            self, mode: str, buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...\n        ) -> IO[Any]: ...\n        @property\n        @abstractmethod\n        def name(self) -> str: ...\n        @abstractmethod\n        def __truediv__(self, child: str) -> Traversable: ...\n        @abstractmethod\n        def read_bytes(self) -> bytes: ...\n        @abstractmethod\n        def read_text(self, encoding: str | None = None) -> str: ...\n\n    class TraversableResources(ResourceReader):\n        @abstractmethod\n        def files(self) -> Traversable: ...\n        def open_resource(self, resource: str) -> BufferedReader: ...\n        def resource_path(self, resource: Any) -> NoReturn: ...\n        def is_resource(self, path: str) -> bool: ...\n        def contents(self) -> Iterator[str]: ...\n",
  "/typeshed/stdlib/importlib/machinery.pyi": "import importlib.abc\nimport sys\nimport types\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable, Iterable, Sequence\nfrom typing import Any\n\nif sys.version_info >= (3, 8):\n    from importlib.metadata import DistributionFinder, PathDistribution\n\nclass ModuleSpec:\n    def __init__(\n        self,\n        name: str,\n        loader: importlib.abc.Loader | None,\n        *,\n        origin: str | None = None,\n        loader_state: Any = None,\n        is_package: bool | None = None,\n    ) -> None: ...\n    name: str\n    loader: importlib.abc.Loader | None\n    origin: str | None\n    submodule_search_locations: list[str] | None\n    loader_state: Any\n    cached: str | None\n    @property\n    def parent(self) -> str | None: ...\n    has_location: bool\n    def __eq__(self, other: object) -> bool: ...\n\nclass BuiltinImporter(importlib.abc.MetaPathFinder, importlib.abc.InspectLoader):\n    # MetaPathFinder\n    @classmethod\n    def find_module(cls, fullname: str, path: Sequence[str] | None = None) -> importlib.abc.Loader | None: ...\n    @classmethod\n    def find_spec(\n        cls, fullname: str, path: Sequence[str] | None = None, target: types.ModuleType | None = None\n    ) -> ModuleSpec | None: ...\n    # InspectLoader\n    @classmethod\n    def is_package(cls, fullname: str) -> bool: ...\n    @classmethod\n    def load_module(cls, fullname: str) -> types.ModuleType: ...\n    @classmethod\n    def get_code(cls, fullname: str) -> None: ...\n    @classmethod\n    def get_source(cls, fullname: str) -> None: ...\n    # Loader\n    @staticmethod\n    def module_repr(module: types.ModuleType) -> str: ...\n    if sys.version_info >= (3, 10):\n        @staticmethod\n        def create_module(spec: ModuleSpec) -> types.ModuleType | None: ...\n        @staticmethod\n        def exec_module(module: types.ModuleType) -> None: ...\n    else:\n        @classmethod\n        def create_module(cls, spec: ModuleSpec) -> types.ModuleType | None: ...\n        @classmethod\n        def exec_module(cls, module: types.ModuleType) -> None: ...\n\nclass FrozenImporter(importlib.abc.MetaPathFinder, importlib.abc.InspectLoader):\n    # MetaPathFinder\n    @classmethod\n    def find_module(cls, fullname: str, path: Sequence[str] | None = None) -> importlib.abc.Loader | None: ...\n    @classmethod\n    def find_spec(\n        cls, fullname: str, path: Sequence[str] | None = None, target: types.ModuleType | None = None\n    ) -> ModuleSpec | None: ...\n    # InspectLoader\n    @classmethod\n    def is_package(cls, fullname: str) -> bool: ...\n    @classmethod\n    def load_module(cls, fullname: str) -> types.ModuleType: ...\n    @classmethod\n    def get_code(cls, fullname: str) -> None: ...\n    @classmethod\n    def get_source(cls, fullname: str) -> None: ...\n    # Loader\n    @staticmethod\n    def module_repr(m: types.ModuleType) -> str: ...\n    if sys.version_info >= (3, 10):\n        @staticmethod\n        def create_module(spec: ModuleSpec) -> types.ModuleType | None: ...\n    else:\n        @classmethod\n        def create_module(cls, spec: ModuleSpec) -> types.ModuleType | None: ...\n\n    @staticmethod\n    def exec_module(module: types.ModuleType) -> None: ...\n\nclass WindowsRegistryFinder(importlib.abc.MetaPathFinder):\n    @classmethod\n    def find_module(cls, fullname: str, path: Sequence[str] | None = None) -> importlib.abc.Loader | None: ...\n    @classmethod\n    def find_spec(\n        cls, fullname: str, path: Sequence[str] | None = None, target: types.ModuleType | None = None\n    ) -> ModuleSpec | None: ...\n\nclass PathFinder:\n    if sys.version_info >= (3, 10):\n        @staticmethod\n        def invalidate_caches() -> None: ...\n    else:\n        @classmethod\n        def invalidate_caches(cls) -> None: ...\n    if sys.version_info >= (3, 10):\n        @staticmethod\n        def find_distributions(context: DistributionFinder.Context = ...) -> Iterable[PathDistribution]: ...\n    elif sys.version_info >= (3, 8):\n        @classmethod\n        def find_distributions(cls, context: DistributionFinder.Context = ...) -> Iterable[PathDistribution]: ...\n\n    @classmethod\n    def find_spec(\n        cls, fullname: str, path: Sequence[str] | None = None, target: types.ModuleType | None = None\n    ) -> ModuleSpec | None: ...\n    @classmethod\n    def find_module(cls, fullname: str, path: Sequence[str] | None = None) -> importlib.abc.Loader | None: ...\n\nSOURCE_SUFFIXES: list[str]\nDEBUG_BYTECODE_SUFFIXES: list[str]\nOPTIMIZED_BYTECODE_SUFFIXES: list[str]\nBYTECODE_SUFFIXES: list[str]\nEXTENSION_SUFFIXES: list[str]\n\ndef all_suffixes() -> list[str]: ...\n\nclass FileFinder(importlib.abc.PathEntryFinder):\n    path: str\n    def __init__(self, path: str, *loader_details: tuple[type[importlib.abc.Loader], list[str]]) -> None: ...\n    @classmethod\n    def path_hook(\n        cls, *loader_details: tuple[type[importlib.abc.Loader], list[str]]\n    ) -> Callable[[str], importlib.abc.PathEntryFinder]: ...\n\nclass SourceFileLoader(importlib.abc.FileLoader, importlib.abc.SourceLoader):\n    def set_data(self, path: str, data: ReadableBuffer, *, _mode: int = 0o666) -> None: ...\n\nclass SourcelessFileLoader(importlib.abc.FileLoader, importlib.abc.SourceLoader): ...\n\nclass ExtensionFileLoader(importlib.abc.ExecutionLoader):\n    def __init__(self, name: str, path: str) -> None: ...\n    def get_filename(self, name: str | None = None) -> str: ...\n    def get_source(self, fullname: str) -> None: ...\n    def create_module(self, spec: ModuleSpec) -> types.ModuleType: ...\n    def exec_module(self, module: types.ModuleType) -> None: ...\n    def get_code(self, fullname: str) -> None: ...\n    def __eq__(self, other: object) -> bool: ...\n",
  "/typeshed/stdlib/importlib/util.pyi": "import importlib.abc\nimport importlib.machinery\nimport types\nfrom _typeshed import ReadableBuffer, StrOrBytesPath\nfrom collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import ParamSpec\n\n_P = ParamSpec(\"_P\")\n\ndef module_for_loader(fxn: Callable[_P, types.ModuleType]) -> Callable[_P, types.ModuleType]: ...\ndef set_loader(fxn: Callable[_P, types.ModuleType]) -> Callable[_P, types.ModuleType]: ...\ndef set_package(fxn: Callable[_P, types.ModuleType]) -> Callable[_P, types.ModuleType]: ...\ndef resolve_name(name: str, package: str | None) -> str: ...\n\nMAGIC_NUMBER: bytes\n\ndef cache_from_source(path: str, debug_override: bool | None = None, *, optimization: Any | None = None) -> str: ...\ndef source_from_cache(path: str) -> str: ...\ndef decode_source(source_bytes: ReadableBuffer) -> str: ...\ndef find_spec(name: str, package: str | None = None) -> importlib.machinery.ModuleSpec | None: ...\ndef spec_from_loader(\n    name: str, loader: importlib.abc.Loader | None, *, origin: str | None = None, is_package: bool | None = None\n) -> importlib.machinery.ModuleSpec | None: ...\ndef spec_from_file_location(\n    name: str,\n    location: StrOrBytesPath | None = None,\n    *,\n    loader: importlib.abc.Loader | None = None,\n    submodule_search_locations: list[str] | None = ...,\n) -> importlib.machinery.ModuleSpec | None: ...\ndef module_from_spec(spec: importlib.machinery.ModuleSpec) -> types.ModuleType: ...\n\nclass LazyLoader(importlib.abc.Loader):\n    def __init__(self, loader: importlib.abc.Loader) -> None: ...\n    @classmethod\n    def factory(cls, loader: importlib.abc.Loader) -> Callable[..., LazyLoader]: ...\n    def exec_module(self, module: types.ModuleType) -> None: ...\n\ndef source_hash(source_bytes: ReadableBuffer) -> int: ...\n",
  "/typeshed/stdlib/importlib/metadata/__init__.pyi": "import abc\nimport pathlib\nimport sys\nfrom _typeshed import StrPath\nfrom collections.abc import Iterable, Mapping\nfrom email.message import Message\nfrom importlib.abc import MetaPathFinder\nfrom os import PathLike\nfrom pathlib import Path\nfrom re import Pattern\nfrom typing import Any, ClassVar, NamedTuple, overload\nfrom typing_extensions import Self\n\n__all__ = [\n    \"Distribution\",\n    \"DistributionFinder\",\n    \"PackageNotFoundError\",\n    \"distribution\",\n    \"distributions\",\n    \"entry_points\",\n    \"files\",\n    \"metadata\",\n    \"requires\",\n    \"version\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"PackageMetadata\", \"packages_distributions\"]\n\nif sys.version_info >= (3, 10):\n    from importlib.metadata._meta import PackageMetadata as PackageMetadata\n    def packages_distributions() -> Mapping[str, list[str]]: ...\n\nclass PackageNotFoundError(ModuleNotFoundError):\n    @property\n    def name(self) -> str: ...  # type: ignore[override]\n\nclass _EntryPointBase(NamedTuple):\n    name: str\n    value: str\n    group: str\n\nclass EntryPoint(_EntryPointBase):\n    pattern: ClassVar[Pattern[str]]\n    if sys.version_info >= (3, 11):\n        def __init__(self, name: str, value: str, group: str) -> None: ...\n\n    def load(self) -> Any: ...  # Callable[[], Any] or an importable module\n    @property\n    def extras(self) -> list[str]: ...\n    if sys.version_info >= (3, 9):\n        @property\n        def module(self) -> str: ...\n        @property\n        def attr(self) -> str: ...\n    if sys.version_info >= (3, 10):\n        dist: ClassVar[Distribution | None]\n        def matches(\n            self,\n            *,\n            name: str = ...,\n            value: str = ...,\n            group: str = ...,\n            module: str = ...,\n            attr: str = ...,\n            extras: list[str] = ...,\n        ) -> bool: ...  # undocumented\n\nif sys.version_info >= (3, 10):\n    class EntryPoints(list[EntryPoint]):  # use as list is deprecated since 3.10\n        # int argument is deprecated since 3.10\n        def __getitem__(self, name: int | str) -> EntryPoint: ...  # type: ignore[override]\n        def select(\n            self,\n            *,\n            name: str = ...,\n            value: str = ...,\n            group: str = ...,\n            module: str = ...,\n            attr: str = ...,\n            extras: list[str] = ...,\n        ) -> EntryPoints: ...\n        @property\n        def names(self) -> set[str]: ...\n        @property\n        def groups(self) -> set[str]: ...\n\n    class SelectableGroups(dict[str, EntryPoints]):  # use as dict is deprecated since 3.10\n        @classmethod\n        def load(cls, eps: Iterable[EntryPoint]) -> Self: ...\n        @property\n        def groups(self) -> set[str]: ...\n        @property\n        def names(self) -> set[str]: ...\n        @overload\n        def select(self) -> Self: ...  # type: ignore[misc]\n        @overload\n        def select(\n            self,\n            *,\n            name: str = ...,\n            value: str = ...,\n            group: str = ...,\n            module: str = ...,\n            attr: str = ...,\n            extras: list[str] = ...,\n        ) -> EntryPoints: ...\n\nclass PackagePath(pathlib.PurePosixPath):\n    def read_text(self, encoding: str = \"utf-8\") -> str: ...\n    def read_binary(self) -> bytes: ...\n    def locate(self) -> PathLike[str]: ...\n    # The following attributes are not defined on PackagePath, but are dynamically added by Distribution.files:\n    hash: FileHash | None\n    size: int | None\n    dist: Distribution\n\nclass FileHash:\n    mode: str\n    value: str\n    def __init__(self, spec: str) -> None: ...\n\nclass Distribution:\n    @abc.abstractmethod\n    def read_text(self, filename: str) -> str | None: ...\n    @abc.abstractmethod\n    def locate_file(self, path: StrPath) -> PathLike[str]: ...\n    @classmethod\n    def from_name(cls, name: str) -> Distribution: ...\n    @overload\n    @classmethod\n    def discover(cls, *, context: DistributionFinder.Context) -> Iterable[Distribution]: ...\n    @overload\n    @classmethod\n    def discover(\n        cls, *, context: None = None, name: str | None = ..., path: list[str] = ..., **kwargs: Any\n    ) -> Iterable[Distribution]: ...\n    @staticmethod\n    def at(path: StrPath) -> PathDistribution: ...\n\n    if sys.version_info >= (3, 10):\n        @property\n        def metadata(self) -> PackageMetadata: ...\n        @property\n        def entry_points(self) -> EntryPoints: ...\n    else:\n        @property\n        def metadata(self) -> Message: ...\n        @property\n        def entry_points(self) -> list[EntryPoint]: ...\n\n    @property\n    def version(self) -> str: ...\n    @property\n    def files(self) -> list[PackagePath] | None: ...\n    @property\n    def requires(self) -> list[str] | None: ...\n    if sys.version_info >= (3, 10):\n        @property\n        def name(self) -> str: ...\n\nclass DistributionFinder(MetaPathFinder):\n    class Context:\n        name: str | None\n        def __init__(self, *, name: str | None = ..., path: list[str] = ..., **kwargs: Any) -> None: ...\n        @property\n        def path(self) -> list[str]: ...\n\n    @abc.abstractmethod\n    def find_distributions(self, context: DistributionFinder.Context = ...) -> Iterable[Distribution]: ...\n\nclass MetadataPathFinder(DistributionFinder):\n    @classmethod\n    def find_distributions(cls, context: DistributionFinder.Context = ...) -> Iterable[PathDistribution]: ...\n    if sys.version_info >= (3, 10):\n        # Yes, this is an instance method that has argumend named \"cls\"\n        def invalidate_caches(cls) -> None: ...\n\nclass PathDistribution(Distribution):\n    def __init__(self, path: Path) -> None: ...\n    def read_text(self, filename: StrPath) -> str: ...\n    def locate_file(self, path: StrPath) -> PathLike[str]: ...\n\ndef distribution(distribution_name: str) -> Distribution: ...\n@overload\ndef distributions(*, context: DistributionFinder.Context) -> Iterable[Distribution]: ...\n@overload\ndef distributions(\n    *, context: None = None, name: str | None = ..., path: list[str] = ..., **kwargs: Any\n) -> Iterable[Distribution]: ...\n\nif sys.version_info >= (3, 10):\n    def metadata(distribution_name: str) -> PackageMetadata: ...\n    @overload\n    def entry_points() -> SelectableGroups: ...  # type: ignore[misc]\n    @overload\n    def entry_points(\n        *, name: str = ..., value: str = ..., group: str = ..., module: str = ..., attr: str = ..., extras: list[str] = ...\n    ) -> EntryPoints: ...\n\nelse:\n    def metadata(distribution_name: str) -> Message: ...\n    def entry_points() -> dict[str, list[EntryPoint]]: ...\n\ndef version(distribution_name: str) -> str: ...\ndef files(distribution_name: str) -> list[PackagePath] | None: ...\ndef requires(distribution_name: str) -> list[str] | None: ...\n",
  "/typeshed/stdlib/importlib/metadata/_meta.pyi": "from collections.abc import Iterator\nfrom typing import Any, Protocol, TypeVar\n\n_T = TypeVar(\"_T\")\n\nclass PackageMetadata(Protocol):\n    def __len__(self) -> int: ...\n    def __contains__(self, item: str) -> bool: ...\n    def __getitem__(self, key: str) -> str: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def get_all(self, name: str, failobj: _T = ...) -> list[Any] | _T: ...\n    @property\n    def json(self) -> dict[str, str | list[str]]: ...\n\nclass SimplePath(Protocol):\n    def joinpath(self) -> SimplePath: ...\n    def parent(self) -> SimplePath: ...\n    def read_text(self) -> str: ...\n    # There was a bug in `SimplePath` definition in cpython, see #8451\n    #  Strictly speaking `__div__` was defined in 3.10, not __truediv__,\n    # but it should have always been `__truediv__`.\n    def __truediv__(self) -> SimplePath: ...\n",
  "/typeshed/stdlib/importlib/resources/__init__.pyi": "import os\nimport sys\nfrom collections.abc import Iterator\nfrom contextlib import AbstractContextManager\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Any, BinaryIO, TextIO\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"Package\", \"Resource\", \"contents\", \"is_resource\", \"open_binary\", \"open_text\", \"path\", \"read_binary\", \"read_text\"]\n\nif sys.version_info >= (3, 9):\n    __all__ += [\"as_file\", \"files\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"ResourceReader\"]\n\nPackage: TypeAlias = str | ModuleType\n\nif sys.version_info >= (3, 11):\n    Resource: TypeAlias = str\nelse:\n    Resource: TypeAlias = str | os.PathLike[Any]\n\ndef open_binary(package: Package, resource: Resource) -> BinaryIO: ...\ndef open_text(package: Package, resource: Resource, encoding: str = \"utf-8\", errors: str = \"strict\") -> TextIO: ...\ndef read_binary(package: Package, resource: Resource) -> bytes: ...\ndef read_text(package: Package, resource: Resource, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\ndef path(package: Package, resource: Resource) -> AbstractContextManager[Path]: ...\ndef is_resource(package: Package, name: str) -> bool: ...\ndef contents(package: Package) -> Iterator[str]: ...\n\nif sys.version_info >= (3, 9):\n    from importlib.abc import Traversable\n    def files(package: Package) -> Traversable: ...\n    def as_file(path: Traversable) -> AbstractContextManager[Path]: ...\n\nif sys.version_info >= (3, 10):\n    from importlib.abc import ResourceReader as ResourceReader\n",
  "/typeshed/stdlib/importlib/resources/abc.pyi": "import sys\n\nif sys.version_info >= (3, 11):\n    # These are all actually defined in this file on 3.11+,\n    # and re-exported from importlib.abc,\n    # but it's much less code duplication for typeshed if we pretend that they're still defined\n    # in importlib.abc on 3.11+, and re-exported from this file\n    from importlib.abc import (\n        ResourceReader as ResourceReader,\n        Traversable as Traversable,\n        TraversableResources as TraversableResources,\n    )\n",
  "/typeshed/stdlib/json/__init__.pyi": "from _typeshed import SupportsRead, SupportsWrite\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom .decoder import JSONDecodeError as JSONDecodeError, JSONDecoder as JSONDecoder\nfrom .encoder import JSONEncoder as JSONEncoder\n\n__all__ = [\"dump\", \"dumps\", \"load\", \"loads\", \"JSONDecoder\", \"JSONDecodeError\", \"JSONEncoder\"]\n\ndef dumps(\n    obj: Any,\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = True,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: type[JSONEncoder] | None = None,\n    indent: None | int | str = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kwds: Any,\n) -> str: ...\ndef dump(\n    obj: Any,\n    fp: SupportsWrite[str],\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = True,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: type[JSONEncoder] | None = None,\n    indent: None | int | str = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kwds: Any,\n) -> None: ...\ndef loads(\n    s: str | bytes | bytearray,\n    *,\n    cls: type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[Any, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[Any, Any]]], Any] | None = None,\n    **kwds: Any,\n) -> Any: ...\ndef load(\n    fp: SupportsRead[str | bytes],\n    *,\n    cls: type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[Any, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[Any, Any]]], Any] | None = None,\n    **kwds: Any,\n) -> Any: ...\ndef detect_encoding(b: bytes | bytearray) -> str: ...  # undocumented\n",
  "/typeshed/stdlib/json/decoder.pyi": "from collections.abc import Callable\nfrom typing import Any\n\n__all__ = [\"JSONDecoder\", \"JSONDecodeError\"]\n\nclass JSONDecodeError(ValueError):\n    msg: str\n    doc: str\n    pos: int\n    lineno: int\n    colno: int\n    def __init__(self, msg: str, doc: str, pos: int) -> None: ...\n\nclass JSONDecoder:\n    object_hook: Callable[[dict[str, Any]], Any]\n    parse_float: Callable[[str], Any]\n    parse_int: Callable[[str], Any]\n    parse_constant: Callable[[str], Any]\n    strict: bool\n    object_pairs_hook: Callable[[list[tuple[str, Any]]], Any]\n    def __init__(\n        self,\n        *,\n        object_hook: Callable[[dict[str, Any]], Any] | None = None,\n        parse_float: Callable[[str], Any] | None = None,\n        parse_int: Callable[[str], Any] | None = None,\n        parse_constant: Callable[[str], Any] | None = None,\n        strict: bool = True,\n        object_pairs_hook: Callable[[list[tuple[str, Any]]], Any] | None = None,\n    ) -> None: ...\n    def decode(self, s: str, _w: Callable[..., Any] = ...) -> Any: ...  # _w is undocumented\n    def raw_decode(self, s: str, idx: int = 0) -> tuple[Any, int]: ...\n",
  "/typeshed/stdlib/json/encoder.pyi": "from collections.abc import Callable, Iterator\nfrom re import Pattern\nfrom typing import Any\n\nESCAPE: Pattern[str]\nESCAPE_ASCII: Pattern[str]\nHAS_UTF8: Pattern[bytes]\nESCAPE_DCT: dict[str, str]\nINFINITY: float\n\ndef py_encode_basestring(s: str) -> str: ...  # undocumented\ndef py_encode_basestring_ascii(s: str) -> str: ...  # undocumented\n\nclass JSONEncoder:\n    item_separator: str\n    key_separator: str\n\n    skipkeys: bool\n    ensure_ascii: bool\n    check_circular: bool\n    allow_nan: bool\n    sort_keys: bool\n    indent: int | str\n    def __init__(\n        self,\n        *,\n        skipkeys: bool = False,\n        ensure_ascii: bool = True,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        sort_keys: bool = False,\n        indent: int | str | None = None,\n        separators: tuple[str, str] | None = None,\n        default: Callable[..., Any] | None = None,\n    ) -> None: ...\n    def default(self, o: Any) -> Any: ...\n    def encode(self, o: Any) -> str: ...\n    def iterencode(self, o: Any, _one_shot: bool = False) -> Iterator[str]: ...\n",
  "/typeshed/stdlib/json/tool.pyi": "def main() -> None: ...\n",
  "/typeshed/stdlib/logging/__init__.pyi": "import sys\nimport threading\nfrom _typeshed import StrPath, SupportsWrite\nfrom collections.abc import Callable, Iterable, Mapping, MutableMapping, Sequence\nfrom io import TextIOWrapper\nfrom re import Pattern\nfrom string import Template\nfrom time import struct_time\nfrom types import FrameType, TracebackType\nfrom typing import Any, ClassVar, Generic, TextIO, TypeVar, overload\nfrom typing_extensions import Literal, Self, TypeAlias\n\nif sys.version_info >= (3, 11):\n    from types import GenericAlias\n\n__all__ = [\n    \"BASIC_FORMAT\",\n    \"BufferingFormatter\",\n    \"CRITICAL\",\n    \"DEBUG\",\n    \"ERROR\",\n    \"FATAL\",\n    \"FileHandler\",\n    \"Filter\",\n    \"Formatter\",\n    \"Handler\",\n    \"INFO\",\n    \"LogRecord\",\n    \"Logger\",\n    \"LoggerAdapter\",\n    \"NOTSET\",\n    \"NullHandler\",\n    \"StreamHandler\",\n    \"WARN\",\n    \"WARNING\",\n    \"addLevelName\",\n    \"basicConfig\",\n    \"captureWarnings\",\n    \"critical\",\n    \"debug\",\n    \"disable\",\n    \"error\",\n    \"exception\",\n    \"fatal\",\n    \"getLevelName\",\n    \"getLogger\",\n    \"getLoggerClass\",\n    \"info\",\n    \"log\",\n    \"makeLogRecord\",\n    \"setLoggerClass\",\n    \"shutdown\",\n    \"warn\",\n    \"warning\",\n    \"getLogRecordFactory\",\n    \"setLogRecordFactory\",\n    \"lastResort\",\n    \"raiseExceptions\",\n]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"getLevelNamesMapping\"]\n\n_SysExcInfoType: TypeAlias = tuple[type[BaseException], BaseException, TracebackType | None] | tuple[None, None, None]\n_ExcInfoType: TypeAlias = None | bool | _SysExcInfoType | BaseException\n_ArgsType: TypeAlias = tuple[object, ...] | Mapping[str, object]\n_FilterType: TypeAlias = Filter | Callable[[LogRecord], bool]\n_Level: TypeAlias = int | str\n_FormatStyle: TypeAlias = Literal[\"%\", \"{\", \"$\"]\n\nraiseExceptions: bool\nlogThreads: bool\nlogMultiprocessing: bool\nlogProcesses: bool\n_srcfile: str | None\n\ndef currentframe() -> FrameType: ...\n\n_levelToName: dict[int, str]\n_nameToLevel: dict[str, int]\n\nclass Filterer:\n    filters: list[Filter]\n    def addFilter(self, filter: _FilterType) -> None: ...\n    def removeFilter(self, filter: _FilterType) -> None: ...\n    def filter(self, record: LogRecord) -> bool: ...\n\nclass Manager:  # undocumented\n    root: RootLogger\n    disable: int\n    emittedNoHandlerWarning: bool\n    loggerDict: dict[str, Logger | PlaceHolder]\n    loggerClass: type[Logger] | None\n    logRecordFactory: Callable[..., LogRecord] | None\n    def __init__(self, rootnode: RootLogger) -> None: ...\n    def getLogger(self, name: str) -> Logger: ...\n    def setLoggerClass(self, klass: type[Logger]) -> None: ...\n    def setLogRecordFactory(self, factory: Callable[..., LogRecord]) -> None: ...\n\nclass Logger(Filterer):\n    name: str  # undocumented\n    level: int  # undocumented\n    parent: Logger | None  # undocumented\n    propagate: bool\n    handlers: list[Handler]  # undocumented\n    disabled: bool  # undocumented\n    root: ClassVar[RootLogger]  # undocumented\n    manager: Manager  # undocumented\n    def __init__(self, name: str, level: _Level = 0) -> None: ...\n    def setLevel(self, level: _Level) -> None: ...\n    def isEnabledFor(self, level: int) -> bool: ...\n    def getEffectiveLevel(self) -> int: ...\n    def getChild(self, suffix: str) -> Self: ...  # see python/typing#980\n    if sys.version_info >= (3, 8):\n        def debug(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def info(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def warning(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def warn(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def error(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def exception(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = True,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def critical(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def log(\n            self,\n            level: int,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def _log(\n            self,\n            level: int,\n            msg: object,\n            args: _ArgsType,\n            exc_info: _ExcInfoType | None = None,\n            extra: Mapping[str, object] | None = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n        ) -> None: ...  # undocumented\n    else:\n        def debug(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def info(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def warning(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def warn(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def error(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def critical(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def log(\n            self,\n            level: int,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def exception(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = True,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n        ) -> None: ...\n        def _log(\n            self,\n            level: int,\n            msg: object,\n            args: _ArgsType,\n            exc_info: _ExcInfoType | None = None,\n            extra: Mapping[str, object] | None = None,\n            stack_info: bool = False,\n        ) -> None: ...  # undocumented\n    fatal = critical\n    def addHandler(self, hdlr: Handler) -> None: ...\n    def removeHandler(self, hdlr: Handler) -> None: ...\n    if sys.version_info >= (3, 8):\n        def findCaller(self, stack_info: bool = False, stacklevel: int = 1) -> tuple[str, int, str, str | None]: ...\n    else:\n        def findCaller(self, stack_info: bool = False) -> tuple[str, int, str, str | None]: ...\n\n    def handle(self, record: LogRecord) -> None: ...\n    def makeRecord(\n        self,\n        name: str,\n        level: int,\n        fn: str,\n        lno: int,\n        msg: object,\n        args: _ArgsType,\n        exc_info: _SysExcInfoType | None,\n        func: str | None = None,\n        extra: Mapping[str, object] | None = None,\n        sinfo: str | None = None,\n    ) -> LogRecord: ...\n    def hasHandlers(self) -> bool: ...\n    def callHandlers(self, record: LogRecord) -> None: ...  # undocumented\n\nCRITICAL: int\nFATAL: int\nERROR: int\nWARNING: int\nWARN: int\nINFO: int\nDEBUG: int\nNOTSET: int\n\nclass Handler(Filterer):\n    level: int  # undocumented\n    formatter: Formatter | None  # undocumented\n    lock: threading.Lock | None  # undocumented\n    name: str | None  # undocumented\n    def __init__(self, level: _Level = 0) -> None: ...\n    def get_name(self) -> str: ...  # undocumented\n    def set_name(self, name: str) -> None: ...  # undocumented\n    def createLock(self) -> None: ...\n    def acquire(self) -> None: ...\n    def release(self) -> None: ...\n    def setLevel(self, level: _Level) -> None: ...\n    def setFormatter(self, fmt: Formatter | None) -> None: ...\n    def flush(self) -> None: ...\n    def close(self) -> None: ...\n    def handle(self, record: LogRecord) -> bool: ...\n    def handleError(self, record: LogRecord) -> None: ...\n    def format(self, record: LogRecord) -> str: ...\n    def emit(self, record: LogRecord) -> None: ...\n\nclass Formatter:\n    converter: Callable[[float | None], struct_time]\n    _fmt: str | None  # undocumented\n    datefmt: str | None  # undocumented\n    _style: PercentStyle  # undocumented\n    default_time_format: str\n    if sys.version_info >= (3, 9):\n        default_msec_format: str | None\n    else:\n        default_msec_format: str\n\n    if sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            fmt: str | None = None,\n            datefmt: str | None = None,\n            style: _FormatStyle = \"%\",\n            validate: bool = True,\n            *,\n            defaults: Mapping[str, Any] | None = None,\n        ) -> None: ...\n    elif sys.version_info >= (3, 8):\n        def __init__(\n            self, fmt: str | None = None, datefmt: str | None = None, style: _FormatStyle = \"%\", validate: bool = True\n        ) -> None: ...\n    else:\n        def __init__(self, fmt: str | None = None, datefmt: str | None = None, style: _FormatStyle = \"%\") -> None: ...\n\n    def format(self, record: LogRecord) -> str: ...\n    def formatTime(self, record: LogRecord, datefmt: str | None = None) -> str: ...\n    def formatException(self, ei: _SysExcInfoType) -> str: ...\n    def formatMessage(self, record: LogRecord) -> str: ...  # undocumented\n    def formatStack(self, stack_info: str) -> str: ...\n    def usesTime(self) -> bool: ...  # undocumented\n\nclass BufferingFormatter:\n    linefmt: Formatter\n    def __init__(self, linefmt: Formatter | None = None) -> None: ...\n    def formatHeader(self, records: Sequence[LogRecord]) -> str: ...\n    def formatFooter(self, records: Sequence[LogRecord]) -> str: ...\n    def format(self, records: Sequence[LogRecord]) -> str: ...\n\nclass Filter:\n    name: str  # undocumented\n    nlen: int  # undocumented\n    def __init__(self, name: str = \"\") -> None: ...\n    def filter(self, record: LogRecord) -> bool: ...\n\nclass LogRecord:\n    # args can be set to None by logging.handlers.QueueHandler\n    # (see https://bugs.python.org/issue44473)\n    args: _ArgsType | None\n    asctime: str\n    created: float\n    exc_info: _SysExcInfoType | None\n    exc_text: str | None\n    filename: str\n    funcName: str\n    levelname: str\n    levelno: int\n    lineno: int\n    module: str\n    msecs: float\n    # Only created when logging.Formatter.format is called. See #6132.\n    message: str\n    msg: str | Any  # The runtime accepts any object, but will be a str in 99% of cases\n    name: str\n    pathname: str\n    process: int | None\n    processName: str | None\n    relativeCreated: float\n    stack_info: str | None\n    thread: int | None\n    threadName: str | None\n    def __init__(\n        self,\n        name: str,\n        level: int,\n        pathname: str,\n        lineno: int,\n        msg: object,\n        args: _ArgsType | None,\n        exc_info: _SysExcInfoType | None,\n        func: str | None = None,\n        sinfo: str | None = None,\n    ) -> None: ...\n    def getMessage(self) -> str: ...\n    # Allows setting contextual information on LogRecord objects as per the docs, see #7833\n    def __setattr__(self, __name: str, __value: Any) -> None: ...\n\n_L = TypeVar(\"_L\", bound=Logger | LoggerAdapter[Any])\n\nclass LoggerAdapter(Generic[_L]):\n    logger: _L\n    manager: Manager  # undocumented\n    if sys.version_info >= (3, 10):\n        extra: Mapping[str, object] | None\n        def __init__(self, logger: _L, extra: Mapping[str, object] | None = None) -> None: ...\n    else:\n        extra: Mapping[str, object]\n        def __init__(self, logger: _L, extra: Mapping[str, object]) -> None: ...\n\n    def process(self, msg: Any, kwargs: MutableMapping[str, Any]) -> tuple[Any, MutableMapping[str, Any]]: ...\n    if sys.version_info >= (3, 8):\n        def debug(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def info(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def warning(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def warn(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def error(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def exception(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = True,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def critical(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def log(\n            self,\n            level: int,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            stacklevel: int = 1,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n    else:\n        def debug(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def info(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def warning(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def warn(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def error(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def exception(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = True,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def critical(\n            self,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n        def log(\n            self,\n            level: int,\n            msg: object,\n            *args: object,\n            exc_info: _ExcInfoType = None,\n            stack_info: bool = False,\n            extra: Mapping[str, object] | None = None,\n            **kwargs: object,\n        ) -> None: ...\n\n    def isEnabledFor(self, level: int) -> bool: ...\n    def getEffectiveLevel(self) -> int: ...\n    def setLevel(self, level: _Level) -> None: ...\n    def hasHandlers(self) -> bool: ...\n    def _log(\n        self,\n        level: int,\n        msg: object,\n        args: _ArgsType,\n        exc_info: _ExcInfoType | None = None,\n        extra: Mapping[str, object] | None = None,\n        stack_info: bool = False,\n    ) -> None: ...  # undocumented\n    @property\n    def name(self) -> str: ...  # undocumented\n    if sys.version_info >= (3, 11):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\ndef getLogger(name: str | None = None) -> Logger: ...\ndef getLoggerClass() -> type[Logger]: ...\ndef getLogRecordFactory() -> Callable[..., LogRecord]: ...\n\nif sys.version_info >= (3, 8):\n    def debug(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def info(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def warning(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def warn(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def error(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def critical(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def exception(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = True,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def log(\n        level: int,\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        stacklevel: int = 1,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n\nelse:\n    def debug(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def info(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def warning(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def warn(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def error(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def critical(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def exception(\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = True,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n    def log(\n        level: int,\n        msg: object,\n        *args: object,\n        exc_info: _ExcInfoType = None,\n        stack_info: bool = False,\n        extra: Mapping[str, object] | None = None,\n    ) -> None: ...\n\nfatal = critical\n\ndef disable(level: int = 50) -> None: ...\ndef addLevelName(level: int, levelName: str) -> None: ...\ndef getLevelName(level: _Level) -> Any: ...\n\nif sys.version_info >= (3, 11):\n    def getLevelNamesMapping() -> dict[str, int]: ...\n\ndef makeLogRecord(dict: Mapping[str, object]) -> LogRecord: ...\n\nif sys.version_info >= (3, 9):\n    def basicConfig(\n        *,\n        filename: StrPath | None = ...,\n        filemode: str = ...,\n        format: str = ...,\n        datefmt: str | None = ...,\n        style: _FormatStyle = ...,\n        level: _Level | None = ...,\n        stream: SupportsWrite[str] | None = ...,\n        handlers: Iterable[Handler] | None = ...,\n        force: bool | None = ...,\n        encoding: str | None = ...,\n        errors: str | None = ...,\n    ) -> None: ...\n\nelif sys.version_info >= (3, 8):\n    def basicConfig(\n        *,\n        filename: StrPath | None = ...,\n        filemode: str = ...,\n        format: str = ...,\n        datefmt: str | None = ...,\n        style: _FormatStyle = ...,\n        level: _Level | None = ...,\n        stream: SupportsWrite[str] | None = ...,\n        handlers: Iterable[Handler] | None = ...,\n        force: bool = ...,\n    ) -> None: ...\n\nelse:\n    def basicConfig(\n        *,\n        filename: StrPath | None = ...,\n        filemode: str = ...,\n        format: str = ...,\n        datefmt: str | None = ...,\n        style: _FormatStyle = ...,\n        level: _Level | None = ...,\n        stream: SupportsWrite[str] | None = ...,\n        handlers: Iterable[Handler] | None = ...,\n    ) -> None: ...\n\ndef shutdown(handlerList: Sequence[Any] = ...) -> None: ...  # handlerList is undocumented\ndef setLoggerClass(klass: type[Logger]) -> None: ...\ndef captureWarnings(capture: bool) -> None: ...\ndef setLogRecordFactory(factory: Callable[..., LogRecord]) -> None: ...\n\nlastResort: StreamHandler[Any] | None\n\n_StreamT = TypeVar(\"_StreamT\", bound=SupportsWrite[str])\n\nclass StreamHandler(Handler, Generic[_StreamT]):\n    stream: _StreamT  # undocumented\n    terminator: str\n    @overload\n    def __init__(self: StreamHandler[TextIO], stream: None = None) -> None: ...\n    @overload\n    def __init__(self: StreamHandler[_StreamT], stream: _StreamT) -> None: ...\n    def setStream(self, stream: _StreamT) -> _StreamT | None: ...\n    if sys.version_info >= (3, 11):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass FileHandler(StreamHandler[TextIOWrapper]):\n    baseFilename: str  # undocumented\n    mode: str  # undocumented\n    encoding: str | None  # undocumented\n    delay: bool  # undocumented\n    if sys.version_info >= (3, 9):\n        errors: str | None  # undocumented\n        def __init__(\n            self, filename: StrPath, mode: str = \"a\", encoding: str | None = None, delay: bool = False, errors: str | None = None\n        ) -> None: ...\n    else:\n        def __init__(self, filename: StrPath, mode: str = \"a\", encoding: str | None = None, delay: bool = False) -> None: ...\n\n    def _open(self) -> TextIOWrapper: ...  # undocumented\n\nclass NullHandler(Handler): ...\n\nclass PlaceHolder:  # undocumented\n    loggerMap: dict[Logger, None]\n    def __init__(self, alogger: Logger) -> None: ...\n    def append(self, alogger: Logger) -> None: ...\n\n# Below aren't in module docs but still visible\n\nclass RootLogger(Logger):\n    def __init__(self, level: int) -> None: ...\n\nroot: RootLogger\n\nclass PercentStyle:  # undocumented\n    default_format: str\n    asctime_format: str\n    asctime_search: str\n    if sys.version_info >= (3, 8):\n        validation_pattern: Pattern[str]\n    _fmt: str\n    if sys.version_info >= (3, 10):\n        def __init__(self, fmt: str, *, defaults: Mapping[str, Any] | None = None) -> None: ...\n    else:\n        def __init__(self, fmt: str) -> None: ...\n\n    def usesTime(self) -> bool: ...\n    if sys.version_info >= (3, 8):\n        def validate(self) -> None: ...\n\n    def format(self, record: Any) -> str: ...\n\nclass StrFormatStyle(PercentStyle):  # undocumented\n    fmt_spec: Pattern[str]\n    field_spec: Pattern[str]\n\nclass StringTemplateStyle(PercentStyle):  # undocumented\n    _tpl: Template\n\n_STYLES: dict[str, tuple[PercentStyle, str]]\n\nBASIC_FORMAT: str\n",
  "/typeshed/stdlib/logging/config.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Callable, Sequence\nfrom configparser import RawConfigParser\nfrom re import Pattern\nfrom threading import Thread\nfrom typing import IO, Any\n\nfrom . import _Level\n\nif sys.version_info >= (3, 8):\n    from typing import Literal, TypedDict\nelse:\n    from typing_extensions import Literal, TypedDict\n\nDEFAULT_LOGGING_CONFIG_PORT: int\nRESET_ERROR: int  # undocumented\nIDENTIFIER: Pattern[str]  # undocumented\n\nclass _RootLoggerConfiguration(TypedDict, total=False):\n    level: _Level\n    filters: Sequence[str]\n    handlers: Sequence[str]\n\nclass _LoggerConfiguration(_RootLoggerConfiguration, TypedDict, total=False):\n    propagate: bool\n\nclass _OptionalDictConfigArgs(TypedDict, total=False):\n    # these two can have custom factories (key: `()`) which can have extra keys\n    formatters: dict[str, dict[str, Any]]\n    filters: dict[str, dict[str, Any]]\n    # type checkers would warn about extra keys if this was a TypedDict\n    handlers: dict[str, dict[str, Any]]\n    loggers: dict[str, _LoggerConfiguration]\n    root: _RootLoggerConfiguration | None\n    incremental: bool\n    disable_existing_loggers: bool\n\nclass _DictConfigArgs(_OptionalDictConfigArgs, TypedDict):\n    version: Literal[1]\n\n# Accept dict[str, Any] to avoid false positives if called with a dict\n# type, since dict types are not compatible with TypedDicts.\n#\n# Also accept a TypedDict type, to allow callers to use TypedDict\n# types, and for somewhat stricter type checking of dict literals.\ndef dictConfig(config: _DictConfigArgs | dict[str, Any]) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def fileConfig(\n        fname: StrOrBytesPath | IO[str] | RawConfigParser,\n        defaults: dict[str, str] | None = None,\n        disable_existing_loggers: bool = True,\n        encoding: str | None = None,\n    ) -> None: ...\n\nelse:\n    def fileConfig(\n        fname: StrOrBytesPath | IO[str] | RawConfigParser,\n        defaults: dict[str, str] | None = None,\n        disable_existing_loggers: bool = True,\n    ) -> None: ...\n\ndef valid_ident(s: str) -> Literal[True]: ...  # undocumented\ndef listen(port: int = 9030, verify: Callable[[bytes], bytes | None] | None = None) -> Thread: ...\ndef stopListening() -> None: ...\n",
  "/typeshed/stdlib/logging/handlers.pyi": "import datetime\nimport http.client\nimport ssl\nimport sys\nfrom _typeshed import ReadableBuffer, StrPath\nfrom collections.abc import Callable\nfrom logging import FileHandler, Handler, LogRecord\nfrom queue import Queue, SimpleQueue\nfrom re import Pattern\nfrom socket import SocketKind, socket\nfrom typing import Any, ClassVar\n\nDEFAULT_TCP_LOGGING_PORT: int\nDEFAULT_UDP_LOGGING_PORT: int\nDEFAULT_HTTP_LOGGING_PORT: int\nDEFAULT_SOAP_LOGGING_PORT: int\nSYSLOG_UDP_PORT: int\nSYSLOG_TCP_PORT: int\n\nclass WatchedFileHandler(FileHandler):\n    dev: int  # undocumented\n    ino: int  # undocumented\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self, filename: StrPath, mode: str = \"a\", encoding: str | None = None, delay: bool = False, errors: str | None = None\n        ) -> None: ...\n    else:\n        def __init__(self, filename: StrPath, mode: str = \"a\", encoding: str | None = None, delay: bool = False) -> None: ...\n\n    def _statstream(self) -> None: ...  # undocumented\n    def reopenIfNeeded(self) -> None: ...\n\nclass BaseRotatingHandler(FileHandler):\n    namer: Callable[[str], str] | None\n    rotator: Callable[[str, str], None] | None\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self, filename: StrPath, mode: str, encoding: str | None = None, delay: bool = False, errors: str | None = None\n        ) -> None: ...\n    else:\n        def __init__(self, filename: StrPath, mode: str, encoding: str | None = None, delay: bool = False) -> None: ...\n\n    def rotation_filename(self, default_name: str) -> str: ...\n    def rotate(self, source: str, dest: str) -> None: ...\n\nclass RotatingFileHandler(BaseRotatingHandler):\n    maxBytes: str  # undocumented\n    backupCount: int  # undocumented\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            filename: StrPath,\n            mode: str = \"a\",\n            maxBytes: int = 0,\n            backupCount: int = 0,\n            encoding: str | None = None,\n            delay: bool = False,\n            errors: str | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            filename: StrPath,\n            mode: str = \"a\",\n            maxBytes: int = 0,\n            backupCount: int = 0,\n            encoding: str | None = None,\n            delay: bool = False,\n        ) -> None: ...\n\n    def doRollover(self) -> None: ...\n    def shouldRollover(self, record: LogRecord) -> int: ...  # undocumented\n\nclass TimedRotatingFileHandler(BaseRotatingHandler):\n    when: str  # undocumented\n    backupCount: int  # undocumented\n    utc: bool  # undocumented\n    atTime: datetime.time | None  # undocumented\n    interval: int  # undocumented\n    suffix: str  # undocumented\n    dayOfWeek: int  # undocumented\n    rolloverAt: int  # undocumented\n    extMatch: Pattern[str]  # undocumented\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            filename: StrPath,\n            when: str = \"h\",\n            interval: int = 1,\n            backupCount: int = 0,\n            encoding: str | None = None,\n            delay: bool = False,\n            utc: bool = False,\n            atTime: datetime.time | None = None,\n            errors: str | None = None,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            filename: StrPath,\n            when: str = \"h\",\n            interval: int = 1,\n            backupCount: int = 0,\n            encoding: str | None = None,\n            delay: bool = False,\n            utc: bool = False,\n            atTime: datetime.time | None = None,\n        ) -> None: ...\n\n    def doRollover(self) -> None: ...\n    def shouldRollover(self, record: LogRecord) -> int: ...  # undocumented\n    def computeRollover(self, currentTime: int) -> int: ...  # undocumented\n    def getFilesToDelete(self) -> list[str]: ...  # undocumented\n\nclass SocketHandler(Handler):\n    host: str  # undocumented\n    port: int | None  # undocumented\n    address: tuple[str, int] | str  # undocumented\n    sock: socket | None  # undocumented\n    closeOnError: bool  # undocumented\n    retryTime: float | None  # undocumented\n    retryStart: float  # undocumented\n    retryFactor: float  # undocumented\n    retryMax: float  # undocumented\n    def __init__(self, host: str, port: int | None) -> None: ...\n    def makeSocket(self, timeout: float = 1) -> socket: ...  # timeout is undocumented\n    def makePickle(self, record: LogRecord) -> bytes: ...\n    def send(self, s: ReadableBuffer) -> None: ...\n    def createSocket(self) -> None: ...\n\nclass DatagramHandler(SocketHandler):\n    def makeSocket(self) -> socket: ...  # type: ignore[override]\n\nclass SysLogHandler(Handler):\n    LOG_EMERG: int\n    LOG_ALERT: int\n    LOG_CRIT: int\n    LOG_ERR: int\n    LOG_WARNING: int\n    LOG_NOTICE: int\n    LOG_INFO: int\n    LOG_DEBUG: int\n\n    LOG_KERN: int\n    LOG_USER: int\n    LOG_MAIL: int\n    LOG_DAEMON: int\n    LOG_AUTH: int\n    LOG_SYSLOG: int\n    LOG_LPR: int\n    LOG_NEWS: int\n    LOG_UUCP: int\n    LOG_CRON: int\n    LOG_AUTHPRIV: int\n    LOG_FTP: int\n\n    if sys.version_info >= (3, 9):\n        LOG_NTP: int\n        LOG_SECURITY: int\n        LOG_CONSOLE: int\n        LOG_SOLCRON: int\n\n    LOG_LOCAL0: int\n    LOG_LOCAL1: int\n    LOG_LOCAL2: int\n    LOG_LOCAL3: int\n    LOG_LOCAL4: int\n    LOG_LOCAL5: int\n    LOG_LOCAL6: int\n    LOG_LOCAL7: int\n    address: tuple[str, int] | str  # undocumented\n    unixsocket: bool  # undocumented\n    socktype: SocketKind  # undocumented\n    ident: str  # undocumented\n    append_nul: bool  # undocumented\n    facility: int  # undocumented\n    priority_names: ClassVar[dict[str, int]]  # undocumented\n    facility_names: ClassVar[dict[str, int]]  # undocumented\n    priority_map: ClassVar[dict[str, str]]  # undocumented\n    def __init__(\n        self, address: tuple[str, int] | str = (\"localhost\", 514), facility: int = 1, socktype: SocketKind | None = None\n    ) -> None: ...\n    if sys.version_info >= (3, 11):\n        def createSocket(self) -> None: ...\n\n    def encodePriority(self, facility: int | str, priority: int | str) -> int: ...\n    def mapPriority(self, levelName: str) -> str: ...\n\nclass NTEventLogHandler(Handler):\n    def __init__(self, appname: str, dllname: str | None = None, logtype: str = \"Application\") -> None: ...\n    def getEventCategory(self, record: LogRecord) -> int: ...\n    # TODO correct return value?\n    def getEventType(self, record: LogRecord) -> int: ...\n    def getMessageID(self, record: LogRecord) -> int: ...\n\nclass SMTPHandler(Handler):\n    mailhost: str  # undocumented\n    mailport: int | None  # undocumented\n    username: str | None  # undocumented\n    # password only exists as an attribute if passed credentials is a tuple or list\n    password: str  # undocumented\n    fromaddr: str  # undocumented\n    toaddrs: list[str]  # undocumented\n    subject: str  # undocumented\n    secure: tuple[()] | tuple[str] | tuple[str, str] | None  # undocumented\n    timeout: float  # undocumented\n    def __init__(\n        self,\n        mailhost: str | tuple[str, int],\n        fromaddr: str,\n        toaddrs: str | list[str],\n        subject: str,\n        credentials: tuple[str, str] | None = None,\n        secure: tuple[()] | tuple[str] | tuple[str, str] | None = None,\n        timeout: float = 5.0,\n    ) -> None: ...\n    def getSubject(self, record: LogRecord) -> str: ...\n\nclass BufferingHandler(Handler):\n    capacity: int  # undocumented\n    buffer: list[LogRecord]  # undocumented\n    def __init__(self, capacity: int) -> None: ...\n    def shouldFlush(self, record: LogRecord) -> bool: ...\n\nclass MemoryHandler(BufferingHandler):\n    flushLevel: int  # undocumented\n    target: Handler | None  # undocumented\n    flushOnClose: bool  # undocumented\n    def __init__(self, capacity: int, flushLevel: int = 40, target: Handler | None = None, flushOnClose: bool = True) -> None: ...\n    def setTarget(self, target: Handler | None) -> None: ...\n\nclass HTTPHandler(Handler):\n    host: str  # undocumented\n    url: str  # undocumented\n    method: str  # undocumented\n    secure: bool  # undocumented\n    credentials: tuple[str, str] | None  # undocumented\n    context: ssl.SSLContext | None  # undocumented\n    def __init__(\n        self,\n        host: str,\n        url: str,\n        method: str = \"GET\",\n        secure: bool = False,\n        credentials: tuple[str, str] | None = None,\n        context: ssl.SSLContext | None = None,\n    ) -> None: ...\n    def mapLogRecord(self, record: LogRecord) -> dict[str, Any]: ...\n    if sys.version_info >= (3, 9):\n        def getConnection(self, host: str, secure: bool) -> http.client.HTTPConnection: ...  # undocumented\n\nclass QueueHandler(Handler):\n    queue: SimpleQueue[Any] | Queue[Any]  # undocumented\n    def __init__(self, queue: SimpleQueue[Any] | Queue[Any]) -> None: ...\n    def prepare(self, record: LogRecord) -> Any: ...\n    def enqueue(self, record: LogRecord) -> None: ...\n\nclass QueueListener:\n    handlers: tuple[Handler, ...]  # undocumented\n    respect_handler_level: bool  # undocumented\n    queue: SimpleQueue[Any] | Queue[Any]  # undocumented\n    def __init__(self, queue: SimpleQueue[Any] | Queue[Any], *handlers: Handler, respect_handler_level: bool = False) -> None: ...\n    def dequeue(self, block: bool) -> LogRecord: ...\n    def prepare(self, record: LogRecord) -> Any: ...\n    def start(self) -> None: ...\n    def stop(self) -> None: ...\n    def enqueue_sentinel(self) -> None: ...\n    def handle(self, record: LogRecord) -> None: ...\n",
  "/typeshed/stdlib/msilib/__init__.pyi": "import sys\nfrom collections.abc import Container, Iterable, Sequence\nfrom types import ModuleType\nfrom typing import Any\nfrom typing_extensions import Literal\n\nif sys.platform == \"win32\":\n    from _msi import *\n    from _msi import _Database\n\n    AMD64: bool\n    Win64: bool\n\n    datasizemask: Literal[0x00FF]\n    type_valid: Literal[0x0100]\n    type_localizable: Literal[0x0200]\n    typemask: Literal[0x0C00]\n    type_long: Literal[0x0000]\n    type_short: Literal[0x0400]\n    type_string: Literal[0x0C00]\n    type_binary: Literal[0x0800]\n    type_nullable: Literal[0x1000]\n    type_key: Literal[0x2000]\n    knownbits: Literal[0x3FFF]\n\n    class Table:\n        name: str\n        fields: list[tuple[int, str, int]]\n        def __init__(self, name: str) -> None: ...\n        def add_field(self, index: int, name: str, type: int) -> None: ...\n        def sql(self) -> str: ...\n        def create(self, db: _Database) -> None: ...\n\n    class _Unspecified: ...\n\n    def change_sequence(\n        seq: Sequence[tuple[str, str | None, int]],\n        action: str,\n        seqno: int | type[_Unspecified] = ...,\n        cond: str | type[_Unspecified] = ...,\n    ) -> None: ...\n    def add_data(db: _Database, table: str, values: Iterable[tuple[Any, ...]]) -> None: ...\n    def add_stream(db: _Database, name: str, path: str) -> None: ...\n    def init_database(\n        name: str, schema: ModuleType, ProductName: str, ProductCode: str, ProductVersion: str, Manufacturer: str\n    ) -> _Database: ...\n    def add_tables(db: _Database, module: ModuleType) -> None: ...\n    def make_id(str: str) -> str: ...\n    def gen_uuid() -> str: ...\n\n    class CAB:\n        name: str\n        files: list[tuple[str, str]]\n        filenames: set[str]\n        index: int\n        def __init__(self, name: str) -> None: ...\n        def gen_id(self, file: str) -> str: ...\n        def append(self, full: str, file: str, logical: str) -> tuple[int, str]: ...\n        def commit(self, db: _Database) -> None: ...\n    _directories: set[str]\n\n    class Directory:\n        db: _Database\n        cab: CAB\n        basedir: str\n        physical: str\n        logical: str\n        component: str | None\n        short_names: set[str]\n        ids: set[str]\n        keyfiles: dict[str, str]\n        componentflags: int | None\n        absolute: str\n        def __init__(\n            self,\n            db: _Database,\n            cab: CAB,\n            basedir: str,\n            physical: str,\n            _logical: str,\n            default: str,\n            componentflags: int | None = None,\n        ) -> None: ...\n        def start_component(\n            self,\n            component: str | None = None,\n            feature: Feature | None = None,\n            flags: int | None = None,\n            keyfile: str | None = None,\n            uuid: str | None = None,\n        ) -> None: ...\n        def make_short(self, file: str) -> str: ...\n        def add_file(self, file: str, src: str | None = None, version: str | None = None, language: str | None = None) -> str: ...\n        def glob(self, pattern: str, exclude: Container[str] | None = None) -> list[str]: ...\n        def remove_pyc(self) -> None: ...\n\n    class Binary:\n        name: str\n        def __init__(self, fname: str) -> None: ...\n\n    class Feature:\n        id: str\n        def __init__(\n            self,\n            db: _Database,\n            id: str,\n            title: str,\n            desc: str,\n            display: int,\n            level: int = 1,\n            parent: Feature | None = None,\n            directory: str | None = None,\n            attributes: int = 0,\n        ) -> None: ...\n        def set_current(self) -> None: ...\n\n    class Control:\n        dlg: Dialog\n        name: str\n        def __init__(self, dlg: Dialog, name: str) -> None: ...\n        def event(self, event: str, argument: str, condition: str = \"1\", ordering: int | None = None) -> None: ...\n        def mapping(self, event: str, attribute: str) -> None: ...\n        def condition(self, action: str, condition: str) -> None: ...\n\n    class RadioButtonGroup(Control):\n        property: str\n        index: int\n        def __init__(self, dlg: Dialog, name: str, property: str) -> None: ...\n        def add(self, name: str, x: int, y: int, w: int, h: int, text: str, value: str | None = None) -> None: ...\n\n    class Dialog:\n        db: _Database\n        name: str\n        x: int\n        y: int\n        w: int\n        h: int\n        def __init__(\n            self,\n            db: _Database,\n            name: str,\n            x: int,\n            y: int,\n            w: int,\n            h: int,\n            attr: int,\n            title: str,\n            first: str,\n            default: str,\n            cancel: str,\n        ) -> None: ...\n        def control(\n            self,\n            name: str,\n            type: str,\n            x: int,\n            y: int,\n            w: int,\n            h: int,\n            attr: int,\n            prop: str | None,\n            text: str | None,\n            next: str | None,\n            help: str | None,\n        ) -> Control: ...\n        def text(self, name: str, x: int, y: int, w: int, h: int, attr: int, text: str | None) -> Control: ...\n        def bitmap(self, name: str, x: int, y: int, w: int, h: int, text: str | None) -> Control: ...\n        def line(self, name: str, x: int, y: int, w: int, h: int) -> Control: ...\n        def pushbutton(\n            self, name: str, x: int, y: int, w: int, h: int, attr: int, text: str | None, next: str | None\n        ) -> Control: ...\n        def radiogroup(\n            self, name: str, x: int, y: int, w: int, h: int, attr: int, prop: str | None, text: str | None, next: str | None\n        ) -> RadioButtonGroup: ...\n        def checkbox(\n            self, name: str, x: int, y: int, w: int, h: int, attr: int, prop: str | None, text: str | None, next: str | None\n        ) -> Control: ...\n",
  "/typeshed/stdlib/msilib/schema.pyi": "import sys\n\nif sys.platform == \"win32\":\n    from . import Table\n\n    _Validation: Table\n    ActionText: Table\n    AdminExecuteSequence: Table\n    Condition: Table\n    AdminUISequence: Table\n    AdvtExecuteSequence: Table\n    AdvtUISequence: Table\n    AppId: Table\n    AppSearch: Table\n    Property: Table\n    BBControl: Table\n    Billboard: Table\n    Feature: Table\n    Binary: Table\n    BindImage: Table\n    File: Table\n    CCPSearch: Table\n    CheckBox: Table\n    Class: Table\n    Component: Table\n    Icon: Table\n    ProgId: Table\n    ComboBox: Table\n    CompLocator: Table\n    Complus: Table\n    Directory: Table\n    Control: Table\n    Dialog: Table\n    ControlCondition: Table\n    ControlEvent: Table\n    CreateFolder: Table\n    CustomAction: Table\n    DrLocator: Table\n    DuplicateFile: Table\n    Environment: Table\n    Error: Table\n    EventMapping: Table\n    Extension: Table\n    MIME: Table\n    FeatureComponents: Table\n    FileSFPCatalog: Table\n    SFPCatalog: Table\n    Font: Table\n    IniFile: Table\n    IniLocator: Table\n    InstallExecuteSequence: Table\n    InstallUISequence: Table\n    IsolatedComponent: Table\n    LaunchCondition: Table\n    ListBox: Table\n    ListView: Table\n    LockPermissions: Table\n    Media: Table\n    MoveFile: Table\n    MsiAssembly: Table\n    MsiAssemblyName: Table\n    MsiDigitalCertificate: Table\n    MsiDigitalSignature: Table\n    MsiFileHash: Table\n    MsiPatchHeaders: Table\n    ODBCAttribute: Table\n    ODBCDriver: Table\n    ODBCDataSource: Table\n    ODBCSourceAttribute: Table\n    ODBCTranslator: Table\n    Patch: Table\n    PatchPackage: Table\n    PublishComponent: Table\n    RadioButton: Table\n    Registry: Table\n    RegLocator: Table\n    RemoveFile: Table\n    RemoveIniFile: Table\n    RemoveRegistry: Table\n    ReserveCost: Table\n    SelfReg: Table\n    ServiceControl: Table\n    ServiceInstall: Table\n    Shortcut: Table\n    Signature: Table\n    TextStyle: Table\n    TypeLib: Table\n    UIText: Table\n    Upgrade: Table\n    Verb: Table\n\n    tables: list[Table]\n\n    _Validation_records: list[tuple[str, str, str, int | None, int | None, str | None, int | None, str | None, str | None, str]]\n",
  "/typeshed/stdlib/msilib/sequence.pyi": "import sys\nfrom typing_extensions import TypeAlias\n\nif sys.platform == \"win32\":\n    _SequenceType: TypeAlias = list[tuple[str, str | None, int]]\n\n    AdminExecuteSequence: _SequenceType\n    AdminUISequence: _SequenceType\n    AdvtExecuteSequence: _SequenceType\n    InstallExecuteSequence: _SequenceType\n    InstallUISequence: _SequenceType\n\n    tables: list[str]\n",
  "/typeshed/stdlib/msilib/text.pyi": "import sys\n\nif sys.platform == \"win32\":\n    ActionText: list[tuple[str, str, str | None]]\n    UIText: list[tuple[str, str | None]]\n\n    tables: list[str]\n",
  "/typeshed/stdlib/os/__init__.pyi": "import sys\nfrom _typeshed import (\n    AnyStr_co,\n    BytesPath,\n    FileDescriptorLike,\n    FileDescriptorOrPath,\n    GenericPath,\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    StrOrBytesPath,\n    StrPath,\n    SupportsLenAndGetItem,\n    Unused,\n    WriteableBuffer,\n    structseq,\n)\nfrom abc import abstractmethod\nfrom builtins import OSError\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, MutableMapping, Sequence\nfrom contextlib import AbstractContextManager\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper as _TextIOWrapper\nfrom subprocess import Popen\nfrom typing import IO, Any, AnyStr, BinaryIO, Generic, NoReturn, Protocol, TypeVar, overload, runtime_checkable\nfrom typing_extensions import Final, Literal, Self, TypeAlias, final\n\nfrom . import path as _path\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# This unnecessary alias is to work around various errors\npath = _path\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n\n# ----- os variables -----\n\nerror = OSError\n\nsupports_bytes_environ: bool\n\nsupports_dir_fd: set[Callable[..., Any]]\nsupports_fd: set[Callable[..., Any]]\nsupports_effective_ids: set[Callable[..., Any]]\nsupports_follow_symlinks: set[Callable[..., Any]]\n\nif sys.platform != \"win32\":\n    # Unix only\n    PRIO_PROCESS: int\n    PRIO_PGRP: int\n    PRIO_USER: int\n\n    F_LOCK: int\n    F_TLOCK: int\n    F_ULOCK: int\n    F_TEST: int\n\n    if sys.platform != \"darwin\":\n        POSIX_FADV_NORMAL: int\n        POSIX_FADV_SEQUENTIAL: int\n        POSIX_FADV_RANDOM: int\n        POSIX_FADV_NOREUSE: int\n        POSIX_FADV_WILLNEED: int\n        POSIX_FADV_DONTNEED: int\n\n    SF_NODISKIO: int\n    SF_MNOWAIT: int\n    SF_SYNC: int\n\n    if sys.platform == \"linux\":\n        XATTR_SIZE_MAX: int\n        XATTR_CREATE: int\n        XATTR_REPLACE: int\n\n    P_PID: int\n    P_PGID: int\n    P_ALL: int\n\n    if sys.platform == \"linux\" and sys.version_info >= (3, 9):\n        P_PIDFD: int\n\n    WEXITED: int\n    WSTOPPED: int\n    WNOWAIT: int\n\n    CLD_EXITED: int\n    CLD_DUMPED: int\n    CLD_TRAPPED: int\n    CLD_CONTINUED: int\n\n    if sys.version_info >= (3, 9):\n        CLD_KILLED: int\n        CLD_STOPPED: int\n\n    # TODO: SCHED_RESET_ON_FORK not available on darwin?\n    # TODO: SCHED_BATCH and SCHED_IDLE are linux only?\n    SCHED_OTHER: int  # some flavors of Unix\n    SCHED_BATCH: int  # some flavors of Unix\n    SCHED_IDLE: int  # some flavors of Unix\n    SCHED_SPORADIC: int  # some flavors of Unix\n    SCHED_FIFO: int  # some flavors of Unix\n    SCHED_RR: int  # some flavors of Unix\n    SCHED_RESET_ON_FORK: int  # some flavors of Unix\n\nif sys.platform != \"win32\":\n    RTLD_LAZY: int\n    RTLD_NOW: int\n    RTLD_GLOBAL: int\n    RTLD_LOCAL: int\n    RTLD_NODELETE: int\n    RTLD_NOLOAD: int\n\nif sys.platform == \"linux\":\n    RTLD_DEEPBIND: int\n    GRND_NONBLOCK: int\n    GRND_RANDOM: int\n\nSEEK_SET: int\nSEEK_CUR: int\nSEEK_END: int\nif sys.platform != \"win32\":\n    SEEK_DATA: int  # some flavors of Unix\n    SEEK_HOLE: int  # some flavors of Unix\n\nO_RDONLY: int\nO_WRONLY: int\nO_RDWR: int\nO_APPEND: int\nO_CREAT: int\nO_EXCL: int\nO_TRUNC: int\n# We don't use sys.platform for O_* flags to denote platform-dependent APIs because some codes,\n# including tests for mypy, use a more finer way than sys.platform before using these APIs\n# See https://github.com/python/typeshed/pull/2286 for discussions\nO_DSYNC: int  # Unix only\nO_RSYNC: int  # Unix only\nO_SYNC: int  # Unix only\nO_NDELAY: int  # Unix only\nO_NONBLOCK: int  # Unix only\nO_NOCTTY: int  # Unix only\nO_CLOEXEC: int  # Unix only\nO_SHLOCK: int  # Unix only\nO_EXLOCK: int  # Unix only\nO_BINARY: int  # Windows only\nO_NOINHERIT: int  # Windows only\nO_SHORT_LIVED: int  # Windows only\nO_TEMPORARY: int  # Windows only\nO_RANDOM: int  # Windows only\nO_SEQUENTIAL: int  # Windows only\nO_TEXT: int  # Windows only\nO_ASYNC: int  # Gnu extension if in C library\nO_DIRECT: int  # Gnu extension if in C library\nO_DIRECTORY: int  # Gnu extension if in C library\nO_NOFOLLOW: int  # Gnu extension if in C library\nO_NOATIME: int  # Gnu extension if in C library\nO_PATH: int  # Gnu extension if in C library\nO_TMPFILE: int  # Gnu extension if in C library\nO_LARGEFILE: int  # Gnu extension if in C library\nO_ACCMODE: int  # TODO: when does this exist?\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    # posix, but apparently missing on macos\n    ST_APPEND: int\n    ST_MANDLOCK: int\n    ST_NOATIME: int\n    ST_NODEV: int\n    ST_NODIRATIME: int\n    ST_NOEXEC: int\n    ST_RELATIME: int\n    ST_SYNCHRONOUS: int\n    ST_WRITE: int\n\nif sys.platform != \"win32\":\n    NGROUPS_MAX: int\n    ST_NOSUID: int\n    ST_RDONLY: int\n\ncurdir: str\npardir: str\nsep: str\nif sys.platform == \"win32\":\n    altsep: str\nelse:\n    altsep: str | None\nextsep: str\npathsep: str\ndefpath: str\nlinesep: str\ndevnull: str\nname: str\n\nF_OK: int\nR_OK: int\nW_OK: int\nX_OK: int\n\n_EnvironCodeFunc: TypeAlias = Callable[[AnyStr], AnyStr]\n\nclass _Environ(MutableMapping[AnyStr, AnyStr], Generic[AnyStr]):\n    encodekey: _EnvironCodeFunc[AnyStr]\n    decodekey: _EnvironCodeFunc[AnyStr]\n    encodevalue: _EnvironCodeFunc[AnyStr]\n    decodevalue: _EnvironCodeFunc[AnyStr]\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            data: MutableMapping[AnyStr, AnyStr],\n            encodekey: _EnvironCodeFunc[AnyStr],\n            decodekey: _EnvironCodeFunc[AnyStr],\n            encodevalue: _EnvironCodeFunc[AnyStr],\n            decodevalue: _EnvironCodeFunc[AnyStr],\n        ) -> None: ...\n    else:\n        putenv: Callable[[AnyStr, AnyStr], object]\n        unsetenv: Callable[[AnyStr, AnyStr], object]\n        def __init__(\n            self,\n            data: MutableMapping[AnyStr, AnyStr],\n            encodekey: _EnvironCodeFunc[AnyStr],\n            decodekey: _EnvironCodeFunc[AnyStr],\n            encodevalue: _EnvironCodeFunc[AnyStr],\n            decodevalue: _EnvironCodeFunc[AnyStr],\n            putenv: Callable[[AnyStr, AnyStr], object],\n            unsetenv: Callable[[AnyStr, AnyStr], object],\n        ) -> None: ...\n\n    def setdefault(self, key: AnyStr, value: AnyStr) -> AnyStr: ...  # type: ignore[override]\n    def copy(self) -> dict[AnyStr, AnyStr]: ...\n    def __delitem__(self, key: AnyStr) -> None: ...\n    def __getitem__(self, key: AnyStr) -> AnyStr: ...\n    def __setitem__(self, key: AnyStr, value: AnyStr) -> None: ...\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    def __len__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __or__(self, other: Mapping[_T1, _T2]) -> dict[AnyStr | _T1, AnyStr | _T2]: ...\n        def __ror__(self, other: Mapping[_T1, _T2]) -> dict[AnyStr | _T1, AnyStr | _T2]: ...\n        # We use @overload instead of a Union for reasons similar to those given for\n        # overloading MutableMapping.update in stdlib/typing.pyi\n        # The type: ignore is needed due to incompatible __or__/__ior__ signatures\n        @overload  # type: ignore[misc]\n        def __ior__(self, other: Mapping[AnyStr, AnyStr]) -> Self: ...\n        @overload\n        def __ior__(self, other: Iterable[tuple[AnyStr, AnyStr]]) -> Self: ...\n\nenviron: _Environ[str]\nif sys.platform != \"win32\":\n    environb: _Environ[bytes]\n\nif sys.platform != \"win32\":\n    confstr_names: dict[str, int]\n    pathconf_names: dict[str, int]\n    sysconf_names: dict[str, int]\n\n    EX_OK: int\n    EX_USAGE: int\n    EX_DATAERR: int\n    EX_NOINPUT: int\n    EX_NOUSER: int\n    EX_NOHOST: int\n    EX_UNAVAILABLE: int\n    EX_SOFTWARE: int\n    EX_OSERR: int\n    EX_OSFILE: int\n    EX_CANTCREAT: int\n    EX_IOERR: int\n    EX_TEMPFAIL: int\n    EX_PROTOCOL: int\n    EX_NOPERM: int\n    EX_CONFIG: int\n    EX_NOTFOUND: int\n\nP_NOWAIT: int\nP_NOWAITO: int\nP_WAIT: int\nif sys.platform == \"win32\":\n    P_DETACH: int\n    P_OVERLAY: int\n\n# wait()/waitpid() options\nif sys.platform != \"win32\":\n    WNOHANG: int  # Unix only\n    WCONTINUED: int  # some Unix systems\n    WUNTRACED: int  # Unix only\n\nTMP_MAX: int  # Undocumented, but used by tempfile\n\n# ----- os classes (structures) -----\n@final\nclass stat_result(structseq[float], tuple[int, int, int, int, int, int, int, float, float, float]):\n    # The constructor of this class takes an iterable of variable length (though it must be at least 10).\n    #\n    # However, this class behaves like a tuple of 10 elements,\n    # no matter how long the iterable supplied to the constructor is.\n    # https://github.com/python/typeshed/pull/6560#discussion_r767162532\n    #\n    # The 10 elements always present are st_mode, st_ino, st_dev, st_nlink,\n    # st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime.\n    #\n    # More items may be added at the end by some implementations.\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"st_mode\", \"st_ino\", \"st_dev\", \"st_nlink\", \"st_uid\", \"st_gid\", \"st_size\")\n    @property\n    def st_mode(self) -> int: ...  # protection bits,\n    @property\n    def st_ino(self) -> int: ...  # inode number,\n    @property\n    def st_dev(self) -> int: ...  # device,\n    @property\n    def st_nlink(self) -> int: ...  # number of hard links,\n    @property\n    def st_uid(self) -> int: ...  # user id of owner,\n    @property\n    def st_gid(self) -> int: ...  # group id of owner,\n    @property\n    def st_size(self) -> int: ...  # size of file, in bytes,\n    @property\n    def st_atime(self) -> float: ...  # time of most recent access,\n    @property\n    def st_mtime(self) -> float: ...  # time of most recent content modification,\n    # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows)\n    @property\n    def st_ctime(self) -> float: ...\n    @property\n    def st_atime_ns(self) -> int: ...  # time of most recent access, in nanoseconds\n    @property\n    def st_mtime_ns(self) -> int: ...  # time of most recent content modification in nanoseconds\n    # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows) in nanoseconds\n    @property\n    def st_ctime_ns(self) -> int: ...\n    if sys.platform == \"win32\":\n        @property\n        def st_file_attributes(self) -> int: ...\n        if sys.version_info >= (3, 8):\n            @property\n            def st_reparse_tag(self) -> int: ...\n    else:\n        @property\n        def st_blocks(self) -> int: ...  # number of blocks allocated for file\n        @property\n        def st_blksize(self) -> int: ...  # filesystem blocksize\n        @property\n        def st_rdev(self) -> int: ...  # type of device if an inode device\n        if sys.platform != \"linux\":\n            # These properties are available on MacOS, but not on Windows or Ubuntu.\n            # On other Unix systems (such as FreeBSD), the following attributes may be\n            # available (but may be only filled out if root tries to use them):\n            @property\n            def st_gen(self) -> int: ...  # file generation number\n            @property\n            def st_birthtime(self) -> int: ...  # time of file creation\n    if sys.platform == \"darwin\":\n        @property\n        def st_flags(self) -> int: ...  # user defined flags for file\n    # Attributes documented as sometimes appearing, but deliberately omitted from the stub: `st_creator`, `st_rsize`, `st_type`.\n    # See https://github.com/python/typeshed/pull/6560#issuecomment-991253327\n\n@runtime_checkable\nclass PathLike(Protocol[AnyStr_co]):\n    @abstractmethod\n    def __fspath__(self) -> AnyStr_co: ...\n\n@overload\ndef listdir(path: StrPath | None = None) -> list[str]: ...\n@overload\ndef listdir(path: BytesPath) -> list[bytes]: ...\n@overload\ndef listdir(path: int) -> list[str]: ...\n@final\nclass DirEntry(Generic[AnyStr]):\n    # This is what the scandir iterator yields\n    # The constructor is hidden\n\n    @property\n    def name(self) -> AnyStr: ...\n    @property\n    def path(self) -> AnyStr: ...\n    def inode(self) -> int: ...\n    def is_dir(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_file(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_symlink(self) -> bool: ...\n    def stat(self, *, follow_symlinks: bool = True) -> stat_result: ...\n    def __fspath__(self) -> AnyStr: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n@final\nclass statvfs_result(structseq[int], tuple[int, int, int, int, int, int, int, int, int, int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\n            \"f_bsize\",\n            \"f_frsize\",\n            \"f_blocks\",\n            \"f_bfree\",\n            \"f_bavail\",\n            \"f_files\",\n            \"f_ffree\",\n            \"f_favail\",\n            \"f_flag\",\n            \"f_namemax\",\n        )\n    @property\n    def f_bsize(self) -> int: ...\n    @property\n    def f_frsize(self) -> int: ...\n    @property\n    def f_blocks(self) -> int: ...\n    @property\n    def f_bfree(self) -> int: ...\n    @property\n    def f_bavail(self) -> int: ...\n    @property\n    def f_files(self) -> int: ...\n    @property\n    def f_ffree(self) -> int: ...\n    @property\n    def f_favail(self) -> int: ...\n    @property\n    def f_flag(self) -> int: ...\n    @property\n    def f_namemax(self) -> int: ...\n    @property\n    def f_fsid(self) -> int: ...\n\n# ----- os function stubs -----\ndef fsencode(filename: StrOrBytesPath) -> bytes: ...\ndef fsdecode(filename: StrOrBytesPath) -> str: ...\n@overload\ndef fspath(path: str) -> str: ...\n@overload\ndef fspath(path: bytes) -> bytes: ...\n@overload\ndef fspath(path: PathLike[AnyStr]) -> AnyStr: ...\ndef get_exec_path(env: Mapping[str, str] | None = None) -> list[str]: ...\ndef getlogin() -> str: ...\ndef getpid() -> int: ...\ndef getppid() -> int: ...\ndef strerror(__code: int) -> str: ...\ndef umask(__mask: int) -> int: ...\n@final\nclass uname_result(structseq[str], tuple[str, str, str, str, str]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"sysname\", \"nodename\", \"release\", \"version\", \"machine\")\n    @property\n    def sysname(self) -> str: ...\n    @property\n    def nodename(self) -> str: ...\n    @property\n    def release(self) -> str: ...\n    @property\n    def version(self) -> str: ...\n    @property\n    def machine(self) -> str: ...\n\nif sys.platform != \"win32\":\n    def ctermid() -> str: ...\n    def getegid() -> int: ...\n    def geteuid() -> int: ...\n    def getgid() -> int: ...\n    def getgrouplist(__user: str, __group: int) -> list[int]: ...\n    def getgroups() -> list[int]: ...  # Unix only, behaves differently on Mac\n    def initgroups(__username: str, __gid: int) -> None: ...\n    def getpgid(pid: int) -> int: ...\n    def getpgrp() -> int: ...\n    def getpriority(which: int, who: int) -> int: ...\n    def setpriority(which: int, who: int, priority: int) -> None: ...\n    if sys.platform != \"darwin\":\n        def getresuid() -> tuple[int, int, int]: ...\n        def getresgid() -> tuple[int, int, int]: ...\n\n    def getuid() -> int: ...\n    def setegid(__egid: int) -> None: ...\n    def seteuid(__euid: int) -> None: ...\n    def setgid(__gid: int) -> None: ...\n    def setgroups(__groups: Sequence[int]) -> None: ...\n    def setpgrp() -> None: ...\n    def setpgid(__pid: int, __pgrp: int) -> None: ...\n    def setregid(__rgid: int, __egid: int) -> None: ...\n    if sys.platform != \"darwin\":\n        def setresgid(rgid: int, egid: int, sgid: int) -> None: ...\n        def setresuid(ruid: int, euid: int, suid: int) -> None: ...\n\n    def setreuid(__ruid: int, __euid: int) -> None: ...\n    def getsid(__pid: int) -> int: ...\n    def setsid() -> None: ...\n    def setuid(__uid: int) -> None: ...\n    def uname() -> uname_result: ...\n\n@overload\ndef getenv(key: str) -> str | None: ...\n@overload\ndef getenv(key: str, default: _T) -> str | _T: ...\n\nif sys.platform != \"win32\":\n    @overload\n    def getenvb(key: bytes) -> bytes | None: ...\n    @overload\n    def getenvb(key: bytes, default: _T) -> bytes | _T: ...\n    def putenv(__name: StrOrBytesPath, __value: StrOrBytesPath) -> None: ...\n    def unsetenv(__name: StrOrBytesPath) -> None: ...\n\nelse:\n    def putenv(__name: str, __value: str) -> None: ...\n\n    if sys.version_info >= (3, 9):\n        def unsetenv(__name: str) -> None: ...\n\n_Opener: TypeAlias = Callable[[str, int], int]\n\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenTextMode = \"r\",\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> _TextIOWrapper: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryMode,\n    buffering: Literal[0],\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> FileIO: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeUpdating,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedRandom: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeWriting,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedWriter: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeReading,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedReader: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryMode,\n    buffering: int = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: str,\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef close(fd: int) -> None: ...\ndef closerange(__fd_low: int, __fd_high: int) -> None: ...\ndef device_encoding(fd: int) -> str | None: ...\ndef dup(__fd: int) -> int: ...\ndef dup2(fd: int, fd2: int, inheritable: bool = True) -> int: ...\ndef fstat(fd: int) -> stat_result: ...\ndef ftruncate(__fd: int, __length: int) -> None: ...\ndef fsync(fd: FileDescriptorLike) -> None: ...\ndef isatty(__fd: int) -> bool: ...\n\nif sys.platform != \"win32\" and sys.version_info >= (3, 11):\n    def login_tty(__fd: int) -> None: ...\n\ndef lseek(__fd: int, __position: int, __how: int) -> int: ...\ndef open(path: StrOrBytesPath, flags: int, mode: int = 0o777, *, dir_fd: int | None = None) -> int: ...\ndef pipe() -> tuple[int, int]: ...\ndef read(__fd: int, __length: int) -> bytes: ...\n\nif sys.platform != \"win32\":\n    def fchmod(fd: int, mode: int) -> None: ...\n    def fchown(fd: int, uid: int, gid: int) -> None: ...\n    def fpathconf(__fd: int, __name: str | int) -> int: ...\n    def fstatvfs(__fd: int) -> statvfs_result: ...\n    def get_blocking(__fd: int) -> bool: ...\n    def set_blocking(__fd: int, __blocking: bool) -> None: ...\n    def lockf(__fd: int, __command: int, __length: int) -> None: ...\n    def openpty() -> tuple[int, int]: ...  # some flavors of Unix\n    if sys.platform != \"darwin\":\n        def fdatasync(fd: FileDescriptorLike) -> None: ...\n        def pipe2(__flags: int) -> tuple[int, int]: ...  # some flavors of Unix\n        def posix_fallocate(__fd: int, __offset: int, __length: int) -> None: ...\n        def posix_fadvise(__fd: int, __offset: int, __length: int, __advice: int) -> None: ...\n\n    def pread(__fd: int, __length: int, __offset: int) -> bytes: ...\n    def pwrite(__fd: int, __buffer: ReadableBuffer, __offset: int) -> int: ...\n    # In CI, stubtest sometimes reports that these are available on MacOS, sometimes not\n    def preadv(__fd: int, __buffers: SupportsLenAndGetItem[WriteableBuffer], __offset: int, __flags: int = 0) -> int: ...\n    def pwritev(__fd: int, __buffers: SupportsLenAndGetItem[ReadableBuffer], __offset: int, __flags: int = 0) -> int: ...\n    if sys.platform != \"darwin\":\n        if sys.version_info >= (3, 10):\n            RWF_APPEND: int  # docs say available on 3.7+, stubtest says otherwise\n        RWF_DSYNC: int\n        RWF_SYNC: int\n        RWF_HIPRI: int\n        RWF_NOWAIT: int\n    @overload\n    def sendfile(out_fd: int, in_fd: int, offset: int | None, count: int) -> int: ...\n    @overload\n    def sendfile(\n        out_fd: int,\n        in_fd: int,\n        offset: int,\n        count: int,\n        headers: Sequence[ReadableBuffer] = ...,\n        trailers: Sequence[ReadableBuffer] = ...,\n        flags: int = 0,\n    ) -> int: ...  # FreeBSD and Mac OS X only\n    def readv(__fd: int, __buffers: SupportsLenAndGetItem[WriteableBuffer]) -> int: ...\n    def writev(__fd: int, __buffers: SupportsLenAndGetItem[ReadableBuffer]) -> int: ...\n\n@final\nclass terminal_size(structseq[int], tuple[int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"columns\", \"lines\")\n    @property\n    def columns(self) -> int: ...\n    @property\n    def lines(self) -> int: ...\n\ndef get_terminal_size(__fd: int = ...) -> terminal_size: ...\ndef get_inheritable(__fd: int) -> bool: ...\ndef set_inheritable(__fd: int, __inheritable: bool) -> None: ...\n\nif sys.platform == \"win32\":\n    def get_handle_inheritable(__handle: int) -> bool: ...\n    def set_handle_inheritable(__handle: int, __inheritable: bool) -> None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def tcgetpgrp(__fd: int) -> int: ...\n    def tcsetpgrp(__fd: int, __pgid: int) -> None: ...\n    def ttyname(__fd: int) -> str: ...\n\ndef write(__fd: int, __data: ReadableBuffer) -> int: ...\ndef access(\n    path: FileDescriptorOrPath, mode: int, *, dir_fd: int | None = None, effective_ids: bool = False, follow_symlinks: bool = True\n) -> bool: ...\ndef chdir(path: FileDescriptorOrPath) -> None: ...\n\nif sys.platform != \"win32\":\n    def fchdir(fd: FileDescriptorLike) -> None: ...\n\ndef getcwd() -> str: ...\ndef getcwdb() -> bytes: ...\ndef chmod(path: FileDescriptorOrPath, mode: int, *, dir_fd: int | None = None, follow_symlinks: bool = True) -> None: ...\n\nif sys.platform != \"win32\" and sys.platform != \"linux\":\n    def chflags(path: StrOrBytesPath, flags: int, follow_symlinks: bool = True) -> None: ...  # some flavors of Unix\n    def lchflags(path: StrOrBytesPath, flags: int) -> None: ...\n    def lchmod(path: StrOrBytesPath, mode: int) -> None: ...\n\nif sys.platform != \"win32\":\n    def chroot(path: StrOrBytesPath) -> None: ...\n    def chown(\n        path: FileDescriptorOrPath, uid: int, gid: int, *, dir_fd: int | None = None, follow_symlinks: bool = True\n    ) -> None: ...\n    def lchown(path: StrOrBytesPath, uid: int, gid: int) -> None: ...\n\ndef link(\n    src: StrOrBytesPath,\n    dst: StrOrBytesPath,\n    *,\n    src_dir_fd: int | None = None,\n    dst_dir_fd: int | None = None,\n    follow_symlinks: bool = True,\n) -> None: ...\ndef lstat(path: StrOrBytesPath, *, dir_fd: int | None = None) -> stat_result: ...\ndef mkdir(path: StrOrBytesPath, mode: int = 0o777, *, dir_fd: int | None = None) -> None: ...\n\nif sys.platform != \"win32\":\n    def mkfifo(path: StrOrBytesPath, mode: int = 0o666, *, dir_fd: int | None = None) -> None: ...  # Unix only\n\ndef makedirs(name: StrOrBytesPath, mode: int = 0o777, exist_ok: bool = False) -> None: ...\n\nif sys.platform != \"win32\":\n    def mknod(path: StrOrBytesPath, mode: int = 0o600, device: int = 0, *, dir_fd: int | None = None) -> None: ...\n    def major(__device: int) -> int: ...\n    def minor(__device: int) -> int: ...\n    def makedev(__major: int, __minor: int) -> int: ...\n    def pathconf(path: FileDescriptorOrPath, name: str | int) -> int: ...  # Unix only\n\ndef readlink(path: GenericPath[AnyStr], *, dir_fd: int | None = None) -> AnyStr: ...\ndef remove(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\ndef removedirs(name: StrOrBytesPath) -> None: ...\ndef rename(src: StrOrBytesPath, dst: StrOrBytesPath, *, src_dir_fd: int | None = None, dst_dir_fd: int | None = None) -> None: ...\ndef renames(old: StrOrBytesPath, new: StrOrBytesPath) -> None: ...\ndef replace(\n    src: StrOrBytesPath, dst: StrOrBytesPath, *, src_dir_fd: int | None = None, dst_dir_fd: int | None = None\n) -> None: ...\ndef rmdir(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\n\nclass _ScandirIterator(Iterator[DirEntry[AnyStr]], AbstractContextManager[_ScandirIterator[AnyStr]]):\n    def __next__(self) -> DirEntry[AnyStr]: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def close(self) -> None: ...\n\n@overload\ndef scandir(path: None = None) -> _ScandirIterator[str]: ...\n@overload\ndef scandir(path: int) -> _ScandirIterator[str]: ...\n@overload\ndef scandir(path: GenericPath[AnyStr]) -> _ScandirIterator[AnyStr]: ...\ndef stat(path: FileDescriptorOrPath, *, dir_fd: int | None = None, follow_symlinks: bool = True) -> stat_result: ...\n\nif sys.platform != \"win32\":\n    def statvfs(path: FileDescriptorOrPath) -> statvfs_result: ...  # Unix only\n\ndef symlink(\n    src: StrOrBytesPath, dst: StrOrBytesPath, target_is_directory: bool = False, *, dir_fd: int | None = None\n) -> None: ...\n\nif sys.platform != \"win32\":\n    def sync() -> None: ...  # Unix only\n\ndef truncate(path: FileDescriptorOrPath, length: int) -> None: ...  # Unix only up to version 3.4\ndef unlink(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\ndef utime(\n    path: FileDescriptorOrPath,\n    times: tuple[int, int] | tuple[float, float] | None = None,\n    *,\n    ns: tuple[int, int] = ...,\n    dir_fd: int | None = None,\n    follow_symlinks: bool = True,\n) -> None: ...\n\n_OnError: TypeAlias = Callable[[OSError], object]\n\ndef walk(\n    top: GenericPath[AnyStr], topdown: bool = True, onerror: _OnError | None = None, followlinks: bool = False\n) -> Iterator[tuple[AnyStr, list[AnyStr], list[AnyStr]]]: ...\n\nif sys.platform != \"win32\":\n    @overload\n    def fwalk(\n        top: StrPath = \".\",\n        topdown: bool = True,\n        onerror: _OnError | None = None,\n        *,\n        follow_symlinks: bool = False,\n        dir_fd: int | None = None,\n    ) -> Iterator[tuple[str, list[str], list[str], int]]: ...\n    @overload\n    def fwalk(\n        top: BytesPath,\n        topdown: bool = True,\n        onerror: _OnError | None = None,\n        *,\n        follow_symlinks: bool = False,\n        dir_fd: int | None = None,\n    ) -> Iterator[tuple[bytes, list[bytes], list[bytes], int]]: ...\n    if sys.platform == \"linux\":\n        def getxattr(path: FileDescriptorOrPath, attribute: StrOrBytesPath, *, follow_symlinks: bool = True) -> bytes: ...\n        def listxattr(path: FileDescriptorOrPath | None = None, *, follow_symlinks: bool = True) -> list[str]: ...\n        def removexattr(path: FileDescriptorOrPath, attribute: StrOrBytesPath, *, follow_symlinks: bool = True) -> None: ...\n        def setxattr(\n            path: FileDescriptorOrPath,\n            attribute: StrOrBytesPath,\n            value: ReadableBuffer,\n            flags: int = 0,\n            *,\n            follow_symlinks: bool = True,\n        ) -> None: ...\n\ndef abort() -> NoReturn: ...\n\n# These are defined as execl(file, *args) but the first *arg is mandatory.\ndef execl(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: StrOrBytesPath) -> NoReturn: ...\ndef execlp(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: StrOrBytesPath) -> NoReturn: ...\n\n# These are: execle(file, *args, env) but env is pulled from the last element of the args.\ndef execle(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: Any) -> NoReturn: ...\ndef execlpe(file: StrOrBytesPath, __arg0: StrOrBytesPath, *args: Any) -> NoReturn: ...\n\n# The docs say `args: tuple or list of strings`\n# The implementation enforces tuple or list so we can't use Sequence.\n# Not separating out PathLike[str] and PathLike[bytes] here because it doesn't make much difference\n# in practice, and doing so would explode the number of combinations in this already long union.\n# All these combinations are necessary due to list being invariant.\n_ExecVArgs: TypeAlias = (\n    tuple[StrOrBytesPath, ...]\n    | list[bytes]\n    | list[str]\n    | list[PathLike[Any]]\n    | list[bytes | str]\n    | list[bytes | PathLike[Any]]\n    | list[str | PathLike[Any]]\n    | list[bytes | str | PathLike[Any]]\n)\n# Depending on the OS, the keys and values are passed either to\n# PyUnicode_FSDecoder (which accepts str | ReadableBuffer) or to\n# PyUnicode_FSConverter (which accepts StrOrBytesPath). For simplicity,\n# we limit to str | bytes.\n_ExecEnv: TypeAlias = Mapping[bytes, bytes | str] | Mapping[str, bytes | str]\n\ndef execv(__path: StrOrBytesPath, __argv: _ExecVArgs) -> NoReturn: ...\ndef execve(path: FileDescriptorOrPath, argv: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...\ndef execvp(file: StrOrBytesPath, args: _ExecVArgs) -> NoReturn: ...\ndef execvpe(file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...\ndef _exit(status: int) -> NoReturn: ...\ndef kill(__pid: int, __signal: int) -> None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def fork() -> int: ...\n    def forkpty() -> tuple[int, int]: ...  # some flavors of Unix\n    def killpg(__pgid: int, __signal: int) -> None: ...\n    def nice(__increment: int) -> int: ...\n    if sys.platform != \"darwin\":\n        def plock(__op: int) -> None: ...  # ???op is int?\n\nclass _wrap_close(_TextIOWrapper):\n    def __init__(self, stream: _TextIOWrapper, proc: Popen[str]) -> None: ...\n    def close(self) -> int | None: ...  # type: ignore[override]\n\ndef popen(cmd: str, mode: str = \"r\", buffering: int = -1) -> _wrap_close: ...\ndef spawnl(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\ndef spawnle(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise sig\n\nif sys.platform != \"win32\":\n    def spawnv(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n    def spawnve(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n\nelse:\n    def spawnv(__mode: int, __path: StrOrBytesPath, __argv: _ExecVArgs) -> int: ...\n    def spawnve(__mode: int, __path: StrOrBytesPath, __argv: _ExecVArgs, __env: _ExecEnv) -> int: ...\n\ndef system(command: StrOrBytesPath) -> int: ...\n@final\nclass times_result(structseq[float], tuple[float, float, float, float, float]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"user\", \"system\", \"children_user\", \"children_system\", \"elapsed\")\n    @property\n    def user(self) -> float: ...\n    @property\n    def system(self) -> float: ...\n    @property\n    def children_user(self) -> float: ...\n    @property\n    def children_system(self) -> float: ...\n    @property\n    def elapsed(self) -> float: ...\n\ndef times() -> times_result: ...\ndef waitpid(__pid: int, __options: int) -> tuple[int, int]: ...\n\nif sys.platform == \"win32\":\n    if sys.version_info >= (3, 8):\n        def startfile(path: StrOrBytesPath, operation: str | None = None) -> None: ...\n    else:\n        def startfile(filepath: StrOrBytesPath, operation: str | None = None) -> None: ...\n\nelse:\n    def spawnlp(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\n    def spawnlpe(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise signature\n    def spawnvp(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n    def spawnvpe(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n    def wait() -> tuple[int, int]: ...  # Unix only\n    if sys.platform != \"darwin\":\n        @final\n        class waitid_result(structseq[int], tuple[int, int, int, int, int]):\n            if sys.version_info >= (3, 10):\n                __match_args__: Final = (\"si_pid\", \"si_uid\", \"si_signo\", \"si_status\", \"si_code\")\n            @property\n            def si_pid(self) -> int: ...\n            @property\n            def si_uid(self) -> int: ...\n            @property\n            def si_signo(self) -> int: ...\n            @property\n            def si_status(self) -> int: ...\n            @property\n            def si_code(self) -> int: ...\n\n        def waitid(__idtype: int, __ident: int, __options: int) -> waitid_result: ...\n\n    def wait3(options: int) -> tuple[int, int, Any]: ...\n    def wait4(pid: int, options: int) -> tuple[int, int, Any]: ...\n    def WCOREDUMP(__status: int) -> bool: ...\n    def WIFCONTINUED(status: int) -> bool: ...\n    def WIFSTOPPED(status: int) -> bool: ...\n    def WIFSIGNALED(status: int) -> bool: ...\n    def WIFEXITED(status: int) -> bool: ...\n    def WEXITSTATUS(status: int) -> int: ...\n    def WSTOPSIG(status: int) -> int: ...\n    def WTERMSIG(status: int) -> int: ...\n    if sys.version_info >= (3, 8):\n        def posix_spawn(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n        def posix_spawnp(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n        POSIX_SPAWN_OPEN: int\n        POSIX_SPAWN_CLOSE: int\n        POSIX_SPAWN_DUP2: int\n\nif sys.platform != \"win32\":\n    @final\n    class sched_param(structseq[int], tuple[int]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\"sched_priority\",)\n        def __new__(cls, sched_priority: int) -> Self: ...\n        @property\n        def sched_priority(self) -> int: ...\n\n    def sched_get_priority_min(policy: int) -> int: ...  # some flavors of Unix\n    def sched_get_priority_max(policy: int) -> int: ...  # some flavors of Unix\n    def sched_yield() -> None: ...  # some flavors of Unix\n    if sys.platform != \"darwin\":\n        def sched_setscheduler(__pid: int, __policy: int, __param: sched_param) -> None: ...  # some flavors of Unix\n        def sched_getscheduler(__pid: int) -> int: ...  # some flavors of Unix\n        def sched_rr_get_interval(__pid: int) -> float: ...  # some flavors of Unix\n        def sched_setparam(__pid: int, __param: sched_param) -> None: ...  # some flavors of Unix\n        def sched_getparam(__pid: int) -> sched_param: ...  # some flavors of Unix\n        def sched_setaffinity(__pid: int, __mask: Iterable[int]) -> None: ...  # some flavors of Unix\n        def sched_getaffinity(__pid: int) -> set[int]: ...  # some flavors of Unix\n\ndef cpu_count() -> int | None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def confstr(__name: str | int) -> str | None: ...\n    def getloadavg() -> tuple[float, float, float]: ...\n    def sysconf(__name: str | int) -> int: ...\n\nif sys.platform == \"linux\":\n    def getrandom(size: int, flags: int = 0) -> bytes: ...\n\ndef urandom(__size: int) -> bytes: ...\n\nif sys.platform != \"win32\":\n    def register_at_fork(\n        *,\n        before: Callable[..., Any] | None = ...,\n        after_in_parent: Callable[..., Any] | None = ...,\n        after_in_child: Callable[..., Any] | None = ...,\n    ) -> None: ...\n\nif sys.version_info >= (3, 8):\n    if sys.platform == \"win32\":\n        class _AddedDllDirectory:\n            path: str | None\n            def __init__(self, path: str | None, cookie: _T, remove_dll_directory: Callable[[_T], object]) -> None: ...\n            def close(self) -> None: ...\n            def __enter__(self) -> Self: ...\n            def __exit__(self, *args: Unused) -> None: ...\n\n        def add_dll_directory(path: str) -> _AddedDllDirectory: ...\n    if sys.platform == \"linux\":\n        MFD_CLOEXEC: int\n        MFD_ALLOW_SEALING: int\n        MFD_HUGETLB: int\n        MFD_HUGE_SHIFT: int\n        MFD_HUGE_MASK: int\n        MFD_HUGE_64KB: int\n        MFD_HUGE_512KB: int\n        MFD_HUGE_1MB: int\n        MFD_HUGE_2MB: int\n        MFD_HUGE_8MB: int\n        MFD_HUGE_16MB: int\n        MFD_HUGE_32MB: int\n        MFD_HUGE_256MB: int\n        MFD_HUGE_512MB: int\n        MFD_HUGE_1GB: int\n        MFD_HUGE_2GB: int\n        MFD_HUGE_16GB: int\n        def memfd_create(name: str, flags: int = ...) -> int: ...\n        def copy_file_range(\n            src: int, dst: int, count: int, offset_src: int | None = ..., offset_dst: int | None = ...\n        ) -> int: ...\n\nif sys.version_info >= (3, 9):\n    def waitstatus_to_exitcode(status: int) -> int: ...\n\n    if sys.platform == \"linux\":\n        def pidfd_open(pid: int, flags: int = ...) -> int: ...\n",
  "/typeshed/stdlib/os/path.pyi": "import sys\n\nif sys.platform == \"win32\":\n    from ntpath import *\n    from ntpath import __all__ as __all__\nelse:\n    from posixpath import *\n    from posixpath import __all__ as __all__\n",
  "/typeshed/stdlib/pydoc_data/__init__.pyi": "",
  "/typeshed/stdlib/pydoc_data/topics.pyi": "topics: dict[str, str]\n",
  "/typeshed/stdlib/pyexpat/__init__.pyi": "from _typeshed import ReadableBuffer, SupportsRead\nfrom collections.abc import Callable\nfrom pyexpat import errors as errors, model as model\nfrom typing import Any\nfrom typing_extensions import TypeAlias, final\n\nEXPAT_VERSION: str  # undocumented\nversion_info: tuple[int, int, int]  # undocumented\nnative_encoding: str  # undocumented\nfeatures: list[tuple[str, int]]  # undocumented\n\nclass ExpatError(Exception):\n    code: int\n    lineno: int\n    offset: int\n\nerror = ExpatError\n\nXML_PARAM_ENTITY_PARSING_NEVER: int\nXML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE: int\nXML_PARAM_ENTITY_PARSING_ALWAYS: int\n\n_Model: TypeAlias = tuple[int, int, str | None, tuple[Any, ...]]\n\n@final\nclass XMLParserType:\n    def Parse(self, __data: str | ReadableBuffer, __isfinal: bool = False) -> int: ...\n    def ParseFile(self, __file: SupportsRead[bytes]) -> int: ...\n    def SetBase(self, __base: str) -> None: ...\n    def GetBase(self) -> str | None: ...\n    def GetInputContext(self) -> bytes | None: ...\n    def ExternalEntityParserCreate(self, __context: str | None, __encoding: str = ...) -> XMLParserType: ...\n    def SetParamEntityParsing(self, __flag: int) -> int: ...\n    def UseForeignDTD(self, __flag: bool = True) -> None: ...\n    @property\n    def intern(self) -> dict[str, str]: ...\n    buffer_size: int\n    buffer_text: bool\n    buffer_used: int\n    namespace_prefixes: bool  # undocumented\n    ordered_attributes: bool\n    specified_attributes: bool\n    ErrorByteIndex: int\n    ErrorCode: int\n    ErrorColumnNumber: int\n    ErrorLineNumber: int\n    CurrentByteIndex: int\n    CurrentColumnNumber: int\n    CurrentLineNumber: int\n    XmlDeclHandler: Callable[[str, str | None, int], Any] | None\n    StartDoctypeDeclHandler: Callable[[str, str | None, str | None, bool], Any] | None\n    EndDoctypeDeclHandler: Callable[[], Any] | None\n    ElementDeclHandler: Callable[[str, _Model], Any] | None\n    AttlistDeclHandler: Callable[[str, str, str, str | None, bool], Any] | None\n    StartElementHandler: Callable[[str, dict[str, str]], Any] | Callable[[str, list[str]], Any] | Callable[\n        [str, dict[str, str], list[str]], Any\n    ] | None\n    EndElementHandler: Callable[[str], Any] | None\n    ProcessingInstructionHandler: Callable[[str, str], Any] | None\n    CharacterDataHandler: Callable[[str], Any] | None\n    UnparsedEntityDeclHandler: Callable[[str, str | None, str, str | None, str], Any] | None\n    EntityDeclHandler: Callable[[str, bool, str | None, str | None, str, str | None, str | None], Any] | None\n    NotationDeclHandler: Callable[[str, str | None, str, str | None], Any] | None\n    StartNamespaceDeclHandler: Callable[[str, str], Any] | None\n    EndNamespaceDeclHandler: Callable[[str], Any] | None\n    CommentHandler: Callable[[str], Any] | None\n    StartCdataSectionHandler: Callable[[], Any] | None\n    EndCdataSectionHandler: Callable[[], Any] | None\n    DefaultHandler: Callable[[str], Any] | None\n    DefaultHandlerExpand: Callable[[str], Any] | None\n    NotStandaloneHandler: Callable[[], int] | None\n    ExternalEntityRefHandler: Callable[[str, str | None, str | None, str | None], int] | None\n    SkippedEntityHandler: Callable[[str, bool], Any] | None\n\ndef ErrorString(__code: int) -> str: ...\n\n# intern is undocumented\ndef ParserCreate(\n    encoding: str | None = None, namespace_separator: str | None = None, intern: dict[str, Any] | None = None\n) -> XMLParserType: ...\n",
  "/typeshed/stdlib/pyexpat/errors.pyi": "import sys\n\ncodes: dict[str, int]\nmessages: dict[int, str]\n\nXML_ERROR_ABORTED: str\nXML_ERROR_ASYNC_ENTITY: str\nXML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF: str\nXML_ERROR_BAD_CHAR_REF: str\nXML_ERROR_BINARY_ENTITY_REF: str\nXML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING: str\nXML_ERROR_DUPLICATE_ATTRIBUTE: str\nXML_ERROR_ENTITY_DECLARED_IN_PE: str\nXML_ERROR_EXTERNAL_ENTITY_HANDLING: str\nXML_ERROR_FEATURE_REQUIRES_XML_DTD: str\nXML_ERROR_FINISHED: str\nXML_ERROR_INCOMPLETE_PE: str\nXML_ERROR_INCORRECT_ENCODING: str\nXML_ERROR_INVALID_TOKEN: str\nXML_ERROR_JUNK_AFTER_DOC_ELEMENT: str\nXML_ERROR_MISPLACED_XML_PI: str\nXML_ERROR_NOT_STANDALONE: str\nXML_ERROR_NOT_SUSPENDED: str\nXML_ERROR_NO_ELEMENTS: str\nXML_ERROR_NO_MEMORY: str\nXML_ERROR_PARAM_ENTITY_REF: str\nXML_ERROR_PARTIAL_CHAR: str\nXML_ERROR_PUBLICID: str\nXML_ERROR_RECURSIVE_ENTITY_REF: str\nXML_ERROR_SUSPENDED: str\nXML_ERROR_SUSPEND_PE: str\nXML_ERROR_SYNTAX: str\nXML_ERROR_TAG_MISMATCH: str\nXML_ERROR_TEXT_DECL: str\nXML_ERROR_UNBOUND_PREFIX: str\nXML_ERROR_UNCLOSED_CDATA_SECTION: str\nXML_ERROR_UNCLOSED_TOKEN: str\nXML_ERROR_UNDECLARING_PREFIX: str\nXML_ERROR_UNDEFINED_ENTITY: str\nXML_ERROR_UNEXPECTED_STATE: str\nXML_ERROR_UNKNOWN_ENCODING: str\nXML_ERROR_XML_DECL: str\nif sys.version_info >= (3, 11):\n    XML_ERROR_RESERVED_PREFIX_XML: str\n    XML_ERROR_RESERVED_PREFIX_XMLNS: str\n    XML_ERROR_RESERVED_NAMESPACE_URI: str\n    XML_ERROR_INVALID_ARGUMENT: str\n    XML_ERROR_NO_BUFFER: str\n    XML_ERROR_AMPLIFICATION_LIMIT_BREACH: str\n",
  "/typeshed/stdlib/pyexpat/model.pyi": "XML_CTYPE_ANY: int\nXML_CTYPE_CHOICE: int\nXML_CTYPE_EMPTY: int\nXML_CTYPE_MIXED: int\nXML_CTYPE_NAME: int\nXML_CTYPE_SEQ: int\n\nXML_CQUANT_NONE: int\nXML_CQUANT_OPT: int\nXML_CQUANT_PLUS: int\nXML_CQUANT_REP: int\n",
  "/typeshed/stdlib/sqlite3/__init__.pyi": "from sqlite3.dbapi2 import *\n",
  "/typeshed/stdlib/sqlite3/dbapi2.pyi": "import sqlite3\nimport sys\nfrom _typeshed import Incomplete, ReadableBuffer, StrOrBytesPath, SupportsLenAndGetItem, Unused\nfrom collections.abc import Callable, Generator, Iterable, Iterator, Mapping\nfrom datetime import date, datetime, time\nfrom types import TracebackType\nfrom typing import Any, Protocol, TypeVar, overload\nfrom typing_extensions import Literal, Self, SupportsIndex, TypeAlias, final\n\n_T = TypeVar(\"_T\")\n_CursorT = TypeVar(\"_CursorT\", bound=Cursor)\n_SqliteData: TypeAlias = str | ReadableBuffer | int | float | None\n# Data that is passed through adapters can be of any type accepted by an adapter.\n_AdaptedInputData: TypeAlias = _SqliteData | Any\n# The Mapping must really be a dict, but making it invariant is too annoying.\n_Parameters: TypeAlias = SupportsLenAndGetItem[_AdaptedInputData] | Mapping[str, _AdaptedInputData]\n_Adapter: TypeAlias = Callable[[_T], _SqliteData]\n_Converter: TypeAlias = Callable[[bytes], Any]\n\nparamstyle: str\nthreadsafety: int\napilevel: str\nDate = date\nTime = time\nTimestamp = datetime\n\ndef DateFromTicks(ticks: float) -> Date: ...\ndef TimeFromTicks(ticks: float) -> Time: ...\ndef TimestampFromTicks(ticks: float) -> Timestamp: ...\n\nversion_info: tuple[int, int, int]\nsqlite_version_info: tuple[int, int, int]\nBinary = memoryview\n\n# The remaining definitions are imported from _sqlite3.\n\nPARSE_COLNAMES: int\nPARSE_DECLTYPES: int\nSQLITE_ALTER_TABLE: int\nSQLITE_ANALYZE: int\nSQLITE_ATTACH: int\nSQLITE_CREATE_INDEX: int\nSQLITE_CREATE_TABLE: int\nSQLITE_CREATE_TEMP_INDEX: int\nSQLITE_CREATE_TEMP_TABLE: int\nSQLITE_CREATE_TEMP_TRIGGER: int\nSQLITE_CREATE_TEMP_VIEW: int\nSQLITE_CREATE_TRIGGER: int\nSQLITE_CREATE_VIEW: int\nSQLITE_CREATE_VTABLE: int\nSQLITE_DELETE: int\nSQLITE_DENY: int\nSQLITE_DETACH: int\nSQLITE_DONE: int\nSQLITE_DROP_INDEX: int\nSQLITE_DROP_TABLE: int\nSQLITE_DROP_TEMP_INDEX: int\nSQLITE_DROP_TEMP_TABLE: int\nSQLITE_DROP_TEMP_TRIGGER: int\nSQLITE_DROP_TEMP_VIEW: int\nSQLITE_DROP_TRIGGER: int\nSQLITE_DROP_VIEW: int\nSQLITE_DROP_VTABLE: int\nSQLITE_FUNCTION: int\nSQLITE_IGNORE: int\nSQLITE_INSERT: int\nSQLITE_OK: int\nif sys.version_info >= (3, 11):\n    SQLITE_LIMIT_LENGTH: int\n    SQLITE_LIMIT_SQL_LENGTH: int\n    SQLITE_LIMIT_COLUMN: int\n    SQLITE_LIMIT_EXPR_DEPTH: int\n    SQLITE_LIMIT_COMPOUND_SELECT: int\n    SQLITE_LIMIT_VDBE_OP: int\n    SQLITE_LIMIT_FUNCTION_ARG: int\n    SQLITE_LIMIT_ATTACHED: int\n    SQLITE_LIMIT_LIKE_PATTERN_LENGTH: int\n    SQLITE_LIMIT_VARIABLE_NUMBER: int\n    SQLITE_LIMIT_TRIGGER_DEPTH: int\n    SQLITE_LIMIT_WORKER_THREADS: int\nSQLITE_PRAGMA: int\nSQLITE_READ: int\nSQLITE_REINDEX: int\nSQLITE_RECURSIVE: int\nSQLITE_SAVEPOINT: int\nSQLITE_SELECT: int\nSQLITE_TRANSACTION: int\nSQLITE_UPDATE: int\nadapters: dict[tuple[type[Any], type[Any]], _Adapter[Any]]\nconverters: dict[str, _Converter]\nsqlite_version: str\nversion: str\n\nif sys.version_info >= (3, 11):\n    SQLITE_ABORT: int\n    SQLITE_ABORT_ROLLBACK: int\n    SQLITE_AUTH: int\n    SQLITE_AUTH_USER: int\n    SQLITE_BUSY: int\n    SQLITE_BUSY_RECOVERY: int\n    SQLITE_BUSY_SNAPSHOT: int\n    SQLITE_BUSY_TIMEOUT: int\n    SQLITE_CANTOPEN: int\n    SQLITE_CANTOPEN_CONVPATH: int\n    SQLITE_CANTOPEN_DIRTYWAL: int\n    SQLITE_CANTOPEN_FULLPATH: int\n    SQLITE_CANTOPEN_ISDIR: int\n    SQLITE_CANTOPEN_NOTEMPDIR: int\n    SQLITE_CANTOPEN_SYMLINK: int\n    SQLITE_CONSTRAINT: int\n    SQLITE_CONSTRAINT_CHECK: int\n    SQLITE_CONSTRAINT_COMMITHOOK: int\n    SQLITE_CONSTRAINT_FOREIGNKEY: int\n    SQLITE_CONSTRAINT_FUNCTION: int\n    SQLITE_CONSTRAINT_NOTNULL: int\n    SQLITE_CONSTRAINT_PINNED: int\n    SQLITE_CONSTRAINT_PRIMARYKEY: int\n    SQLITE_CONSTRAINT_ROWID: int\n    SQLITE_CONSTRAINT_TRIGGER: int\n    SQLITE_CONSTRAINT_UNIQUE: int\n    SQLITE_CONSTRAINT_VTAB: int\n    SQLITE_CORRUPT: int\n    SQLITE_CORRUPT_INDEX: int\n    SQLITE_CORRUPT_SEQUENCE: int\n    SQLITE_CORRUPT_VTAB: int\n    SQLITE_EMPTY: int\n    SQLITE_ERROR: int\n    SQLITE_ERROR_MISSING_COLLSEQ: int\n    SQLITE_ERROR_RETRY: int\n    SQLITE_ERROR_SNAPSHOT: int\n    SQLITE_FORMAT: int\n    SQLITE_FULL: int\n    SQLITE_INTERNAL: int\n    SQLITE_INTERRUPT: int\n    SQLITE_IOERR: int\n    SQLITE_IOERR_ACCESS: int\n    SQLITE_IOERR_AUTH: int\n    SQLITE_IOERR_BEGIN_ATOMIC: int\n    SQLITE_IOERR_BLOCKED: int\n    SQLITE_IOERR_CHECKRESERVEDLOCK: int\n    SQLITE_IOERR_CLOSE: int\n    SQLITE_IOERR_COMMIT_ATOMIC: int\n    SQLITE_IOERR_CONVPATH: int\n    SQLITE_IOERR_CORRUPTFS: int\n    SQLITE_IOERR_DATA: int\n    SQLITE_IOERR_DELETE: int\n    SQLITE_IOERR_DELETE_NOENT: int\n    SQLITE_IOERR_DIR_CLOSE: int\n    SQLITE_IOERR_DIR_FSYNC: int\n    SQLITE_IOERR_FSTAT: int\n    SQLITE_IOERR_FSYNC: int\n    SQLITE_IOERR_GETTEMPPATH: int\n    SQLITE_IOERR_LOCK: int\n    SQLITE_IOERR_MMAP: int\n    SQLITE_IOERR_NOMEM: int\n    SQLITE_IOERR_RDLOCK: int\n    SQLITE_IOERR_READ: int\n    SQLITE_IOERR_ROLLBACK_ATOMIC: int\n    SQLITE_IOERR_SEEK: int\n    SQLITE_IOERR_SHMLOCK: int\n    SQLITE_IOERR_SHMMAP: int\n    SQLITE_IOERR_SHMOPEN: int\n    SQLITE_IOERR_SHMSIZE: int\n    SQLITE_IOERR_SHORT_READ: int\n    SQLITE_IOERR_TRUNCATE: int\n    SQLITE_IOERR_UNLOCK: int\n    SQLITE_IOERR_VNODE: int\n    SQLITE_IOERR_WRITE: int\n    SQLITE_LOCKED: int\n    SQLITE_LOCKED_SHAREDCACHE: int\n    SQLITE_LOCKED_VTAB: int\n    SQLITE_MISMATCH: int\n    SQLITE_MISUSE: int\n    SQLITE_NOLFS: int\n    SQLITE_NOMEM: int\n    SQLITE_NOTADB: int\n    SQLITE_NOTFOUND: int\n    SQLITE_NOTICE: int\n    SQLITE_NOTICE_RECOVER_ROLLBACK: int\n    SQLITE_NOTICE_RECOVER_WAL: int\n    SQLITE_OK_LOAD_PERMANENTLY: int\n    SQLITE_OK_SYMLINK: int\n    SQLITE_PERM: int\n    SQLITE_PROTOCOL: int\n    SQLITE_RANGE: int\n    SQLITE_READONLY: int\n    SQLITE_READONLY_CANTINIT: int\n    SQLITE_READONLY_CANTLOCK: int\n    SQLITE_READONLY_DBMOVED: int\n    SQLITE_READONLY_DIRECTORY: int\n    SQLITE_READONLY_RECOVERY: int\n    SQLITE_READONLY_ROLLBACK: int\n    SQLITE_ROW: int\n    SQLITE_SCHEMA: int\n    SQLITE_TOOBIG: int\n    SQLITE_WARNING: int\n    SQLITE_WARNING_AUTOINDEX: int\n\n# Can take or return anything depending on what's in the registry.\n@overload\ndef adapt(__obj: Any, __proto: Any) -> Any: ...\n@overload\ndef adapt(__obj: Any, __proto: Any, __alt: _T) -> Any | _T: ...\ndef complete_statement(statement: str) -> bool: ...\ndef connect(\n    database: StrOrBytesPath,\n    timeout: float = ...,\n    detect_types: int = ...,\n    isolation_level: str | None = ...,\n    check_same_thread: bool = ...,\n    factory: type[Connection] | None = ...,\n    cached_statements: int = ...,\n    uri: bool = ...,\n) -> Connection: ...\ndef enable_callback_tracebacks(__enable: bool) -> None: ...\n\n# takes a pos-or-keyword argument because there is a C wrapper\ndef enable_shared_cache(enable: int) -> None: ...\n\nif sys.version_info >= (3, 10):\n    def register_adapter(__type: type[_T], __adapter: _Adapter[_T]) -> None: ...\n    def register_converter(__typename: str, __converter: _Converter) -> None: ...\n\nelse:\n    def register_adapter(__type: type[_T], __caster: _Adapter[_T]) -> None: ...\n    def register_converter(__name: str, __converter: _Converter) -> None: ...\n\nif sys.version_info < (3, 8):\n    class Cache:\n        def __init__(self, *args: Incomplete, **kwargs: Unused) -> None: ...\n        def display(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...\n        def get(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...\n\nclass _AggregateProtocol(Protocol):\n    def step(self, __value: int) -> object: ...\n    def finalize(self) -> int: ...\n\nclass _SingleParamWindowAggregateClass(Protocol):\n    def step(self, __param: Any) -> object: ...\n    def inverse(self, __param: Any) -> object: ...\n    def value(self) -> _SqliteData: ...\n    def finalize(self) -> _SqliteData: ...\n\nclass _AnyParamWindowAggregateClass(Protocol):\n    def step(self, *args: Any) -> object: ...\n    def inverse(self, *args: Any) -> object: ...\n    def value(self) -> _SqliteData: ...\n    def finalize(self) -> _SqliteData: ...\n\nclass _WindowAggregateClass(Protocol):\n    step: Callable[..., object]\n    inverse: Callable[..., object]\n    def value(self) -> _SqliteData: ...\n    def finalize(self) -> _SqliteData: ...\n\nclass Connection:\n    @property\n    def DataError(self) -> type[sqlite3.DataError]: ...\n    @property\n    def DatabaseError(self) -> type[sqlite3.DatabaseError]: ...\n    @property\n    def Error(self) -> type[sqlite3.Error]: ...\n    @property\n    def IntegrityError(self) -> type[sqlite3.IntegrityError]: ...\n    @property\n    def InterfaceError(self) -> type[sqlite3.InterfaceError]: ...\n    @property\n    def InternalError(self) -> type[sqlite3.InternalError]: ...\n    @property\n    def NotSupportedError(self) -> type[sqlite3.NotSupportedError]: ...\n    @property\n    def OperationalError(self) -> type[sqlite3.OperationalError]: ...\n    @property\n    def ProgrammingError(self) -> type[sqlite3.ProgrammingError]: ...\n    @property\n    def Warning(self) -> type[sqlite3.Warning]: ...\n    @property\n    def in_transaction(self) -> bool: ...\n    isolation_level: str | None  # one of '', 'DEFERRED', 'IMMEDIATE' or 'EXCLUSIVE'\n    @property\n    def total_changes(self) -> int: ...\n    row_factory: Any\n    text_factory: Any\n    def __init__(\n        self,\n        database: StrOrBytesPath,\n        timeout: float = ...,\n        detect_types: int = ...,\n        isolation_level: str | None = ...,\n        check_same_thread: bool = ...,\n        factory: type[Connection] | None = ...,\n        cached_statements: int = ...,\n        uri: bool = ...,\n    ) -> None: ...\n    def close(self) -> None: ...\n    if sys.version_info >= (3, 11):\n        def blobopen(self, __table: str, __column: str, __row: int, *, readonly: bool = False, name: str = \"main\") -> Blob: ...\n\n    def commit(self) -> None: ...\n    def create_aggregate(self, name: str, n_arg: int, aggregate_class: Callable[[], _AggregateProtocol]) -> None: ...\n    if sys.version_info >= (3, 11):\n        # num_params determines how many params will be passed to the aggregate class. We provide an overload\n        # for the case where num_params = 1, which is expected to be the common case.\n        @overload\n        def create_window_function(\n            self, __name: str, __num_params: Literal[1], __aggregate_class: Callable[[], _SingleParamWindowAggregateClass] | None\n        ) -> None: ...\n        # And for num_params = -1, which means the aggregate must accept any number of parameters.\n        @overload\n        def create_window_function(\n            self, __name: str, __num_params: Literal[-1], __aggregate_class: Callable[[], _AnyParamWindowAggregateClass] | None\n        ) -> None: ...\n        @overload\n        def create_window_function(\n            self, __name: str, __num_params: int, __aggregate_class: Callable[[], _WindowAggregateClass] | None\n        ) -> None: ...\n\n    def create_collation(self, __name: str, __callback: Callable[[str, str], int | SupportsIndex] | None) -> None: ...\n    if sys.version_info >= (3, 8):\n        def create_function(\n            self, name: str, narg: int, func: Callable[..., _SqliteData] | None, *, deterministic: bool = False\n        ) -> None: ...\n    else:\n        def create_function(self, name: str, num_params: int, func: Callable[..., _SqliteData] | None) -> None: ...\n\n    @overload\n    def cursor(self, cursorClass: None = None) -> Cursor: ...\n    @overload\n    def cursor(self, cursorClass: Callable[[], _CursorT]) -> _CursorT: ...\n    def execute(self, sql: str, parameters: _Parameters = ...) -> Cursor: ...\n    def executemany(self, __sql: str, __parameters: Iterable[_Parameters]) -> Cursor: ...\n    def executescript(self, __sql_script: str) -> Cursor: ...\n    def interrupt(self) -> None: ...\n    def iterdump(self) -> Generator[str, None, None]: ...\n    def rollback(self) -> None: ...\n    def set_authorizer(\n        self, authorizer_callback: Callable[[int, str | None, str | None, str | None, str | None], int] | None\n    ) -> None: ...\n    def set_progress_handler(self, progress_handler: Callable[[], int | None] | None, n: int) -> None: ...\n    def set_trace_callback(self, trace_callback: Callable[[str], object] | None) -> None: ...\n    # enable_load_extension and load_extension is not available on python distributions compiled\n    # without sqlite3 loadable extension support. see footnotes https://docs.python.org/3/library/sqlite3.html#f1\n    def enable_load_extension(self, __enable: bool) -> None: ...\n    def load_extension(self, __name: str) -> None: ...\n    def backup(\n        self,\n        target: Connection,\n        *,\n        pages: int = -1,\n        progress: Callable[[int, int, int], object] | None = None,\n        name: str = \"main\",\n        sleep: float = 0.25,\n    ) -> None: ...\n    if sys.version_info >= (3, 11):\n        def setlimit(self, __category: int, __limit: int) -> int: ...\n        def getlimit(self, __category: int) -> int: ...\n        def serialize(self, *, name: str = \"main\") -> bytes: ...\n        def deserialize(self, __data: ReadableBuffer, *, name: str = \"main\") -> None: ...\n\n    def __call__(self, __sql: str) -> _Statement: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, __type: type[BaseException] | None, __value: BaseException | None, __traceback: TracebackType | None\n    ) -> Literal[False]: ...\n\nclass Cursor(Iterator[Any]):\n    arraysize: int\n    @property\n    def connection(self) -> Connection: ...\n    # May be None, but using | Any instead to avoid slightly annoying false positives.\n    @property\n    def description(self) -> tuple[tuple[str, None, None, None, None, None, None], ...] | Any: ...\n    @property\n    def lastrowid(self) -> int | None: ...\n    row_factory: Callable[[Cursor, Row], object] | None\n    @property\n    def rowcount(self) -> int: ...\n    def __init__(self, __cursor: Connection) -> None: ...\n    def close(self) -> None: ...\n    def execute(self, __sql: str, __parameters: _Parameters = ()) -> Self: ...\n    def executemany(self, __sql: str, __seq_of_parameters: Iterable[_Parameters]) -> Self: ...\n    def executescript(self, __sql_script: str) -> Cursor: ...\n    def fetchall(self) -> list[Any]: ...\n    def fetchmany(self, size: int | None = 1) -> list[Any]: ...\n    # Returns either a row (as created by the row_factory) or None, but\n    # putting None in the return annotation causes annoying false positives.\n    def fetchone(self) -> Any: ...\n    def setinputsizes(self, __sizes: Unused) -> None: ...  # does nothing\n    def setoutputsize(self, __size: Unused, __column: Unused = None) -> None: ...  # does nothing\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> Any: ...\n\nclass DataError(DatabaseError): ...\nclass DatabaseError(Error): ...\n\nclass Error(Exception):\n    if sys.version_info >= (3, 11):\n        sqlite_errorcode: int\n        sqlite_errorname: str\n\nclass IntegrityError(DatabaseError): ...\nclass InterfaceError(Error): ...\nclass InternalError(DatabaseError): ...\nclass NotSupportedError(DatabaseError): ...\nclass OperationalError(DatabaseError): ...\n\nif sys.version_info < (3, 10):\n    OptimizedUnicode = str\n\n@final\nclass PrepareProtocol:\n    def __init__(self, *args: object, **kwargs: object) -> None: ...\n\nclass ProgrammingError(DatabaseError): ...\n\nclass Row:\n    def __init__(self, __cursor: Cursor, __data: tuple[Any, ...]) -> None: ...\n    def keys(self) -> list[str]: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> Any: ...\n    @overload\n    def __getitem__(self, __key: slice) -> tuple[Any, ...]: ...\n    def __iter__(self) -> Iterator[Any]: ...\n    def __len__(self) -> int: ...\n    # These return NotImplemented for anything that is not a Row.\n    def __eq__(self, __value: object) -> bool: ...\n    def __ge__(self, __value: object) -> bool: ...\n    def __gt__(self, __value: object) -> bool: ...\n    def __le__(self, __value: object) -> bool: ...\n    def __lt__(self, __value: object) -> bool: ...\n    def __ne__(self, __value: object) -> bool: ...\n\nif sys.version_info >= (3, 8):\n    @final\n    class _Statement: ...\n\nelse:\n    @final\n    class Statement:\n        def __init__(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...\n    _Statement: TypeAlias = Statement\n\nclass Warning(Exception): ...\n\nif sys.version_info >= (3, 11):\n    @final\n    class Blob:\n        def close(self) -> None: ...\n        def read(self, __length: int = -1) -> bytes: ...\n        def write(self, __data: ReadableBuffer) -> None: ...\n        def tell(self) -> int: ...\n        # whence must be one of os.SEEK_SET, os.SEEK_CUR, os.SEEK_END\n        def seek(self, __offset: int, __origin: int = 0) -> None: ...\n        def __len__(self) -> int: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(self, __type: object, __val: object, __tb: object) -> Literal[False]: ...\n        def __getitem__(self, __key: SupportsIndex | slice) -> int: ...\n        def __setitem__(self, __key: SupportsIndex | slice, __value: int) -> None: ...\n",
  "/typeshed/stdlib/urllib/__init__.pyi": "",
  "/typeshed/stdlib/urllib/error.pyi": "from email.message import Message\nfrom typing import IO\nfrom urllib.response import addinfourl\n\n__all__ = [\"URLError\", \"HTTPError\", \"ContentTooShortError\"]\n\nclass URLError(OSError):\n    reason: str | BaseException\n    def __init__(self, reason: str | BaseException, filename: str | None = None) -> None: ...\n\nclass HTTPError(URLError, addinfourl):\n    @property\n    def headers(self) -> Message: ...\n    @headers.setter\n    def headers(self, headers: Message) -> None: ...\n    @property\n    def reason(self) -> str: ...  # type: ignore[override]\n    code: int\n    def __init__(self, url: str, code: int, msg: str, hdrs: Message, fp: IO[bytes] | None) -> None: ...\n\nclass ContentTooShortError(URLError):\n    content: tuple[str, Message]\n    def __init__(self, message: str, content: tuple[str, Message]) -> None: ...\n",
  "/typeshed/stdlib/urllib/parse.pyi": "import sys\nfrom collections.abc import Callable, Iterable, Mapping, Sequence\nfrom typing import Any, AnyStr, Generic, NamedTuple, TypeVar, overload\nfrom typing_extensions import Literal, TypeAlias\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n__all__ = [\n    \"urlparse\",\n    \"urlunparse\",\n    \"urljoin\",\n    \"urldefrag\",\n    \"urlsplit\",\n    \"urlunsplit\",\n    \"urlencode\",\n    \"parse_qs\",\n    \"parse_qsl\",\n    \"quote\",\n    \"quote_plus\",\n    \"quote_from_bytes\",\n    \"unquote\",\n    \"unquote_plus\",\n    \"unquote_to_bytes\",\n    \"DefragResult\",\n    \"ParseResult\",\n    \"SplitResult\",\n    \"DefragResultBytes\",\n    \"ParseResultBytes\",\n    \"SplitResultBytes\",\n]\n\nuses_relative: list[str]\nuses_netloc: list[str]\nuses_params: list[str]\nnon_hierarchical: list[str]\nuses_query: list[str]\nuses_fragment: list[str]\nscheme_chars: str\nif sys.version_info < (3, 11):\n    MAX_CACHE_SIZE: int\n\nclass _ResultMixinStr:\n    def encode(self, encoding: str = \"ascii\", errors: str = \"strict\") -> _ResultMixinBytes: ...\n\nclass _ResultMixinBytes:\n    def decode(self, encoding: str = \"ascii\", errors: str = \"strict\") -> _ResultMixinStr: ...\n\nclass _NetlocResultMixinBase(Generic[AnyStr]):\n    @property\n    def username(self) -> AnyStr | None: ...\n    @property\n    def password(self) -> AnyStr | None: ...\n    @property\n    def hostname(self) -> AnyStr | None: ...\n    @property\n    def port(self) -> int | None: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass _NetlocResultMixinStr(_NetlocResultMixinBase[str], _ResultMixinStr): ...\nclass _NetlocResultMixinBytes(_NetlocResultMixinBase[bytes], _ResultMixinBytes): ...\n\nclass _DefragResultBase(NamedTuple, Generic[AnyStr]):\n    url: AnyStr\n    fragment: AnyStr\n\nclass _SplitResultBase(NamedTuple, Generic[AnyStr]):\n    scheme: AnyStr\n    netloc: AnyStr\n    path: AnyStr\n    query: AnyStr\n    fragment: AnyStr\n\nclass _ParseResultBase(NamedTuple, Generic[AnyStr]):\n    scheme: AnyStr\n    netloc: AnyStr\n    path: AnyStr\n    params: AnyStr\n    query: AnyStr\n    fragment: AnyStr\n\n# Structured result objects for string data\nclass DefragResult(_DefragResultBase[str], _ResultMixinStr):\n    def geturl(self) -> str: ...\n\nclass SplitResult(_SplitResultBase[str], _NetlocResultMixinStr):\n    def geturl(self) -> str: ...\n\nclass ParseResult(_ParseResultBase[str], _NetlocResultMixinStr):\n    def geturl(self) -> str: ...\n\n# Structured result objects for bytes data\nclass DefragResultBytes(_DefragResultBase[bytes], _ResultMixinBytes):\n    def geturl(self) -> bytes: ...\n\nclass SplitResultBytes(_SplitResultBase[bytes], _NetlocResultMixinBytes):\n    def geturl(self) -> bytes: ...\n\nclass ParseResultBytes(_ParseResultBase[bytes], _NetlocResultMixinBytes):\n    def geturl(self) -> bytes: ...\n\ndef parse_qs(\n    qs: AnyStr | None,\n    keep_blank_values: bool = False,\n    strict_parsing: bool = False,\n    encoding: str = \"utf-8\",\n    errors: str = \"replace\",\n    max_num_fields: int | None = None,\n    separator: str = \"&\",\n) -> dict[AnyStr, list[AnyStr]]: ...\ndef parse_qsl(\n    qs: AnyStr | None,\n    keep_blank_values: bool = False,\n    strict_parsing: bool = False,\n    encoding: str = \"utf-8\",\n    errors: str = \"replace\",\n    max_num_fields: int | None = None,\n    separator: str = \"&\",\n) -> list[tuple[AnyStr, AnyStr]]: ...\n@overload\ndef quote(string: str, safe: str | Iterable[int] = \"/\", encoding: str | None = None, errors: str | None = None) -> str: ...\n@overload\ndef quote(string: bytes | bytearray, safe: str | Iterable[int] = \"/\") -> str: ...\ndef quote_from_bytes(bs: bytes | bytearray, safe: str | Iterable[int] = \"/\") -> str: ...\n@overload\ndef quote_plus(string: str, safe: str | Iterable[int] = \"\", encoding: str | None = None, errors: str | None = None) -> str: ...\n@overload\ndef quote_plus(string: bytes | bytearray, safe: str | Iterable[int] = \"\") -> str: ...\n\nif sys.version_info >= (3, 9):\n    def unquote(string: str | bytes, encoding: str = \"utf-8\", errors: str = \"replace\") -> str: ...\n\nelse:\n    def unquote(string: str, encoding: str = \"utf-8\", errors: str = \"replace\") -> str: ...\n\ndef unquote_to_bytes(string: str | bytes | bytearray) -> bytes: ...\ndef unquote_plus(string: str, encoding: str = \"utf-8\", errors: str = \"replace\") -> str: ...\n@overload\ndef urldefrag(url: str) -> DefragResult: ...\n@overload\ndef urldefrag(url: bytes | bytearray | None) -> DefragResultBytes: ...\n\n_Q = TypeVar(\"_Q\", bound=str | Iterable[int])\n_QueryType: TypeAlias = (\n    Mapping[Any, Any] | Mapping[Any, Sequence[Any]] | Sequence[tuple[Any, Any]] | Sequence[tuple[Any, Sequence[Any]]]\n)\n\n@overload\ndef urlencode(\n    query: _QueryType,\n    doseq: bool = False,\n    safe: str = \"\",\n    encoding: str | None = None,\n    errors: str | None = None,\n    quote_via: Callable[[AnyStr, str, str, str], str] = ...,\n) -> str: ...\n@overload\ndef urlencode(\n    query: _QueryType,\n    doseq: bool,\n    safe: _Q,\n    encoding: str | None = None,\n    errors: str | None = None,\n    quote_via: Callable[[AnyStr, _Q, str, str], str] = ...,\n) -> str: ...\n@overload\ndef urlencode(\n    query: _QueryType,\n    doseq: bool = False,\n    *,\n    safe: _Q,\n    encoding: str | None = None,\n    errors: str | None = None,\n    quote_via: Callable[[AnyStr, _Q, str, str], str] = ...,\n) -> str: ...\ndef urljoin(base: AnyStr, url: AnyStr | None, allow_fragments: bool = True) -> AnyStr: ...\n@overload\ndef urlparse(url: str, scheme: str = \"\", allow_fragments: bool = True) -> ParseResult: ...\n@overload\ndef urlparse(\n    url: bytes | bytearray | None, scheme: bytes | bytearray | None | Literal[\"\"] = \"\", allow_fragments: bool = True\n) -> ParseResultBytes: ...\n@overload\ndef urlsplit(url: str, scheme: str = \"\", allow_fragments: bool = True) -> SplitResult: ...\n\nif sys.version_info >= (3, 11):\n    @overload\n    def urlsplit(\n        url: bytes | None, scheme: bytes | None | Literal[\"\"] = \"\", allow_fragments: bool = True\n    ) -> SplitResultBytes: ...\n\nelse:\n    @overload\n    def urlsplit(\n        url: bytes | bytearray | None, scheme: bytes | bytearray | None | Literal[\"\"] = \"\", allow_fragments: bool = True\n    ) -> SplitResultBytes: ...\n\n# Requires an iterable of length 6\n@overload\ndef urlunparse(components: Iterable[None]) -> Literal[b\"\"]: ...\n@overload\ndef urlunparse(components: Iterable[AnyStr | None]) -> AnyStr: ...\n\n# Requires an iterable of length 5\n@overload\ndef urlunsplit(components: Iterable[None]) -> Literal[b\"\"]: ...\n@overload\ndef urlunsplit(components: Iterable[AnyStr | None]) -> AnyStr: ...\ndef unwrap(url: str) -> str: ...\n",
  "/typeshed/stdlib/urllib/request.pyi": "import ssl\nimport sys\nfrom _typeshed import ReadableBuffer, StrOrBytesPath, SupportsRead\nfrom collections.abc import Callable, Iterable, Mapping, MutableMapping, Sequence\nfrom email.message import Message\nfrom http.client import HTTPConnection, HTTPMessage, HTTPResponse\nfrom http.cookiejar import CookieJar\nfrom re import Pattern\nfrom typing import IO, Any, ClassVar, NoReturn, Protocol, TypeVar, overload\nfrom typing_extensions import TypeAlias\nfrom urllib.error import HTTPError as HTTPError\nfrom urllib.response import addclosehook, addinfourl\n\n__all__ = [\n    \"Request\",\n    \"OpenerDirector\",\n    \"BaseHandler\",\n    \"HTTPDefaultErrorHandler\",\n    \"HTTPRedirectHandler\",\n    \"HTTPCookieProcessor\",\n    \"ProxyHandler\",\n    \"HTTPPasswordMgr\",\n    \"HTTPPasswordMgrWithDefaultRealm\",\n    \"HTTPPasswordMgrWithPriorAuth\",\n    \"AbstractBasicAuthHandler\",\n    \"HTTPBasicAuthHandler\",\n    \"ProxyBasicAuthHandler\",\n    \"AbstractDigestAuthHandler\",\n    \"HTTPDigestAuthHandler\",\n    \"ProxyDigestAuthHandler\",\n    \"HTTPHandler\",\n    \"FileHandler\",\n    \"FTPHandler\",\n    \"CacheFTPHandler\",\n    \"DataHandler\",\n    \"UnknownHandler\",\n    \"HTTPErrorProcessor\",\n    \"urlopen\",\n    \"install_opener\",\n    \"build_opener\",\n    \"pathname2url\",\n    \"url2pathname\",\n    \"getproxies\",\n    \"urlretrieve\",\n    \"urlcleanup\",\n    \"URLopener\",\n    \"FancyURLopener\",\n    \"HTTPSHandler\",\n]\n\n_T = TypeVar(\"_T\")\n_UrlopenRet: TypeAlias = Any\n_DataType: TypeAlias = ReadableBuffer | SupportsRead[bytes] | Iterable[bytes] | None\n\ndef urlopen(\n    url: str | Request,\n    data: _DataType | None = None,\n    timeout: float | None = ...,\n    *,\n    cafile: str | None = None,\n    capath: str | None = None,\n    cadefault: bool = False,\n    context: ssl.SSLContext | None = None,\n) -> _UrlopenRet: ...\ndef install_opener(opener: OpenerDirector) -> None: ...\ndef build_opener(*handlers: BaseHandler | Callable[[], BaseHandler]) -> OpenerDirector: ...\n\nif sys.platform == \"win32\":\n    from nturl2path import pathname2url as pathname2url, url2pathname as url2pathname\nelse:\n    def url2pathname(pathname: str) -> str: ...\n    def pathname2url(pathname: str) -> str: ...\n\ndef getproxies() -> dict[str, str]: ...\ndef parse_http_list(s: str) -> list[str]: ...\ndef parse_keqv_list(l: list[str]) -> dict[str, str]: ...\n\nif sys.platform == \"win32\" or sys.platform == \"darwin\":\n    def proxy_bypass(host: str) -> Any: ...  # undocumented\n\nelse:\n    def proxy_bypass(host: str, proxies: Mapping[str, str] | None = None) -> Any: ...  # undocumented\n\nclass Request:\n    @property\n    def full_url(self) -> str: ...\n    @full_url.setter\n    def full_url(self, value: str) -> None: ...\n    @full_url.deleter\n    def full_url(self) -> None: ...\n    type: str\n    host: str\n    origin_req_host: str\n    selector: str\n    data: _DataType\n    headers: MutableMapping[str, str]\n    unredirected_hdrs: dict[str, str]\n    unverifiable: bool\n    method: str | None\n    timeout: float | None  # Undocumented, only set after __init__() by OpenerDirector.open()\n    def __init__(\n        self,\n        url: str,\n        data: _DataType = None,\n        headers: MutableMapping[str, str] = {},\n        origin_req_host: str | None = None,\n        unverifiable: bool = False,\n        method: str | None = None,\n    ) -> None: ...\n    def get_method(self) -> str: ...\n    def add_header(self, key: str, val: str) -> None: ...\n    def add_unredirected_header(self, key: str, val: str) -> None: ...\n    def has_header(self, header_name: str) -> bool: ...\n    def remove_header(self, header_name: str) -> None: ...\n    def get_full_url(self) -> str: ...\n    def set_proxy(self, host: str, type: str) -> None: ...\n    @overload\n    def get_header(self, header_name: str) -> str | None: ...\n    @overload\n    def get_header(self, header_name: str, default: _T) -> str | _T: ...\n    def header_items(self) -> list[tuple[str, str]]: ...\n    def has_proxy(self) -> bool: ...\n\nclass OpenerDirector:\n    addheaders: list[tuple[str, str]]\n    def add_handler(self, handler: BaseHandler) -> None: ...\n    def open(self, fullurl: str | Request, data: _DataType = None, timeout: float | None = ...) -> _UrlopenRet: ...\n    def error(self, proto: str, *args: Any) -> _UrlopenRet: ...\n    def close(self) -> None: ...\n\nclass BaseHandler:\n    handler_order: ClassVar[int]\n    parent: OpenerDirector\n    def add_parent(self, parent: OpenerDirector) -> None: ...\n    def close(self) -> None: ...\n    def __lt__(self, other: object) -> bool: ...\n\nclass HTTPDefaultErrorHandler(BaseHandler):\n    def http_error_default(\n        self, req: Request, fp: IO[bytes], code: int, msg: str, hdrs: HTTPMessage\n    ) -> HTTPError: ...  # undocumented\n\nclass HTTPRedirectHandler(BaseHandler):\n    max_redirections: ClassVar[int]  # undocumented\n    max_repeats: ClassVar[int]  # undocumented\n    inf_msg: ClassVar[str]  # undocumented\n    def redirect_request(\n        self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage, newurl: str\n    ) -> Request | None: ...\n    def http_error_301(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n    def http_error_302(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n    def http_error_303(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n    def http_error_307(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n    if sys.version_info >= (3, 11):\n        def http_error_308(\n            self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage\n        ) -> _UrlopenRet | None: ...\n\nclass HTTPCookieProcessor(BaseHandler):\n    cookiejar: CookieJar\n    def __init__(self, cookiejar: CookieJar | None = None) -> None: ...\n    def http_request(self, request: Request) -> Request: ...  # undocumented\n    def http_response(self, request: Request, response: HTTPResponse) -> HTTPResponse: ...  # undocumented\n    def https_request(self, request: Request) -> Request: ...  # undocumented\n    def https_response(self, request: Request, response: HTTPResponse) -> HTTPResponse: ...  # undocumented\n\nclass ProxyHandler(BaseHandler):\n    def __init__(self, proxies: dict[str, str] | None = None) -> None: ...\n    def proxy_open(self, req: Request, proxy: str, type: str) -> _UrlopenRet | None: ...  # undocumented\n    # TODO add a method for every (common) proxy protocol\n\nclass HTTPPasswordMgr:\n    def add_password(self, realm: str, uri: str | Sequence[str], user: str, passwd: str) -> None: ...\n    def find_user_password(self, realm: str, authuri: str) -> tuple[str | None, str | None]: ...\n    def is_suburi(self, base: str, test: str) -> bool: ...  # undocumented\n    def reduce_uri(self, uri: str, default_port: bool = True) -> str: ...  # undocumented\n\nclass HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):\n    def add_password(self, realm: str | None, uri: str | Sequence[str], user: str, passwd: str) -> None: ...\n    def find_user_password(self, realm: str | None, authuri: str) -> tuple[str | None, str | None]: ...\n\nclass HTTPPasswordMgrWithPriorAuth(HTTPPasswordMgrWithDefaultRealm):\n    def add_password(\n        self, realm: str | None, uri: str | Sequence[str], user: str, passwd: str, is_authenticated: bool = False\n    ) -> None: ...\n    def update_authenticated(self, uri: str | Sequence[str], is_authenticated: bool = False) -> None: ...\n    def is_authenticated(self, authuri: str) -> bool: ...\n\nclass AbstractBasicAuthHandler:\n    rx: ClassVar[Pattern[str]]  # undocumented\n    passwd: HTTPPasswordMgr\n    add_password: Callable[[str, str | Sequence[str], str, str], None]\n    def __init__(self, password_mgr: HTTPPasswordMgr | None = None) -> None: ...\n    def http_error_auth_reqed(self, authreq: str, host: str, req: Request, headers: HTTPMessage) -> None: ...\n    def http_request(self, req: Request) -> Request: ...  # undocumented\n    def http_response(self, req: Request, response: HTTPResponse) -> HTTPResponse: ...  # undocumented\n    def https_request(self, req: Request) -> Request: ...  # undocumented\n    def https_response(self, req: Request, response: HTTPResponse) -> HTTPResponse: ...  # undocumented\n    def retry_http_basic_auth(self, host: str, req: Request, realm: str) -> _UrlopenRet | None: ...  # undocumented\n\nclass HTTPBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):\n    auth_header: ClassVar[str]  # undocumented\n    def http_error_401(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n\nclass ProxyBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):\n    auth_header: ClassVar[str]\n    def http_error_407(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n\nclass AbstractDigestAuthHandler:\n    def __init__(self, passwd: HTTPPasswordMgr | None = None) -> None: ...\n    def reset_retry_count(self) -> None: ...\n    def http_error_auth_reqed(self, auth_header: str, host: str, req: Request, headers: HTTPMessage) -> None: ...\n    def retry_http_digest_auth(self, req: Request, auth: str) -> _UrlopenRet | None: ...\n    def get_cnonce(self, nonce: str) -> str: ...\n    def get_authorization(self, req: Request, chal: Mapping[str, str]) -> str: ...\n    def get_algorithm_impls(self, algorithm: str) -> tuple[Callable[[str], str], Callable[[str, str], str]]: ...\n    def get_entity_digest(self, data: ReadableBuffer | None, chal: Mapping[str, str]) -> str | None: ...\n\nclass HTTPDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):\n    auth_header: ClassVar[str]  # undocumented\n    def http_error_401(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n\nclass ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):\n    auth_header: ClassVar[str]  # undocumented\n    def http_error_407(self, req: Request, fp: IO[bytes], code: int, msg: str, headers: HTTPMessage) -> _UrlopenRet | None: ...\n\nclass _HTTPConnectionProtocol(Protocol):\n    def __call__(\n        self,\n        host: str,\n        port: int | None = ...,\n        timeout: float = ...,\n        source_address: tuple[str, int] | None = ...,\n        blocksize: int = ...,\n    ) -> HTTPConnection: ...\n\nclass AbstractHTTPHandler(BaseHandler):  # undocumented\n    def __init__(self, debuglevel: int = 0) -> None: ...\n    def set_http_debuglevel(self, level: int) -> None: ...\n    def do_request_(self, request: Request) -> Request: ...\n    def do_open(self, http_class: _HTTPConnectionProtocol, req: Request, **http_conn_args: Any) -> HTTPResponse: ...\n\nclass HTTPHandler(AbstractHTTPHandler):\n    def http_open(self, req: Request) -> HTTPResponse: ...\n    def http_request(self, request: Request) -> Request: ...  # undocumented\n\nclass HTTPSHandler(AbstractHTTPHandler):\n    def __init__(\n        self, debuglevel: int = 0, context: ssl.SSLContext | None = None, check_hostname: bool | None = None\n    ) -> None: ...\n    def https_open(self, req: Request) -> HTTPResponse: ...\n    def https_request(self, request: Request) -> Request: ...  # undocumented\n\nclass FileHandler(BaseHandler):\n    names: ClassVar[tuple[str, ...] | None]  # undocumented\n    def file_open(self, req: Request) -> addinfourl: ...\n    def get_names(self) -> tuple[str, ...]: ...  # undocumented\n    def open_local_file(self, req: Request) -> addinfourl: ...  # undocumented\n\nclass DataHandler(BaseHandler):\n    def data_open(self, req: Request) -> addinfourl: ...\n\nclass ftpwrapper:  # undocumented\n    def __init__(\n        self, user: str, passwd: str, host: str, port: int, dirs: str, timeout: float | None = None, persistent: bool = True\n    ) -> None: ...\n    def close(self) -> None: ...\n    def endtransfer(self) -> None: ...\n    def file_close(self) -> None: ...\n    def init(self) -> None: ...\n    def real_close(self) -> None: ...\n    def retrfile(self, file: str, type: str) -> tuple[addclosehook, int]: ...\n\nclass FTPHandler(BaseHandler):\n    def ftp_open(self, req: Request) -> addinfourl: ...\n    def connect_ftp(\n        self, user: str, passwd: str, host: str, port: int, dirs: str, timeout: float\n    ) -> ftpwrapper: ...  # undocumented\n\nclass CacheFTPHandler(FTPHandler):\n    def setTimeout(self, t: float) -> None: ...\n    def setMaxConns(self, m: int) -> None: ...\n    def check_cache(self) -> None: ...  # undocumented\n    def clear_cache(self) -> None: ...  # undocumented\n\nclass UnknownHandler(BaseHandler):\n    def unknown_open(self, req: Request) -> NoReturn: ...\n\nclass HTTPErrorProcessor(BaseHandler):\n    def http_response(self, request: Request, response: HTTPResponse) -> _UrlopenRet: ...\n    def https_response(self, request: Request, response: HTTPResponse) -> _UrlopenRet: ...\n\ndef urlretrieve(\n    url: str,\n    filename: StrOrBytesPath | None = None,\n    reporthook: Callable[[int, int, int], object] | None = None,\n    data: _DataType = None,\n) -> tuple[str, HTTPMessage]: ...\ndef urlcleanup() -> None: ...\n\nclass URLopener:\n    version: ClassVar[str]\n    def __init__(self, proxies: dict[str, str] | None = None, **x509: str) -> None: ...\n    def open(self, fullurl: str, data: ReadableBuffer | None = None) -> _UrlopenRet: ...\n    def open_unknown(self, fullurl: str, data: ReadableBuffer | None = None) -> _UrlopenRet: ...\n    def retrieve(\n        self,\n        url: str,\n        filename: str | None = None,\n        reporthook: Callable[[int, int, int], object] | None = None,\n        data: ReadableBuffer | None = None,\n    ) -> tuple[str, Message | None]: ...\n    def addheader(self, *args: tuple[str, str]) -> None: ...  # undocumented\n    def cleanup(self) -> None: ...  # undocumented\n    def close(self) -> None: ...  # undocumented\n    def http_error(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: bytes | None = None\n    ) -> _UrlopenRet: ...  # undocumented\n    def http_error_default(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage\n    ) -> _UrlopenRet: ...  # undocumented\n    def open_data(self, url: str, data: ReadableBuffer | None = None) -> addinfourl: ...  # undocumented\n    def open_file(self, url: str) -> addinfourl: ...  # undocumented\n    def open_ftp(self, url: str) -> addinfourl: ...  # undocumented\n    def open_http(self, url: str, data: ReadableBuffer | None = None) -> _UrlopenRet: ...  # undocumented\n    def open_https(self, url: str, data: ReadableBuffer | None = None) -> _UrlopenRet: ...  # undocumented\n    def open_local_file(self, url: str) -> addinfourl: ...  # undocumented\n    def open_unknown_proxy(self, proxy: str, fullurl: str, data: ReadableBuffer | None = None) -> None: ...  # undocumented\n\nclass FancyURLopener(URLopener):\n    def prompt_user_passwd(self, host: str, realm: str) -> tuple[str, str]: ...\n    def get_user_passwd(self, host: str, realm: str, clear_cache: int = 0) -> tuple[str, str]: ...  # undocumented\n    def http_error_301(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | addinfourl | None: ...  # undocumented\n    def http_error_302(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | addinfourl | None: ...  # undocumented\n    def http_error_303(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | addinfourl | None: ...  # undocumented\n    def http_error_307(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | addinfourl | None: ...  # undocumented\n    if sys.version_info >= (3, 11):\n        def http_error_308(\n            self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None = None\n        ) -> _UrlopenRet | addinfourl | None: ...  # undocumented\n\n    def http_error_401(\n        self,\n        url: str,\n        fp: IO[bytes],\n        errcode: int,\n        errmsg: str,\n        headers: HTTPMessage,\n        data: ReadableBuffer | None = None,\n        retry: bool = False,\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def http_error_407(\n        self,\n        url: str,\n        fp: IO[bytes],\n        errcode: int,\n        errmsg: str,\n        headers: HTTPMessage,\n        data: ReadableBuffer | None = None,\n        retry: bool = False,\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def http_error_default(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage\n    ) -> addinfourl: ...  # undocumented\n    def redirect_internal(\n        self, url: str, fp: IO[bytes], errcode: int, errmsg: str, headers: HTTPMessage, data: ReadableBuffer | None\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def retry_http_basic_auth(\n        self, url: str, realm: str, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def retry_https_basic_auth(\n        self, url: str, realm: str, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def retry_proxy_http_basic_auth(\n        self, url: str, realm: str, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | None: ...  # undocumented\n    def retry_proxy_https_basic_auth(\n        self, url: str, realm: str, data: ReadableBuffer | None = None\n    ) -> _UrlopenRet | None: ...  # undocumented\n",
  "/typeshed/stdlib/urllib/response.pyi": "import sys\nfrom _typeshed import ReadableBuffer\nfrom collections.abc import Callable, Iterable\nfrom email.message import Message\nfrom types import TracebackType\nfrom typing import IO, Any, BinaryIO\nfrom typing_extensions import Self\n\n__all__ = [\"addbase\", \"addclosehook\", \"addinfo\", \"addinfourl\"]\n\nclass addbase(BinaryIO):\n    fp: IO[bytes]\n    def __init__(self, fp: IO[bytes]) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> bytes: ...\n    def close(self) -> None: ...\n    # These methods don't actually exist, but the class inherits at runtime from\n    # tempfile._TemporaryFileWrapper, which uses __getattr__ to delegate to the\n    # underlying file object. To satisfy the BinaryIO interface, we pretend that this\n    # class has these additional methods.\n    def fileno(self) -> int: ...\n    def flush(self) -> None: ...\n    def isatty(self) -> bool: ...\n    def read(self, n: int = ...) -> bytes: ...\n    def readable(self) -> bool: ...\n    def readline(self, limit: int = ...) -> bytes: ...\n    def readlines(self, hint: int = ...) -> list[bytes]: ...\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    def seekable(self) -> bool: ...\n    def tell(self) -> int: ...\n    def truncate(self, size: int | None = ...) -> int: ...\n    def writable(self) -> bool: ...\n    def write(self, s: ReadableBuffer) -> int: ...\n    def writelines(self, lines: Iterable[ReadableBuffer]) -> None: ...\n\nclass addclosehook(addbase):\n    closehook: Callable[..., object]\n    hookargs: tuple[Any, ...]\n    def __init__(self, fp: IO[bytes], closehook: Callable[..., object], *hookargs: Any) -> None: ...\n\nclass addinfo(addbase):\n    headers: Message\n    def __init__(self, fp: IO[bytes], headers: Message) -> None: ...\n    def info(self) -> Message: ...\n\nclass addinfourl(addinfo):\n    url: str\n    code: int | None\n    if sys.version_info >= (3, 9):\n        @property\n        def status(self) -> int | None: ...\n\n    def __init__(self, fp: IO[bytes], headers: Message, url: str, code: int | None = None) -> None: ...\n    def geturl(self) -> str: ...\n    def getcode(self) -> int | None: ...\n",
  "/typeshed/stdlib/urllib/robotparser.pyi": "import sys\nfrom collections.abc import Iterable\nfrom typing import NamedTuple\n\n__all__ = [\"RobotFileParser\"]\n\nclass RequestRate(NamedTuple):\n    requests: int\n    seconds: int\n\nclass RobotFileParser:\n    def __init__(self, url: str = \"\") -> None: ...\n    def set_url(self, url: str) -> None: ...\n    def read(self) -> None: ...\n    def parse(self, lines: Iterable[str]) -> None: ...\n    def can_fetch(self, useragent: str, url: str) -> bool: ...\n    def mtime(self) -> int: ...\n    def modified(self) -> None: ...\n    def crawl_delay(self, useragent: str) -> str | None: ...\n    def request_rate(self, useragent: str) -> RequestRate | None: ...\n    if sys.version_info >= (3, 8):\n        def site_maps(self) -> list[str] | None: ...\n",
  "/typeshed/stdlib/venv/__init__.pyi": "import logging\nimport sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Sequence\nfrom types import SimpleNamespace\n\nlogger: logging.Logger\n\nif sys.version_info >= (3, 9):\n    CORE_VENV_DEPS: tuple[str, ...]\n\nclass EnvBuilder:\n    system_site_packages: bool\n    clear: bool\n    symlinks: bool\n    upgrade: bool\n    with_pip: bool\n    prompt: str | None\n\n    if sys.version_info >= (3, 9):\n        def __init__(\n            self,\n            system_site_packages: bool = False,\n            clear: bool = False,\n            symlinks: bool = False,\n            upgrade: bool = False,\n            with_pip: bool = False,\n            prompt: str | None = None,\n            upgrade_deps: bool = False,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            system_site_packages: bool = False,\n            clear: bool = False,\n            symlinks: bool = False,\n            upgrade: bool = False,\n            with_pip: bool = False,\n            prompt: str | None = None,\n        ) -> None: ...\n\n    def create(self, env_dir: StrOrBytesPath) -> None: ...\n    def clear_directory(self, path: StrOrBytesPath) -> None: ...  # undocumented\n    def ensure_directories(self, env_dir: StrOrBytesPath) -> SimpleNamespace: ...\n    def create_configuration(self, context: SimpleNamespace) -> None: ...\n    def symlink_or_copy(\n        self, src: StrOrBytesPath, dst: StrOrBytesPath, relative_symlinks_ok: bool = False\n    ) -> None: ...  # undocumented\n    def setup_python(self, context: SimpleNamespace) -> None: ...\n    def _setup_pip(self, context: SimpleNamespace) -> None: ...  # undocumented\n    def setup_scripts(self, context: SimpleNamespace) -> None: ...\n    def post_setup(self, context: SimpleNamespace) -> None: ...\n    def replace_variables(self, text: str, context: SimpleNamespace) -> str: ...  # undocumented\n    def install_scripts(self, context: SimpleNamespace, path: str) -> None: ...\n    if sys.version_info >= (3, 9):\n        def upgrade_dependencies(self, context: SimpleNamespace) -> None: ...\n\nif sys.version_info >= (3, 9):\n    def create(\n        env_dir: StrOrBytesPath,\n        system_site_packages: bool = False,\n        clear: bool = False,\n        symlinks: bool = False,\n        with_pip: bool = False,\n        prompt: str | None = None,\n        upgrade_deps: bool = False,\n    ) -> None: ...\n\nelse:\n    def create(\n        env_dir: StrOrBytesPath,\n        system_site_packages: bool = False,\n        clear: bool = False,\n        symlinks: bool = False,\n        with_pip: bool = False,\n        prompt: str | None = None,\n    ) -> None: ...\n\ndef main(args: Sequence[str] | None = None) -> None: ...\n",
  "/typeshed/stdlib/zoneinfo/__init__.pyi": "from _typeshed import StrPath\nfrom collections.abc import Iterable, Sequence\nfrom datetime import datetime, timedelta, tzinfo\nfrom typing import Any, Protocol\nfrom typing_extensions import Self\n\n__all__ = [\"ZoneInfo\", \"reset_tzpath\", \"available_timezones\", \"TZPATH\", \"ZoneInfoNotFoundError\", \"InvalidTZPathWarning\"]\n\nclass _IOBytes(Protocol):\n    def read(self, __size: int) -> bytes: ...\n    def seek(self, __size: int, __whence: int = ...) -> Any: ...\n\nclass ZoneInfo(tzinfo):\n    @property\n    def key(self) -> str: ...\n    def __init__(self, key: str) -> None: ...\n    @classmethod\n    def no_cache(cls, key: str) -> Self: ...\n    @classmethod\n    def from_file(cls, __fobj: _IOBytes, key: str | None = ...) -> Self: ...\n    @classmethod\n    def clear_cache(cls, *, only_keys: Iterable[str] | None = ...) -> None: ...\n    def tzname(self, __dt: datetime | None) -> str | None: ...\n    def utcoffset(self, __dt: datetime | None) -> timedelta | None: ...\n    def dst(self, __dt: datetime | None) -> timedelta | None: ...\n\n# Note: Both here and in clear_cache, the types allow the use of `str` where\n# a sequence of strings is required. This should be remedied if a solution\n# to this typing bug is found: https://github.com/python/typing/issues/256\ndef reset_tzpath(to: Sequence[StrPath] | None = None) -> None: ...\ndef available_timezones() -> set[str]: ...\n\nTZPATH: Sequence[str]\n\nclass ZoneInfoNotFoundError(KeyError): ...\nclass InvalidTZPathWarning(RuntimeWarning): ...\n\ndef __dir__() -> list[str]: ...\n",
  "/src/pyrightconfig.json": "{\n  \"pythonVersion\": \"3.10\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportUnusedFunction\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"reportMissingImports\": false,\n  \"verboseOutput\": true\n}\n",
  "/src/typings/htmltools/__init__.pyi": "from . import svg, tags\nfrom ._core import HTML, HTMLDependency, HTMLDocument, MetadataNode, RenderedHTML, Tag, TagAttrArg, TagAttrValue, TagAttrs, TagChild, TagChildArg, TagFunction, TagList, TagNode, Tagifiable, head_content\nfrom ._util import css, html_escape\nfrom .tags import a, br, code, div, em, h1, h2, h3, h4, h5, h6, hr, img, p, pre, span, strong\n\n__version__ = ...\n__all__ = (\"svg\", \"tags\", \"HTML\", \"HTMLDependency\", \"HTMLDocument\", \"MetadataNode\", \"RenderedHTML\", \"Tag\", \"TagAttrs\", \"TagAttrValue\", \"TagChild\", \"TagFunction\", \"Tagifiable\", \"TagList\", \"TagNode\", \"head_content\", \"css\", \"html_escape\", \"a\", \"br\", \"code\", \"div\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"img\", \"p\", \"pre\", \"span\", \"strong\")\n",
  "/src/typings/htmltools/_core.pyi": "import sys\nfrom typing import Any, Dict, Iterable, List, Literal, Mapping, Optional, Protocol, Sequence, SupportsIndex, TypeVar, Union, runtime_checkable\nfrom typing_extensions import Never, NotRequired, TypedDict\nfrom packaging.version import Version\n\nif sys.version_info >= (3, 11):\n    ...\nelse:\n    ...\n__all__ = (\"TagList\", \"Tag\", \"HTMLDocument\", \"HTML\", \"MetadataNode\", \"HTMLDependency\", \"RenderedHTML\", \"TagAttrs\", \"TagAttrValue\", \"TagChild\", \"TagNode\", \"TagFunction\", \"Tagifiable\", \"head_content\")\nclass RenderedHTML(TypedDict):\n    dependencies: list[HTMLDependency]\n    html: str\n    ...\n\n\nclass MetadataNode:\n    ...\n\n\nT = TypeVar(\"T\")\nTagT = TypeVar(\"TagT\", bound=\"Tag\")\nTagAttrValue = Union[str, float, bool, None]\nTagAttrs = Dict[str, TagAttrValue]\nTagNode = Union[\"Tagifiable\", \"Tag\", MetadataNode, str]\nTagChild = Union[TagNode, \"TagList\", float, None, Sequence[\"TagChild\"],]\nTagChildArg = Never\nTagAttrArg = Never\n@runtime_checkable\nclass Tagifiable(Protocol):\n    \"\"\"\n    Objects with `tagify()` methods are considered `Tagifiable`. Note that an object\n    returns a `TagList`, the children of the `TagList` must also be tagified.\n    \"\"\"\n    def tagify(self) -> TagList | Tag | MetadataNode | str:\n        ...\n    \n\n\n@runtime_checkable\nclass TagFunction(Protocol):\n    \"\"\"\n    Tag functions, like `div()`, `span()`, etc.\n    \"\"\"\n    def __call__(self, *args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n        ...\n    \n\n\nclass TagList(List[TagNode]):\n    \"\"\"\n    Create an HTML tag list (i.e., a fragment of HTML)\n\n    Parameters\n    ----------\n    *args\n        The tag children to add to the list.\n\n    Examples\n    --------\n    >>> from htmltools import TagList, div\n    >>> TagList(\"hello\", div(id=\"foo\", class_=\"bar\"))\n    hello\n    <div id=\"foo\" class=\"bar\"></div>\n    \"\"\"\n    def __init__(self, *args: TagChild) -> None:\n        ...\n    \n    def extend(self, x: Iterable[TagChild]) -> None:\n        \"\"\"\n        Extend the children by appending an iterable of children.\n        \"\"\"\n        ...\n    \n    def append(self, *args: TagChild) -> None:\n        \"\"\"\n        Append tag children to the end of the list.\n        \"\"\"\n        ...\n    \n    def insert(self, index: SupportsIndex, x: TagChild) -> None:\n        \"\"\"\n        Insert tag children before a given index.\n        \"\"\"\n        ...\n    \n    def tagify(self) -> TagList:\n        \"\"\"\n        Convert any tagifiable children to Tag/TagList objects.\n        \"\"\"\n        ...\n    \n    def save_html(self, file: str, *, libdir: Optional[str] = ..., include_version: bool = ...) -> str:\n        \"\"\"\n        Save to a HTML file.\n\n        Parameters\n        ----------\n        file\n            The file to save to.\n        libdir\n            The directory to save the dependencies to.\n        include_version\n            Whether to include the version number in the dependency folder name.\n\n        Returns\n        -------\n        :\n            The path to the generated HTML file.\n        \"\"\"\n        ...\n    \n    def render(self) -> RenderedHTML:\n        \"\"\"\n        Get string representation as well as it's HTML dependencies.\n        \"\"\"\n        ...\n    \n    def get_html_string(self, indent: int = ..., eol: str = ..., *, add_ws: bool = ..., _escape_strings: bool = ...) -> HTML:\n        \"\"\"\n        Return the HTML string for this tag list.\n\n        Parameters\n        ----------\n        indent\n            Number of spaces to indent each line of the HTML.\n        eol\n            End-of-line character(s).\n        add_ws:\n            Whether to add whitespace between the opening tag and the first child. If\n            either this is True, or the child's add_ws attribute is True, then\n            whitespace will be added; if they are both False, then no whitespace will be\n            added.\n        \"\"\"\n        ...\n    \n    def get_dependencies(self, *, dedup: bool = ...) -> list[HTMLDependency]:\n        \"\"\"\n        Get any dependencies needed to render the HTML.\n\n        Parameters\n        ----------\n        dedup\n            Whether to deduplicate the dependencies.\n        \"\"\"\n        ...\n    \n    def show(self, renderer: Literal[\"auto\", \"ipython\", \"browser\"] = ...) -> object:\n        \"\"\"\n        Preview as a complete HTML document.\n\n        Parameters\n        ----------\n        renderer\n            The renderer to use.\n        \"\"\"\n        ...\n    \n    def __str__(self) -> str:\n        ...\n    \n    def __eq__(self, other: Any) -> bool:\n        ...\n    \n    def __repr__(self) -> str:\n        ...\n    \n\n\nclass TagAttrDict(Dict[str, str]):\n    \"\"\"\n    A dictionary-like object that can be used to store attributes for a tag. All\n    attribute values will be stored as strings.\n\n    Parameters\n    ----------\n    *args\n        A dictionary of attributes. The values can be strings, numbers, or booleans, and\n        they will be converted to strings. A value can also be ``None``, in which case\n        it will be skipped.\n    **kwargs\n        More attributes.\n    \"\"\"\n    def __init__(self, *args: Mapping[str, TagAttrValue], **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def __setitem__(self, name: str, value: TagAttrValue) -> None:\n        ...\n    \n    def update(self, *args: Mapping[str, TagAttrValue], **kwargs: TagAttrValue) -> None:\n        ...\n    \n\n\nclass Tag:\n    \"\"\"\n    The HTML tag class.\n\n    A Tag object consists of a name, attributes, and children. The name is a string, the\n    attributes are held in a TagAttrDict object, and the children are held in a TagList\n    object.\n\n    This class usually should not be instantiated directly. Instead, use the tag wrapper\n    functions in ``htmltools.tags``, like ``div()`` or ``a()``.\n\n    Parameters\n    -----------\n    _name\n        The tag's name.\n    *args\n        Children for the tag.\n    _add_ws\n        Whether to add whitespace surrounding the tag (see Note for details).\n    **kwargs\n        Attributes for the tag.\n\n    Attributes\n    ----------\n    name\n        The tag's name.\n    attrs\n        The tag's attributes.\n    children\n        The tag's children.\n\n    Note\n    ----\n    The `_add_ws` parameter controls whether whitespace is added around the tag. Inline\n    tags (like `span()` and `a()`) default to  `False` and block tags (like `div()` and\n    `p()`) default to `True`.\n\n    When a tag with `_add_ws=True` is rendered to HTML, whitespace (including\n    indentation) is added before the opening tag (like `<div>`), after the closing tag\n    (like `</div>`), and also between the opening tag and its first child. This usually\n    results in formatting that is easier to read.\n\n    The only times that whitespace is not added around tags is when two sibling tags\n    have `_add_ws=False`, or when a tag and its first child both have `_add_ws=False`.\n    Bare strings are treated as children with `_add_ws=False`.\n\n    If you need fine control over whitespace in the output HTML, you can create tags\n    with `_add_ws=False` and manually add whitespace, like `div(\"\\\\n\", span(\"a\"),\n    _add_ws=False)`.\n\n    Examples\n    --------\n    >>> from htmltools import div\n    >>> x = div(\"hello\", id=\"foo\", class_=\"bar\")\n    >>> x\n    <div id=\"foo\" class=\"bar\">hello</div>\n    >>> x.show()\n    \"\"\"\n    name: str\n    add_ws: bool\n    attrs: TagAttrDict\n    children: TagList\n    def __init__(self, _name: str, *args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def __copy__(self: TagT) -> TagT:\n        ...\n    \n    def insert(self, index: SupportsIndex, x: TagChild) -> None:\n        \"\"\"\n        Insert tag children before a given index.\n        \"\"\"\n        ...\n    \n    def extend(self, x: Iterable[TagChild]) -> None:\n        \"\"\"\n        Extend the children by appending an iterable of children.\n        \"\"\"\n        ...\n    \n    def append(self, *args: TagChild) -> None:\n        \"\"\"\n        Append tag children to the end of the list.\n        \"\"\"\n        ...\n    \n    def add_class(self: TagT, class_: str, *, prepend: bool = ...) -> TagT:\n        \"\"\"\n        Add a class value to the HTML class attribute.\n\n        Parameters\n        ----------\n        class_\n            The class name to add.\n        prepend\n            Bool that determines if the `class` is added to the beginning or end of the\n            class attribute.\n\n        Returns\n        -------\n        :\n            The modified tag.\n        \"\"\"\n        ...\n    \n    def remove_class(self: TagT, class_: str) -> TagT:\n        \"\"\"\n        Remove a class value from the HTML class attribute.\n\n        Parameters\n        ----------\n        class_\n            The class name to remove.\n\n        Returns\n        -------\n        :\n            The modified tag.\n        \"\"\"\n        ...\n    \n    def has_class(self, class_: str) -> bool:\n        \"\"\"\n        Check if the tag has a particular class value.\n\n        Parameters\n        ----------\n        class_\n            The class name to check for.\n\n        Returns\n        -------\n        :\n            ``True`` if the tag has the class, ``False`` otherwise.\n        \"\"\"\n        ...\n    \n    def add_style(self: TagT, style: str, *, prepend: bool = ...) -> TagT:\n        \"\"\"\n        Add a style value(s) to the HTML style attribute.\n\n        Parameters\n        ----------\n        style\n            CSS properties and values already properly formatted. Each should already\n            contain trailing semicolons.\n        prepend\n            Bool that determines if the `style` is added to the beginning or end of the\n            style attribute.\n\n        See Also\n        --------\n        ~htmltools.css\n\n        Returns\n        -------\n        :\n            The modified tag.\n        \"\"\"\n        ...\n    \n    def tagify(self: TagT) -> TagT:\n        \"\"\"\n        Convert any tagifiable children to Tag/TagList objects.\n        \"\"\"\n        ...\n    \n    def get_html_string(self, indent: int = ..., eol: str = ...) -> HTML:\n        \"\"\"\n        Get the HTML string representation of the tag.\n\n        Parameters\n        ----------\n        indent\n            The number of spaces to indent the tag.\n        eol\n            The end-of-line character(s).\n        \"\"\"\n        ...\n    \n    def render(self) -> RenderedHTML:\n        \"\"\"\n        Get string representation as well as it's HTML dependencies.\n        \"\"\"\n        ...\n    \n    def save_html(self, file: str, *, libdir: Optional[str] = ..., include_version: bool = ...) -> str:\n        \"\"\"\n        Save to a HTML file.\n\n        Parameters\n        ----------\n        file\n            The file to save to.\n        libdir\n            The directory to save the dependencies to.\n        include_version\n            Whether to include the version number in the dependency folder name.\n\n        Returns\n        -------\n        The path to the generated HTML file.\n        \"\"\"\n        ...\n    \n    def get_dependencies(self, dedup: bool = ...) -> list[HTMLDependency]:\n        \"\"\"\n        Get any HTML dependencies.\n        \"\"\"\n        ...\n    \n    def show(self, renderer: Literal[\"auto\", \"ipython\", \"browser\"] = ...) -> object:\n        \"\"\"\n        Preview as a complete HTML document.\n\n        Parameters\n        ----------\n        renderer\n            The renderer to use.\n        \"\"\"\n        ...\n    \n    def __str__(self) -> str:\n        ...\n    \n    def __repr__(self) -> str:\n        ...\n    \n    def __eq__(self, other: Any) -> bool:\n        ...\n    \n\n\n_VOID_TAG_NAMES = ...\n_NO_ESCAPE_TAG_NAMES = ...\nclass HTMLDocument:\n    \"\"\"\n    Create an HTML document.\n\n    Parameters\n    ----------\n    *args\n        Children to add to the document.\n    **kwargs\n        Attributes to set on the document (i.e., the root <html> tag).\n\n    Examples\n    --------\n    >>> from htmltools import HTMLDocument, h1, tags\n    >>> HTMLDocument(h1(\"Hello\"), tags.meta(name=\"description\", content=\"test\"), lang = \"en\")\n    \"\"\"\n    def __init__(self, *args: TagChild, **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def __copy__(self) -> HTMLDocument:\n        ...\n    \n    def append(self, *args: TagChild) -> None:\n        \"\"\"\n        Add children to the document.\n\n        Parameters\n        ----------\n        *args\n            Children to add to the document.\n        \"\"\"\n        ...\n    \n    def render(self, *, lib_prefix: Optional[str] = ..., include_version: bool = ...) -> RenderedHTML:\n        \"\"\"\n        Render the document.\n\n        Parameters\n        ----------\n        lib_prefix\n            A prefix to add to relative paths to dependency files.\n        include_version\n            Whether to include the version number in the dependency's folder name.\n        \"\"\"\n        ...\n    \n    def save_html(self, file: str, libdir: Optional[str] = ..., include_version: bool = ...) -> str:\n        \"\"\"\n        Save the document to a HTML file.\n\n        Parameters\n        ----------\n        file\n            The file to save to.\n        libdir\n            The directory to save the dependencies to (relative to the file's directory).\n        include_version\n            Whether to include the version number in the dependency folder name.\n        \"\"\"\n        ...\n    \n\n\nclass HTML(str):\n    \"\"\"\n    Mark a string as raw HTML. This will prevent the string from being escaped when\n    rendered inside an HTML tag.\n\n    Examples\n    --------\n    >>> from htmltools import HTML, div\n    >>> div(\"<p>Hello</p>\")\n    <div>&lt;p&gt;Hello&lt;/p&gt;</div>\n    >>> div(HTML(\"<p>Hello</p>\"))\n    <div><p>Hello</p></div>\n    \"\"\"\n    def __str__(self) -> str:\n        ...\n    \n    def __add__(self, other: str | HTML) -> str:\n        ...\n    \n    def __repr__(self) -> str:\n        ...\n    \n    def as_string(self) -> str:\n        ...\n    \n\n\nclass HTMLDependencySource(TypedDict):\n    package: NotRequired[Optional[str]]\n    subdir: str\n    ...\n\n\nclass HTMLDependencyUrl(TypedDict):\n    href: str\n    ...\n\n\nclass SourcePathMapping(TypedDict):\n    source: str\n    href: str\n    ...\n\n\nclass ScriptItemBaseAttrs(TypedDict):\n    src: str\n    ...\n\n\nScriptItemExtraAttrs = TypedDict(\"ScriptItemExtraAttrs\", { \"async\": str,\"crossorigin\": str,\"defer\": str,\"fetchpriority\": str,\"integrity\": str,\"referrerpolicy\": str,\"type\": str }, total=False)\nclass ScriptItem(ScriptItemBaseAttrs, ScriptItemExtraAttrs):\n    ...\n\n\nclass StylesheetItemBaseAttrs(TypedDict):\n    href: str\n    ...\n\n\nStylesheetItemExtraAttrs = TypedDict(\"StylesheetItemExtraAttrs\", { \"as\": str,\"crossorigin\": str,\"disabled\": str,\"hreflang\": str,\"imagesizes\": str,\"imagesrcset\": str,\"integrity\": str,\"media\": str,\"prefetch\": str,\"referrerpolicy\": str,\"rel\": str,\"sizes\": str,\"title\": str,\"type\": str }, total=False)\nclass StylesheetItem(StylesheetItemExtraAttrs, StylesheetItemBaseAttrs):\n    ...\n\n\nclass MetaItemBaseAttrs(TypedDict):\n    name: str\n    content: str\n    ...\n\n\nMetaItemExtraAttrs = TypedDict(\"MetaItemExtraAttrs\", { \"charset\": str,\"http-equiv\": str }, total=False)\nclass MetaItem(MetaItemBaseAttrs, MetaItemExtraAttrs):\n    ...\n\n\nclass HTMLDependency(MetadataNode):\n    \"\"\"\n    Define an HTML dependency.\n\n    Define an HTML dependency (i.e. CSS and/or JavaScript bundled in a directory). HTML\n    dependencies make it possible to use libraries like jQuery, Bootstrap, and d3 in a\n    more composable and portable way than simply using script, link, and style tags.\n\n    Parameters\n    ----------\n    name\n        Library name.\n    version\n        Library version.\n    source\n        A specification for the location of dependency files.\n    script\n        ``<script>`` tags to include in the document's ``<head>``. Each tag definition\n        should include at least the ``src`` attribute (which should be file path\n        relative to the ``source`` file location).\n    stylesheet\n        ``<link>`` tags to include in the document's ``<head>``. Each tag definition\n        should include at least the ``href`` attribute (which should be file path\n        relative to the ``source`` file location).\n    all_files\n        Whether all files under the ``source`` directory are dependency files. If\n        ``False``, only the files specified in script and stylesheet are treated as\n        dependency files.\n    meta\n        ``<meta>`` tags to include in the document's ``<head>``.\n    head\n        Tags to include in the document's ``<head>``.\n\n    Examples\n    --------\n    >>> dep = HTMLDependency(\n            name=\"mypackage\",\n            version=\"1.0\",\n            source={\n                \"package\": \"mypackage\",\n                \"subdir\": \"lib/\",\n            },\n            script={\"src\": \"foo.js\"},\n            stylesheet={\"href\": \"css/foo.css\"},\n        )\n\n    >>> x = div(\"Hello\", dep)\n    >>> x.render()\n    \"\"\"\n    name: str\n    version: Version\n    source: Optional[HTMLDependencySource | HTMLDependencyUrl]\n    script: list[ScriptItem]\n    stylesheet: list[StylesheetItem]\n    meta: list[MetaItem]\n    all_files: bool\n    head: Optional[TagList]\n    def __init__(self, name: str, version: str | Version, *, source: Optional[HTMLDependencySource | HTMLDependencyUrl] = ..., script: Optional[ScriptItem | list[ScriptItem]] = ..., stylesheet: Optional[StylesheetItem | list[StylesheetItem]] = ..., all_files: bool = ..., meta: Optional[MetaItem | list[MetaItem]] = ..., head: TagChild = ...) -> None:\n        ...\n    \n    def source_path_map(self, *, lib_prefix: Optional[str] = ..., include_version: bool = ...) -> SourcePathMapping:\n        \"\"\"\n        Returns a dict of the absolute 'source' filepath and the 'href' path it will\n        point to in the HTML (given the lib_prefix).\n        \"\"\"\n        ...\n    \n    def as_html_tags(self, *, lib_prefix: Optional[str] = ..., include_version: bool = ...) -> TagList:\n        \"\"\"\n        Render the dependency as a ``TagList()``.\n        \"\"\"\n        ...\n    \n    def as_dict(self, *, lib_prefix: Optional[str] = ..., include_version: bool = ...) -> dict[str, Any]:\n        \"\"\"\n        Returns a dict of the dependency's attributes.\n        \"\"\"\n        ...\n    \n    def copy_to(self, path: str, include_version: bool = ...) -> None:\n        \"\"\"\n        Copy the dependency's files to the given path.\n        \"\"\"\n        ...\n    \n    def __repr__(self): # -> str:\n        ...\n    \n    def __str__(self) -> str:\n        ...\n    \n    def __eq__(self, other: Any) -> bool:\n        ...\n    \n\n\ndef head_content(*args: TagChild) -> HTMLDependency:\n    \"\"\"\n    Place content in the ``<head>`` of the HTML document.\n\n    Parameters\n    ----------\n    *args\n        The content to place in the ``<head>``.\n\n    Note\n    ----\n    If the same content, ``x``, is included in a document multiple times via\n    ``head_content(x)``, ``x`` will only appear once in the final HTML document's\n    ``<head>``. More often than not, this is desirable behavior, but if you need the\n    same content included multiple times, you can add some irrelevant/empty tags (e.g.,\n    ``TagList(x, Tag(\"meta\"))``) to make sure ``x`` is included multiple times.\n\n    Examples\n    --------\n    >>> from htmltools import *\n    >>> x = div(head_content(title(\"My Title\")))\n    >>> print(HTMLDocument(x).render()[\"html\"])\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <meta charset=\"utf-8\"/>\n        <title>My Title</title>\n      </head>\n      <body>\n        <div></div>\n      </body>\n    </html>\n    \"\"\"\n    ...\n\n",
  "/src/typings/htmltools/_jsx.pyi": "from typing import Callable, Dict, Iterable, Mapping, Optional\nfrom ._core import Tag, TagNode\n\n\"\"\"\nWARNING: this is a highly experimental/unsupported/private module for JSX/React\ncomponents. Although JSXTag currently allows for HTML tags on attributes and children,\nthat's an issue for HTML() and <script> tags, so using normal HTML tags inside JSX\ncomponents may become unsupported in a future version (see #26 and #28)\n\"\"\"\n__all__ = ()\nJSXTagAttrValue = object\nclass JSXTagAttrDict(Dict[str, JSXTagAttrValue]):\n    def __init__(self, **kwargs: JSXTagAttrValue) -> None:\n        ...\n    \n    def __setitem__(self, name: str, value: JSXTagAttrValue) -> None:\n        ...\n    \n    def update(self, *args: Mapping[str, JSXTagAttrValue], **kwargs: JSXTagAttrValue) -> None:\n        ...\n    \n\n\nclass JSXTag:\n    \"\"\"\n    Create a JSX tag.\n\n    Warning\n    -------\n    This class shouldn't be used directly to create a JSX tag. Instead, use the\n    jsx_tag_create() function.\n\n    See Also\n    --------\n    jsx_tag_create\n    \"\"\"\n    def __init__(self, _name: str, *args: TagNode, allowedProps: Optional[list[str]] = ..., **kwargs: JSXTagAttrValue) -> None:\n        ...\n    \n    def extend(self, x: Iterable[TagNode]) -> None:\n        ...\n    \n    def append(self, *args: TagNode) -> None:\n        ...\n    \n    def tagify(self) -> Tag:\n        ...\n    \n    def __str__(self) -> str:\n        ...\n    \n    def __repr__(self) -> str:\n        ...\n    \n\n\ndef jsx_tag_create(name: str, allowedProps: Optional[list[str]] = ...) -> Callable[..., JSXTag]:\n    \"\"\"\n    Create a function that creates a JSXTag object.\n\n    Parameters\n    ----------\n    name\n        The name of the JSX tag (should be camelCase and start with a capital letter).\n    allowedProps\n        A list of allowed properties for the tag. If ``None``, all properties are\n        allowed.\n\n    Returns\n    -------\n    :\n        JSXTag\n\n    Examples\n    --------\n    >>> from htmltools import jsx_tag_create\n    >>> MyTag = jsx_tag_create(\"MyTag\")\n    >>> MyTag(id=\"foo\", class_=\"bar\")\n    <script type=\"text/javascript\">\n    (function() {\n      var container = new DocumentFragment();\n      ReactDOM.render(\n        React.createElement(\n          MyTag, {\"id\": \"foo\", \"class\": \"bar\"})\n      , container);\n      document.currentScript.after(container);\n    })();\n    </script>\n    \"\"\"\n    ...\n\nclass jsx(str):\n    \"\"\"\n    Mark a string as a JSX expression.\n\n    Example\n    -------\n    >>> Foo = JSXTag(\"Foo\")\n    >>> Foo(prop = \"A string\", jsxProp = jsx(\"() => console.log('here')\"))\n    <script type=\"text/javascript\">\n    (function() {\n      var container = new DocumentFragment();\n      ReactDOM.render(\n        React.createElement(\n          Foo, {\"prop\": \"A string\", \"jsxProp\": () => console.log('here')})\n      , container);\n      document.currentScript.after(container);\n    })();\n    </script>\n    \"\"\"\n    def __new__(cls, *args: str) -> jsx:\n        ...\n    \n    def __add__(self, other: str | jsx) -> str:\n        ...\n    \n\n\n",
  "/src/typings/htmltools/_util.pyi": "from http.server import SimpleHTTPRequestHandler\nfrom threading import Thread\nfrom typing import Hashable, Iterable, NamedTuple, Optional, TypeVar, Union\n\nT = TypeVar(\"T\")\nHashableT = TypeVar(\"HashableT\", bound=Hashable)\n__all__ = (\"css\", )\ndef css(collapse_: str = ..., **kwargs: str | float | None) -> Optional[str]:\n    \"\"\"\n    CSS string helper\n\n    Convenience function for building CSS style declarations (i.e. the string that goes\n    into a style attribute, or the parts that go inside curly braces in a full\n    stylesheet).\n\n    Parameters\n    ----------\n    collapse_\n        Character to use to collapse properties into a single string; likely \"\" (the\n        default) for style attributes, and either \"\\n\" or None for style blocks.\n    **kwargs\n        Named style properties, where the name is the property name and the argument is\n        the property value.\n\n    Returns\n    -------\n    :\n        A string of CSS style declarations, or ``None`` if no properties were given.\n\n    Example\n    -------\n    >>> from htmltools import css\n    >>> css(font_size = \"12px\", backgroundColor = \"red\")\n    'font-size:12px;background-color:red;'\n\n    Note\n    ----\n    CSS uses '-' (minus) as a separator character in property names, which isn't allowed\n    in Python's keyword arguments. This function allows you to use '_' (underscore) as a\n    separator and/or camelCase notation instead.\n    \"\"\"\n    ...\n\ndef flatten(x: Iterable[Union[T, None]]) -> list[T]:\n    ...\n\ndef unique(x: list[HashableT]) -> list[HashableT]:\n    ...\n\nHTML_ESCAPE_TABLE = ...\nHTML_ATTRS_ESCAPE_TABLE = ...\ndef html_escape(text: str, attr: bool = ...) -> str:\n    ...\n\n_html_escape = ...\ndef package_dir(package: str) -> str:\n    ...\n\n_package_dir = ...\ndef hash_deterministic(s: str) -> str:\n    \"\"\"\n    Returns a deterministic hash of the given string.\n    \"\"\"\n    ...\n\nclass _HttpServerInfo(NamedTuple):\n    port: int\n    thread: Thread\n    ...\n\n\n_http_servers: dict[str, _HttpServerInfo] = ...\ndef ensure_http_server(path: str) -> int:\n    ...\n\ndef start_http_server(path: str) -> _HttpServerInfo:\n    ...\n\ndef http_server(port: int, path: str): # -> None:\n    class Handler(SimpleHTTPRequestHandler):\n        ...\n    \n    \n\ndef get_open_port() -> int:\n    ...\n\n",
  "/src/typings/htmltools/_versions.pyi": "versions = ...\n",
  "/src/typings/htmltools/svg.pyi": "from ._core import Tag, TagAttrValue, TagAttrs, TagChild\n\n\"\"\"\nFunctions for creating SVG tags.\n\"\"\"\ndef a(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <a> tag.\n\n    Creates the <a> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/a\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef animate(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <animate> tag.\n\n    Creates the <animate> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animate\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef animateMotion(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <animateMotion> tag.\n\n    Creates the <animateMotion> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animateMotion\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef animateTransform(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <animateTransform> tag.\n\n    Creates the <animateTransform> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animateTransform\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef circle(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <circle> tag.\n\n    Creates the <circle> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef clipPath(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <clipPath> tag.\n\n    Creates the <clipPath> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef defs(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <defs> tag.\n\n    Creates the <defs> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef desc(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <desc> tag.\n\n    Creates the <desc> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef discard(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <discard> tag.\n\n    Creates the <discard> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/discard\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef ellipse(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <ellipse> tag.\n\n    Creates the <ellipse> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feBlend(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feBlend> tag.\n\n    Creates the <feBlend> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feBlend\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feColorMatrix(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feColorMatrix> tag.\n\n    Creates the <feColorMatrix> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feColorMatrix\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feComponentTransfer(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feComponentTransfer> tag.\n\n    Creates the <feComponentTransfer> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feComponentTransfer\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feComposite(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feComposite> tag.\n\n    Creates the <feComposite> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feComposite\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feConvolveMatrix(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feConvolveMatrix> tag.\n\n    Creates the <feConvolveMatrix> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feConvolveMatrix\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feDiffuseLighting(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feDiffuseLighting> tag.\n\n    Creates the <feDiffuseLighting> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDiffuseLighting\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feDisplacementMap(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feDisplacementMap> tag.\n\n    Creates the <feDisplacementMap> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDisplacementMap\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feDistantLight(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feDistantLight> tag.\n\n    Creates the <feDistantLight> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDistantLight\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feDropShadow(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feDropShadow> tag.\n\n    Creates the <feDropShadow> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDropShadow\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feFlood(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feFlood> tag.\n\n    Creates the <feFlood> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFlood\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feFuncA(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feFuncA> tag.\n\n    Creates the <feFuncA> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncA\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feFuncB(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feFuncB> tag.\n\n    Creates the <feFuncB> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncB\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feFuncG(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feFuncG> tag.\n\n    Creates the <feFuncG> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncG\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feFuncR(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feFuncR> tag.\n\n    Creates the <feFuncR> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncR\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feGaussianBlur(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feGaussianBlur> tag.\n\n    Creates the <feGaussianBlur> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feGaussianBlur\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feImage(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feImage> tag.\n\n    Creates the <feImage> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feImage\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feMerge(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feMerge> tag.\n\n    Creates the <feMerge> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMerge\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feMergeNode(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feMergeNode> tag.\n\n    Creates the <feMergeNode> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMergeNode\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feMorphology(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feMorphology> tag.\n\n    Creates the <feMorphology> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMorphology\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feOffset(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feOffset> tag.\n\n    Creates the <feOffset> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feOffset\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef fePointLight(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <fePointLight> tag.\n\n    Creates the <fePointLight> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/fePointLight\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feSpecularLighting(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feSpecularLighting> tag.\n\n    Creates the <feSpecularLighting> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feSpecularLighting\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feSpotLight(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feSpotLight> tag.\n\n    Creates the <feSpotLight> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feSpotLight\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feTile(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feTile> tag.\n\n    Creates the <feTile> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feTile\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef feTurbulence(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <feTurbulence> tag.\n\n    Creates the <feTurbulence> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feTurbulence\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef filter(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <filter> tag.\n\n    Creates the <filter> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef foreignObject(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <foreignObject> tag.\n\n    Creates the <foreignObject> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef g(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <g> tag.\n\n    Creates the <g> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/g\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef hatch(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <hatch> tag.\n\n    Creates the <hatch> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/hatch\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef hatchpath(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <hatchpath> tag.\n\n    Creates the <hatchpath> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/hatchpath\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef image(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <image> tag.\n\n    Creates the <image> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef line(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <line> tag.\n\n    Creates the <line> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef linearGradient(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <linearGradient> tag.\n\n    Creates the <linearGradient> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef marker(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <marker> tag.\n\n    Creates the <marker> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/marker\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef mask(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <mask> tag.\n\n    Creates the <mask> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/mask\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef metadata(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <metadata> tag.\n\n    Creates the <metadata> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/metadata\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef mpath(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <mpath> tag.\n\n    Creates the <mpath> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/mpath\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef path(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <path> tag.\n\n    Creates the <path> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef pattern(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <pattern> tag.\n\n    Creates the <pattern> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/pattern\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef polygon(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <polygon> tag.\n\n    Creates the <polygon> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef polyline(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <polyline> tag.\n\n    Creates the <polyline> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef radialGradient(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <radialGradient> tag.\n\n    Creates the <radialGradient> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef rect(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <rect> tag.\n\n    Creates the <rect> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef script(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <script> tag.\n\n    Creates the <script> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/script\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef set(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <set> tag.\n\n    Creates the <set> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/set\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef stop(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <stop> tag.\n\n    Creates the <stop> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef style(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <style> tag.\n\n    Creates the <style> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/style\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef svg(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <svg> tag.\n\n    Creates the <svg> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef switch(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <switch> tag.\n\n    Creates the <switch> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/switch\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef symbol(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <symbol> tag.\n\n    Creates the <symbol> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/symbol\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef text(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <text> tag.\n\n    Creates the <text> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/text\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef textPath(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <textPath> tag.\n\n    Creates the <textPath> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef title(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <title> tag.\n\n    Creates the <title> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef tspan(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <tspan> tag.\n\n    Creates the <tspan> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef use(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <use> tag.\n\n    Creates the <use> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef view(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <view> tag.\n\n    Creates the <view> SVG element. Learn more at https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\n",
  "/src/typings/htmltools/tags.pyi": "from ._core import Tag, TagAttrValue, TagAttrs, TagChild\n\n\"\"\"\nFunctions for creating HTML tags.\n\"\"\"\n__all__ = (\"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"a\", \"br\", \"div\", \"span\", \"pre\", \"code\", \"img\", \"strong\", \"em\", \"hr\")\ndef html(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <html> tag.\n\n    The <html> HTML element represents the root (top-level element) of an HTML document, so it is also referred to as the root element. All other elements must be descendants of this element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef base(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <base> tag.\n\n    The <base> HTML element specifies the base URL to use for all relative URLs in a document. There can be only one <base> element in a document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef head(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <head> tag.\n\n    The <head> HTML element contains machine-readable information (metadata) about the document, like its title, scripts, and style sheets. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef link(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <link> tag.\n\n    The <link> HTML element specifies relationships between the current document and an external resource.\n    This element is most commonly used to link to CSS, but is also used to establish site icons (both \"favicon\" style icons and icons for the home screen and apps on mobile devices) among other things. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef meta(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <meta> tag.\n\n    The <meta> HTML element represents Metadata that cannot be represented by other HTML meta-related elements, like base, link, script, style or title. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef style(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <style> tag.\n\n    The <style> HTML element contains style information for a document, or part of a document. It contains CSS, which is applied to the contents of the document containing the <style> element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef title(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <title> tag.\n\n    The <title> HTML element defines the document's title that is shown in a Browser's title bar or a page's tab. It only contains text; tags within the element are ignored. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef body(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <body> tag.\n\n    The <body> HTML element represents the content of an HTML document. There can be only one <body> element in a document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef address(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <address> tag.\n\n    The <address> HTML element indicates that the enclosed HTML provides contact information for a person or people, or for an organization. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef article(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <article> tag.\n\n    The <article> HTML element represents a self-contained composition in a document, page, application, or site, which is intended to be independently distributable or reusable (e.g., in syndication). Examples include: a forum post, a magazine or newspaper article, or a blog entry, a product card, a user-submitted comment, an interactive widget or gadget, or any other independent item of content. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef aside(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <aside> tag.\n\n    The <aside> HTML element represents a portion of a document whose content is only indirectly related to the document's main content. Asides are frequently presented as sidebars or call-out boxes. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef footer(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <footer> tag.\n\n    The <footer> HTML element represents a footer for its nearest sectioning content or sectioning root element. A <footer> typically contains information about the author of the section, copyright data or links to related documents. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef header(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <header> tag.\n\n    The <header> HTML element represents introductory content, typically a group of introductory or navigational aids. It may contain some heading elements but also a logo, a search form, an author name, and other elements. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h1(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h1> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h2(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h2> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h3(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h3> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h4(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h4> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h5(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h5> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef h6(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <h6> tag.\n\n    The <h1> to <h6> HTML elements represent six levels of section headings. <h1> is the highest section level and <h6> is the lowest. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef main(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <main> tag.\n\n    The <main> HTML element represents the dominant content of the body of a document. The main content area consists of content that is directly related to or expands upon the central topic of a document, or the central functionality of an application. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef nav(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <nav> tag.\n\n    The <nav> HTML element represents a section of a page whose purpose is to provide navigation links, either within the current document or to other documents. Common examples of navigation sections are menus, tables of contents, and indexes. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef section(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <section> tag.\n\n    The <section> HTML element represents a generic standalone section of a document, which doesn't have a more specific semantic element to represent it. Sections should always have a heading, with very few exceptions. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef blockquote(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <blockquote> tag.\n\n    The <blockquote> HTML element indicates that the enclosed text is an extended quotation. Usually, this is rendered visually by indentation (see Notes for how to change it). A URL for the source of the quotation may be given using the cite attribute, while a text representation of the source can be given using the cite element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef dd(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <dd> tag.\n\n    The <dd> HTML element provides the description, definition, or value for the preceding term (dt) in a description list (dl). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef div(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <div> tag.\n\n    The <div> HTML element is the generic container for flow content. It has no effect on the content or layout until styled in some way using CSS (e.g. styling is directly applied to it, or some kind of layout model like Flexbox is applied to its parent element). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef dl(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <dl> tag.\n\n    The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the dt element) and descriptions (provided by dd elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef dt(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <dt> tag.\n\n    The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a dl element. It is usually followed by a dd element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next dd element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef figcaption(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <figcaption> tag.\n\n    The <figcaption> HTML element represents a caption or legend describing the rest of the contents of its parent figure element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef figure(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <figure> tag.\n\n    The <figure> HTML element represents self-contained content, potentially with an optional caption, which is specified using the figcaption element. The figure, its caption, and its contents are referenced as a single unit. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef hr(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <hr> tag.\n\n    The <hr> HTML element represents a thematic break between paragraph-level elements: for example, a change of scene in a story, or a shift of topic within a section. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef li(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <li> tag.\n\n    The <li> HTML element is used to represent an item in a list. It must be contained in a parent element: an ordered list (ol), an unordered list (ul), or a menu (menu). In menus and unordered lists, list items are usually displayed using bullet points. In ordered lists, they are usually displayed with an ascending counter on the left, such as a number or letter. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef menu(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <menu> tag.\n\n    The <menu> HTML element is a semantic alternative to ul. It represents an unordered list of items (represented by li elements), each of these represent a link or other command that the user can activate. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef ol(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <ol> tag.\n\n    The <ol> HTML element represents an ordered list of items \u2014 typically rendered as a numbered list. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef p(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <p> tag.\n\n    The <p> HTML element represents a paragraph. Paragraphs are usually represented in visual media as blocks of text separated from adjacent blocks by blank lines and/or first-line indentation, but HTML paragraphs can be any structural grouping of related content, such as images or form fields. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef pre(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <pre> tag.\n\n    The <pre> HTML element represents preformatted text which is to be presented exactly as written in the HTML file. The text is typically rendered using a non-proportional, or \"monospaced, font. Whitespace inside this element is displayed as written. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef ul(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <ul> tag.\n\n    The <ul> HTML element represents an unordered list of items, typically rendered as a bulleted list. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef a(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <a> tag.\n\n    The <a> HTML element (or anchor element), with its href attribute, creates a hyperlink to web pages, files, email addresses, locations in the same page, or anything else a URL can address. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef abbr(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <abbr> tag.\n\n    The <abbr> HTML element represents an abbreviation or acronym; the optional title attribute can provide an expansion or description for the abbreviation. If present, title must contain this full description and nothing else. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef b(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <b> tag.\n\n    The <b> HTML element is used to draw the reader's attention to the element's contents, which are not otherwise granted special importance. This was formerly known as the Boldface element, and most browsers still draw the text in boldface. However, you should not use <b> for styling text; instead, you should use the CSS font-weight property to create boldface text, or the strong element to indicate that text is of special importance. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef bdi(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <bdi> tag.\n\n    The <bdi> HTML element tells the browser's bidirectional algorithm to treat the text it contains in isolation from its surrounding text. It's particularly useful when a website dynamically inserts some text and doesn't know the directionality of the text being inserted. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef bdo(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <bdo> tag.\n\n    The <bdo> HTML element overrides the current directionality of text, so that the text within is rendered in a different direction. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef br(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <br> tag.\n\n    The <br> HTML element produces a line break in text (carriage-return). It is useful for writing a poem or an address, where the division of lines is significant. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef cite(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <cite> tag.\n\n    The <cite> HTML element is used to describe a reference to a cited creative work, and must include the title of that work. The reference may be in an abbreviated form according to context-appropriate conventions related to citation metadata. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef code(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <code> tag.\n\n    The <code> HTML element displays its contents styled in a fashion intended to indicate that the text is a short fragment of computer code. By default, the content text is displayed using the user agent default monospace font. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef data(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <data> tag.\n\n    The <data> HTML element links a given piece of content with a machine-readable translation. If the content is time- or date-related, the time element must be used. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef dfn(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <dfn> tag.\n\n    The <dfn> HTML element is used to indicate the term being defined within the context of a definition phrase or sentence. The p element, the dt/dd pairing, or the section element which is the nearest ancestor of the <dfn> is considered to be the definition of the term. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef em(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <em> tag.\n\n    The <em> HTML element marks text that has stress emphasis. The <em> element can be nested, with each level of nesting indicating a greater degree of emphasis. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef i(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <i> tag.\n\n    The <i> HTML element represents a range of text that is set off from the normal text for some reason, such as idiomatic text, technical terms, taxonomical designations, among others. Historically, these have been presented using italicized type, which is the original source of the <i> naming of this element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef kbd(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <kbd> tag.\n\n    The <kbd> HTML element represents a span of inline text denoting textual user input from a keyboard, voice input, or any other text entry device. By convention, the user agent defaults to rendering the contents of a <kbd> element using its default monospace font, although this is not mandated by the HTML standard. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef mark(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <mark> tag.\n\n    The <mark> HTML element represents text which is marked or highlighted for reference or notation purposes, due to the marked passage's relevance or importance in the enclosing context. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef q(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <q> tag.\n\n    The <q> HTML element indicates that the enclosed text is a short inline quotation. Most modern browsers implement this by surrounding the text in quotation marks. This element is intended for short quotations that don't require paragraph breaks; for long quotations use the blockquote element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef rp(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <rp> tag.\n\n    The <rp> HTML element is used to provide fall-back parentheses for browsers that do not support display of ruby annotations using the ruby element. One <rp> element should enclose each of the opening and closing parentheses that wrap the rt element that contains the annotation's text. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rp\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef rt(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <rt> tag.\n\n    The <rt> HTML element specifies the ruby text component of a ruby annotation, which is used to provide pronunciation, translation, or transliteration information for East Asian typography. The <rt> element must always be contained within a ruby element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef ruby(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <ruby> tag.\n\n    The <ruby> HTML element represents small annotations that are rendered above, below, or next to base text, usually used for showing the pronunciation of East Asian characters. It can also be used for annotating other kinds of text, but this usage is less common. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef s(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <s> tag.\n\n    The <s> HTML element renders text with a strikethrough, or a line through it. Use the <s> element to represent things that are no longer relevant or no longer accurate. However, <s> is not appropriate when indicating document edits; for that, use the del and ins elements, as appropriate. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef samp(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <samp> tag.\n\n    The <samp> HTML element is used to enclose inline text which represents sample (or quoted) output from a computer program. Its contents are typically rendered using the browser's default monospaced font (such as Courier or Lucida Console). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef small(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <small> tag.\n\n    The <small> HTML element represents side-comments and small print, like copyright and legal text, independent of its styled presentation. By default, it renders text within it one font-size smaller, such as from small to x-small. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef span(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <span> tag.\n\n    The <span> HTML element is a generic inline container for phrasing content, which does not inherently represent anything. It can be used to group elements for styling purposes (using the class or id attributes), or because they share attribute values, such as lang. It should be used only when no other semantic element is appropriate. <span> is very much like a div element, but div is a block-level element whereas a <span> is an inline element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef strong(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <strong> tag.\n\n    The <strong> HTML element indicates that its contents have strong importance, seriousness, or urgency. Browsers typically render the contents in bold type. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef sub(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <sub> tag.\n\n    The <sub> HTML element specifies inline text which should be displayed as subscript for solely typographical reasons. Subscripts are typically rendered with a lowered baseline using smaller text. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef sup(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <sup> tag.\n\n    The <sup> HTML element specifies inline text which is to be displayed as superscript for solely typographical reasons. Superscripts are usually rendered with a raised baseline using smaller text. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef time(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <time> tag.\n\n    The <time> HTML element represents a specific period in time. It may include the datetime attribute to translate dates into machine-readable format, allowing for better search engine results or custom features such as reminders. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef u(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <u> tag.\n\n    The <u> HTML element represents a span of inline text which should be rendered in a way that indicates that it has a non-textual annotation. This is rendered by default as a simple solid underline, but may be altered using CSS. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef var(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <var> tag.\n\n    The <var> HTML element represents the name of a variable in a mathematical expression or a programming context. It's typically presented using an italicized version of the current typeface, although that behavior is browser-dependent. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/var\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef wbr(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <wbr> tag.\n\n    The <wbr> HTML element represents a word break opportunity\u2014a position within text where the browser may optionally break a line, though its line-breaking rules would not otherwise create a break at that location. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef area(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <area> tag.\n\n    The <area> HTML element defines an area inside an image map that has predefined clickable areas. An image map allows geometric areas on an image to be associated with Hyperlink. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef audio(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <audio> tag.\n\n    The <audio> HTML element is used to embed sound content in documents. It may contain one or more audio sources, represented using the src attribute or the source element: the browser will choose the most suitable one. It can also be the destination for streamed media, using a MediaStream. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef img(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <img> tag.\n\n    The <img> HTML element embeds an image into the document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef map(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <map> tag.\n\n    The <map> HTML element is used with area elements to define an image map (a clickable link area). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef track(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <track> tag.\n\n    The <track> HTML element is used as a child of the media elements, audio and video. It lets you specify timed text tracks (or time-based data), for example to automatically handle subtitles. The tracks are formatted in WebVTT format (.vtt files) \u2014 Web Video Text Tracks. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef video(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <video> tag.\n\n    The <video> HTML element embeds a media player which supports video playback into the document. You can use <video> for audio content as well, but the audio element may provide a more appropriate user experience. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef embed(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <embed> tag.\n\n    The <embed> HTML element embeds external content at the specified point in the document. This content is provided by an external application or other source of interactive content such as a browser plug-in. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef iframe(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <iframe> tag.\n\n    The <iframe> HTML element represents a nested browsing context, embedding another HTML page into the current one. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef object(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <object> tag.\n\n    The <object> HTML element represents an external resource, which can be treated as an image, a nested browsing context, or a resource to be handled by a plugin. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef param(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <param> tag.\n\n    The <param> HTML element defines parameters for an object element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/param\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef picture(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <picture> tag.\n\n    The <picture> HTML element contains zero or more source elements and one img element to offer alternative versions of an image for different display/device scenarios. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef portal(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <portal> tag.\n\n    The <portal> HTML element enables the embedding of another HTML page into the current one for the purposes of allowing smoother navigation into new pages. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/portal\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef source(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <source> tag.\n\n    The <source> HTML element specifies multiple media resources for the picture, the audio element, or the video element. It is an empty element, meaning that it has no content and does not have a closing tag. It is commonly used to offer the same media content in multiple file formats in order to provide compatibility with a broad range of browsers given their differing support for image file formats and media file formats. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef svg(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <svg> tag.\n\n    The svg element is a container that defines a new\n    coordinate system and\n    viewport. It is used\n    as the outermost element of SVG documents, but it can also be used to\n    embed an SVG fragment inside an SVG or HTML document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/svg\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef math(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <math> tag.\n\n    The top-level element in MathML is <math>. Every valid\n    MathML instance must be wrapped in <math> tags. In\n    addition you must not nest a second <math> element in\n    another, but you can have an arbitrary number of other child elements in\n    it. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/math\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef canvas(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <canvas> tag.\n\n    Use the HTML <canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef noscript(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <noscript> tag.\n\n    The <noscript> HTML element defines a section of HTML to be inserted if a script type on the page is unsupported or if scripting is currently turned off in the browser. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef script(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <script> tag.\n\n    The <script> HTML element is used to embed executable code or data; this is typically used to embed or refer to JavaScript code. The <script> element can also be used with other languages, such as WebGL's GLSL shader programming language and JSON. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef ins(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <ins> tag.\n\n    The <ins> HTML element represents a range of text that has been added to a document. You can use the del element to similarly represent a range of text that has been deleted from the document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef caption(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <caption> tag.\n\n    The <caption> HTML element specifies the caption (or title) of a table. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef col(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <col> tag.\n\n    The <col> HTML element defines a column within a table and is used for defining common semantics on all common cells. It is generally found within a colgroup element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef colgroup(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <colgroup> tag.\n\n    The <colgroup> HTML element defines a group of columns within a table. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef table(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <table> tag.\n\n    The <table> HTML element represents tabular data \u2014 that is, information presented in a two-dimensional table comprised of rows and columns of cells containing data. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef tbody(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <tbody> tag.\n\n    The <tbody> HTML element encapsulates a set of table rows (tr elements), indicating that they comprise the body of the table (table). Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef td(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <td> tag.\n\n    The <td> HTML element defines a cell of a table that contains data. It participates in the table model. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef tfoot(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <tfoot> tag.\n\n    The <tfoot> HTML element defines a set of rows summarizing the columns of the table. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef th(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <th> tag.\n\n    The <th> HTML element defines a cell as header of a group of table cells. The exact nature of this group is defined by the scope and headers attributes. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef thead(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <thead> tag.\n\n    The <thead> HTML element defines a set of rows defining the head of the columns of the table. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef tr(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <tr> tag.\n\n    The <tr> HTML element defines a row of cells in a table. The row's cells can then be established using a mix of td (data cell) and th (header cell) elements. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef button(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <button> tag.\n\n    The <button> HTML element represents a clickable button, used to submit forms or anywhere in a document for accessible, standard button functionality. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef datalist(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <datalist> tag.\n\n    The <datalist> HTML element contains a set of option elements that represent the permissible or recommended options available to choose from within other controls. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef fieldset(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <fieldset> tag.\n\n    The <fieldset> HTML element is used to group several controls as well as labels (label) within a web form. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef form(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <form> tag.\n\n    The <form> HTML element represents a document section containing interactive controls for submitting information. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef input(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <input> tag.\n\n    The <input> HTML element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent. The <input> element is one of the most powerful and complex in all of HTML due to the sheer number of combinations of input types and attributes. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef label(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <label> tag.\n\n    The <label> HTML element represents a caption for an item in a user interface. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef legend(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <legend> tag.\n\n    The <legend> HTML element represents a caption for the content of its parent fieldset. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef meter(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <meter> tag.\n\n    The <meter> HTML element represents either a scalar value within a known range or a fractional value. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef optgroup(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <optgroup> tag.\n\n    The <optgroup> HTML element creates a grouping of options within a select element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef option(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <option> tag.\n\n    The <option> HTML element is used to define an item contained in a select, an optgroup, or a datalist element. As such, <option> can represent menu items in popups and other lists of items in an HTML document. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef output(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <output> tag.\n\n    The <output> HTML element is a container element into which a site or app can inject the results of a calculation or the outcome of a user action. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef progress(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <progress> tag.\n\n    The <progress> HTML element displays an indicator showing the completion progress of a task, typically displayed as a progress bar. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef select(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <select> tag.\n\n    The <select> HTML element represents a control that provides a menu of options: Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef textarea(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <textarea> tag.\n\n    The <textarea> HTML element represents a multi-line plain-text editing control, useful when you want to allow users to enter a sizeable amount of free-form text, for example a comment on a review or feedback form. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef details(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <details> tag.\n\n    The <details> HTML element creates a disclosure widget in which information is visible only when the widget is toggled into an \"open\" state. A summary or label must be provided using the summary element. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef dialog(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <dialog> tag.\n\n    The <dialog> HTML element represents a dialog box or other interactive component, such as a dismissible alert, inspector, or subwindow. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef summary(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <summary> tag.\n\n    The <summary> HTML element specifies a summary, caption, or legend for a details element's disclosure box. Clicking the <summary> element toggles the state of the parent <details> element open and closed. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef slot(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <slot> tag.\n\n    The <slot> HTML element\u2014part of the Web Components technology suite\u2014is a placeholder inside a web component that you can fill with your own markup, which lets you create separate DOM trees and present them together. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\ndef template(*args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a <template> tag.\n\n    The <template> HTML element is a mechanism for holding HTML that is not to be rendered immediately when a page is loaded but may be instantiated subsequently during runtime using JavaScript. Learn more at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template\n\n    Parameters\n    ----------\n    *args\n        Child elements to this tag.\n    _add_ws\n        Whether whitespace should be added around this tag.\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        A :func:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    ~htmltools.Tag\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/__init__.pyi": "from ._shinyenv import is_pyodide as _is_pyodide\nfrom . import module, reactive, render, session, ui\nfrom .session import Inputs, Outputs, Session\nfrom ._app import App\nfrom ._validation import req\nfrom ._deprecated import *\nfrom ._main import run_app\n\n\"\"\"A package for building reactive web applications.\"\"\"\n__version__ = ...\nif _is_pyodide:\n    run_app = ...\nelse:\n    ...\n__all__ = (\"reactive\", \"render\", \"session\", \"ui\", \"App\", \"run_app\", \"module\", \"Session\", \"Inputs\", \"Outputs\", \"req\", \"render_text\", \"render_plot\", \"render_image\", \"render_ui\", \"event\")\n",
  "/src/typings/shiny/__main__.pyi": "if __name__ == \"__main__\":\n    ...\n",
  "/src/typings/shiny/_app.pyi": "import os\nfrom typing import Callable, Optional\nfrom htmltools import HTMLDependency, RenderedHTML, Tag, TagList\nfrom starlette.requests import Request\nfrom starlette.types import Receive, Scope, Send\nfrom .session import Inputs, Outputs, Session\n\nLIB_PREFIX: str = ...\nSANITIZE_ERRORS: bool = ...\nSANITIZE_ERROR_MSG: str = ...\nclass App:\n    \"\"\"\n    Create a Shiny app instance.\n\n    Parameters\n    ----------\n    ui\n        The UI definition for the app (e.g., a call to :func:`~shiny.ui.page_fluid` or\n        :func:`~shiny.ui.page_fixed`, with layouts and controls nested inside). You can\n        also pass a function that takes a :class:`~starlette.requests.Request` and\n        returns a UI definition, if you need the UI definition to be created dynamically\n        for each pageview.\n    server\n        A function which is called once for each session, ensuring that each app is\n        independent.\n    static_assets\n        An absolute directory containing static files to be served by the app.\n    debug\n        Whether to enable debug mode.\n\n    Example\n    -------\n\n    ```{python}\n    #| eval: false\n    from shiny import  App, Inputs, Outputs, Session, ui\n\n    app_ui = ui.page_fluid(\"Hello Shiny!\")\n\n    def server(input: Inputs, output: Outputs, session: Session):\n        pass\n\n    app = App(app_ui, server)\n    ```\n    \"\"\"\n    lib_prefix: str = ...\n    sanitize_errors: bool = ...\n    sanitize_error_msg: str = ...\n    ui: RenderedHTML | Callable[[Request], Tag | TagList]\n    server: Callable[[Inputs, Outputs, Session], None]\n    def __init__(self, ui: Tag | TagList | Callable[[Request], Tag | TagList], server: Optional[Callable[[Inputs, Outputs, Session], None]], *, static_assets: Optional[str | os.PathLike[str]] = ..., debug: bool = ...) -> None:\n        ...\n    \n    def init_starlette_app(self): # -> Starlette:\n        ...\n    \n    def run(self, **kwargs: object) -> None:\n        \"\"\"\n        Run the app.\n\n        Parameters\n        ----------\n        kwargs\n            Keyword arguments passed to :func:`~shiny.run_app`.\n        \"\"\"\n        ...\n    \n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        ...\n    \n    async def call_pyodide(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Communicate with pyodide.\n\n        Warning\n        -------\n        This method is not intended for public usage. It's exported for use by\n        shinylive.\n        \"\"\"\n        ...\n    \n    async def stop(self) -> None:\n        \"\"\"\n        Stop the app (i.e., close all sessions).\n\n        See Also\n        --------\n        ~shiny.Session.close\n        \"\"\"\n        ...\n    \n\n\ndef is_uifunc(x: Tag | TagList | Callable[[Request], Tag | TagList]): # -> bool:\n    ...\n\ndef html_dep_name(dep: HTMLDependency) -> str:\n    ...\n\n",
  "/src/typings/shiny/_autoreload.pyi": "import logging\nfrom typing import Callable, Optional\nfrom asgiref.typing import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, ASGISendEvent, Scope\nfrom ._shinyenv import is_pyodide\n\nif notis_pyodide:\n    ...\ndef autoreload_url() -> Optional[str]:\n    ...\n\nclass HotReloadHandler(logging.Handler):\n    \"\"\"Uvicorn log reader, detects reload events.\"\"\"\n    def __init__(self) -> None:\n        ...\n    \n    def emit(self, record: logging.LogRecord) -> None:\n        ...\n    \n\n\ndef reload_begin(): # -> None:\n    ...\n\ndef reload_end(): # -> None:\n    ...\n\nclass InjectAutoreloadMiddleware:\n    \"\"\"Inserts shiny-autoreload.js into the head.\n\n    It's necessary to do it using middleware instead of in a nice htmldependency,\n    because we want autoreload to be effective even when displaying an error page.\n    \"\"\"\n    def __init__(self, app: ASGI3Application) -> None:\n        ...\n    \n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        ...\n    \n\n\ndef start_server(port: int, app_port: int, launch_browser: bool): # -> None:\n    \"\"\"Starts a websocket server that listens on its own port (separate from the main\n    Shiny listener).\n\n    Clients can connect on either the /autoreload or /notify path.\n\n    Clients from the uvicorn worker process connect to the /notify path to notify us\n    that a successful startup or reload has occurred.\n\n    Clients from browsers (on localhost only) connect to the /autoreload path to be\n    notified when a successful startup or reload has occurred.\n    \"\"\"\n    ...\n\nclass ResponseMangler:\n    \"\"\"A class that assists with intercepting and rewriting response bodies being sent\n    over ASGI. This would be easy if not for 1) response bodies are potentially sent in\n    chunks, over multiple events; 2) the first response event we receive is the one that\n    contains the Content-Length, which can be affected when we do rewriting later on.\n    The ResponseMangler handles the buffering and content-length rewriting, leaving the\n    caller to only have to worry about the actual body-modifying logic.\n    \"\"\"\n    def __init__(self, send: ASGISendCallable, mangler: Callable[[bytes], tuple[bytes, bool]]) -> None:\n        ...\n    \n    async def send(self, event: ASGISendEvent) -> None:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_connection.pyi": "import starlette.websockets\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\nfrom starlette.requests import HTTPConnection\n\nclass Connection(ABC):\n    \"\"\"Abstract class to serve a session and send/receive messages to the\n    client.\"\"\"\n    @abstractmethod\n    async def send(self, message: str) -> None:\n        ...\n    \n    @abstractmethod\n    async def receive(self) -> str:\n        ...\n    \n    @abstractmethod\n    async def close(self, code: int, reason: Optional[str]) -> None:\n        ...\n    \n    @abstractmethod\n    def get_http_conn(self) -> HTTPConnection:\n        ...\n    \n\n\nclass MockConnection(Connection):\n    def __init__(self) -> None:\n        ...\n    \n    async def send(self, message: str) -> None:\n        ...\n    \n    async def receive(self) -> str:\n        ...\n    \n    async def close(self, code: int, reason: Optional[str]) -> None:\n        ...\n    \n    def get_http_conn(self) -> HTTPConnection:\n        ...\n    \n    def cause_receive(self, message: str) -> None:\n        \"\"\"Call from tests to simulate the other side sending a message\"\"\"\n        ...\n    \n    def cause_disconnect(self) -> None:\n        \"\"\"Call from tests to simulate the other side disconnecting\"\"\"\n        ...\n    \n\n\nclass StarletteConnection(Connection):\n    conn: starlette.websockets.WebSocket\n    def __init__(self, conn: starlette.websockets.WebSocket) -> None:\n        ...\n    \n    async def accept(self, subprotocol: Optional[str] = ...): # -> None:\n        ...\n    \n    async def send(self, message: str) -> None:\n        ...\n    \n    async def receive(self) -> str:\n        ...\n    \n    async def close(self, code: int, reason: Optional[str]) -> None:\n        ...\n    \n    def get_http_conn(self) -> HTTPConnection:\n        ...\n    \n\n\nclass ConnectionClosed(Exception):\n    \"\"\"Raised when a Connection is closed from the other side.\"\"\"\n    ...\n\n\n",
  "/src/typings/shiny/_datastructures.pyi": "from typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\nclass PriorityQueueFIFO(Generic[T]):\n    \"\"\"\n    Similar to queue.PriorityQueue, except that if two elements have the same\n    priority, they are returned in the order they were inserted. Also, the item\n    is kept separate from the priority value (with PriorityQueue, the priority\n    is part of the item).\n    \"\"\"\n    def __init__(self) -> None:\n        ...\n    \n    def put(self, priority: int, item: T) -> None:\n        \"\"\"\n        Add an item to the queue.\n\n        Parameters:\n           priority (int): The priority of the item. Higher priority items will\n                           come out of the queue before lower priority items.\n           item (T): The item to put in the queue.\n        \"\"\"\n        ...\n    \n    def get(self) -> T:\n        ...\n    \n    def empty(self) -> bool:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_deprecated.pyi": "from typing import Any\n\n__all__ = (\"render_text\", \"render_plot\", \"render_image\", \"render_ui\", \"event\")\nclass ShinyDeprecationWarning(RuntimeWarning):\n    ...\n\n\ndef warn_deprecated(message: str): # -> None:\n    ...\n\ndef render_text(): # -> (RenderTextFunc | RenderTextFuncAsync) -> RenderText:\n    \"\"\"Deprecated. Please use render.text() instead of render_text().\"\"\"\n    ...\n\ndef render_ui(): # -> (RenderUIFunc | RenderUIFuncAsync) -> RenderUI:\n    \"\"\"Deprecated. Please use render.ui() instead of render_ui().\"\"\"\n    ...\n\ndef render_plot(*args: Any, **kwargs: Any): # -> (RenderPlotFunc | RenderPlotFuncAsync) -> RenderPlot:\n    \"\"\"Deprecated. Please use render.plot() instead of render_plot().\"\"\"\n    ...\n\ndef render_image(*args: Any, **kwargs: Any): # -> (RenderImageFunc | RenderImageFuncAsync) -> RenderImage:\n    \"\"\"Deprecated. Please use render.image() instead of render_image().\"\"\"\n    ...\n\ndef event(*args: Any, **kwargs: Any): # -> (() -> T@event) -> (() -> T@event):\n    \"\"\"Deprecated. Please use @reactive.event() instead of @event().\"\"\"\n    ...\n\n",
  "/src/typings/shiny/_docstring.pyi": "from typing import Any, Callable, Literal, TypeVar\n\nex_dir: str = ...\nFuncType = Callable[..., Any]\nF = TypeVar(\"F\", bound=FuncType)\nclass DocStringWithExample(str):\n    ...\n\n\ndef add_example(directive: Literal[\"shinyapp::\", \"shinylive-editor::\", \"code-block:: python\", \"cell::\", \"terminal::\",] = ..., **options: object) -> Callable[[F], F]:\n    \"\"\"\n    Add an example to the docstring of a function, method, or class.\n\n    This decorator must, at the moment, be used on a function, method, or class whose\n    ``__name__`` matches the name of directory under ``shiny/api-examples/``, and must\n    also contain a ``app.py`` file in that directory.\n\n    Parameters\n    ----------\n    directive\n        A directive for rendering the example. This can be one of:\n            - ``shinyapp``: A live shiny app (statically served via wasm).\n            - ``code``: A python code snippet.\n            - ``shinylive-editor``: A live shiny app with editor (statically served via wasm).\n            - ``cell``: A executable Python cell.\n            - ``terminal``: A minimal Python IDE\n    **options\n        Options for the directive. See docs/source/sphinxext/pyshinyapp.py for details.\n    \"\"\"\n    ...\n\ndef doc_format(**kwargs: str) -> Callable[[F], F]:\n    ...\n\n",
  "/src/typings/shiny/_error.pyi": "from starlette.types import ASGIApp, Receive, Scope, Send\n\nclass ErrorMiddleware:\n    \"\"\"Inserts shiny-autoreload.js into the head.\n\n    It's necessary to do it using middleware instead of in a nice htmldependency,\n    because we want autoreload to be effective even when displaying an error page.\n    \"\"\"\n    def __init__(self, app: ASGIApp) -> None:\n        ...\n    \n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_fileupload.pyi": "from typing import List, Optional\nfrom .types import FileInfo\n\nclass FileUploadOperation:\n    def __init__(self, parent: FileUploadManager, id: str, dir: str, file_infos: List[FileInfo]) -> None:\n        ...\n    \n    def file_begin(self) -> None:\n        ...\n    \n    def file_end(self) -> None:\n        ...\n    \n    def write_chunk(self, chunk: bytes) -> None:\n        ...\n    \n    def finish(self) -> List[FileInfo]:\n        ...\n    \n    def __enter__(self) -> None:\n        ...\n    \n    def __exit__(self, type, value, trace) -> None:\n        ...\n    \n\n\nclass FileUploadManager:\n    def __init__(self) -> None:\n        ...\n    \n    def create_upload_operation(self, file_infos: List[FileInfo]) -> str:\n        ...\n    \n    def get_upload_operation(self, id: str) -> Optional[FileUploadOperation]:\n        ...\n    \n    def on_job_finished(self, job_id: str) -> None:\n        ...\n    \n    def rm_upload_dir(self) -> None:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_hostenv.pyi": "import logging\nimport typing\nfrom typing import Pattern\n\ndef is_workbench() -> bool:\n    ...\n\ndef is_proxy_env() -> bool:\n    ...\n\nport_cache: dict[int, str] = ...\ndef get_proxy_url(url: str) -> str:\n    ...\n\npat_local_url: Pattern[str] = ...\nclass ProxyUrlFilter:\n    def __init__(self) -> None:\n        ...\n    \n    def filter(self, record: logging.LogRecord) -> int:\n        ...\n    \n    def url_replacement(self, match: typing.Match[str]) -> str:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_launchbrowser.pyi": "import logging\n\nclass LaunchBrowserHandler(logging.Handler):\n    \"\"\"Uvicorn log reader, detects successful app startup so we can launch a browser.\n\n    This class is ONLY used when reload mode is turned off; in the case of reload, the\n    launching of the browser must be tightly coupled to the HotReloadHandler as that is\n    the only way to ensure the browser is only launched at startup, not on every reload.\n    \"\"\"\n    def __init__(self) -> None:\n        ...\n    \n    def emit(self, record: logging.LogRecord) -> None:\n        ...\n    \n\n\n",
  "/src/typings/shiny/_main.pyi": "import types\nimport click\nimport uvicorn\nimport uvicorn.config\nimport shiny\nfrom pathlib import Path\nfrom typing import Any, Optional\nfrom ._typing_extensions import NotRequired, TypedDict\n\n@click.group(\"main\")\ndef main() -> None:\n    ...\n\nstop_shortcut = ...\n@main.command(help=<Expression>)\n@click.argument(\"app\", default=\"app.py:app\")\n@click.option(\"-h\", \"--host\", type=str, default=\"127.0.0.1\", help=\"Bind socket to this host.\", show_default=True)\n@click.option(\"-p\", \"--port\", type=int, default=8000, help=\"Bind socket to this port. If 0, a random port will be used.\", show_default=True)\n@click.option(\"--autoreload-port\", type=int, default=0, help=\"Bind autoreload socket to this port. If 0, a random port will be used. Ignored if --reload is not used.\", show_default=True)\n@click.option(\"-r\", \"--reload\", is_flag=True, default=False, help=\"Enable auto-reload, when these types of files change: .py .css .js .html\")\n@click.option(\"--reload-dir\", \"reload_dirs\", multiple=True, help=\"Indicate a directory `--reload` should (recursively) monitor for changes, in \" \"addition to the app's parent directory. Can be used more than once.\", type=click.Path(exists=True))\n@click.option(\"--ws-max-size\", type=int, default=16777216, help=\"WebSocket max size message in bytes\", show_default=True)\n@click.option(\"--log-level\", type=click.Choice(list(uvicorn.config.LOG_LEVELS.keys())), default=None, help=\"Log level. [default: info]\", show_default=True)\n@click.option(\"-d\", \"--app-dir\", default=\".\", show_default=True, help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH.\" \" Defaults to the current working directory. If APP is a file path, this argument\" \" is ignored.\")\n@click.option(\"--factory\", is_flag=True, default=False, help=\"Treat APP as an application factory, i.e. a () -> <ASGI app> callable.\", show_default=True)\n@click.option(\"-b\", \"--launch-browser\", is_flag=True, default=False, help=\"Launch app browser after app starts, using the Python webbrowser module.\", show_default=True)\ndef run(app: str | shiny.App, host: str, port: int, autoreload_port: int, reload: bool, reload_dirs: tuple[str, ...], ws_max_size: int, log_level: str, app_dir: str, factory: bool, launch_browser: bool) -> None:\n    ...\n\ndef run_app(app: str | shiny.App = ..., host: str = ..., port: int = ..., autoreload_port: int = ..., reload: bool = ..., reload_dirs: Optional[list[str]] = ..., ws_max_size: int = ..., log_level: Optional[str] = ..., app_dir: Optional[str] = ..., factory: bool = ..., launch_browser: bool = ...) -> None:\n    \"\"\"\n    Starts a Shiny app. Press ``Ctrl+C`` (or ``Ctrl+Break`` on Windows) to stop.\n\n    Parameters\n    ----------\n    app\n        The app to run. The default, ``app:app``, represents the \"usual\" case where the\n        application is named ``app`` inside a ``app.py`` file within the current working\n        directory. In other cases, the app location can be specified as a\n        ``<module>:<attribute>`` string where the ``:<attribute>`` is only necessary if\n        the application is named something other than ``app``. Note that ``<module>``\n        can be relative path to a ``.py`` file or a directory (with an ``app.py`` file\n        inside it); and in this case, the relative path is resolved relative to the\n        ``app_dir`` directory.\n    host\n        The address that the app should listen on.\n    port\n        The port that the app should listen on. Set to 0 to use a random port.\n    autoreload_port\n        The port that should be used for an additional websocket that is used to support\n        hot-reload. Set to 0 to use a random port.\n    reload\n        Enable auto-reload.\n    ws_max_size\n        WebSocket max size message in bytes.\n    log_level\n        Log level.\n    app_dir\n        Look for ``app`` under this directory (by adding this to the ``PYTHONPATH``).\n    factory\n        Treat ``app`` as an application factory, i.e. a () -> <ASGI app> callable.\n    launch_browser\n        Launch app browser after app starts, using the Python webbrowser module.\n\n    Tip\n    ---\n    The ``shiny run`` command-line interface (which comes installed with Shiny) provides\n    the same functionality as this function.\n\n    Examples\n    --------\n\n    ```{python}\n    #|eval: false\n    from shiny import run_app\n\n    # Run ``app`` inside ``./app.py``\n    run_app()\n\n    # Run ``app`` inside ``./myapp.py`` (or ``./myapp/app.py``)\n    run_app(\"myapp\")\n\n    # Run ``my_app`` inside ``./myapp.py`` (or ``./myapp/app.py``)\n    run_app(\"myapp:my_app\")\n\n    # Run ``my_app`` inside ``../myapp.py`` (or ``../myapp/app.py``)\n    run_app(\"myapp:my_app\", app_dir=\"..\")\n    ```\n    \"\"\"\n    ...\n\ndef setup_hot_reload(log_config: dict[str, Any], autoreload_port: int, app_port: int, launch_browser: bool) -> None:\n    ...\n\ndef setup_launch_browser(log_config: dict[str, Any]): # -> None:\n    ...\n\ndef maybe_setup_rsw_proxying(log_config: dict[str, Any]) -> None:\n    ...\n\ndef is_file(app: str) -> bool:\n    ...\n\ndef resolve_app(app: str, app_dir: Optional[str]) -> tuple[str, Optional[str]]:\n    ...\n\ndef try_import_module(module: str) -> Optional[types.ModuleType]:\n    ...\n\n@main.command(help=\"\"\"Create a Shiny application from a template.\n\nAPPDIR is the directory to the Shiny application. A file named app.py will be created in\nthat directory.\n\nAfter creating the application, you use `shiny run`:\n\n    shiny run APPDIR/app.py --reload\n\"\"\")\n@click.argument(\"appdir\", type=str, default=\".\")\ndef create(appdir: str) -> None:\n    ...\n\n@main.command(help=\"\"\"The functionality from `shiny static` has been moved to the shinylive package.\nPlease install shinylive and use `shinylive export` instead of `shiny static`:\n\n  \\b\n  shiny static-assets remove\n  pip install shinylive\n  shinylive export APPDIR DESTDIR\n\n\"\"\", context_settings=dict(ignore_unknown_options=True, allow_extra_args=True))\ndef static() -> None:\n    ...\n\n@main.command(no_args_is_help=True, help=\"\"\"Manage local copy of assets for static app deployment. (Deprecated)\n\n    \\b\n    Commands:\n        remove: Remove local copies of assets.\n        info: Print information about the local assets.\n\n\"\"\")\n@click.argument(\"command\", type=str)\ndef static_assets(command: str) -> None:\n    ...\n\nclass ReloadArgs(TypedDict):\n    reload: NotRequired[bool]\n    reload_includes: NotRequired[list[str]]\n    reload_dirs: NotRequired[list[str]]\n    ...\n\n\n",
  "/src/typings/shiny/_namespaces.pyi": "from contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Pattern, Union\n\nclass ResolvedId(str):\n    def __call__(self, id: Id) -> ResolvedId:\n        ...\n    \n\n\nRoot: ResolvedId = ...\nId = Union[str, ResolvedId]\ndef current_namespace() -> ResolvedId:\n    ...\n\ndef resolve_id(id: Id) -> ResolvedId:\n    \"\"\"\n    Resolve an ID, possibly with a module namespace.\n\n    Parameters\n    ----------\n    Args\n        id: An ID.\n\n    Returns\n        An ID (if in a module, this will contain a namespace prefix).\n    \"\"\"\n    ...\n\nre_valid_id: Pattern[str] = ...\ndef validate_id(id: str): # -> None:\n    ...\n\n_current_namespace: ContextVar[ResolvedId] = ...\n@contextmanager\ndef namespace_context(id: Id | None): # -> Generator[None, Any, None]:\n    ...\n\n",
  "/src/typings/shiny/_shinyenv.pyi": "\"\"\"\nInformation about the execution environment for Shiny\n\"\"\"\nis_pyodide: bool = ...\n",
  "/src/typings/shiny/_static.pyi": "from pathlib import Path\nfrom typing import Optional\n\ndef remove_shinylive_local(shinylive_dir: Optional[Path] = ..., version: Optional[str] = ...) -> None:\n    \"\"\"Removes local copy of shinylive.\n\n    Parameters\n    ----------\n    shinylive_dir\n        The directory where shinylive is stored. If None, the default directory will\n        be used.\n\n    version\n        If a version is specified, only that version will be removed.\n        If None, all local versions of shinylive will be removed.\n    \"\"\"\n    ...\n\ndef get_default_shinylive_dir() -> Path:\n    ...\n\ndef print_shinylive_local_info() -> None:\n    ...\n\n",
  "/src/typings/shiny/_typing_extensions.pyi": "import sys\n\n__all__ = (\"Concatenate\", \"ParamSpec\", \"TypeGuard\", \"NotRequired\", \"TypedDict\", \"assert_type\")\nif sys.version_info >= (3, 10):\n    ...\nelse:\n    ...\nif sys.version_info >= (3, 11):\n    ...\nelse:\n    ...\n",
  "/src/typings/shiny/_utils.pyi": "import asyncio\nimport contextlib\nimport os\nfrom typing import Any, Awaitable, Callable, TypeVar\nfrom ._typing_extensions import ParamSpec, TypeGuard\n\nCancelledError = asyncio.CancelledError\ndef rand_hex(bytes: int) -> str:\n    \"\"\"\n    Creates a random hexadecimal string of size `bytes`. The length in\n    characters will be bytes*2.\n    \"\"\"\n    ...\n\ndef drop_none(x: dict[str, Any]) -> dict[str, object]:\n    ...\n\ndef lists_to_tuples(x: object) -> object:\n    ...\n\ndef guess_mime_type(url: str | os.PathLike[str], default: str = ..., strict: bool = ...) -> str:\n    \"\"\"\n    Guess the MIME type of a file. This is a wrapper for mimetypes.guess_type, but it\n    only returns the type (and not encoding), and it allows a default value.\n    \"\"\"\n    ...\n\ndef random_port(min: int = ..., max: int = ..., host: str = ..., n: int = ...) -> int:\n    \"\"\"Find an open TCP port\n\n    Finds a random available TCP port for listening on, within a specified range\n    of ports. The default range of ports to check is 1024 to 49151, which is the\n    set of TCP User Ports. This function automatically excludes some ports which\n    are considered unsafe by web browsers.\n\n    Parameters\n    ----------\n    min\n        Minimum port number.\n    max\n        Maximum port number, inclusive.\n    host\n        Before returning a port number, ensure that we can successfully bind it on this\n        host.\n    n\n        Number of times to attempt before giving up.\n    \"\"\"\n    ...\n\ndef private_random_int(min: int, max: int) -> str:\n    ...\n\n@contextlib.contextmanager\ndef private_seed(): # -> Generator[None, Any, None]:\n    ...\n\ncurrent_random_state = ...\nown_random_state = ...\nT = TypeVar(\"T\")\nP = ParamSpec(\"P\")\ndef wrap_async(fn: Callable[P, T] | Callable[P, Awaitable[T]]) -> Callable[P, Awaitable[T]]:\n    \"\"\"\n    Given a synchronous function that returns T, return an async function that wraps the\n    original function. If the input function is already async, then return it unchanged.\n    \"\"\"\n    ...\n\ndef is_async_callable(obj: Callable[P, T] | Callable[P, Awaitable[T]]) -> TypeGuard[Callable[P, Awaitable[T]]]:\n    \"\"\"\n    Returns True if `obj` is an `async def` function, or if it's an object with a\n    `__call__` method which is an `async def` function. This function should generally\n    be used in this code base instead of iscoroutinefunction().\n    \"\"\"\n    ...\n\ndef run_coro_sync(coro: Awaitable[T]) -> T:\n    \"\"\"\n    Run a coroutine that is in fact synchronous. Given a coroutine (which is\n    returned by calling an `async def` function), this function will run the\n    coroutine for one iteration. If the coroutine completes, then return the\n    value. If it does not complete, then it will throw a `RuntimeError`.\n\n    What it means to be \"in fact synchronous\": the coroutine must not yield\n    control to the event loop. A coroutine may have an `await` expression in it, and that may call another function that has an `await`, but the chain will\n    only yield control if a `yield` statement bubbles through `await`s all the\n    way up. For example, `await asyncio.sleep(0)` will have a `yield` which\n    bubbles up to the next level. Note that a `yield` in a generator used the\n    regular way (not with `await`) will not bubble up, since it is not awaited\n    on.\n    \"\"\"\n    ...\n\ndef run_coro_hybrid(coro: Awaitable[T]) -> asyncio.Future[T]:\n    \"\"\"\n    Synchronously runs the given coro up to its first yield, then runs the rest of the\n    coro by scheduling it on the current event loop, as per normal. You can think of\n    this as either a run_coro_sync() that keeps running in the future, or, as an\n    asyncio.create_task() that starts executing immediately instead of via call_soon.\n\n    The status/result/exception can be access through the returned future. Even if an\n    error happens synchronously, run_coro_hybrid() will not throw, but rather the error\n    will be reported through the future object.\n\n    **PLEASE ONLY USE THIS IF IT'S ABSOLUTELY NECESSARY.** Relative to the official\n    asyncio Task implementation, this is a hastily assembled hack job; who knows what\n    unknown unknowns lurk here.\n    \"\"\"\n    ...\n\nclass Callbacks:\n    def __init__(self) -> None:\n        ...\n    \n    def register(self, fn: Callable[[], None], once: bool = ...) -> Callable[[], None]:\n        ...\n    \n    def invoke(self) -> None:\n        ...\n    \n    def count(self) -> int:\n        ...\n    \n\n\nclass AsyncCallbacks:\n    def __init__(self) -> None:\n        ...\n    \n    def register(self, fn: Callable[[], Awaitable[None]], once: bool = ...) -> Callable[[], None]:\n        ...\n    \n    async def invoke(self) -> None:\n        ...\n    \n    def count(self) -> int:\n        ...\n    \n\n\ndef package_dir(package: str) -> str:\n    ...\n\n",
  "/src/typings/shiny/_validation.pyi": "from typing import TypeVar, overload\nfrom ._docstring import add_example\n\nT = TypeVar(\"T\")\n@overload\ndef req(*, cancel_output: bool = ...) -> None:\n    ...\n\n@overload\ndef req(*args: T, cancel_output: bool = ...) -> T:\n    ...\n\n@add_example()\ndef req(*args: T, cancel_output: bool = ...) -> T | None:\n    \"\"\"\n    Throw a silent exception for falsy values.\n\n    This is a convenient shorthand for throwing :func:`~shiny.types.SilentException` /\n    :func:`~shiny.types.SilentCancelOutputException` if any of the arguments are falsy.\n\n    Parameters\n    ----------\n    args\n        Any number of arguments to check.\n    cancel_output\n        If ``True``, throw :func:`~shiny.types.SilentCancelOutputException` instead of\n        :func:`~shiny.types.SilentException`.\n\n    Returns\n    -------\n    :\n        The first argument. If no arguments are provided, returns ``None``.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/_versions.pyi": "shiny_html_deps = ...\nbslib = ...\nhtmltools = ...\nbootstrap = ...\nrequirejs = ...\n__all__ = (\"shiny_html_deps\", \"bslib\", \"htmltools\", \"bootstrap\", \"requirejs\")\n",
  "/src/typings/shiny/html_dependencies.pyi": "from htmltools import HTMLDependency\n\ndef shiny_deps() -> HTMLDependency:\n    ...\n\ndef jquery_deps() -> HTMLDependency:\n    ...\n\ndef require_deps() -> HTMLDependency:\n    ...\n\n",
  "/src/typings/shiny/http_staticfiles.pyi": "import sys\nimport os\nimport pathlib\nfrom starlette.background import BackgroundTask\nfrom typing import MutableMapping, Optional\nfrom starlette.responses import PlainTextResponse\nfrom starlette.types import Receive, Scope, Send\n\n\"\"\"\nWe can't use starlette's StaticFiles when running in wasm mode, because it launches a\nthread. Instead, use our own crappy version. Fortunately, this is all we need.\n\nWhen running in native Python mode, use the starlette StaticFiles impl; it's battle\ntested, whereas ours is not. Under wasm, it's OK if ours has bugs, even security holes:\neverything is running in the browser sandbox including the filesystem, so there's\nnothing we could disclose that an attacker wouldn't already have access to. The same is\nnot true when running in native Python, we want to be as safe as possible.\n\"\"\"\n__all__ = (\"StaticFiles\", \"FileResponse\")\nif \"pyodide\" not in sys.modules:\n    StaticFiles = ...\n    FileResponse = ...\nelse:\n    class StaticFiles:\n        dir: pathlib.Path\n        root_path: str\n        def __init__(self, *, directory: str | os.PathLike[str]) -> None:\n            ...\n        \n        async def __call__(self, scope: Scope, receive: Receive, send: Send): # -> None:\n            ...\n        \n    \n    \n    class Error404(PlainTextResponse):\n        def __init__(self) -> None:\n            ...\n        \n    \n    \n    class FileResponse:\n        file: pathlib.Path\n        headers: Optional[MutableMapping[str, str]]\n        media_type: str\n        def __init__(self, file: pathlib.Path, headers: Optional[MutableMapping[str, str]] = ..., media_type: Optional[str] = ..., background: Optional[BackgroundTask] = ...) -> None:\n            ...\n        \n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            ...\n        \n    \n    \n",
  "/src/typings/shiny/input_handler.pyi": "from datetime import date, datetime\nfrom typing import Any, Callable, Dict, TYPE_CHECKING\nfrom .session import Session\nfrom .types import ActionButtonValue\n\n__all__ = (\"input_handlers\", )\nif TYPE_CHECKING:\n    ...\nInputHandlerType = Callable[[Any, str, \"Session\"], Any]\nclass _InputHandlers(Dict[str, InputHandlerType]):\n    def __init__(self) -> None:\n        ...\n    \n    def add(self, type: str, force: bool = ...) -> Callable[[InputHandlerType], None]:\n        ...\n    \n    def remove(self, type: str): # -> None:\n        ...\n    \n\n\ninput_handlers: _InputHandlers = ...\n@input_handlers.add(\"shiny.date\")\ndef _(value: str | list[str], name: str, session: Session) -> date | tuple[date, date]:\n    ...\n\n@input_handlers.add(\"shiny.datetime\")\ndef _(value: int | float | list[int] | list[float], name: str, session: Session) -> datetime | tuple[datetime, datetime]:\n    ...\n\n@input_handlers.add(\"shiny.action\")\ndef _(value: int, name: str, session: Session) -> ActionButtonValue:\n    ...\n\n@input_handlers.add(\"shiny.number\")\ndef _(value: str, name: str, session: Session) -> str:\n    ...\n\n@input_handlers.add(\"shiny.password\")\ndef _(value: str, name: str, session: Session) -> str:\n    ...\n\n@input_handlers.add(\"shiny.file\")\ndef _(value: Any, name: str, session: Session) -> Any:\n    ...\n\n",
  "/src/typings/shiny/module.pyi": "from typing import Callable, TypeVar\nfrom ._typing_extensions import Concatenate, ParamSpec\nfrom .session import Inputs, Outputs, Session\n\n__all__ = (\"current_namespace\", \"resolve_id\", \"ui\", \"server\")\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\ndef ui(fn: Callable[P, R]) -> Callable[Concatenate[str, P], R]:\n    ...\n\ndef server(fn: Callable[Concatenate[Inputs, Outputs, Session, P], R]) -> Callable[Concatenate[str, P], R]:\n    ...\n\n",
  "/src/typings/shiny/plotutils.pyi": "import pandas as pd\nfrom typing import Literal, Optional, TYPE_CHECKING, Union\nfrom ._typing_extensions import TypedDict\nfrom .types import BrushInfo, CoordInfo\n\n__all__ = (\"brushed_points\", \"near_points\")\nif TYPE_CHECKING:\n    ...\nDataFrameColumn = Union[\"pd.Series[int]\", \"pd.Series[float]\", \"pd.Series[str]\", \"pd.Categorical\", \"pd.DatetimeIndex\",]\nclass SeriesFloatXY(TypedDict):\n    x: pd.Series[float]\n    y: pd.Series[float]\n    ...\n\n\ndef brushed_points(df: pd.DataFrame, brush: BrushInfo | None, xvar: Optional[str] = ..., yvar: Optional[str] = ..., panelvar1: Optional[str] = ..., panelvar2: Optional[str] = ..., *, all_rows: bool = ...) -> pd.DataFrame:\n    \"\"\"Find rows of data selected on an interactive plot.\n\n    This function is used with interactive plots. It returns the rows of a data frame\n    which are under a brush.\n\n    It currently supports plots created by matplotlib, seaborn, and plotnine. If\n    plotnine is used, it can usually automatically infer the x and y variables, along\n    with variables used for facets.\n\n    Parameters\n    ----------\n    df\n        A pandas DataFrame from which to select rows.\n    brush\n        The data from a brush, like `input.myplot_brush()`.\n    xvar\n        The name of the column in `df` that contains the x values. (Note that when using\n        plotnine, `xvar`, `yvar`, `panelvar1`, and `panelvar2` can usually be\n        automatically inferred from the brush data.)\n    yvar\n        The name of the column in `df` that contains the y values.\n    panelvar1\n        The name of the column in `df` that contains the first variable used for\n        subpanels (if subpanels are used).\n    panelvar2\n        The name of the column in `df` that contains the second variable used for\n        subpanels.\n    all_rows\n        If `False` (the default), return a data frame containing only the rows that are\n        selected. If `True`, then all rows from the data frame will be returned, along\n        with an additional column named `selected_`, which indicates whether or not each\n        row was selected.\n\n    Returns\n    -------\n    :\n        A pandas DataFrame containing the rows selected by the brush. If `all_rows` is\n        `True`, then all rows from the original data will be returned, along with an\n        additional column named `selected_`, which indicates whether or not each row was\n        selected.\n    \"\"\"\n    ...\n\ndef near_points(df: pd.DataFrame, coordinfo: CoordInfo | None, xvar: Optional[str] = ..., yvar: Optional[str] = ..., panelvar1: Optional[str] = ..., panelvar2: Optional[str] = ..., *, threshold: float = ..., max_points: Optional[int] = ..., add_dist: bool = ..., all_rows: bool = ...) -> pd.DataFrame:\n    \"\"\"Find rows of data selected on an interactive plot.\n\n    This function is used with interactive plots. It returns the rows of a data frame\n    which are under a brush.\n\n    It currently supports plots created by matplotlib, seaborn, and plotnine. If\n    plotnine is used, it can usually automatically infer the x and y variables, along\n    with variables used for facets.\n\n    Parameters\n    ----------\n    df\n        A pandas DataFrame from which to select rows.\n    coordinfo\n        The data from a click/dblclick/hover event, like `input.myplot_click()`.\n    xvar\n        The name of the column in `df` that contains the x values. (Note that when using\n        plotnine, `xvar`, `yvar`, `panelvar1`, and `panelvar2` can usually be\n        automatically inferred from the brush data.)\n    yvar\n        The name of the column in `df` that contains the y values.\n    panelvar1\n        The name of the column in `df` that contains the first variable used for\n        subpanels (if subpanels are used).\n    panelvar2\n        The name of the column in `df` that contains the second variable used for\n        subpanels.\n    threshold\n        A maximum distance (in pixels) to the pointer location. Rows in the data frame\n        will be selected if the distance to the pointer is less than `threshold`.\n    max_points\n        Maximum number of rows to return. If `None` (the default), will return all rows\n        within the threshold distance.\n    add_dist\n        If `True`, add a column named `dist_` that contains the distance from the\n        coordinate to the point, in pixels. When no pointer event has yet occurred, the\n        value of `dist_` will be `numpy.NaN`.\n    all_rows\n        If `False` (the default), return a data frame containing only the rows that are\n        selected. If `True`, then all rows from the data frame will be returned, along\n        with an additional column named `selected_`, which indicates whether or not each\n        row was selected.\n\n    Returns\n    -------\n    :\n        A pandas DataFrame containing the rows selected by the brush. If `all_rows` is\n        `True`, then all rows from the original data will be returned, along with an\n        additional column named `selected_`, which indicates whether or not each row was\n        selected.\n    \"\"\"\n    ...\n\ndef within_brush(vals: DataFrameColumn, brush: BrushInfo, var: Literal[\"x\", \"y\"] = ...) -> pd.Series[bool]:\n    ...\n\ndef to_float(x: DataFrameColumn) -> pd.Series[float]:\n    ...\n\ndef map_linear(x: pd.Series[float], domain_min: float, domain_max: float, range_min: float, range_max: float, clip: bool = ...) -> pd.Series[float]:\n    ...\n\ndef scale_1d(val: pd.Series[float], domain_min: float, domain_max: float, range_min: float, range_max: float, logbase: Optional[float] = ..., clip: bool = ...) -> pd.Series[float]:\n    ...\n\ndef scale_coords(x: pd.Series[float], y: pd.Series[float], coordinfo: CoordInfo) -> SeriesFloatXY:\n    ...\n\n",
  "/src/typings/shiny/types.pyi": "from typing import Any, BinaryIO, Literal, Optional, Protocol, TYPE_CHECKING\nfrom htmltools import TagChild\nfrom ._docstring import add_example\nfrom ._typing_extensions import NotRequired, TypedDict\nfrom matplotlib.figure import Figure\n\n__all__ = (\"MISSING\", \"MISSING_TYPE\", \"FileInfo\", \"ImgData\", \"SafeException\", \"SilentException\", \"SilentCancelOutputException\")\nif TYPE_CHECKING:\n    ...\nclass MISSING_TYPE:\n    ...\n\n\nMISSING: MISSING_TYPE = ...\nclass FileInfo(TypedDict):\n    \"\"\"\n    Information about a file upload.\n\n    See Also\n    --------\n    ~shiny.ui.input_file\n\n    Example\n    -------\n    See :func:`~shiny.ui.input_file`.\n    \"\"\"\n    name: str\n    size: int\n    type: str\n    datapath: str\n    ...\n\n\nclass ImgData(TypedDict):\n    \"\"\"\n    Return type for :func:`~shiny.render.image`.\n\n    See Also\n    --------\n    ~shiny.render.image\n\n    Example\n    -------\n    See :func:`~shiny.render.image`.\n    \"\"\"\n    src: str\n    width: NotRequired[str | float]\n    height: NotRequired[str | float]\n    alt: NotRequired[str]\n    style: NotRequired[str]\n    coordmap: NotRequired[Any]\n    ...\n\n\n@add_example()\nclass SafeException(Exception):\n    \"\"\"\n    Throw a safe exception.\n\n    When ``shiny.App.SANITIZE_ERRORS`` is ``True`` (which is the case\n    in some production environments like Posit Connect), exceptions are sanitized\n    to prevent leaking of sensitive information. This class provides a way to\n    generate an error that is OK to be displayed to the user.\n    \"\"\"\n    ...\n\n\n@add_example()\nclass SilentException(Exception):\n    \"\"\"\n    Throw a silent exception.\n\n    Normally, when an exception occurs inside a reactive context, it's either:\n\n    - Displayed to the user (as a big red error message)\n        - This happens when the exception is raised from an output context (e.g., :func:`shiny.render.ui`)\n    - Crashes the application\n        - This happens when the exception is raised from an :func:`shiny.reactive.Effect`\n\n    This exception is used to silently throw inside a reactive context, meaning that\n    execution is paused, and no output is shown to users (or the python console).\n\n    See Also\n    --------\n    ~SilentCancelOutputException\n    \"\"\"\n    ...\n\n\n@add_example()\nclass SilentCancelOutputException(Exception):\n    \"\"\"\n    Throw a silent exception and don't clear output\n\n    Similar to :class:`~SilentException`, but if thrown in an output context,\n    existing output isn't cleared.\n\n    See Also\n    --------\n    ~SilentException\n    \"\"\"\n    ...\n\n\nclass ActionButtonValue(int):\n    ...\n\n\nclass NavSetArg(Protocol):\n    \"\"\"\n    An value suitable for passing to a navigation container (e.g.,\n    :func:`~shiny.ui.navset_tab`).\n    \"\"\"\n    def resolve(self, selected: Optional[str], context: dict[str, Any]) -> tuple[TagChild, TagChild]:\n        \"\"\"\n        Resolve information provided by the navigation container.\n\n        Parameters\n        ----------\n        selected\n            The value of the navigation item to be shown on page load.\n        context\n            Additional context supplied by the navigation container.\n        \"\"\"\n        ...\n    \n    def get_value(self) -> Optional[str]:\n        \"\"\"\n        Get the value of this navigation item (if any).\n\n        This value is only used to determine what navigation item should be shown\n        by default when none is specified (i.e., the first navigation item that\n        returns a value is used to determine the container's ``selected`` value).\n        \"\"\"\n        ...\n    \n\n\nclass PlotnineFigure(Protocol):\n    scales: list[Any]\n    coordinates: Any\n    facet: Any\n    layout: Any\n    mapping: dict[str, str]\n    def save(self, filename: BinaryIO, format: str, units: str, dpi: float, width: float, height: float, verbose: bool, bbox_inches: object = ...): # -> None:\n        ...\n    \n    def draw(self, show: bool) -> Figure:\n        ...\n    \n\n\nclass CoordmapDims(TypedDict):\n    width: float\n    height: float\n    ...\n\n\nclass CoordmapPanelLog(TypedDict):\n    x: float | None\n    y: float | None\n    ...\n\n\nclass CoordmapPanelDomain(TypedDict):\n    left: float\n    right: float\n    bottom: float\n    top: float\n    ...\n\n\nclass CoordmapPanelRange(TypedDict):\n    left: float\n    right: float\n    bottom: float\n    top: float\n    ...\n\n\nclass CoordmapPanelMapping(TypedDict):\n    x: str | None\n    y: str | None\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]\n    ...\n\n\nclass CoordmapPanelvarValues(TypedDict):\n    panelvar1: NotRequired[float]\n    panelvar2: NotRequired[float]\n    ...\n\n\nclass CoordmapPanel(TypedDict):\n    panel: int\n    row: NotRequired[int]\n    col: NotRequired[int]\n    panel_vars: NotRequired[CoordmapPanelvarValues]\n    log: CoordmapPanelLog\n    domain: CoordmapPanelDomain\n    mapping: CoordmapPanelMapping\n    range: CoordmapPanelRange\n    ...\n\n\nclass Coordmap(TypedDict):\n    panels: list[CoordmapPanel]\n    dims: CoordmapDims\n    ...\n\n\nclass CoordXY(TypedDict):\n    x: float\n    y: float\n    ...\n\n\nclass CoordInfo(TypedDict):\n    x: float\n    y: float\n    coords_css: CoordXY\n    coords_img: CoordXY\n    img_css_ratio: CoordXY\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]\n    mapping: CoordmapPanelMapping\n    domain: CoordmapPanelDomain\n    range: CoordmapPanelRange\n    log: CoordmapPanelLog\n    ...\n\n\nclass BrushInfo(TypedDict):\n    xmin: float\n    xmax: float\n    ymin: float\n    ymax: float\n    coords_css: CoordXY\n    coords_img: CoordXY\n    img_css_ratio: CoordXY\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]\n    mapping: CoordmapPanelMapping\n    domain: CoordmapPanelDomain\n    range: CoordmapPanelRange\n    log: CoordmapPanelLog\n    direction: Literal[\"x\", \"y\", \"xy\"]\n    ...\n\n\n",
  "/src/typings/shiny/experimental/__init__.pyi": "from . import ui\n\n__all__ = (\"ui\", )\n",
  "/src/typings/shiny/experimental/ui/__init__.pyi": "from ._accordion import AccordionPanel, accordion, accordion_panel, accordion_panel_close, accordion_panel_insert, accordion_panel_open, accordion_panel_remove, accordion_panel_set, update_accordion_panel\nfrom ._card import CardItem, ImgContainer, TagCallable, WrapperCallable, card, card_body, card_footer, card_header, card_image, card_title\nfrom ._css_unit import CssUnit, as_css_padding, as_css_unit\nfrom ._fill import FillingLayout, as_fill_carrier, as_fill_item, as_fillable_container, is_fill_carrier, is_fill_item, is_fillable_container, remove_all_fill\nfrom ._input_text import input_text_area\nfrom ._layout import layout_column_wrap\nfrom ._navs import navset_bar, navset_pill_card, navset_tab_card\nfrom ._output import output_image, output_plot, output_ui\nfrom ._page import page_fillable, page_navbar, page_sidebar\nfrom ._sidebar import DeprecatedPanelMain, DeprecatedPanelSidebar, Sidebar, layout_sidebar, panel_main, panel_sidebar, sidebar, sidebar_toggle\nfrom ._tooltip import tooltip, tooltip_toggle, update_tooltip\nfrom ._valuebox import showcase_left_center, showcase_top_right, value_box\n\n__all__ = (\"CssUnit\", \"as_css_unit\", \"as_css_padding\", \"DeprecatedPanelMain\", \"DeprecatedPanelSidebar\", \"Sidebar\", \"layout_sidebar\", \"panel_main\", \"panel_sidebar\", \"sidebar\", \"sidebar_toggle\", \"page_sidebar\", \"page_fillable\", \"page_navbar\", \"navset_bar\", \"navset_tab_card\", \"navset_pill_card\", \"CardItem\", \"ImgContainer\", \"TagCallable\", \"WrapperCallable\", \"card\", \"card_header\", \"card_title\", \"card_body\", \"card_image\", \"card_footer\", \"layout_column_wrap\", \"tooltip\", \"tooltip_toggle\", \"update_tooltip\", \"value_box\", \"showcase_left_center\", \"showcase_top_right\", \"FillingLayout\", \"as_fill_carrier\", \"as_fillable_container\", \"as_fill_item\", \"remove_all_fill\", \"is_fill_carrier\", \"is_fillable_container\", \"is_fill_item\", \"output_image\", \"output_plot\", \"output_ui\", \"input_text_area\", \"AccordionPanel\", \"accordion\", \"accordion_panel\", \"accordion_panel_set\", \"accordion_panel_open\", \"accordion_panel_close\", \"accordion_panel_insert\", \"accordion_panel_remove\", \"update_accordion_panel\")\n",
  "/src/typings/shiny/experimental/ui/_accordion.pyi": "from typing import Literal, Optional, TypeVar\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild\nfrom ... import Session\nfrom ...types import MISSING_TYPE\nfrom ._css_unit import CssUnit\n\n__all__ = (\"accordion\", \"accordion_panel\", \"accordion_panel_close\", \"accordion_panel_insert\", \"accordion_panel_open\", \"accordion_panel_remove\", \"accordion_panel_set\", \"update_accordion_panel\")\nclass AccordionPanel:\n    \"\"\"\n    Internal class used to represent an accordion panel.\n\n    This class is used to represent an accordion panel. It is not intended to be\n    instantiated directly. Instead, use :func:`~shiny.experimental.ui.accordion_panel`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the accordion panel body. Or tag attributes that are supplied to the\n        returned :class:`~htmltools.Tag` object.\n    data_value\n        A character string that uniquely identifies this panel.\n    icon\n        A :class:`~htmltools.Tag` which is positioned just before the `title`.\n    title\n        A title to appear in the :func:`~shiny.experimental.ui.accordion_panel`'s header.\n    id\n        A unique id for this panel.\n    **kwargs\n        Tag attributes to the `accordion-body` div Tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    _args: tuple[TagChild | TagAttrs, ...]\n    _kwargs: dict[str, TagAttrValue]\n    _data_value: str\n    _icon: TagChild | None\n    _title: TagChild | None\n    _id: str | None\n    _is_open: bool\n    _is_multiple: bool\n    def __init__(self, *args: TagChild | TagAttrs, data_value: str, icon: TagChild | None, title: TagChild | None, id: str | None, **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def resolve(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object representing the\n            :class:`~shiny.experimental.ui.AccordionPanel`.\n        \"\"\"\n        ...\n    \n    def tagify(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A tagified `resolve()`d value.\n        \"\"\"\n        ...\n    \n\n\ndef accordion(*args: AccordionPanel | TagAttrs, id: Optional[str] = ..., open: Optional[bool | str | list[str]] = ..., multiple: bool = ..., class_: Optional[str] = ..., width: Optional[CssUnit] = ..., height: Optional[CssUnit] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a vertically collapsing accordion.\n\n    Parameters\n    ----------\n    *args\n        :class:`~shiny.experimental.ui.AccordionPanel` objects returned from\n        :func:`~shiny.experimental.ui.accordion_panel`. Or tag attributes that are\n        supplied to the returned :class:`~htmltools.Tag` object.\n    id\n        If provided, you can use `input.id()` in your server logic to determine which of\n        the :func:`~shiny.experimental.ui.accordion_panel`s are currently active. The\n        value will correspond to the :func:`~shiny.experimental.ui.accordion_panel`'s\n        `value` argument.\n    open\n        A list of :func:`~shiny.experimental.ui.accordion_panel` values to open (i.e.,\n        show) by default. The default value of `None` will open the first\n        :func:`~shiny.experimental.ui.accordion_panel`. Use a value of `True` to open\n        all (or `False` to open none) of the items. It's only possible to open more than\n        one panel when `multiple=True`.\n    multiple\n        Whether multiple :func:`~shiny.experimental.ui.accordion_panel` can be open at\n        once.\n    class_\n        Additional CSS classes to include on the accordion div.\n    width\n        Any valid CSS unit; for example, height=\"100%\".\n    height\n        Any valid CSS unit; for example, height=\"100%\".\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        Accordion panel Tag object.\n\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel(title: TagChild, *args: TagChild | TagAttrs, value: Optional[str] | MISSING_TYPE = ..., icon: Optional[TagChild] = ..., **kwargs: TagAttrValue) -> AccordionPanel:\n    \"\"\"\n    Single accordion panel.\n\n    Parameters\n    ----------\n    title\n        A title to appear in the :func:`~shiny.experimental.ui.accordion_panel`'s header.\n    *args\n        Contents to the accordion panel body. Or tag attributes that are supplied to the\n        returned :class:`~htmltools.Tag` object.\n    value\n        A character string that uniquely identifies this panel. If `MISSING`, the\n        `title` will be used.\n    icon\n        A :class:`~htmltools.Tag` which is positioned just before the `title`.\n    **kwargs\n        Tag attributes to the `accordion-body` div Tag.\n\n    Returns\n    -------\n    :\n        `AccordionPanel` object.\n\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel_set(id: str, values: bool | str | list[str], session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Dynamically set accordions panel state\n\n    Dynamically (i.e., programmatically) update/modify :func:`~shiny.experimental.ui.accordion`s in a Shiny app.\n    These functions require an `id` to be provided to the :func:`~shiny.experimental.ui.accordion` and must also be\n    called within an active Shiny session.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel_open(id: str, values: bool | str | list[str], session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Open a set of :func:`~shiny.experimental.ui.accordion_panel`s.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel_close(id: str, values: bool | str | list[str], session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Close a set of accordion panels in an :func:`~shiny.experimental.ui.accordion`.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel_insert(id: str, panel: AccordionPanel, target: Optional[str] = ..., position: Literal[\"after\", \"before\"] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Insert an :func:`~shiny.experimental.ui.accordion_panel`\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    panel\n        An :func:`~shiny.experimental.ui.accordion_panel` object to insert.\n    target\n        The `value` of an existing panel to insert next to.\n    position\n        Should `panel` be added before or after the target? When `target=None`,\n        `\"after\"` will append after the last panel and `\"before\"` will prepend before\n        the first panel.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\ndef accordion_panel_remove(id: str, target: str | list[str], session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Remove an :func:`~shiny.experimental.ui.accordion_panel`\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    target\n        The `value` of an existing panel to remove.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    ...\n\nT = TypeVar(\"T\")\ndef update_accordion_panel(id: str, target: str, *body: TagChild, title: TagChild | None | MISSING_TYPE = ..., value: str | None | MISSING_TYPE = ..., icon: TagChild | None | MISSING_TYPE = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Dynamically update accordions panel contents\n\n    Dynamically (i.e., programmatically) update/modify :func:`~shiny.experimental.ui.accordion` panels in a Shiny app.\n    These functions require an `id` to be provided to the :func:`~shiny.experimental.ui.accordion` and must also be\n    called within an active Shiny session.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    target\n        The `value` of an existing panel to update.\n    *body\n        If provided, the new body contents of the panel.\n    title\n        If not missing, the new title of the panel.\n    value\n        If not missing, the new value of the panel.\n    icon\n        If not missing, the new icon of the panel.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_card.pyi": "import io\nfrom pathlib import Path, PurePath\nfrom typing import Literal, Optional, Protocol\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild, TagList, Tagifiable\nfrom ...types import MISSING_TYPE\nfrom ._css_unit import CssUnit\n\n__all__ = (\"CardItem\", \"card\", \"card_body\", \"card_title\", \"card_header\", \"card_footer\", \"card_image\")\ndef card(*args: TagChild | TagAttrs | CardItem, full_screen: bool = ..., height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ..., min_height: Optional[CssUnit] = ..., fill: bool = ..., class_: Optional[str] = ..., wrapper: WrapperCallable | None | MISSING_TYPE = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    A Bootstrap card component\n\n    A general purpose container for grouping related UI elements together with a border\n    and optional padding. To learn more about `card()`s, see [this\n    article](https://rstudio.github.io/bslib/articles/cards.html).\n\n    Parameters\n    ----------\n    *args\n        Unnamed arguments can be any valid child of an :class:`~htmltools.Tag` (which\n        includes card items such as :func:`~shiny.experimental.ui.card_body`. Named\n        arguments become HTML attributes on the returned Tag.\n    full_screen\n        If `True`, an icon will appear when hovering over the card body. Clicking the\n        icon expands the card to fit viewport size.\n    height,max_height,min_height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether or not to allow the card to grow/shrink to fit a fillable container with\n        an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    class_\n        Additional CSS classes for the returned Tag.\n    wrapper\n        A function (which returns a UI element) to call on unnamed arguments in `*args`\n        which are not already card item(s) (like\n        :func:`~shiny.experimental.ui.card_header`,\n        :func:`~shiny.experimental.ui.card_body`, etc.). Note that non-card items are\n        grouped together into one `wrapper` call (e.g. given `card(\"a\", \"b\",\n        card_body(\"c\"), \"d\")`, `wrapper` would be called twice, once with `\"a\"` and\n        `\"b\"` and once with `\"d\"`).\n\n    Returns\n    -------\n    :\n        An :func:`~htmltools.div` tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_column_wrap` for laying out multiple cards\n      (or multiple columns inside a card).\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    ...\n\nclass CardItem:\n    \"\"\"\n    A wrapper around a :class:`~htmltools.Tag` object that represents a card item (e.g.,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.card_header`, etc.).\n\n    This class is used to allow for consecutive non-card items to be bundled into a\n    single `card_body` within :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    item\n        A :class:`~htmltools.Tag` object that represents a card item (e.g.,\n        :func:`~shiny.experimental.ui.card_body`, :func:`~shiny.experimental.ui.card_header`, etc.).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    \"\"\"\n    def __init__(self, item: TagChild) -> None:\n        ...\n    \n    def resolve(self) -> TagChild:\n        \"\"\"\n        Resolves the `CardItem` class by returning the `item` provided at initialization.\n\n        Returns\n        -------\n        :\n            The `item` provided at initialization.\n        \"\"\"\n        ...\n    \n    def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `item`\n\n        Returns\n        -------\n        :\n            A tagified :class:`~htmltools.TagList` object.\n        \"\"\"\n        ...\n    \n\n\ndef card_body(*args: TagChild | TagAttrs, fillable: bool = ..., min_height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ..., max_height_full_screen: Optional[CssUnit] | MISSING_TYPE = ..., height: Optional[CssUnit] = ..., padding: Optional[CssUnit | list[CssUnit]] = ..., gap: Optional[CssUnit] = ..., fill: bool = ..., class_: Optional[str] = ..., **kwargs: TagAttrValue) -> CardItem:\n    \"\"\"\n    Card body container\n\n    A general container for the \"main content\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as direct children to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the card's body. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    fillable\n        Whether or not the card item should be a fillable (i.e. flexbox) container.\n    min_height,max_height,max_height_full_screen\n        Any valid CSS length unit. If `max_height_full_screen` is missing, it is set to\n        `max_height`.\n    height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    padding\n        Padding to use for the body. This can be a numeric vector\n        (which will be interpreted as pixels) or a character vector with valid CSS\n        lengths. The length can be between one and four. If one, then that value\n        will be used for all four sides. If two, then the first value will be used\n        for the top and bottom, while the second value will be used for left and\n        right. If three, then the first will be used for top, the second will be\n        left and right, and the third will be bottom. If four, then the values will\n        be interpreted as top, right, bottom, and left respectively.\n    gap\n        A CSS length unit defining the `gap` (i.e., spacing) between elements provided\n        to `*args`. This argument is only applicable when `fillable = TRUE`.\n    fill\n        Whether to allow this element to grow/shrink to fit its `card` container.\n    class_\n        Additional CSS classes for the returned Tag.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_column_wrap` for laying out multiple cards\n        (or multiple columns inside a card).\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    ...\n\nclass WrapperCallable(Protocol):\n    \"\"\"\n    A callable that wraps children into a :func:`~shiny.experimental.ui.CardItem`.\n    \"\"\"\n    def __call__(self, *args: TagChild) -> CardItem:\n        \"\"\"\n        Wraps children into a :func:`~shiny.experimental.ui.CardItem`.\n\n        Parameters\n        ----------\n        *args\n            `TagChild` children to wrap.\n\n        Returns\n        -------\n        :\n            A :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...\n    \n\n\nclass TagCallable(Protocol):\n    \"\"\"\n    Callable definition for a defined :class:`~htmltools.Tag` method.\n\n    This is used to define the `container` argument in :func:`~shiny.experimental.ui.card_title`,\n    :func:`~shiny.experimental.ui.card_header`, and :func:`~shiny.experimental.ui.card_footer`.\n\n    See Also\n    --------\n    * :class:`~htmltools.Tag`\n    \"\"\"\n    def __call__(self, *args: TagChild | TagAttrs, _add_ws: bool = ..., **kwargs: TagAttrValue) -> Tagifiable:\n        \"\"\"\n        A tag method.\n\n        Parameters\n        ----------\n        *args\n            Contents to the tag method. Or tag attributes that are supplied to the\n            resolved :class:`~htmltools.Tag` object.\n        _add_ws\n            Whether or not to add whitespace to the returned :class:`~htmltools.Tag`\n            object.\n        **kwargs\n            Additional HTML attributes for the returned Tag.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object.\n        \"\"\"\n        ...\n    \n\n\ndef card_title(*args: TagChild | TagAttrs, container: TagCallable = ..., **kwargs: TagAttrValue) -> Tagifiable:\n    \"\"\"\n    Card title container\n\n    A general container for the \"title\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the card's title. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    container\n        Method for the returned Tag object. Defaults to :func:`shiny.ui.tags.h5`.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A Tag object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    ...\n\ndef card_header(*args: TagChild | TagAttrs, container: TagCallable = ..., **kwargs: TagAttrValue) -> CardItem:\n    \"\"\"\n    Card header container\n\n    A general container for the \"header\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    The header has a different background color and border than the rest of the card.\n\n    Parameters\n    ----------\n    *args\n        Contents to the header container. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    container\n        Method for the returned Tag object. Defaults to :func:`~shiny.ui.tags.div`.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    ...\n\ndef card_footer(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> CardItem:\n    \"\"\"\n    Card footer container\n\n    A general container for the \"footer\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    The footer has a different background color and border than the rest of the card.\n\n    Parameters\n    ----------\n    *args\n        Contents to the footer container. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    ...\n\nclass ImgContainer(Protocol):\n    \"\"\"\n    A callable that wraps the return value of `card_image()`. To isolate your object in a card, return a :func:`~shiny.experimental.ui.CardItem`.\n    \"\"\"\n    def __call__(self, *args: Tag) -> Tagifiable:\n        \"\"\"\n        Wraps the return value of `card_image()`.\n\n        Parameters\n        ----------\n        *args\n            The return value of `card_image()`.\n\n        Returns\n        -------\n        :\n            A tagifiable object, such as a :class:`~htmltools.Tag` or\n            :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...\n    \n\n\ndef card_image(file: str | Path | PurePath | io.BytesIO | None, *args: TagAttrs, href: Optional[str] = ..., border_radius: Literal[\"top\", \"bottom\", \"all\", \"none\"] = ..., mime_type: Optional[str] = ..., class_: Optional[str] = ..., height: Optional[CssUnit] = ..., fill: bool = ..., width: Optional[CssUnit] = ..., container: ImgContainer = ..., **kwargs: TagAttrValue) -> Tagifiable:\n    \"\"\"\n    Card image container\n\n    A general container for an image within a :func:`~shiny.experimental.ui.card`. This component is designed to be\n    provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    file\n        A file path pointing an image. The image will be base64 encoded and provided to\n        the `src` attribute of the `<img>`. Alternatively, you may set this value to\n        `None` and provide the `src` yourself via `*args:TagAttrs` or\n        `**kwargs:TagAttrValue` (e.g. `{\"src\": \"HOSTED_PATH_TO_IMAGE\"}` or\n        `src=\"HOSTED_PATH_TO_IMAGE\"`).\n    *args\n        Dictionary of tag attributes that are supplied to the resolved\n        :class:`~htmltools.Tag` object.\n    href\n        An optional URL to link to.\n    border_radius\n        Where to apply `border-radius` on the image.\n    mime_type\n        The mime type of the `file`.\n    class_\n        Additional CSS classes for the resolved Tag.\n    height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether to allow this element to grow/shrink to fit its `card` container.\n    width\n        Any valid CSS unit (e.g., `width=\"100%\"`).\n    container\n        Method to wrap the returned Tag object. Defaults to :func:`~shiny.experimental.ui.card_body`.\n        If :func:`~shiny.experimental.ui.card_body` is used, each image will be in separate cards. If\n        the `container` method does not return a :class:`~shiny.experimental.ui.CardItem`, it\n        allows for consecutive non-`CardItem` objects to be bundled into a single\n        :func:`~.shiny.experimental.card_body` within :func:`~shiny.experimental.ui.card`.\n    **kwargs\n        Additional HTML attributes for the resolved Tag.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_css_unit.pyi": "from typing import Union, overload\n\n__all__ = (\"CssUnit\", \"as_css_unit\", \"as_css_padding\")\nCssUnit = Union[int, float, str,]\n@overload\ndef as_css_unit(value: None) -> None:\n    ...\n\n@overload\ndef as_css_unit(value: CssUnit) -> str:\n    ...\n\ndef as_css_unit(value: None | CssUnit) -> None | str:\n    \"\"\"\n    Convert a value into a CSS unit.\n\n    Parameters\n    ----------\n    value\n        A value to convert into a CSS unit.\n\n    Returns\n    -------\n    :\n        If the `value` is `None`, then `None`. If the value is `0`, then `\"0\"`. If the `value` is numeric, then a formatted pixel value. Otherwise, the `value` as-is.\n    \"\"\"\n    ...\n\n@overload\ndef as_css_padding(padding: CssUnit | list[CssUnit]) -> str:\n    ...\n\n@overload\ndef as_css_padding(padding: None) -> None:\n    ...\n\ndef as_css_padding(padding: CssUnit | list[CssUnit] | None) -> str | None:\n    \"\"\"\n    Convert a CSS unit or list of CSS units into a CSS padding value.\n\n    Parameters\n    ----------\n    padding\n        A CSS unit or list of CSS units.\n\n    Returns\n    -------\n    :\n        A CSS padding value.\n    \"\"\"\n    ...\n\ndef as_width_unit(x: str | float | int) -> str:\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_fill.pyi": "from typing import Optional, Protocol, TypeVar, runtime_checkable\nfrom htmltools import Tag, TagChild\nfrom ._css_unit import CssUnit\n\n__all__ = (\"bind_fill_role\", \"as_fill_carrier\", \"as_fillable_container\", \"as_fill_item\", \"remove_all_fill\", \"is_fill_carrier\", \"is_fillable_container\", \"is_fill_item\", \"FillingLayout\")\nTagFillingLayoutT = TypeVar(\"TagFillingLayoutT\", bound=\"Tag | FillingLayout\")\nTagT = TypeVar(\"TagT\", bound=\"Tag\")\nFILL_ITEM_CLASS = ...\nFILL_CONTAINER_CLASS = ...\ndef bind_fill_role(tag: TagT, *, item: Optional[bool] = ..., container: Optional[bool] = ..., overwrite: bool = ...) -> TagT:\n    \"\"\"\n    Allow tags to intelligently fill their container\n\n    Create fill containers and items. If a fill item is a direct child of a fill\n    container, and that container has an opinionated height, then the item is allowed to\n    grow and shrink to its container's size.\n\n    Parameters\n    ----------\n    tag\n        a T object.\n    item\n        whether or not to treat `tag` as a fill item.\n    container\n        whether or not to treat `x` as a fill container. Note, this will set the CSS\n        `display` property on the tag to `flex` which can change how its direct children\n        are rendered. Thus, one should be careful not to mark a tag as a fill container\n        when it needs to rely on other `display` behavior.\n    overwrite\n        whether or not to override previous filling layout calls (e.g., to remove the\n        item/container role from a tag).\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HtmlDependency`).\n    \"\"\"\n    ...\n\ndef as_fill_carrier(tag: TagFillingLayoutT, *, min_height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ..., gap: Optional[CssUnit] = ...) -> TagFillingLayoutT:\n    \"\"\"\n    Make a tag a fill carrier\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height,gap\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HtmlDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef as_fillable_container(tag: TagFillingLayoutT, *, min_height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ..., gap: Optional[CssUnit] = ...) -> TagFillingLayoutT:\n    \"\"\"\n    Coerce a tag to be a fillable container\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height,gap\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HtmlDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef as_fill_item(tag: TagFillingLayoutT, *, min_height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ...) -> TagFillingLayoutT:\n    \"\"\"\n    Coerce a tag to a fill item\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HtmlDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef remove_all_fill(tag: TagFillingLayoutT) -> TagFillingLayoutT:\n    \"\"\"\n    Remove any filling layouts from a tag\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object with filling layout attributes\n        removed.\n\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef is_fill_carrier(tag: Tag | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fill carrier\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fill carrier.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef is_fillable_container(tag: TagChild | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fillable container\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fillable container.\n\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\ndef is_fill_item(tag: TagChild | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fill item\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fill item.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    ...\n\nT = TypeVar(\"T\")\n@runtime_checkable\nclass FillingLayout(Protocol):\n    \"\"\"\n    Generic protocol for filling layouts objects\n    \"\"\"\n    def add_class(self: T, class_: str, **kwargs: object) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `class` to an object\n\n        Parameters\n        ----------\n        class_\n            A character vector of class names to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n    \n    def add_style(self: T, style: str, **kwargs: object) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `style` to an object\n\n        Parameters\n        ----------\n        style\n            A character vector of CSS properties to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n    \n    def is_fill_item(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fill item\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fill item\n        \"\"\"\n        ...\n    \n    def is_fillable_container(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fillable container\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fillable container\n        \"\"\"\n        ...\n    \n    def as_fill_item(self: T) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fill item\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n    \n    def as_fillable_container(self: T) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fillable container\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n    \n    def remove_all_fill(self: T) -> T:\n        \"\"\"\n        Generic method to handle removing all fill properties from an object\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n    \n\n\n",
  "/src/typings/shiny/experimental/ui/_htmldeps.pyi": "from typing import Literal\nfrom htmltools import HTMLDependency\nfrom ..._typing_extensions import NotRequired, TypedDict\n\n_x_www = ...\n_x_www_path = ...\n_x_htmltools_path = ...\n_x_components_path = ...\nclass _ScriptItemDict(TypedDict):\n    src: str\n    type: NotRequired[Literal[\"module\"]]\n    ...\n\n\ndef fill_dependency() -> HTMLDependency:\n    ...\n\ndef accordion_dependency() -> HTMLDependency:\n    ...\n\ndef card_dependency() -> HTMLDependency:\n    ...\n\ndef grid_dependency() -> HTMLDependency:\n    ...\n\ndef page_fillable_dependency() -> HTMLDependency:\n    ...\n\ndef page_sidebar_dependency() -> HTMLDependency:\n    ...\n\ndef sidebar_dependency() -> HTMLDependency:\n    ...\n\ndef value_box_dependency() -> HTMLDependency:\n    ...\n\ndef web_component_dependency() -> HTMLDependency:\n    ...\n\ndef autoresize_dependency(): # -> HTMLDependency:\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_input_text.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagChild\n\n__all__ = (\"input_text_area\", )\ndef input_text_area(id: str, label: TagChild, value: str = ..., *, width: Optional[str] = ..., height: Optional[str] = ..., cols: Optional[int] = ..., rows: Optional[int] = ..., placeholder: Optional[str] = ..., resize: Optional[Literal[\"none\", \"both\", \"horizontal\", \"vertical\"]] = ..., autoresize: bool = ..., autocomplete: Optional[str] = ..., spellcheck: Optional[Literal[\"true\", \"false\"]] = ...) -> Tag:\n    \"\"\"\n    Create a textarea input control for entry of unstructured text values. This is an\n    experimental version of :func:`~shiny.ui.input_text_area` that can automatically\n    resize to fit the input text.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    height\n        The CSS height, e.g. '400px', or '100%'\n    cols\n        Value of the visible character columns of the input, e.g. 80. This argument will\n        only take effect if there is not a CSS width rule defined for this element; such\n        a rule could come from the width argument of this function or from a containing\n        page layout such as :func:`~shiny.ui.page_fluid`.\n    rows\n        The value of the visible character rows of the input, e.g. 6. If the height\n        argument is specified, height will take precedence in the browser's rendering.\n    placeholder\n        A hint as to what can be entered into the control.\n    resize\n        Which directions the textarea box can be resized. Can be one of \"both\", \"none\",\n        \"vertical\", and \"horizontal\". The default, ``None``, will use the client\n        browser's default setting for resizing textareas.\n    autoresize\n        If True, then the textarea will automatically resize the height to fit the input\n        text.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is \"off\").\n        If `None`, then it will use the browser's default behavior. Other possible\n        values include \"on\", \"name\", \"username\", and \"email\". See [Mozila's autocomplete\n        documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)\n        for more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    :func:`~shiny.ui.input_text`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_layout.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild\nfrom ._css_unit import CssUnit\n\ndef layout_column_wrap(width: Optional[CssUnit], *args: TagChild | TagAttrs, fixed_width: bool = ..., heights_equal: Literal[\"all\", \"row\"] = ..., fill: bool = ..., fillable: bool = ..., height: Optional[CssUnit] = ..., height_mobile: Optional[CssUnit] = ..., gap: Optional[CssUnit] = ..., class_: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    A grid-like, column-first layout\n\n    Wraps a 1d sequence of UI elements into a 2d grid. The number of columns (and rows)\n    in the grid dependent on the column `width` as well as the size of the display.\n\n    Parameters\n    ----------\n    width\n        The desired width of each card. It can be a (unit-less) number between 0 and 1\n        and should be specified as `1/num`, where `num` represents the number of desired\n        columns. It can be a CSS length unit representing either the minimum (when\n        `fixed_width=False`) or fixed width (`fixed_width=True`). It can also be `None`,\n        which allows power users to set the `grid-template-columns` CSS property\n        manually, either via a `style` attribute or a CSS stylesheet.\n    *args\n        Unnamed arguments should be UI elements (e.g.,\n        :func:`~shiny.experimental.ui.card`). Named arguments become attributes on the\n        containing :class:`~htmltools.Tag` element.\n    fixed_width\n        Whether or not to interpret the `width` as a minimum (`fixed_width=False`) or\n        fixed (`fixed_width=True`) width when it is a CSS length unit.\n    heights_equal\n        If `\"all\"` (the default), every card in every row of the grid will have the same\n        height. If `\"row\"`, then every card in _each_ row of the grid will have the same\n        height, but heights may vary between rows.\n    fill\n        Whether or not to allow the layout to grow/shrink to fit a fillable container\n        with an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    fillable\n        Whether or not each element is wrapped in a fillable container.\n    height\n        Any valid CSS unit to use for the height.\n    height_mobile\n        Any valid CSS unit to use for the height when on mobile devices (or narrow\n        windows).\n    gap\n        Any valid CSS unit to use for the gap between columns.\n    class_\n        A CSS class to apply to the containing element.\n    **kwargs\n        Additional attributes to apply to the containing element.\n\n    Returns\n    -------\n    :\n        A :class:`~htmltools.Tag` element.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_navs.pyi": "from typing import Any, Literal, Optional, Sequence\nfrom htmltools import MetadataNode, Tag, TagChild, TagList\nfrom ...types import NavSetArg\nfrom ._card import CardItem\nfrom ._css_unit import CssUnit\nfrom ._sidebar import Sidebar\n\n__all__ = (\"navset_bar\", \"navset_tab_card\", \"navset_pill_card\")\nclass Nav:\n    nav: Tag\n    content: Optional[Tag]\n    def __init__(self, nav: Tag, content: Optional[Tag] = ...) -> None:\n        ...\n    \n    def resolve(self, selected: Optional[str], context: dict[str, Any]) -> tuple[TagChild, TagChild]:\n        ...\n    \n    def get_value(self) -> Optional[str]:\n        ...\n    \n    def tagify(self) -> None:\n        ...\n    \n\n\nclass NavSet:\n    args: tuple[NavSetArg | MetadataNode]\n    ul_class: str\n    id: Optional[str]\n    selected: Optional[str]\n    header: TagChild\n    footer: TagChild\n    def __init__(self, *args: NavSetArg | MetadataNode, ul_class: str, id: Optional[str], selected: Optional[str], header: TagChild = ..., footer: TagChild = ...) -> None:\n        ...\n    \n    def tagify(self) -> TagList | Tag:\n        ...\n    \n    def layout(self, nav: Tag, content: Tag) -> TagList | Tag:\n        ...\n    \n\n\nclass NavSetCard(NavSet):\n    placement: Literal[\"above\", \"below\"]\n    sidebar: Optional[Sidebar]\n    def __init__(self, *args: NavSetArg, ul_class: str, id: Optional[str], selected: Optional[str], sidebar: Optional[Sidebar] = ..., header: TagChild = ..., footer: TagChild = ..., placement: Literal[\"above\", \"below\"] = ...) -> None:\n        ...\n    \n    def layout(self, nav: Tag, content: Tag) -> Tag:\n        ...\n    \n\n\ndef navset_card_body(content: Tag, sidebar: Optional[Sidebar] = ...) -> CardItem:\n    ...\n\ndef navset_tab_card(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., sidebar: Optional[Sidebar] = ..., header: TagChild = ..., footer: TagChild = ...) -> NavSetCard:\n    \"\"\"\n    Render nav items as a tabset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.experimental.ui.navset_bar\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_pill_card\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\ndef navset_pill_card(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., sidebar: Optional[Sidebar] = ..., header: TagChild = ..., footer: TagChild = ..., placement: Literal[\"above\", \"below\"] = ...) -> NavSetCard:\n    \"\"\"\n    Render nav items as a pillset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    placement\n        Placement of the nav items relative to the content.\n\n    See Also\n    -------\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.experimental.ui.navset_bar\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_tab_card\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\nclass NavSetBar(NavSet):\n    title: TagChild\n    sidebar: Optional[Sidebar]\n    fillable: bool | list[str]\n    gap: Optional[CssUnit]\n    padding: Optional[CssUnit | list[CssUnit]]\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"]\n    bg: Optional[str]\n    inverse: bool\n    collapsible: bool\n    fluid: bool\n    def __init__(self, *args: NavSetArg | MetadataNode, ul_class: str, title: TagChild, id: Optional[str], selected: Optional[str], sidebar: Optional[Sidebar] = ..., fillable: bool | list[str] = ..., gap: Optional[CssUnit], padding: Optional[CssUnit | list[CssUnit]], position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"] = ..., header: TagChild = ..., footer: TagChild = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ...) -> None:\n        ...\n    \n    def layout(self, nav: Tag, content: Tag) -> TagList:\n        ...\n    \n\n\ndef navset_bar(*args: NavSetArg | MetadataNode | Sequence[MetadataNode], title: TagChild, id: Optional[str] = ..., selected: Optional[str] = ..., sidebar: Optional[Sidebar] = ..., fillable: bool | list[str] = ..., gap: Optional[CssUnit] = ..., padding: Optional[CssUnit | list[CssUnit]] = ..., position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"] = ..., header: TagChild = ..., footer: TagChild = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ...) -> NavSetBar:\n    \"\"\"\n    Render nav items as a navbar.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    title\n        Title to display in the navbar.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n\n    See Also\n    -------\n    * ~shiny.ui.page_navbar\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_tab_card\n    * ~shiny.experimental.ui.navset_pill_card\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_output.pyi": "from typing import Optional\nfrom htmltools import Tag, TagAttrValue, TagFunction\nfrom ...types import MISSING_TYPE\nfrom ...ui._plot_output_opts import BrushOpts, ClickOpts, DblClickOpts, HoverOpts\n\ndef output_plot(id: str, width: str = ..., height: str = ..., *, inline: bool = ..., click: bool | ClickOpts = ..., dblclick: bool | DblClickOpts = ..., hover: bool | HoverOpts = ..., brush: bool | BrushOpts = ..., fill: bool | MISSING_TYPE = ...) -> Tag:\n    \"\"\"\n    Create a output container for a static plot.\n\n    Place a :func:`~shiny.render.plot` result in the user interface. See\n    :func:`~shiny.render.plot` for more details on what types of plots are supported.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    * :func:`~shiny.render.plot`\n    * :func:`~shiny.ui.output_image`\n    \"\"\"\n    ...\n\ndef output_image(id: str, width: str = ..., height: str = ..., *, inline: bool = ..., click: bool | ClickOpts = ..., dblclick: bool | DblClickOpts = ..., hover: bool | HoverOpts = ..., brush: bool | BrushOpts = ..., fill: bool = ...) -> Tag:\n    \"\"\"\n    Create a output container for a static image.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.image\n    ~shiny.ui.output_plot\n    \"\"\"\n    ...\n\ndef output_ui(id: str, inline: bool = ..., container: Optional[TagFunction] = ..., fill: bool = ..., fillable: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a output container for a UI (i.e., HTML) element.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n    kwargs\n        Attributes to be applied to the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_text\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_page.pyi": "from typing import Literal, Optional, Sequence\nfrom htmltools import MetadataNode, Tag, TagAttrValue, TagAttrs, TagChild, TagList\nfrom ...types import MISSING_TYPE, NavSetArg\nfrom ._css_unit import CssUnit\nfrom ._sidebar import Sidebar\n\ndef page_sidebar(sidebar: Sidebar | TagChild | TagAttrs, *args: TagChild | TagAttrs, title: Optional[str | Tag | TagList] = ..., fillable: bool = ..., fillable_mobile: bool = ..., window_title: str | MISSING_TYPE = ..., lang: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a page with a sidebar and a title.\n\n    Parameters\n    ----------\n    args\n        UI elements.\n    sidebar\n        Content to display in the sidebar.\n    title\n        A title to display at the top of the page.\n    fillable\n        Whether or not the main content area should be considered a fillable\n        (i.e., flexbox) container.\n    fillable_mobile\n        Whether or not ``fillable`` should apply on mobile devices.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Additional attributes passed to :func:`~shiny.ui.layout_sidebar`.\n\n    Returns\n    -------\n    :\n        A UI element.\n    \"\"\"\n    ...\n\ndef page_navbar(*args: NavSetArg | MetadataNode | Sequence[MetadataNode], title: Optional[str | Tag | TagList] = ..., id: Optional[str] = ..., selected: Optional[str] = ..., sidebar: Optional[Sidebar] = ..., fillable: bool | list[str] = ..., fillable_mobile: bool = ..., gap: Optional[CssUnit] = ..., padding: Optional[CssUnit | list[CssUnit]] = ..., position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\"] = ..., header: Optional[TagChild] = ..., footer: Optional[TagChild] = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ..., window_title: str | MISSING_TYPE = ..., lang: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a page with a navbar and a title.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    sidebar\n        A :func:`~shiny.ui.sidebar` component to display on every page.\n    fillable\n        Whether or not the main content area should be considered a fillable\n        (i.e., flexbox) container.\n    fillable_mobile\n        Whether or not ``fillable`` should apply on mobile devices.\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    * :func:`~shiny.ui.nav`\n    * :func:`~shiny.ui.nav_menu`\n    * :func:`~shiny.experimental.ui.navset_bar`\n    * :func:`~shiny.ui.page_fluid`\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n    ...\n\ndef page_fillable(*args: TagChild | TagAttrs, padding: Optional[CssUnit | list[CssUnit]] = ..., gap: Optional[CssUnit] = ..., fillable_mobile: bool = ..., title: Optional[str] = ..., lang: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates a fillable page\n\n    Parameters\n    ----------\n    *args\n        UI elements.\n    padding\n        Padding to use for the body. See :func:`~shiny.experimental.ui.as_css_padding`\n        for more details.\n    fillable_mobile\n        Whether or not the page should fill the viewport's height on mobile devices\n        (i.e., narrow windows).\n    gap\n        A CSS length unit passed through :func:`~shiny.experimental.ui.as_css_unit`\n        defining the `gap` (i.e., spacing) between elements provided to `*args`.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    * :func:`~shiny.ui.page_fluid`\n    * :func:`~shiny.ui.page_fixed`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_sidebar.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild, TagList\nfrom ... import Session\nfrom ._card import CardItem\nfrom ._css_unit import CssUnit\n\nclass Sidebar:\n    \"\"\"\n    Sidebar object\n\n    Class returned from :func:`~shiny.experimental.ui.sidebar`. Please do not use this\n    class directly. Instead, supply the :func:`~shiny.experimental.ui.sidebar` object to\n    :func:`~shiny.experimental.ui.layout_sidebar`.\n\n    Attributes\n    ----------\n    tag\n        The :class:`~htmltools.Tag` object that represents the sidebar.\n    collapse_tag\n        The :class:`~htmltools.Tag` object that represents the collapse button.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n    color_fg\n        A foreground color.\n    color_bg\n        A background color.\n\n    Parameters\n    ----------\n    tag\n        The :class:`~htmltools.Tag` object that represents the sidebar.\n    collapse_tag\n        The :class:`~htmltools.Tag` object that represents the collapse button.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n    color_fg\n        A foreground color.\n    color_bg\n        A background color.\n\n\n    \"\"\"\n    def __init__(self, tag: Tag, collapse_tag: Optional[Tag], position: Literal[\"left\", \"right\"], open: Literal[\"desktop\", \"open\", \"closed\", \"always\"], width: CssUnit, max_height_mobile: Optional[str | float], color_fg: Optional[str], color_bg: Optional[str]) -> None:\n        ...\n    \n    def tagify(self) -> Tag:\n        \"\"\"\n        Not implemented\n        \"\"\"\n        ...\n    \n\n\ndef sidebar(*args: TagChild | TagAttrs, width: CssUnit = ..., position: Literal[\"left\", \"right\"] = ..., open: Literal[\"desktop\", \"open\", \"closed\", \"always\"] = ..., id: Optional[str] = ..., title: TagChild | str = ..., bg: Optional[str] = ..., fg: Optional[str] = ..., class_: Optional[str] = ..., max_height_mobile: Optional[str | float] = ...) -> Sidebar:\n    \"\"\"\n    Sidebar element\n\n    Create a collapsing sidebar layout by providing a `sidebar()` object to the\n    `sidebar=` argument of:\n\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n      * Creates a sidebar layout component which can be dropped inside any\n        :func:`~shiny.ui.page` or :func:`~shiny.experimental.ui.card` context.\n    * :func:`~shiny.experimental.ui.navset_bar`, :func:`~shiny.experimental.ui.navset_tab_card`, and :func:`~shiny.experimental.ui.navset_pill_card`\n      * Creates a multi page/tab UI with a singular `sidebar()` (which is\n        shown on every page/tab).\n\n    Parameters\n    ----------\n    *args\n        Contents to the sidebar. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar. It can be `\"desktop\"` (the sidebar starts open\n        on desktop screen, closed on mobile), `\"open\"` or `True` (the sidebar starts\n        open), `\"closed\"` or `False` (the sidebar starts closed), or `\"always\"` or\n        `None` (the sidebar is always open and cannot be closed).\n\n        In :func:`~shiny.experimental.ui.sidebar_toggle`, `open` indicates the desired\n        state of the sidebar, where the default of `open = None` will cause the sidebar\n        to be toggled open if closed or vice versa. Note that\n        :func:`~shiny.experimental.ui.sidebar_toggle` can only open or close the\n        sidebar, so it does not support the `\"desktop\"` and `\"always\"` options.\n    id\n        A character string. Required if wanting to re-actively read (or update) the\n        `collapsible` state in a Shiny app.\n    title\n        A character title to be used as the sidebar title, which will be wrapped in a\n        `<div>` element with class `sidebar-title`. You can also provide a custom\n        :func:`~shiny.htmltools.tag` for the title element, in which case you'll\n        likely want to give this element `class = \"sidebar-title\"`.\n    bg,fg\n        A background or foreground color.\n    class_\n        CSS classes for the sidebar container element, in addition to the fixed\n        `.sidebar` class.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.Sidebar` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.navset_bar`\n    * :func:`~shiny.experimental.ui.navset_tab_card`\n    * :func:`~shiny.experimental.ui.navset_pill_card`\n    \"\"\"\n    ...\n\ndef layout_sidebar(sidebar: Sidebar | TagChild | TagAttrs, *args: TagChild | TagAttrs, fillable: bool = ..., fill: bool = ..., bg: Optional[str] = ..., fg: Optional[str] = ..., border: Optional[bool] = ..., border_radius: Optional[bool] = ..., border_color: Optional[str] = ..., gap: Optional[CssUnit] = ..., padding: Optional[CssUnit | list[CssUnit]] = ..., height: Optional[CssUnit] = ..., **kwargs: TagAttrValue) -> CardItem:\n    \"\"\"\n    Sidebar layout\n\n    Create a sidebar layout component which can be dropped inside any\n    :func:`~shiny.ui.page` or :func:`~shiny.experimental.ui.card` context.\n\n    Parameters\n    ----------\n    sidebar\n        A :class:`~shiny.experimental.ui.Sidebar` object created by :func:`~shiny.experimental.ui.sidebar`.\n    *args\n        Contents to the main content area. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    fillable\n        Whether or not the main content area should be wrapped in a fillable container.\n        See :func:`~shiny.experimental.ui.as_fillable_container` for details.\n    fill\n        Whether or not the sidebar layout should be wrapped in a fillable container. See\n        :func:`~shiny.experimental.ui.as_fill_item` for details.\n    bg,fg\n        A background or foreground color.\n    border\n        Whether or not to show a border around the sidebar layout.\n    border_radius\n        Whether or not to round the corners of the sidebar layout.\n    border_color\n        A border color.\n    gap\n        A CSS length unit defining the `gap` (i.e., spacing) between elements provided\n        to `*args`. This argument is only applicable when `fillable = TRUE`.\n    padding\n        Padding to use for the body. This can be a numeric vector\n        (which will be interpreted as pixels) or a character vector with valid CSS\n        lengths. The length can be between one and four. If one, then that value\n        will be used for all four sides. If two, then the first value will be used\n        for the top and bottom, while the second value will be used for left and\n        right. If three, then the first will be used for top, the second will be\n        left and right, and the third will be bottom. If four, then the values will\n        be interpreted as top, right, bottom, and left respectively.\n    height\n        Any valid CSS unit to use for the height.\n\n    Returns\n    -------\n    :\n        A :class:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n    ...\n\ndef sidebar_toggle(id: str, open: Literal[\"toggle\", \"open\", \"closed\", \"always\"] | bool | None = ..., session: Session | None = ...) -> None:\n    \"\"\"\n    Toggle a sidebar\n\n    Toggle a :func:`~shiny.experimental.ui.sidebar` state during an active Shiny user session.\n\n    Parameters\n    ----------\n    id\n        The `id` of the :func:`~shiny.experimental.ui.sidebar` to toggle.\n    open\n        The desired state of the sidebar, choosing from the following options: `None`\n        (toggle sidebar open and closed), `\"open\"` or `True` (open the sidebar),\n        `\"closed\"` or `False` (close the sidebar). Note that `sidebar_toggle()` can only\n        open or close the sidebar, so it does not support the `\"desktop\"` and `\"always\"`\n    session\n        A Shiny session object (the default should almost always be used).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.sidebar`\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    \"\"\"\n    ...\n\n_sidebar_func = ...\ndef panel_sidebar(*args: TagChild | TagAttrs, width: int = ..., **kwargs: TagAttrValue) -> DeprecatedPanelSidebar:\n    \"\"\"Deprecated. Please use :func:`~shiny.experimental.ui.sidebar` instead of\n    `ui.panel_sidebar()`.\"\"\"\n    ...\n\nclass DeprecatedPanelSidebar:\n    \"\"\"\n    [Deprecated] Sidebar panel\n\n    Class returned from :func:`~shiny.experimental.ui.panel_sidebar`. Please do not\n    use this class and instead supply your content to\n    :func:`~shiny.experimental.ui.layout_sidebar` directly.\n\n    Parameters\n    ----------\n    *args\n        Contents to the sidebar. Or tag attributes that are supplied to the resolved\n        :class:`~htmltools.Tag` object.\n    width\n        An integeger between 1 and 12, inclusive, that determines the width of the\n        sidebar. The default is 4.\n    **kwargs\n        Tag attributes that are supplied to the resolved :class:`~htmltools.Tag` object.\n\n    Attributes\n    ----------\n    sidebar\n        A output from :func:`~shiny.experimental.ui.sidebar`.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n    sidebar: Sidebar\n    def __init__(self, *args: TagChild | TagAttrs, width: int = ..., **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def tagify(self) -> Tag:\n        \"\"\"\n        Tagify the `self.sidebar.tag` and return the result in a TagList\n        \"\"\"\n        ...\n    \n\n\ndef panel_main(*args: TagChild | TagAttrs, width: int = ..., **kwargs: TagAttrValue) -> TagList | DeprecatedPanelMain:\n    \"\"\"Deprecated. Please supply `panel_main(*args)` directly to `layout_sidebar()`.\"\"\"\n    ...\n\nclass DeprecatedPanelMain:\n    \"\"\"\n    [Deprecated] Main panel\n\n    Class returned from :func:`~shiny.experimental.ui.panel_main`. Please do not use\n    this class and instead supply your content to\n    :func:`~shiny.experimental.ui.layout_sidebar` directly.\n\n\n    Parameters\n    ----------\n    attrs\n        Attributes to apply to the parent tag of the children.\n    children\n        Children UI Elements to render inside the parent tag.\n\n    Attributes\n    ----------\n    attrs\n        Attributes to apply to the parent tag of the children.\n    children\n        Children UI Elements to render inside the parent tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n    attrs: TagAttrs\n    children: list[TagChild]\n    def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        ...\n    \n    def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `children` and return the result in a TagList\n        \"\"\"\n        ...\n    \n\n\n",
  "/src/typings/shiny/experimental/ui/_tag.pyi": "from typing import TypeVar\n\nTagT = TypeVar(\"TagT\", bound=\"Tag\")\ndef tag_prepend_class(tag: TagT, *class_: str | None) -> TagT:\n    ...\n\ndef tag_remove_class(tag: TagT, *class_: str | None) -> TagT:\n    \"\"\"\n    Remove a class value from the HTML class attribute.\n\n    Parameters\n    ----------\n    *class_\n        The class name to remove.\n\n    Returns\n    -------\n    :\n        The modified tag.\n    \"\"\"\n    ...\n\ndef tag_add_style(tag: TagT, *style: str | None) -> TagT:\n    \"\"\"\n    Add a style value(s) to the HTML style attribute.\n\n    Parameters\n    ----------\n    *style\n        CSS properties and values already properly formatted. Each should already contain trailing semicolons.\n\n    See Also\n    --------\n    ~htmltools.css\n\n    Returns\n    -------\n    :\n        The modified tag.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_tooltip.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild\nfrom ... import Session\n\ndef tooltip(trigger: TagChild, *args: TagChild | TagAttrs, id: Optional[str] = ..., placement: Literal[\"auto\", \"top\", \"right\", \"bottom\", \"left\"] = ..., options: Optional[dict[str, object]] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Add a tooltip to a UI element\n\n    Display additional information when focusing (or hovering over) a UI element.\n\n    Parameters\n    ----------\n    trigger\n        A UI element (i.e., :class:`~htmltools.Tag`) to serve as the tooltips trigger.\n        It's good practice for this element to be a keyboard-focusable and interactive\n        element (e.g., :func:`~shiny.ui.input_action_button`,\n        :func:`~shiny.ui.input_action_link`, etc.) so that the tooltip is accessible to\n        keyboard and assistive technology users.\n    *args\n        Contents to the tooltip's body. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    id\n        A character string. Required to re-actively respond to the visibility of the\n        tooltip (via the `input[id]` value) and/or update the visibility/contents of the\n        tooltip.\n    placement\n        The placement of the tooltip relative to its trigger.\n    options\n        A list of additional [Bootstrap\n        options](https://getbootstrap.com/docs/5.2/components/tooltips/#options).\n\n    Details\n    -------\n\n    If `trigger` yields multiple HTML elements (e.g., a :class:`~htmltools.TagList` or\n    complex [`shinywidgets`](https://github.com/rstudio/py-shinywidgets) object), the\n    last HTML element is used as the trigger. If the `trigger` should contain all of\n    those elements, wrap the object in a :func:`~htmltools.div` or :func:`~htmltools.span`.\n\n    See Also\n    --------\n\n    * [Bootstrap tooltips documentation](https://getbootstrap.com/docs/5.2/components/tooltips/)\n    \"\"\"\n    ...\n\ndef tooltip_toggle(id: str, show: Optional[bool] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Programmatically show/hide a tooltip\n\n    Parameters\n    ----------\n    id\n        A character string that matches an existing tooltip id.\n    show\n        Whether to show (`True`) or hide (`False`) the tooltip. The default (`None`)\n        will show if currently hidden and hide if currently shown. Note that a tooltip\n        will not be shown if the trigger is not visible (e.g., it's hidden behind a\n        tab).\n    session\n        A Shiny session object (the default should almost always be used).\n    \"\"\"\n    ...\n\ndef update_tooltip(id: str, *args: TagChild, session: Optional[Session] = ...) -> None:\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_utils.pyi": "import typing\nfrom typing import overload\nfrom htmltools import TagAttrValue, TagAttrs, TagChild\nfrom ..._typing_extensions import TypeGuard\n\nTagChildT = typing.TypeVar(\"TagChildT\", bound=TagChild)\n@overload\ndef consolidate_attrs(*args: TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChild]]:\n    ...\n\n@overload\ndef consolidate_attrs(*args: TagChildT | TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChildT]]:\n    ...\n\ndef consolidate_attrs(*args: TagChildT | TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChildT]]:\n    ...\n\ndef is_01_scalar(x: object) -> TypeGuard[float]:\n    ...\n\n@overload\ndef trinary(x: None) -> None:\n    ...\n\n@overload\ndef trinary(x: bool | str) -> str:\n    ...\n\ndef trinary(x: bool | str | None) -> None | str:\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_valuebox.pyi": "from typing import Callable, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild\nfrom ._card import CardItem\nfrom ._css_unit import CssUnit\n\n__all__ = (\"value_box\", \"showcase_left_center\", \"showcase_top_right\")\ndef value_box(title: TagChild, value: TagChild, *args: TagChild | TagAttrs, showcase: Optional[TagChild] = ..., showcase_layout: Callable[[TagChild, Tag], CardItem] | None = ..., full_screen: bool = ..., theme_color: Optional[str] = ..., height: Optional[CssUnit] = ..., max_height: Optional[CssUnit] = ..., fill: bool = ..., class_: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Value box\n\n    An opinionated (:func:`~shiny.experimental.ui.card`-powered) box, designed for\n    displaying a `value` and `title`. Optionally, a `showcase` can provide for context\n    for what the `value` represents (for example, it could hold an icon, or even a\n    :func:`~shiny.ui.output_plot`).\n\n    Parameters\n    ----------\n    title,value\n        A string, number, or :class:`~htmltools.Tag` child to display as\n        the title or value of the value box. The `title` appears above the `value`.\n    *args\n        Unnamed arguments may be any :class:`~htmltools.Tag` children to display below\n        `value`. Named arguments are passed to :func:`~shiny.experimental.ui.card` as\n        element attributes.\n    showcase\n        A :class:`~htmltools.Tag` child to showcase (e.g., an icon, a\n        :func:`~shiny.ui.output_plot`, etc).\n    showcase_layout\n        Either :func:`~shiny.experimental.ui.showcase_left_center` or\n        :func:`~shiny.experimental.ui.showcase_top_right`.\n    theme_color\n        A theme color to use for the background color. Should match a name in the\n        Bootstrap Sass variable `$theme-colors` (e.g., `\"secondary\"`, `\"success\"`,\n        `\"danger\"`, etc).\n    height,max_height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether to allow the value box to grow/shrink to fit a fillable container with\n        an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    class_\n        Utility classes for customizing the appearance of the summary card. Use `bg-*`\n        and `text-*` classes (e.g, `\"bg-danger\"` and `\"text-light\"`) to customize the\n        background/foreground colors.\n    **kwargs\n        Additional attributes to pass to :func:`~shiny.experimental.ui.card`.\n\n    Returns\n    -------\n    :\n        A :func:`~shiny.experimental.ui.card`\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card`\n    \"\"\"\n    ...\n\ndef showcase_left_center(width: CssUnit = ..., max_height: CssUnit = ..., max_height_full_screen: CssUnit = ...) -> Callable[[TagChild | TagAttrs, Tag], CardItem]:\n    \"\"\"\n    Left center showcase for a value box\n\n    Gives the showcase a width and centers it vertically.\n\n    Parameters\n    ----------\n    width\n        A proportion (i.e., a number between 0 and 1) of available width to allocate to\n        the showcase. Or, A vector of length 2 valid CSS unit defining the width of each\n        column (for `showcase_left_center()` the 1st unit defines the showcase width and\n        for `showcase_top_right` the 2nd unit defines the showcase width). Note that any\n        units supported by the CSS grid `grid-template-columns` property may be used\n        (e.g., `fr` units).\n    max_height,max_height_full_screen\n        A proportion (i.e., a number between 0 and 1) or any valid CSS unit defining the\n        showcase max_height.\n\n    Returns\n    -------\n    :\n        A function that takes a showcase and contents and returns a :func:`~shiny.experimental.ui.card_body`\n    \"\"\"\n    ...\n\ndef showcase_top_right(width: CssUnit = ..., max_height: CssUnit = ..., max_height_full_screen: CssUnit = ...) -> Callable[[TagChild | TagAttrs, Tag], CardItem]:\n    \"\"\"\n    Top right showcase for a value box\n\n    Gives the showcase a width and in the top right corner.\n\n    Parameters\n    ----------\n    width\n        A proportion (i.e., a number between 0 and 1) of available width to allocate to\n        the showcase. Or, A vector of length 2 valid CSS unit defining the width of each\n        column (for `showcase_left_center()` the 1st unit defines the showcase width and\n        for `showcase_top_right` the 2nd unit defines the showcase width). Note that any\n        units supported by the CSS grid `grid-template-columns` property may be used\n        (e.g., `fr` units).\n    max_height,max_height_full_screen\n        A proportion (i.e., a number between 0 and 1) or any valid CSS unit defining the\n        showcase max_height.\n\n    Returns\n    -------\n    :\n        A function that takes a showcase and contents and returns a :func:`~shiny.experimental.ui.card_body`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/experimental/ui/_web_component.pyi": "from htmltools import Tag, TagAttrValue, TagAttrs, TagChild\n\ndef web_component(tag_name: str, *args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    ...\n\n",
  "/src/typings/shiny/reactive/__init__.pyi": "from ._core import flush, get_current_context, invalidate_later, isolate, lock, on_flushed\nfrom ._poll import file_reader, poll\nfrom ._reactives import Calc, CalcAsync_, Calc_, Effect, Effect_, Value, event\n\n__all__ = (\"isolate\", \"invalidate_later\", \"flush\", \"lock\", \"on_flushed\", \"poll\", \"file_reader\", \"Value\", \"Calc\", \"Effect\", \"event\")\n",
  "/src/typings/shiny/reactive/_core.pyi": "import asyncio\nimport contextlib\nimport typing\nfrom typing import Awaitable, Callable, TYPE_CHECKING, TypeVar\nfrom .._docstring import add_example\nfrom ..types import MISSING_TYPE\nfrom ..session import Session\n\n\"\"\"Low-level reactive components.\"\"\"\n__all__ = (\"isolate\", \"invalidate_later\", \"flush\", \"lock\", \"on_flushed\", \"get_current_context\")\nif TYPE_CHECKING:\n    ...\nT = TypeVar(\"T\")\nclass ReactiveWarning(RuntimeWarning):\n    ...\n\n\nclass Context:\n    \"\"\"A reactive context\"\"\"\n    def __init__(self) -> None:\n        ...\n    \n    def __call__(self) -> typing.ContextManager[None]:\n        ...\n    \n    def invalidate(self) -> None:\n        \"\"\"Invalidate this context. It will immediately call the callbacks\n        that have been registered with onInvalidate().\"\"\"\n        ...\n    \n    def on_invalidate(self, func: Callable[[], None]) -> None:\n        \"\"\"Register a function to be called when this context is invalidated\"\"\"\n        ...\n    \n    def add_pending_flush(self, priority: int) -> None:\n        \"\"\"Tell the reactive environment that this context should be flushed the\n        next time flushReact() called.\"\"\"\n        ...\n    \n    def on_flush(self, func: Callable[[], Awaitable[None]]) -> None:\n        \"\"\"Register a function to be called when this context is flushed.\"\"\"\n        ...\n    \n    async def execute_flush_callbacks(self) -> None:\n        \"\"\"Execute all flush callbacks\"\"\"\n        ...\n    \n\n\nclass Dependents:\n    def __init__(self) -> None:\n        ...\n    \n    def register(self) -> None:\n        ...\n    \n    def invalidate(self) -> None:\n        ...\n    \n\n\nclass ReactiveEnvironment:\n    \"\"\"The reactive environment\"\"\"\n    def __init__(self) -> None:\n        ...\n    \n    @property\n    def lock(self) -> asyncio.Lock:\n        \"\"\"\n        Lock that protects this ReactiveEnvironment. It must be lazily created, because\n        at the time the module is loaded, there generally isn't a running asyncio loop\n        yet. This causes the asyncio.Lock to be created with a different loop than it\n        will be invoked from later; when that happens, acquire() will succeed if there's\n        no contention, but throw a \"hey you're on the wrong loop\" error if there is.\n        \"\"\"\n        ...\n    \n    def next_id(self) -> int:\n        \"\"\"Return the next available id\"\"\"\n        ...\n    \n    @contextlib.contextmanager\n    def use_context(self, ctx: Context) -> typing.Generator[None, None, None]:\n        ...\n    \n    def current_context(self) -> Context:\n        \"\"\"Return the current Context object\"\"\"\n        ...\n    \n    def on_flushed(self, func: Callable[[], Awaitable[None]], once: bool = ...) -> Callable[[], None]:\n        ...\n    \n    async def flush(self) -> None:\n        \"\"\"Flush all pending operations\"\"\"\n        ...\n    \n    def add_pending_flush(self, ctx: Context, priority: int) -> None:\n        ...\n    \n    @contextlib.contextmanager\n    def isolate(self): # -> Generator[None, Any, None]:\n        ...\n    \n\n\n_reactive_environment = ...\n@add_example()\n@contextlib.contextmanager\ndef isolate(): # -> Generator[None, Any, None]:\n    \"\"\"\n    Create a non-reactive scope within a reactive scope.\n\n    Ordinarily, the simple act of reading a reactive value causes a relationship to be\n    established between the caller and the reactive value, where a change to the\n    reactive value will cause the caller to re-execute. (The same applies for the act of\n    getting a reactive expression's value.) `with isolate()` lets you read a reactive\n    value or expression without establishing this relationship.\n\n    ``with isolate()`` can also be useful for calling reactive expression at the\n    console, which can be useful for debugging. To do so, wrap the calls to the reactive\n    expression with ``with isolate()``.\n\n    Returns\n    -------\n    :\n        A context manager that executes the given expression in a scope where reactive\n        values can be read, but do not cause the reactive scope of the caller to be\n        re-evaluated when they change.\n\n    See Also\n    --------\n    ~shiny.reactive.event\n    \"\"\"\n    ...\n\ndef get_current_context() -> Context:\n    \"\"\"\n    Get the current reactive context.\n\n    Returns\n    -------\n    :\n        A :class:`~Context`.\n\n    Raises\n    ------\n    RuntimeError\n        If called outside of a reactive context.\n    \"\"\"\n    ...\n\nasync def flush() -> None:\n    \"\"\"\n    Run any pending invalidations (i.e., flush the reactive environment).\n\n    Warning\n    -------\n    This function shouldn't ever need to be called inside a Shiny app. It's only\n    useful for testing and running reactive code interactively in the console.\n    \"\"\"\n    ...\n\ndef on_flushed(func: Callable[[], Awaitable[None]], once: bool = ...) -> Callable[[], None]:\n    \"\"\"\n    Register a function to be called when the reactive environment is flushed\n\n    Parameters\n    ----------\n    func\n        The function to be called when the reactive environment is flushed\n    once\n        If True, the function will only be called once, and then removed from the\n\n    Returns\n    -------\n    :\n        A function that can be used to unregister the callback.\n\n    See Also\n    --------\n    flush\n    \"\"\"\n    ...\n\ndef lock() -> asyncio.Lock:\n    \"\"\"\n    A lock that should be held whenever manipulating the reactive graph.\n\n    For example, this makes it safe to set a :class:`~reactive.Value` and call\n    :func:`~reactive.flush()` from a different :class:`~asyncio.Task` than the one that\n    is running the Shiny :class:`~shiny.Session`.\n    \"\"\"\n    ...\n\n@add_example()\ndef invalidate_later(delay: float, *, session: MISSING_TYPE | Session | None = ...) -> None:\n    \"\"\"\n    Scheduled Invalidation\n\n    Schedules the current reactive context to be invalidated in the given number of\n    seconds.\n\n    Parameters\n    ----------\n    delay\n        The number of seconds to wait before invalidating.\n\n    Note\n    ----\n    When called within a reactive function (i.e., :func:`Effect`, :func:`Calc`,\n    :func:`render.ui`, etc.), that reactive context is invalidated (and re-executes)\n    after the interval has passed. The re-execution will reset the invalidation flag, so\n    in a typical use case, the object will keep re-executing and waiting for the\n    specified interval. It's possible to stop this cycle by adding conditional logic\n    that prevents the ``invalidate_later`` from being run.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/reactive/_poll.pyi": "import os\nfrom typing import Any, Awaitable, Callable, TYPE_CHECKING, TypeVar\nfrom .._docstring import add_example\nfrom ..types import MISSING_TYPE\nfrom ..session import Session\n\nif TYPE_CHECKING:\n    ...\n__all__ = (\"poll\", \"file_reader\")\nT = TypeVar(\"T\")\n@add_example()\ndef poll(poll_func: Callable[[], Any] | Callable[[], Awaitable[Any]], interval_secs: float = ..., *, equals: Callable[[Any, Any], bool] = ..., priority: int = ..., session: MISSING_TYPE | Session | None = ...) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Create a reactive polling object.\n\n    Polling is a technique that approximates \"real-time\" or streaming updates, using a\n    data source that does not actually have push notifications but does have a quick way\n    to repeatedly check for changes on demand.\n\n    A reactive polling object is constructed using two functions: a polling function,\n    which is a fast-running, inexpensive function that is used to determine whether some\n    data source has changed (such as the timestamp of a file, or a `SELECT MAX(updated)\n    FROM table` query); and a slower-running reading function that actually loads and\n    returns the data that is desired. The `poll()` function is intended to be used as a\n    decorator: the poll function is passed as the `poll_func` arg to `@poll()`, while\n    the data reading function is the target of the decorator.\n\n    Reactive consumers can invoke the resulting polling object to get the current data,\n    and will automatically invalidate when the polling function detects a change.\n    Polling objects also cache the results of the read function; for this reason, apps\n    where all sessions depend on the same data source may want to declare the polling\n    object at the top level of app.py (outside of the server function).\n\n    Both `poll_func` and the decorated (data reading) function can read reactive values\n    and ~shiny.reactive.Calc objects. Any invalidations triggered by reactive\n    dependencies will apply to the reactive polling object immediately (not waiting for\n    the `interval_secs` delay to expire).\n\n    Parameters\n    ----------\n    poll_func\n        A function to be called frequently to determine whether a data source has\n        changed. The return value should be something that can be compared inexpensively\n        using `==`. Both regular functions and coroutine functions are allowed.\n\n        Note that the `poll_func` should NOT return a bool that indicates whether the\n        data source has changed. Rather, each `poll_func` return value will be checked\n        for equality with its preceding `poll_func` return value (using `==` semantics\n        by default), and if it differs, the data source will be considered changed.\n    interval_secs\n        The number of seconds to wait after each `poll_func` invocation before polling\n        again. Note: depending on what other tasks are executing, the actual wait time\n        may far exceed this value.\n    equals\n        The function that will be used to compare each `poll_func` return value with its\n        immediate predecessor.\n    priority\n        Reactive polling is implemented using an ~shiny.reactive.Effect to call\n        `poll_func` on a timer; use the `priority` argument to control the order of this\n        Effect's execution versus other Effects in your app. See ~shiny.reactive.Effect\n        for more details.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`. If there is no current session (i.e.\n        `poll` is being created outside of the server function), the lifetime of this\n        reactive poll object will not be tied to any specific session.\n\n    Returns\n    -------\n    :\n        A decorator that should be applied to a no-argument function that (expensively)\n    reads whatever data is desired. (This function may be a regular function or a\n    coroutine function.) The result of the decorator is a reactive ~shiny.reactive.Calc\n    that always returns up-to-date data, and invalidates callers when changes are\n    detected via polling.\n\n    See Also\n    --------\n    ~shiny.reactive.file_reader\n    \"\"\"\n    ...\n\n@add_example()\ndef file_reader(filepath: str | os.PathLike[str] | Callable[[], str] | Callable[[], os.PathLike[str]], interval_secs: float = ..., *, priority: int = ..., session: MISSING_TYPE | Session | None = ...) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Create a reactive file reader.\n\n    This is a decorator, meant to be applied to a no-argument function that reads data\n    from a file on disk. Whenever the file changes (or to be precise, the file size or\n    last modified time changes), past readers of the data are reactively invalidated.\n    This makes it incredibly easy to write apps that automatically update all of their\n    outputs as soon as files on disk change.\n\n    Note that `file_reader` works only on single files, not directories of files.\n\n    Both the `filepath` function and the decorated (file reading) function can read\n    reactive values and ~shiny.reactive.Calc objects. Any invalidations triggered by\n    reactive dependencies will apply to the reactive file reader object immediately (not\n    waiting for the `interval_secs` delay to expire).\n\n    Parameters\n    ----------\n    filepath\n        Either a string indicating the file path to be monitored, or, a no-argument\n        function that returns such a string. The latter is useful if the file to be\n        monitored depends on some user input, the current date/time, etc.\n\n        The file path provided MUST exist, otherwise Shiny will treat it as an unhandled\n        error and close the session.\n\n        If a function is used, make sure it is high performance (or is cached, i.e. use\n        a ~shiny.reactive.Calc), as it will be called very frequently.\n    interval_secs\n        The number of seconds to wait after each time the file metadata is checked.\n        Note: depending on what other tasks are executing, the actual wait time may far\n        exceed this value.\n    priority\n        Reactive polling is implemented using an ~shiny.reactive.Effect to call\n        `poll_func` on a timer; use the `priority` argument to control the order of this\n        Effect's execution versus other Effects in your app. See ~shiny.reactive.Effect\n        for more details.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`. If there is no current session (i.e.\n        `poll` is being created outside of the server function), the lifetime of this\n        reactive poll object will not be tied to any specific session.\n\n    Returns\n    -------\n    :\n        A decorator that should be applied to a no-argument function that (expensively)\n    reads whatever data is desired. (This function may be a regular function or a\n    coroutine function.) The result of the decorator is a reactive ~shiny.reactive.Calc\n    that always returns up-to-date data, and invalidates callers when changes are\n    detected via polling.\n\n    See Also\n    --------\n    ~shiny.reactive.poll\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/reactive/_reactives.pyi": "from typing import Awaitable, Callable, Generic, Optional, TYPE_CHECKING, TypeVar, overload\nfrom .._docstring import add_example\nfrom ..types import MISSING_TYPE\nfrom ..session import Session\n\n\"\"\"Reactive components\"\"\"\n__all__ = (\"Value\", \"Calc\", \"Calc_\", \"CalcAsync_\", \"Effect\", \"Effect_\", \"event\")\nif TYPE_CHECKING:\n    ...\nT = TypeVar(\"T\")\n@add_example()\nclass Value(Generic[T]):\n    \"\"\"\n    Create a reactive value.\n\n    Reactive values are the source of reactivity in Shiny. Changes to reactive values\n    invalidate downstream reactive functions (:func:`~shiny.reactive.Calc`,\n    :func:`~shiny.reactive.Effect`, and `render` functions decorated with `@output`).\n    When these functions are invalidated, they get scheduled to re-execute.\n\n    Shiny input values are read-only reactive values. For example, `input.x` is a\n    reactive value object, and to get the current value, you can call `input.x()` or\n    `input.x.get()`. When you do that inside of a reactive function, the function takes\n    a dependency on the reactive value.\n\n    Parameters\n    ----------\n    value\n        An optional initial value.\n    read_only\n        If ``True``, then the reactive value cannot be `set()`.\n\n    Returns\n    -------\n    :\n        An instance of a reactive value.\n\n    Raises\n    ------\n    ~shiny.types.SilentException\n        If :func:`~Value.get` is called before a value is provided/set.\n\n    Note\n    ----\n    A reactive value may only be read from within a reactive function (e.g.,\n    :func:`~shiny.reactive.Calc`, :func:`~shiny.reactive.Effect`,\n    :func:`shiny.render.text`, etc.) and, when doing so, the function takes a reactive\n    dependency on the value (i.e., when the value changes, the calling reactive function\n    will re-execute).\n\n    See Also\n    --------\n    ~shiny.Inputs ~shiny.reactive.Calc ~shiny.reactive.Effect\n    \"\"\"\n    @overload\n    def __init__(self, value: MISSING_TYPE = ..., *, read_only: bool = ...) -> None:\n        ...\n    \n    @overload\n    def __init__(self, value: T, *, read_only: bool = ...) -> None:\n        ...\n    \n    def __init__(self, value: T | MISSING_TYPE = ..., *, read_only: bool = ...) -> None:\n        ...\n    \n    def __call__(self) -> T:\n        ...\n    \n    def get(self) -> T:\n        \"\"\"\n        Read the reactive value.\n\n        Returns\n        -------\n        :\n            A value.\n\n        Raises\n        ------\n        ~shiny.types.SilentException\n            If the value is not set.\n        RuntimeError\n            If called from outside a reactive function.\n        \"\"\"\n        ...\n    \n    def set(self, value: T) -> bool:\n        \"\"\"\n        Set the reactive value to a new value.\n\n        Parameters\n        ----------\n        value\n            A value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set to a different value and ``False`` otherwise.\n\n        Raises\n        ------\n        RuntimeError\n            If called on a read-only reactive value.\n        \"\"\"\n        ...\n    \n    def unset(self) -> None:\n        \"\"\"\n        Unset the reactive value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set prior to this unsetting.\n        \"\"\"\n        ...\n    \n    def is_set(self) -> bool:\n        \"\"\"\n        Check if the reactive value is set.\n\n        Returns\n        -------\n        :\n            ``True`` if the value is set, ``False`` otherwise.\n        \"\"\"\n        ...\n    \n    def freeze(self) -> None:\n        \"\"\"\n        Freeze the reactive value.\n\n        Freezing is equivalent to unsetting the value, but it does not invalidate\n        dependents.\n        \"\"\"\n        ...\n    \n\n\nCalcFunction = Callable[[], T]\nCalcFunctionAsync = Callable[[], Awaitable[T]]\nclass Calc_(Generic[T]):\n    \"\"\"\n    Mark a function as a reactive calculation.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive calculation\n    (instead, use the :func:`~shiny.reactive.Calc` decorator).\n    \"\"\"\n    def __init__(self, fn: CalcFunction[T], *, session: MISSING_TYPE | Session | None = ...) -> None:\n        ...\n    \n    def __call__(self) -> T:\n        ...\n    \n    async def get_value(self) -> T:\n        ...\n    \n    async def update_value(self) -> None:\n        ...\n    \n\n\nclass CalcAsync_(Calc_[T]):\n    \"\"\"\n    Mark an async function as a reactive calculation.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive calculation\n    (instead, use the :func:`~shiny.reactive.Calc` decorator).\n    \"\"\"\n    def __init__(self, fn: CalcFunctionAsync[T], *, session: MISSING_TYPE | Session | None = ...) -> None:\n        ...\n    \n    async def __call__(self) -> T:\n        ...\n    \n\n\n@overload\ndef Calc(fn: CalcFunctionAsync[T]) -> CalcAsync_[T]:\n    ...\n\n@overload\ndef Calc(fn: CalcFunction[T]) -> Calc_[T]:\n    ...\n\n@overload\ndef Calc(*, session: MISSING_TYPE | Session | None = ...) -> Callable[[CalcFunction[T]], Calc_[T]]:\n    ...\n\n@add_example()\ndef Calc(fn: Optional[CalcFunction[T] | CalcFunctionAsync[T]] = ..., *, session: MISSING_TYPE | Session | None = ...) -> Calc_[T] | Callable[[CalcFunction[T]], Calc_[T]]:\n    \"\"\"\n    Mark a function as a reactive calculation.\n\n    A reactive calculation is a function whose return value depends solely on other\n    reactive value(s) (i.e., :class:`~shiny.Inputs`, :class:`~shiny.reactive.Value`,\n    and other reactive calculations). Whenever a reactive value changes, any reactive\n    calculations that depend on it are \"invalidated\" and automatically re-execute when\n    necessary. If a reactive calculation is marked as invalidated, any other reactive\n    calculations that recently called it are also marked as invalidated. In this way,\n    invalidations ripple through reactive calculations that depend on each other.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as a reactive calculation.\n\n    Tip\n    ---\n    Reactive calculations should not produce any side effects; to reactively produce\n    side effects, use :func:`~shiny.reactive.Effect` instead.\n\n    See Also\n    --------\n    ~shiny.Inputs\n    ~shiny.reactive.Value\n    ~shiny.reactive.Effect\n    ~shiny.reactive.invalidate_later\n    ~shiny.reactive.event\n    \"\"\"\n    ...\n\nEffectFunction = Callable[[], None]\nEffectFunctionAsync = Callable[[], Awaitable[None]]\nclass Effect_:\n    \"\"\"\n    Mark a function as a reactive side effect.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive side effect\n    (instead, use the :func:`Effect` decorator).\n    \"\"\"\n    def __init__(self, fn: EffectFunction | EffectFunctionAsync, *, suspended: bool = ..., priority: int = ..., session: MISSING_TYPE | Session | None = ...) -> None:\n        ...\n    \n    def on_invalidate(self, callback: Callable[[], None]) -> None:\n        \"\"\"\n        Register a callback that will be called when this reactive effect is\n        invalidated.\n\n        Parameters\n        ----------\n        callback\n            A callback that will be called when this reactive effect is invalidated.\n        \"\"\"\n        ...\n    \n    def destroy(self) -> None:\n        \"\"\"\n        Destroy this reactive effect.\n\n        Stops the observer from executing ever again, even if it is currently scheduled\n        for re-execution.\n        \"\"\"\n        ...\n    \n    def suspend(self) -> None:\n        \"\"\"\n        Suspend the effect.\n\n        Pauses scheduling of flushes (re-executions) in response to invalidations. If\n        the effect was invalidated prior to this call but it has not re-executed yet\n        (because it waits until on_flush is called) then that re-execution will still\n        occur, because the flush is already scheduled.\n        \"\"\"\n        ...\n    \n    def resume(self) -> None:\n        \"\"\"\n        Resume the effect.\n\n        Causes this effect to start re-executing in response to invalidations. If the\n        effect was invalidated while suspended, then it will schedule itself for\n        re-execution (pending flush).\n        \"\"\"\n        ...\n    \n    def set_priority(self, priority: int = ...) -> None:\n        \"\"\"\n        Control the execution priority for this effect.\n\n        Parameters\n        ----------\n        priority\n            The new priority. A higher value means higher priority: an effect with a\n            higher priority value will execute before all effects with lower priority\n            values. Positive, negative, and zero values are allowed.\n\n        Note\n        ----\n        If the observer is currently invalidated, then the change in priority will not\n        take effect until the next invalidation--unless the observer is also currently\n        suspended, in which case the priority change will be effective upon resume.\n        \"\"\"\n        ...\n    \n\n\n@overload\ndef Effect(fn: EffectFunction | EffectFunctionAsync) -> Effect_:\n    ...\n\n@overload\ndef Effect(*, suspended: bool = ..., priority: int = ..., session: MISSING_TYPE | Session | None = ...) -> Callable[[EffectFunction | EffectFunctionAsync], Effect_]:\n    ...\n\n@add_example()\ndef Effect(fn: Optional[EffectFunction | EffectFunctionAsync] = ..., *, suspended: bool = ..., priority: int = ..., session: MISSING_TYPE | Session | None = ...) -> Effect_ | Callable[[EffectFunction | EffectFunctionAsync], Effect_]:\n    \"\"\"\n    Mark a function as a reactive side effect.\n\n    A reactive effect is like a reactive calculation (:func:`~shiny.reactive.Calc`) in\n    that it can read reactive values and call reactive calculations, and will\n    automatically re-execute when those dependencies change. But unlike reactive\n    calculations, it doesn't return a result and can't be used as an input to other\n    reactive expressions. Thus, observers are only useful for their side effects (for\n    example, performing I/O).\n\n    Another contrast between reactive calculations and effects is their execution\n    strategy. Reactive calculations use lazy evaluation; that is, when their\n    dependencies change, they don't re-execute right away but rather wait until they are\n    called by someone else. Indeed, if they are not called then they will never\n    re-execute. In contrast, effects use eager evaluation; as soon as their dependencies\n    change, they schedule themselves to re-execute.\n\n    Parameters\n    ----------\n    suspended\n        If ``TRUE``, start the effect in a suspended state (i.e., it will not execute\n        until resumed and invalidated).\n    priority\n        The new priority. A higher value means higher priority: an effect with a higher\n        priority value will execute before all effects with lower priority values.\n        Positive, negative, and zero values are allowed.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as a reactive effect (:class:`Effect_`).\n\n    See Also\n    --------\n    ~shiny.Inputs\n    ~shiny.reactive.Value\n    ~shiny.reactive.Effect\n    ~shiny.reactive.invalidate_later\n    ~shiny.reactive.event\n    \"\"\"\n    ...\n\n@add_example()\ndef event(*args: Callable[[], object] | Callable[[], Awaitable[object]], ignore_none: bool = ..., ignore_init: bool = ...) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Mark a function to react only when an \"event\" occurs.\n\n    Shiny's reactive programming framework is primarily designed for calculated values\n    (:func:`~shiny.reactive.Calc`) and side-effect-causing actions\n    (:func:`~shiny.reactive.Effect`) that respond to **any** of their inputs changing.\n    That's often what is desired in Shiny apps, but not always: sometimes you want to\n    wait for a specific action to be taken from the user, like clicking an\n    :func:`~shiny.ui.input_action_button`, before calculating or taking an action. A\n    reactive value (or function) which triggers other calculation or action in this way\n    is called an event.\n\n    These situations demand a more imperative, \"event handling\" style of programming,\n    which ``@reactive.event()`` provides. It does this by using the\n    :func:`~shiny.reactive.isolate` primitive under-the-hood to essentially \"limit\" the\n    set of reactive dependencies to those in ``args``.\n\n    Parameters\n    ----------\n    args\n        One or more callables that represent the event; most likely this will be a\n        reactive input value linked to a :func:`~shiny.ui.input_action_button` or\n        similar (e.g., ``input.click``), but it can also be a (reactive or non-reactive)\n        function that returns a value.\n    ignore_none\n        Whether to ignore the event if the value is ``None`` or ``0``.\n    ignore_init\n        If ``False``, the event trigger on the first run.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as an event handler.\n\n    Tip\n    ----\n    This decorator must be applied before the relevant reactivity decorator (i.e.,\n    ``@reactive.event`` must be applied before ``@reactive.Effect``, ``@reactive.Calc``,\n    ``@render.ui``, etc).\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/render/__init__.pyi": "from ._render import RenderFunction, RenderFunctionAsync, RenderImage, RenderImageAsync, RenderPlot, RenderPlotAsync, RenderTable, RenderTableAsync, RenderText, RenderTextAsync, RenderUI, RenderUIAsync, image, plot, table, text, ui\nfrom ._dataframe import DataGrid, DataTable, RenderDataFrame, RenderDataFrameAsync, data_frame\n\n\"\"\"\nTools for reactively rendering output for the user interface.\n\"\"\"\n__all__ = (\"DataGrid\", \"DataTable\", \"data_frame\", \"text\", \"plot\", \"image\", \"table\", \"ui\")\n",
  "/src/typings/shiny/render/_coordmap.pyi": "from typing import TYPE_CHECKING\nfrom ..types import Coordmap, CoordmapPanel, PlotnineFigure\nfrom matplotlib.axes import Axes\nfrom matplotlib.figure import Figure\n\nif TYPE_CHECKING:\n    ...\ndef get_coordmap(fig: Figure) -> Coordmap | None:\n    ...\n\ndef get_coordmap_panel(axes: Axes, panel_num: int, height: float) -> CoordmapPanel:\n    ...\n\ndef get_coordmap_plotnine(p: PlotnineFigure, fig: Figure) -> Coordmap | None:\n    ...\n\n",
  "/src/typings/shiny/render/_dataframe.pyi": "import abc\nimport pandas as pd\nfrom typing import Any, Awaitable, Callable, Literal, Optional, Protocol, TYPE_CHECKING, Union, overload, runtime_checkable\nfrom .._docstring import add_example\nfrom . import RenderFunction, RenderFunctionAsync\n\nif TYPE_CHECKING:\n    ...\nclass AbstractTabularData(abc.ABC):\n    @abc.abstractmethod\n    def to_payload(self) -> object:\n        ...\n    \n\n\nclass DataGrid(AbstractTabularData):\n    \"\"\"\n    Holds the data and options for a ``shiny.render.data_frame`` output, for a\n    spreadsheet-like view.\n\n    Parameters\n    ----------\n    data\n        A pandas `DataFrame` object, or any object that has a `.to_pandas()` method\n        (e.g., a Polars data frame or Arrow table).\n    width\n        A _maximum_ amount of vertical space for the data grid to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. The\n        default is `fit-content`, which sets the grid's width according to its contents.\n        Set this to `100%` to use the maximum available horizontal space.\n    height\n        A _maximum_ amount of vertical space for the data grid to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. If there\n        are more rows than can fit in this space, the grid will scroll. Set the height\n        to `None` to allow the grid to grow to fit all of the rows (this is not\n        recommended for large data sets, as it may crash the browser).\n    summary\n        If `True` (the default), shows a message like \"Viewing rows 1 through 10 of 20\"\n        below the grid when not all of the rows are being shown. If `False`, the message\n        is not displayed. You can also specify a string template to customize the\n        message, containing `{start}`, `{end}`, and `{total}` tokens. For example:\n        `\"Viendo filas {start} a {end} de {total}\"`.\n    filters\n        If `True`, shows a row of filter inputs below the headers, one for each column.\n    row_selection_mode\n        Use `\"none\"` to disable row selection, `\"single\"` to allow a single row to be\n        selected at a time, and `\"multiple\"` to allow multiple rows to be selected by\n        clicking on them individually.\n\n    Returns\n    -------\n    :\n        An object suitable for being returned from a `@render.data_frame`-decorated\n        output function.\n\n    See Also\n    --------\n    :func:`~shiny.ui.output_data_frame`\n    :func:`~shiny.render.data_frame`\n    :class:`~shiny.render.DataTable`\n    \"\"\"\n    def __init__(self, data: object, *, width: str | float | None = ..., height: Union[str, float, None] = ..., summary: Union[bool, str] = ..., filters: bool = ..., row_selection_mode: Literal[\"none\", \"single\", \"multiple\"] = ...) -> None:\n        ...\n    \n    def to_payload(self) -> object:\n        ...\n    \n\n\nclass DataTable(AbstractTabularData):\n    \"\"\"\n    Holds the data and options for a ``shiny.render.data_frame`` output, for a\n    spreadsheet-like view.\n\n    Parameters\n    ----------\n    data\n        A pandas `DataFrame` object, or any object that has a `.to_pandas()` method\n        (e.g., a Polars data frame or Arrow table).\n    width\n        A _maximum_ amount of vertical space for the data table to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. The\n        default is `fit-content`, which sets the table's width according to its\n        contents. Set this to `100%` to use the maximum available horizontal space.\n    height\n        A _maximum_ amount of vertical space for the data table to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. If there\n        are more rows than can fit in this space, the table body will scroll. Set the\n        height to `None` to allow the table to grow to fit all of the rows (this is not\n        recommended for large data sets, as it may crash the browser).\n    summary\n        If `True` (the default), shows a message like \"Viewing rows 1 through 10 of 20\"\n        below the grid when not all of the rows are being shown. If `False`, the message\n        is not displayed. You can also specify a string template to customize the\n        message, containing `{start}`, `{end}`, and `{total}` tokens. For example:\n        `\"Viendo filas {start} a {end} de {total}\"`.\n    filters\n        If `True`, shows a row of filter inputs below the headers, one for each column.\n    row_selection_mode\n        Use `\"none\"` to disable row selection, `\"single\"` to allow a single row to be\n        selected at a time, and `\"multiple\"` to allow multiple rows to be selected by\n        clicking on them individually.\n\n    Returns\n    -------\n    :\n        An object suitable for being returned from a `@render.data_frame`-decorated\n        output function.\n\n    See Also\n    --------\n    :func:`~shiny.ui.output_data_frame`\n    :func:`~shiny.render.data_frame`\n    :class:`~shiny.render.DataGrid`\n    \"\"\"\n    def __init__(self, data: object, *, width: Union[str, float, None] = ..., height: Union[str, float, None] = ..., summary: Union[bool, str] = ..., filters: bool = ..., row_selection_mode: Union[Literal[\"none\"], Literal[\"single\"], Literal[\"multiple\"]] = ...) -> None:\n        ...\n    \n    def to_payload(self) -> object:\n        ...\n    \n\n\ndef serialize_pandas_df(df: pd.DataFrame) -> dict[str, Any]:\n    ...\n\nDataFrameResult = Union[None, \"pd.DataFrame\", DataGrid, DataTable]\nRenderDataFrameFunc = Callable[[], DataFrameResult]\nRenderDataFrameFuncAsync = Callable[[], Awaitable[DataFrameResult]]\n@runtime_checkable\nclass PandasCompatible(Protocol):\n    def to_pandas(self) -> object:\n        ...\n    \n\n\nclass RenderDataFrame(RenderFunction[DataFrameResult, object]):\n    def __init__(self, fn: RenderDataFrameFunc) -> None:\n        ...\n    \n    def __call__(self) -> object:\n        ...\n    \n\n\ndef cast_to_pandas(x: object, error_message_begin: str) -> object:\n    ...\n\nclass RenderDataFrameAsync(RenderDataFrame, RenderFunctionAsync[DataFrameResult, object]):\n    def __init__(self, fn: RenderDataFrameFuncAsync) -> None:\n        ...\n    \n    async def __call__(self) -> object:\n        ...\n    \n\n\n@overload\ndef data_frame(fn: RenderDataFrameFunc | RenderDataFrameFuncAsync) -> RenderDataFrame:\n    ...\n\n@overload\ndef data_frame() -> Callable[[RenderDataFrameFunc | RenderDataFrameFuncAsync], RenderDataFrame]:\n    ...\n\n@add_example()\ndef data_frame(fn: Optional[RenderDataFrameFunc | RenderDataFrameFuncAsync] = ...) -> (RenderDataFrame | Callable[[RenderDataFrameFunc | RenderDataFrameFuncAsync], RenderDataFrame]):\n    \"\"\"\n    Reactively render a Pandas data frame object (or similar) as a basic HTML table.\n\n    Parameters\n    ----------\n    index\n        Whether to print index (row) labels.\n    selection\n\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A pandas :class:`DataFrame` object.\n        2. A pandas :class:`Styler` object.\n        3. Any object that has a `.to_pandas()` method (e.g., a Polars data frame or\n           Arrow table).\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_table` container (see :func:`~shiny.ui.output_table` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_data_frame\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/render/_dataframe_unsafe.pyi": "import typing\nimport pandas as pd\nfrom typing import Any\n\nif typing.TYPE_CHECKING:\n    ...\ndef serialize_numpy_dtypes(df: pd.DataFrame) -> list[dict[str, Any]]:\n    ...\n\ndef serialize_numpy_dtype(col: pd.Series) -> dict[str, Any]:\n    ...\n\n",
  "/src/typings/shiny/render/_render.pyi": "import pandas as pd\nfrom typing import Any, Awaitable, Callable, Generic, Optional, Protocol, TYPE_CHECKING, TypeVar, Union, overload, runtime_checkable\nfrom htmltools import TagChild\nfrom ..session import Session\nfrom ..session._utils import RenderedDeps\nfrom ..types import ImgData\n\n__all__ = (\"RenderFunction\", \"RenderFunctionAsync\", \"RenderText\", \"RenderTextAsync\", \"text\", \"RenderPlot\", \"RenderPlotAsync\", \"plot\", \"RenderImage\", \"RenderImageAsync\", \"image\", \"RenderTable\", \"RenderTableAsync\", \"table\", \"RenderUI\", \"RenderUIAsync\", \"ui\")\nif TYPE_CHECKING:\n    ...\nIT = TypeVar(\"IT\")\nOT = TypeVar(\"OT\")\nclass RenderFunction(Generic[IT, OT]):\n    def __init__(self, fn: Callable[[], IT]) -> None:\n        ...\n    \n    def __call__(self) -> OT:\n        ...\n    \n    def set_metadata(self, session: Session, name: str) -> None:\n        \"\"\"When RenderFunctions are assigned to Output object slots, this method\n        is used to pass along session and name information.\n        \"\"\"\n        ...\n    \n\n\nclass RenderFunctionAsync(RenderFunction[IT, OT]):\n    async def __call__(self) -> OT:\n        ...\n    \n\n\nRenderTextFunc = Callable[[], \"str | None\"]\nRenderTextFuncAsync = Callable[[], Awaitable[\"str | None\"]]\nclass RenderText(RenderFunction[\"str | None\", \"str | None\"]):\n    def __init__(self, fn: RenderTextFunc) -> None:\n        ...\n    \n    def __call__(self) -> str | None:\n        ...\n    \n\n\nclass RenderTextAsync(RenderText, RenderFunctionAsync[\"str | None\", \"str | None\"]):\n    def __init__(self, fn: RenderTextFuncAsync) -> None:\n        ...\n    \n    async def __call__(self) -> str | None:\n        ...\n    \n\n\n@overload\ndef text(fn: RenderTextFunc | RenderTextFuncAsync) -> RenderText:\n    ...\n\n@overload\ndef text() -> Callable[[RenderTextFunc | RenderTextFuncAsync], RenderText]:\n    ...\n\ndef text(fn: Optional[RenderTextFunc | RenderTextFuncAsync] = ...) -> RenderText | Callable[[RenderTextFunc | RenderTextFuncAsync], RenderText]:\n    \"\"\"\n    Reactively render text.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns a string.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_text` container (see :func:`~shiny.ui.output_text` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_text\n    \"\"\"\n    ...\n\nRenderPlotFunc = Callable[[], object]\nRenderPlotFuncAsync = Callable[[], Awaitable[object]]\nclass RenderPlot(RenderFunction[object, \"ImgData | None\"]):\n    _ppi: float = ...\n    _is_userfn_async = ...\n    def __init__(self, fn: RenderPlotFunc, *, alt: Optional[str] = ..., **kwargs: object) -> None:\n        ...\n    \n    def __call__(self) -> ImgData | None:\n        ...\n    \n\n\nclass RenderPlotAsync(RenderPlot, RenderFunctionAsync[object, \"ImgData | None\"]):\n    _is_userfn_async = ...\n    def __init__(self, fn: RenderPlotFuncAsync, alt: Optional[str] = ..., **kwargs: Any) -> None:\n        ...\n    \n    async def __call__(self) -> ImgData | None:\n        ...\n    \n\n\n@overload\ndef plot(fn: RenderPlotFunc | RenderPlotFuncAsync) -> RenderPlot:\n    ...\n\n@overload\ndef plot(*, alt: Optional[str] = ..., **kwargs: Any) -> Callable[[RenderPlotFunc | RenderPlotFuncAsync], RenderPlot]:\n    ...\n\ndef plot(fn: Optional[RenderPlotFunc | RenderPlotFuncAsync] = ..., *, alt: Optional[str] = ..., **kwargs: Any) -> RenderPlot | Callable[[RenderPlotFunc | RenderPlotFuncAsync], RenderPlot]:\n    \"\"\"\n    Reactively render a plot object as an HTML image.\n\n    Parameters\n    ----------\n    alt\n        Alternative text for the image if it cannot be displayed or viewed (i.e., the\n        user uses a screen reader).\n    **kwargs\n        Additional keyword arguments passed to the relevant method for saving the image\n        (e.g., for matplotlib, arguments to ``savefig()``; for PIL and plotnine,\n        arguments to ``save()``).\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A :class:`matplotlib.figure.Figure` instance.\n        2. An :class:`matplotlib.artist.Artist` instance.\n        3. A list/tuple of Figure/Artist instances.\n        4. An object with a 'figure' attribute pointing to a\n           :class:`matplotlib.figure.Figure` instance.\n        5. A :class:`PIL.Image.Image` instance.\n\n    It's also possible to use the ``matplotlib.pyplot`` interface; in that case, your\n    function should just call pyplot functions and not return anything. (Note that if\n    the decorated function is async, then it's not safe to use pyplot. Shiny will detect\n    this case and throw an error asking you to use matplotlib's object-oriented\n    interface instead.)\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of a\n    :func:`~shiny.ui.output_plot` container (see :func:`~shiny.ui.output_plot` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_plot\n    ~shiny.render.image\n    \"\"\"\n    ...\n\nRenderImageFunc = Callable[[], \"ImgData | None\"]\nRenderImageFuncAsync = Callable[[], Awaitable[\"ImgData | None\"]]\nclass RenderImage(RenderFunction[\"ImgData | None\", \"ImgData | None\"]):\n    def __init__(self, fn: RenderImageFunc, *, delete_file: bool = ...) -> None:\n        ...\n    \n    def __call__(self) -> ImgData | None:\n        ...\n    \n\n\nclass RenderImageAsync(RenderImage, RenderFunctionAsync[\"ImgData | None\", \"ImgData | None\"]):\n    def __init__(self, fn: RenderImageFuncAsync, delete_file: bool = ...) -> None:\n        ...\n    \n    async def __call__(self) -> ImgData | None:\n        ...\n    \n\n\n@overload\ndef image(fn: RenderImageFunc | RenderImageFuncAsync) -> RenderImage:\n    ...\n\n@overload\ndef image(*, delete_file: bool = ...) -> Callable[[RenderImageFunc | RenderImageFuncAsync], RenderImage]:\n    ...\n\ndef image(fn: Optional[RenderImageFunc | RenderImageFuncAsync] = ..., *, delete_file: bool = ...) -> RenderImage | Callable[[RenderImageFunc | RenderImageFuncAsync], RenderImage]:\n    \"\"\"\n    Reactively render a image file as an HTML image.\n\n    Parameters\n    ----------\n    delete_file\n        If ``True``, the image file will be deleted after rendering.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns an `~shiny.types.ImgData` object.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_image` container (see :func:`~shiny.ui.output_image` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_image\n    ~shiny.types.ImgData\n    ~shiny.render.plot\n    \"\"\"\n    ...\n\n@runtime_checkable\nclass PandasCompatible(Protocol):\n    def to_pandas(self) -> pd.DataFrame:\n        ...\n    \n\n\nTableResult = Union[None, \"pd.DataFrame\", PandasCompatible]\nRenderTableFunc = Callable[[], TableResult]\nRenderTableFuncAsync = Callable[[], Awaitable[TableResult]]\nclass RenderTable(RenderFunction[object, \"RenderedDeps | None\"]):\n    def __init__(self, fn: RenderTableFunc, *, index: bool = ..., classes: str = ..., border: int = ..., **kwargs: object) -> None:\n        ...\n    \n    def __call__(self) -> RenderedDeps | None:\n        ...\n    \n\n\nclass RenderTableAsync(RenderTable, RenderFunctionAsync[object, \"ImgData | None\"]):\n    def __init__(self, fn: RenderTableFuncAsync, *, index: bool = ..., classes: str = ..., border: int = ..., **kwargs: Any) -> None:\n        ...\n    \n    async def __call__(self) -> RenderedDeps | None:\n        ...\n    \n\n\n@overload\ndef table(fn: RenderTableFunc | RenderTableFuncAsync) -> RenderTable:\n    ...\n\n@overload\ndef table(*, index: bool = ..., classes: str = ..., border: int = ..., **kwargs: Any) -> Callable[[RenderTableFunc | RenderTableFuncAsync], RenderTable]:\n    ...\n\ndef table(fn: Optional[RenderTableFunc | RenderTableFuncAsync] = ..., *, index: bool = ..., classes: str = ..., border: int = ..., **kwargs: Any) -> RenderTable | Callable[[RenderTableFunc | RenderTableFuncAsync], RenderTable]:\n    \"\"\"\n    Reactively render a Pandas data frame object (or similar) as a basic HTML table.\n\n    Consider using ~shiny.render.data_frame instead of this renderer, as it provides\n    high performance virtual scrolling, built-in filtering and sorting, and a better\n    default appearance. This renderer may still be helpful if you use pandas styling\n    features that are not currently supported by ~shiny.render.data_frame.\n\n    Parameters\n    ----------\n    index\n        Whether to print index (row) labels. (Ignored for pandas :class:`Styler`\n        objects; call ``style.hide(axis=\"index\")`` from user code instead.)\n    classes\n        CSS classes (space separated) to apply to the resulting table. By default, we\n        use `table shiny-table w-auto` which is designed to look reasonable with Bootstrap 5.\n        (Ignored for pandas :class:`Styler` objects; call\n        ``style.set_table_attributes('class=\"dataframe table shiny-table w-auto\"')``\n        from user code instead.)\n    **kwargs\n        Additional keyword arguments passed to ``pandas.DataFrame.to_html()`` or\n        ``pandas.io.formats.style.Styler.to_html()``.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A pandas :class:`DataFrame` object.\n        2. A pandas :class:`Styler` object.\n        3. Any object that has a `.to_pandas()` method (e.g., a Polars data frame or\n           Arrow table).\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_table` container (see :func:`~shiny.ui.output_table` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_table for the corresponding UI component to this render function.\n    \"\"\"\n    ...\n\nRenderUIFunc = Callable[[], TagChild]\nRenderUIFuncAsync = Callable[[], Awaitable[TagChild]]\nclass RenderUI(RenderFunction[TagChild, \"RenderedDeps | None\"]):\n    def __init__(self, fn: RenderUIFunc) -> None:\n        ...\n    \n    def __call__(self) -> RenderedDeps | None:\n        ...\n    \n\n\nclass RenderUIAsync(RenderUI, RenderFunctionAsync[TagChild, \"RenderedDeps| None\"]):\n    def __init__(self, fn: RenderUIFuncAsync) -> None:\n        ...\n    \n    async def __call__(self) -> RenderedDeps | None:\n        ...\n    \n\n\n@overload\ndef ui(fn: RenderUIFunc | RenderUIFuncAsync) -> RenderUI:\n    ...\n\n@overload\ndef ui() -> Callable[[RenderUIFunc | RenderUIFuncAsync], RenderUI]:\n    ...\n\ndef ui(fn: Optional[RenderUIFunc | RenderUIFuncAsync] = ...) -> RenderUI | Callable[[RenderUIFunc | RenderUIFuncAsync], RenderUI]:\n    \"\"\"\n    Reactively render HTML content.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns an object of type `~shiny.ui.TagChild`.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_ui` container (see :func:`~shiny.ui.output_ui` for example\n    usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_ui\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/render/_try_render_plot.pyi": "from typing import Optional, TYPE_CHECKING, Tuple\nfrom matplotlib.figure import Figure\n\nTryPlotResult = Tuple[bool, \"ImgData| None\"]\nif TYPE_CHECKING:\n    ...\ndef try_render_matplotlib(x: object, width: float, height: float, pixelratio: float, ppi: float, allow_global: bool, alt: Optional[str], **kwargs: object) -> TryPlotResult:\n    ...\n\ndef get_matplotlib_figure(x: object, allow_global: bool) -> Figure | None:\n    ...\n\ndef try_render_pil(x: object, width: float, height: float, pixelratio: float, ppi: float, alt: Optional[str] = ..., **kwargs: object) -> TryPlotResult:\n    ...\n\ndef try_render_plotnine(x: object, width: float, height: float, pixelratio: float, ppi: float, alt: Optional[str] = ..., **kwargs: object) -> TryPlotResult:\n    ...\n\n",
  "/src/typings/shiny/session/__init__.pyi": "from ._session import Inputs, Outputs, Session\nfrom ._utils import get_current_session, require_active_session, session_context as session_context\n\n\"\"\"\nTools for working within a (user) session context.\n\"\"\"\n__all__ = (\"Session\", \"Inputs\", \"Outputs\", \"get_current_session\", \"require_active_session\")\n",
  "/src/typings/shiny/session/_session.pyi": "import dataclasses\nimport enum\nfrom typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar, overload\nfrom starlette.requests import HTTPConnection, Request\nfrom starlette.types import ASGIApp\nfrom .._app import App\nfrom .._connection import Connection\nfrom .._docstring import add_example\nfrom .._namespaces import Id, ResolvedId\nfrom .._typing_extensions import TypedDict\nfrom ..reactive import Effect_, Value\nfrom ..render import RenderFunction\n\n__all__ = (\"Session\", \"Inputs\", \"Outputs\")\nif TYPE_CHECKING:\n    ...\nIT = TypeVar(\"IT\")\nOT = TypeVar(\"OT\")\nclass ConnectionState(enum.Enum):\n    Start = ...\n    Running = ...\n    Closed = ...\n\n\nclass ProtocolError(Exception):\n    message: str\n    def __init__(self, message: str = ...) -> None:\n        ...\n    \n\n\nclass SessionWarning(RuntimeWarning):\n    ...\n\n\nclass ClientMessage(TypedDict):\n    method: str\n    ...\n\n\nclass ClientMessageInit(ClientMessage):\n    data: dict[str, object]\n    ...\n\n\nclass ClientMessageUpdate(ClientMessage):\n    data: dict[str, object]\n    ...\n\n\nclass ClientMessageOther(ClientMessage):\n    args: list[object]\n    tag: int\n    ...\n\n\nDownloadHandler = Callable[[], \"str | Iterable[bytes | str] | AsyncIterable[bytes | str]\"]\nDynamicRouteHandler = Callable[[Request], ASGIApp]\n@dataclasses.dataclass\nclass DownloadInfo:\n    filename: Callable[[], str] | str | None\n    content_type: Optional[Callable[[], str] | str]\n    handler: DownloadHandler\n    encoding: str\n    ...\n\n\nclass OutBoundMessageQueues(TypedDict):\n    values: list[dict[str, Any]]\n    input_messages: list[dict[str, Any]]\n    errors: list[dict[str, Any]]\n    ...\n\n\ndef empty_outbound_message_queues() -> OutBoundMessageQueues:\n    ...\n\nclass SessionMeta(type):\n    def __instancecheck__(self, __instance: Any) -> bool:\n        ...\n    \n\n\nclass Session(metaclass=SessionMeta):\n    \"\"\"\n    A class representing a user session.\n    \"\"\"\n    ns: ResolvedId = ...\n    app: App\n    id: str\n    http_conn: HTTPConnection\n    input: Inputs\n    output: Outputs\n    user: str | None\n    groups: list[str] | None\n    def __init__(self, app: App, id: str, conn: Connection, debug: bool = ...) -> None:\n        ...\n    \n    async def close(self, code: int = ...) -> None:\n        \"\"\"\n        Close the session.\n        \"\"\"\n        ...\n    \n    def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send an input message to the session.\n\n        Sends a message to an input on the session's client web page; if the input is\n        present and bound on the page at the time the message is received, then the\n        input binding object's ``receiveMessage(el, message)`` method will be called.\n        This method should generally not be called directly from Shiny apps, but through\n        friendlier wrapper functions like ``ui.update_text()``.\n\n        Parameters\n        ----------\n        id\n            An id matching the id of an input to update.\n        message\n            The message to send.\n        \"\"\"\n        ...\n    \n    @add_example()\n    async def send_custom_message(self, type: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send a message to the client.\n\n        Parameters\n        ----------\n        type\n            The type of message to send.\n        message\n            The message to send.\n\n        Note\n        ----\n        Sends messages to the client which can be handled in JavaScript with\n        ``Shiny.addCustomMessageHandler(type, function(message){...})``. Once the\n        message handler is added, it will be invoked each time ``send_custom_message()``\n        is called on the server.\n        \"\"\"\n        ...\n    \n    @add_example()\n    def on_flush(self, fn: Callable[[], None], once: bool = ...) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call before the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        ...\n    \n    @add_example()\n    def on_flushed(self, fn: Callable[[], None], once: bool = ...) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call after the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        ...\n    \n    @add_example()\n    def on_ended(self, fn: Callable[[], None]) -> Callable[[], None]:\n        \"\"\"\n        Registers a function to be called after the client has disconnected.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        ...\n    \n    @add_example()\n    def download(self, id: Optional[str] = ..., filename: Optional[str | Callable[[], str]] = ..., media_type: None | str | Callable[[], str] = ..., encoding: str = ...) -> Callable[[DownloadHandler], None]:\n        \"\"\"\n        Decorator to register a function to handle a download.\n\n        Parameters\n        ----------\n        id\n            The name of the download.\n        filename\n            The filename of the download.\n        media_type\n            The media type of the download.\n        encoding\n            The encoding of the download.\n\n        Returns\n        -------\n        :\n            The decorated function.\n        \"\"\"\n        ...\n    \n    @add_example()\n    def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        \"\"\"\n        Register a function to call when a dynamically generated, session-specific,\n        route is requested.\n\n        Provides a convenient way to serve-up session-dependent values for other\n        clients/applications to consume.\n\n        Parameters\n        ----------\n        name\n            A name for the route (used to determine part of the URL path).\n        handler\n            The function to call when a request is made to the route. This function\n            should take a single argument (a :class:`starlette.requests.Request` object)\n            and return a :class:`starlette.types.ASGIApp` object.\n\n\n        Returns\n        -------\n        :\n            The URL path for the route.\n        \"\"\"\n        ...\n    \n    def make_scope(self, id: Id) -> Session:\n        ...\n    \n    def root_scope(self) -> Session:\n        ...\n    \n\n\nclass SessionProxy:\n    ns: ResolvedId\n    input: Inputs\n    output: Outputs\n    def __init__(self, parent: Session, ns: ResolvedId) -> None:\n        ...\n    \n    def __getattr__(self, attr: str) -> Any:\n        ...\n    \n    def make_scope(self, id: str) -> Session:\n        ...\n    \n    def root_scope(self) -> Session:\n        ...\n    \n    def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        ...\n    \n    def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        ...\n    \n    def download(self, id: Optional[str] = ..., **kwargs: object) -> Callable[[DownloadHandler], None]:\n        ...\n    \n\n\nclass Inputs:\n    \"\"\"\n    A class representing Shiny input values.\n\n    This class provides access to a :class:`~shiny.session.Session`'s input values. The\n    input values are reactive :class:`~shiny.reactive.Values`, and can be accessed with\n    the ``[]`` operator, or with ``.``. For example, if there is an input named ``x``,\n    it can be accessed via ``input[\"x\"]()`` or ``input.x()``.\n    \"\"\"\n    def __init__(self, values: dict[str, Value[Any]], ns: Callable[[str], str] = ...) -> None:\n        ...\n    \n    def __setitem__(self, key: str, value: Value[Any]) -> None:\n        ...\n    \n    def __getitem__(self, key: str) -> Value[Any]:\n        ...\n    \n    def __delitem__(self, key: str) -> None:\n        ...\n    \n    def __setattr__(self, attr: str, value: Value[Any]) -> None:\n        ...\n    \n    def __getattr__(self, attr: str) -> Value[Any]:\n        ...\n    \n    def __delattr__(self, key: str) -> None:\n        ...\n    \n    def __contains__(self, key: str) -> bool:\n        ...\n    \n\n\nclass Outputs:\n    \"\"\"\n    A class representing Shiny output definitions.\n    \"\"\"\n    def __init__(self, session: Session, ns: Callable[[str], str], effects: dict[str, Effect_], suspend_when_hidden: dict[str, bool]) -> None:\n        ...\n    \n    @overload\n    def __call__(self, fn: RenderFunction[Any, Any]) -> None:\n        ...\n    \n    @overload\n    def __call__(self, *, id: Optional[str] = ..., suspend_when_hidden: bool = ..., priority: int = ..., name: Optional[str] = ...) -> Callable[[RenderFunction[Any, Any]], None]:\n        ...\n    \n    def __call__(self, fn: Optional[RenderFunction[IT, OT]] = ..., *, id: Optional[str] = ..., suspend_when_hidden: bool = ..., priority: int = ..., name: Optional[str] = ...) -> None | Callable[[RenderFunction[IT, OT]], None]:\n        ...\n    \n\n\n",
  "/src/typings/shiny/session/_utils.pyi": "from contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar\nfrom ._session import Session\nfrom .._typing_extensions import TypedDict\n\n__all__ = (\"get_current_session\", \"session_context\", \"require_active_session\")\nif TYPE_CHECKING:\n    ...\nclass RenderedDeps(TypedDict):\n    deps: list[dict[str, Any]]\n    html: str\n    ...\n\n\n_current_session: ContextVar[Optional[Session]] = ...\ndef get_current_session() -> Optional[Session]:\n    \"\"\"\n    Get the current user session.\n\n    Returns\n    -------\n    :\n        The current session if one is active, otherwise ``None``.\n\n    Note\n    ----\n    Shiny apps should not need to call this function directly. Instead, it's intended to\n    be used by Shiny developing who wish to create new functions that should only be\n    called from within an active Shiny session.\n\n    See Also\n    -------\n    ~require_active_session\n    \"\"\"\n    ...\n\n@contextmanager\ndef session_context(session: Optional[Session]): # -> Generator[None, Any, None]:\n    \"\"\"\n    Context manager for current session.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n    \"\"\"\n    ...\n\ndef require_active_session(session: Optional[Session]) -> Session:\n    \"\"\"\n    Raise an exception if no Shiny session is currently active.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The session.\n\n    Note\n    ----\n    Shiny apps should not need to call this function directly. Instead, it's intended to\n    be used by Shiny developing who wish to create new functions that should only be\n    called from within an active Shiny session.\n\n    Raises\n    ------\n    ValueError\n        If session is not active.\n\n    See Also\n    -------\n    ~get_current_session\n    \"\"\"\n    ...\n\nT = TypeVar(\"T\", str, int)\ndef read_thunk(thunk: Callable[[], T] | T) -> T:\n    ...\n\ndef read_thunk_opt(thunk: Optional[Callable[[], T] | T]) -> Optional[T]:\n    ...\n\n",
  "/src/typings/shiny/ui/__init__.pyi": "from ._bootstrap import column, help_text, layout_sidebar, panel_absolute, panel_conditional, panel_fixed, panel_main, panel_sidebar, panel_title, panel_well, row\nfrom ._download_button import download_button, download_link\nfrom ._plot_output_opts import brush_opts, click_opts, dblclick_opts, hover_opts\nfrom ._include_helpers import include_css, include_js\nfrom ._input_action_button import input_action_button, input_action_link\nfrom ._input_check_radio import input_checkbox, input_checkbox_group, input_radio_buttons, input_switch\nfrom ._input_date import input_date, input_date_range\nfrom ._input_file import input_file\nfrom ._input_numeric import input_numeric\nfrom ._input_password import input_password\nfrom ._input_select import input_select, input_selectize\nfrom ._input_slider import AnimationOptions, SliderStepArg, SliderValueArg, input_slider\nfrom ._input_text import input_text, input_text_area\nfrom ._input_update import update_action_button, update_action_link, update_checkbox, update_checkbox_group, update_date, update_date_range, update_navs, update_numeric, update_radio_buttons, update_select, update_selectize, update_slider, update_switch, update_text, update_text_area\nfrom ._insert import insert_ui, remove_ui\nfrom ._markdown import markdown\nfrom ._modal import modal, modal_button, modal_remove, modal_show\nfrom ._navs import nav, nav_control, nav_menu, nav_spacer, navset_bar, navset_hidden, navset_pill, navset_pill_card, navset_pill_list, navset_tab, navset_tab_card\nfrom ._notification import notification_remove, notification_show\nfrom ._output import output_image, output_plot, output_table, output_text, output_text_verbatim, output_ui\nfrom ._page import page_bootstrap, page_fixed, page_fluid, page_navbar\nfrom ._progress import Progress\nfrom .dataframe import output_data_frame\nfrom htmltools import HTML, Tag, TagAttrValue, TagAttrs, TagChild, TagList, a, br, code, div, em, h1, h2, h3, h4, h5, h6, head_content, hr, img, p, pre, span, strong, tags\n\n\"\"\"\nTools for creating user interfaces including: custom components, HTML components,\nlayout helpers, page-level containers, and more.\n\"\"\"\n__all__ = (\"row\", \"column\", \"layout_sidebar\", \"panel_well\", \"panel_sidebar\", \"panel_main\", \"panel_conditional\", \"panel_title\", \"panel_fixed\", \"panel_absolute\", \"help_text\", \"download_button\", \"download_link\", \"brush_opts\", \"click_opts\", \"dblclick_opts\", \"hover_opts\", \"include_css\", \"include_js\", \"input_action_button\", \"input_action_link\", \"input_checkbox\", \"input_checkbox_group\", \"input_switch\", \"input_radio_buttons\", \"input_date\", \"input_date_range\", \"input_file\", \"input_numeric\", \"input_password\", \"input_select\", \"input_selectize\", \"input_slider\", \"SliderValueArg\", \"SliderStepArg\", \"AnimationOptions\", \"input_text\", \"input_text_area\", \"update_action_button\", \"update_action_link\", \"update_checkbox\", \"update_switch\", \"update_checkbox_group\", \"update_radio_buttons\", \"update_date\", \"update_date_range\", \"update_numeric\", \"update_select\", \"update_selectize\", \"update_slider\", \"update_text\", \"update_text_area\", \"update_navs\", \"insert_ui\", \"remove_ui\", \"markdown\", \"modal_button\", \"modal\", \"modal_show\", \"modal_remove\", \"nav\", \"nav_menu\", \"nav_control\", \"nav_spacer\", \"navset_tab\", \"navset_tab_card\", \"navset_pill\", \"navset_pill_card\", \"navset_pill_list\", \"navset_hidden\", \"navset_bar\", \"notification_show\", \"notification_remove\", \"output_data_frame\", \"output_plot\", \"output_image\", \"output_text\", \"output_text_verbatim\", \"output_table\", \"output_ui\", \"page_navbar\", \"page_fluid\", \"page_fixed\", \"page_bootstrap\", \"Progress\", \"TagList\", \"Tag\", \"TagChild\", \"TagAttrs\", \"TagAttrValue\", \"tags\", \"HTML\", \"head_content\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"a\", \"br\", \"div\", \"span\", \"pre\", \"code\", \"img\", \"strong\", \"em\", \"hr\")\n",
  "/src/typings/shiny/ui/_bootstrap.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild, TagList, Tagifiable\nfrom .._docstring import add_example\nfrom ..types import MISSING_TYPE\n\n__all__ = (\"row\", \"column\", \"layout_sidebar\", \"panel_well\", \"panel_sidebar\", \"panel_main\", \"panel_conditional\", \"panel_title\", \"panel_fixed\", \"panel_absolute\", \"help_text\")\n@add_example()\ndef row(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Responsive row-column based layout\n\n    Layout UI components using Bootstrap's grid layout system. Use ``row()`` to group\n    elements that should appear on the same line (if the browser has adequate width) and\n    :func:`~shiny.ui.column` to define how much horizontal space within a 12-unit wide\n    grid each on of these elements should occupy. See the [layout\n    guide](https://shiny.posit.co/articles/layout-guide.html>) for more context and\n    examples.\n    (The article is about Shiny for R, but the general principles are the same.)\n\n    Parameters\n    ----------\n    args\n        Any number of child elements.\n    kwargs\n        Attributes to place on the row tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.column`\n    \"\"\"\n    ...\n\ndef column(width: int, *args: TagChild | TagAttrs, offset: int = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Responsive row-column based layout\n\n    See :func:`~shiny.ui.row` for more information.\n\n    Parameters\n    ----------\n    width\n        The width of the column (an integer between 1 and 12).\n    args\n        UI elements to place within the column.\n    offset\n        The number of columns to offset this column from the end of the previous column.\n    kwargs\n        Attributes to place on the column tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.row`\n    \"\"\"\n    ...\n\n@add_example()\ndef layout_sidebar(sidebar: TagChild, main: TagChild, position: Literal[\"left\", \"right\"] = ...) -> Tagifiable:\n    \"\"\"\n    Layout a sidebar and main area\n\n    Create a layout with a sidebar (:func:`~shiny.ui.panel_sidebar`) and main area\n    (:func:`~shiny.ui.panel_main`). The sidebar is displayed with a distinct background\n    color and typically contains input controls. By default, the main area occupies 2/3\n    of the horizontal width and typically contains outputs.\n\n    Parameters\n    ----------\n    sidebar\n        A UI element to place in the sidebar (typically a\n        :func:`~shiny.ui.panel_sidebar`)\n    main\n        A UI element to place in the main area (typically a\n        :func:`~shiny.ui.panel_main`)\n    position\n        The position of the sidebar (left or right)\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n    ...\n\ndef panel_well(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a well panel\n\n    Creates a panel with a slightly inset border and grey background. Equivalent to\n    Bootstrap's ``well`` CSS class.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Attributes to place on the panel tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n    ...\n\ndef panel_sidebar(*args: TagChild | TagAttrs, width: int = ..., **kwargs: TagAttrValue) -> Tagifiable:\n    \"\"\"\n    Create a sidebar panel\n\n    See :func:`~shiny.ui.layout_sidebar` for more information and an example.\n\n    Parameters\n    ----------\n\n    args\n        UI elements to include inside the sidebar.\n    width\n        The width of the sidebar (an integer between 1 and 12)\n    kwargs\n        Attributes to place on the sidebar tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n    ...\n\ndef panel_main(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tagifiable:\n    \"\"\"\n    Create an main area panel\n\n    See :func:`~shiny.ui.layout_sidebar` for more information and an example.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the main area.\n    kwargs\n        Attributes to place on the main area tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.layout_sidebar`\n    \"\"\"\n    ...\n\n@add_example()\ndef panel_conditional(condition: str, *args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a conditional panel\n\n    Show UI elements only if a ``JavaScript`` condition is ``true``.\n\n    Parameters\n    ----------\n    condition\n        A JavaScript expression that will be evaluated repeatedly to determine whether\n        the panel should be displayed.\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Attributes to place on the panel tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    In the JS expression, you can refer to input and output JavaScript objects that\n    contain the current values of input and output. For example, if you have an input\n    with an id of foo, then you can use input.foo to read its value. (Be sure not to\n    modify the input/output objects, as this may cause unpredictable behavior.)\n\n    You are not recommended to use special JavaScript characters such as a period . in\n    the input id's, but if you do use them anyway, for example, ``id = \"foo.bar\"``, you\n    will have to use ``input[\"foo.bar\"]`` instead of ``input.foo.bar`` to read the input\n    value.\n\n    Tip\n    ---\n    A more powerful (but slower) way to conditionally show UI content is to use\n    :func:`~shiny.render.ui`.\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_ui\n    \"\"\"\n    ...\n\n@add_example()\ndef panel_title(title: str | Tag | TagList, window_title: str | MISSING_TYPE = ...) -> TagList:\n    \"\"\"\n    Create title(s) for the application.\n\n    Parameters\n    ----------\n    title\n        A title to display in the app's UI.\n    window_title\n        A title to display on the browser tab.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    This result of this function causes a side effect of adding a title tag to the head\n    of the document (this is necessary for the browser to display the title in the\n    browser window). You can also specify a page title explicitly using the title\n    parameter of the top-level page function (e.g., :func:`~shiny.ui.page_fluid`).\n    \"\"\"\n    ...\n\ndef panel_fixed(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> TagList:\n    \"\"\"\n    Create a panel of absolutely positioned content.\n\n    This function is equivalent to calling :func:`~shiny.ui.panel_absolute` with\n    ``fixed=True`` (i.e., the panel does not scroll with the rest of the page). See\n    :func:`~shiny.ui.panel_absolute` for more information.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Arguments passed along to :func:`~shiny.ui.panel_absolute`.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_absolute`\n    \"\"\"\n    ...\n\n@add_example()\ndef panel_absolute(*args: TagChild | TagAttrs, top: Optional[str] = ..., left: Optional[str] = ..., right: Optional[str] = ..., bottom: Optional[str] = ..., width: Optional[str] = ..., height: Optional[str] = ..., draggable: bool = ..., fixed: bool = ..., cursor: Literal[\"auto\", \"move\", \"default\", \"inherit\"] = ..., **kwargs: TagAttrValue) -> TagList:\n    \"\"\"\n    Create a panel of absolutely positioned content.\n\n    Creates a ``<div>`` tag whose CSS position is set to absolute (or fixed if ``fixed =\n    True``). The way absolute positioning works in HTML is that absolute coordinates are\n    specified relative to its nearest parent element whose position is not set to static\n    (which is the default), and if no such parent is found, then relative to the page\n    borders. If you're not sure what that means, just keep in mind that you may get\n    strange results if you use this function from inside of certain types of panels.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    top\n        Distance between the top of the panel, and the top of the page or parent\n        container.\n    left\n        Distance between the left side of the panel, and the left of the page or parent\n        container.\n    right\n        Distance between the right side of the panel, and the right of the page or\n        parent container.\n    bottom\n        Distance between the bottom of the panel, and the bottom of the page or parent\n        container.\n    width\n        Width of the panel.\n    height\n        Height of the panel.\n    draggable\n        If ``True``, allows the user to move the panel by clicking and dragging.\n    fixed\n        Positions the panel relative to the browser window and prevents it from being\n        scrolled with the rest of the page.\n    cursor\n        The type of cursor that should appear when the user mouses over the panel. Use\n        ``\"move\"`` for a north-east-south-west icon, ``\"default\"`` for the usual cursor\n        arrow, or ``\"inherit\"`` for the usual cursor behavior (including changing to an\n        I-beam when the cursor is over text). The default is ``\"auto\"``, which is\n        equivalent to ``\"move\" if draggable else \"inherit\"``.\n    kwargs\n        Attributes added to the content's container tag.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Tip\n    ----\n    The position (``top``, ``left``, ``right``, ``bottom``) and size (``width``,\n    ``height``) parameters are all optional, but you should specify exactly two of top,\n    bottom, and height and exactly two of left, right, and width for predictable\n    results.\n\n    Like most other distance parameters in Shiny, the position and size parameters take\n    a number (interpreted as pixels) or a valid CSS size string, such as ``\"100px\"``\n    (100 pixels) or ``\"25%\"``.\n\n    For arcane HTML reasons, to have the panel fill the page or parent you should\n    specify 0 for ``top``, ``left``, ``right``, and ``bottom`` rather than the more\n    obvious ``width = \"100%\"`` and ``height = \"100%\"``.\n    \"\"\"\n    ...\n\ndef help_text(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a help text element\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the help text.\n    kwargs\n        Attributes to add to the text container.\n\n    Returns\n    -------\n    :\n        A UI element\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_download_button.pyi": "from typing import Optional\nfrom htmltools import Tag, TagAttrValue, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"download_button\", \"download_link\")\n@add_example()\ndef download_button(id: str, label: TagChild, *, icon: TagChild = ..., width: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a download button\n\n    Parameters\n    ----------\n    id\n        An id for the download.\n    label\n        An input label.\n    icon\n        An icon to display on the button.\n    width\n        The width of the button.\n    kwargs\n        Additional attributes for the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    --------\n    ~shiny.Session.download\n    ~shiny.ui.download_link\n    \"\"\"\n    ...\n\n@add_example()\ndef download_link(id: str, label: TagChild, *, icon: TagChild = ..., width: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a download button\n\n    Parameters\n    ----------\n    id\n        An id for the download.\n    label\n        An input label.\n    icon\n        An icon to display on the button.\n    width\n        The width of the button.\n    kwargs\n        Additional attributes for the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    --------\n    ~shiny.Session.download\n    ~shiny.ui.download_link\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_html_dependencies.pyi": "from htmltools import HTMLDependency\n\ndef nav_spacer_deps() -> list[HTMLDependency]:\n    ...\n\ndef bootstrap_deps() -> list[HTMLDependency]:\n    ...\n\ndef ionrangeslider_deps() -> list[HTMLDependency]:\n    ...\n\ndef datepicker_deps() -> HTMLDependency:\n    ...\n\ndef selectize_deps() -> HTMLDependency:\n    ...\n\ndef jqui_deps() -> HTMLDependency:\n    ...\n\n",
  "/src/typings/shiny/ui/_include_helpers.pyi": "from pathlib import Path\nfrom typing import Literal\nfrom htmltools import HTMLDependency, Tag, TagAttrValue\nfrom .._docstring import add_example\n\n__all__ = (\"include_js\", \"include_css\")\n@add_example()\ndef include_js(path: Path | str, *, method: Literal[\"link\", \"link_files\", \"inline\"] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Include a JavaScript file\n\n    Parameters\n    ----------\n    path\n        A path to a JS file.\n    method\n        One of the following: ``\"link\"``, ``\"link_files\"``, or ``\"inline\"``. ``\"link\"``\n        is the link to the CSS file via a :func:`~ui.tags.link` tag. This method is\n        generally preferrable to ``\"inline\"`` since it allows the browser to cache the\n        file. ``\"link_files\"`` is the same as ``\"link\"``, but also allow for the CSS\n        file to request other files within ``path``'s immediate parent directory (e.g.,\n        ``@import()`` another file). Note that this isn't the default behavior because\n        you should **be careful not to include files in the same directory as ``path``\n        that contain sensitive information**. A good general rule of thumb to follow is\n        to have ``path`` be located in a subdirectory of the app directory. For example,\n        if the app's source is located at ``/app/app.py``, then ``path`` should be\n        somewhere like ``/app/css/custom.css`` (and all the other relevant accompanying\n        'safe' files should be located under ``/app/css/``). And finally, ``\"inline\"``\n        is the inline the CSS file contents within a :func:`~ui.tags.style` tag.\n    **kwargs\n        Attributes which are passed on to `~ui.tags.script`\n\n\n    Returns\n    -------\n    :\n        A :func:`~ui.tags.script` tag.\n\n    Note\n    ----\n    This places a :func:`~ui.tags.script` tag in the :func:`~ui.tags.body` of the\n    document. If instead, you want to place the tag in the :func:`~ui.tags.head` of the\n    document, you can wrap it in ``head_content`` (in this case, just make sure you're\n    aware that the DOM probably won't be ready when the script is executed).\n\n    ```{python}\n    #| eval: false\n    ui.page_fluid(\n        ui.head_content(ui.include_js(\"custom.js\")),\n    )\n\n    # Alternately you can inline Javscript by changing the method.\n    ui.page_fluid(\n        ui.head_content(ui.include_js(\"custom.js\", method = \"inline\")),\n    )\n    ```\n\n    See Also\n    --------\n    ~ui.tags.script\n    ~include_css\n    \"\"\"\n    ...\n\n@add_example()\ndef include_css(path: Path | str, *, method: Literal[\"link\", \"link_files\", \"inline\"] = ...) -> Tag:\n    \"\"\"\n    Include a CSS file\n\n    Parameters\n    ----------\n    path\n        A path to a CSS file.\n    method\n        One of the following: ``\"link\"``, ``\"link_files\"``, or ``\"inline\"``. ``\"link\"``\n        is the link to the CSS file via a :func:`~ui.tags.link` tag. This method is\n        generally preferrable to ``\"inline\"`` since it allows the browser to cache the\n        file. ``\"link_files\"`` is the same as ``\"link\"``, but also allow for the CSS\n        file to request other files within ``path``'s immediate parent directory (e.g.,\n        ``@import()`` another file). Note that this isn't the default behavior because\n        you should **be careful not to include files in the same directory as ``path``\n        that contain sensitive information**. A good general rule of thumb to follow is\n        to have ``path`` be located in a subdirectory of the app directory. For example,\n        if the app's source is located at ``/app/app.py``, then ``path`` should be\n        somewhere like ``/app/css/custom.css`` (and all the other relevant accompanying\n        'safe' files should be located under ``/app/css/``). And finally, ``\"inline\"``\n        is the inline the CSS file contents within a :func:`~ui.tags.style` tag.\n\n\n    Returns\n    -------\n    :\n\n        If ``method=\"inline\"``, returns a :func:`~ui.tags.style` tag; otherwise, returns a\n        :func:`~ui.tags.link` tag.\n\n    Note\n    ----\n    By default this places a :func:`~ui.tags.link` (or :func:`~ui.tags.style`) tag in\n    the :func:`~ui.tags.body` of the document, which isn't optimal for performance, and\n    may result in a Flash of Unstyled Content (FOUC). To instead place the CSS in the\n    :func:`~ui.tags.head` of the document, you can wrap it in ``head_content``:\n\n    ```{python}\n    #| eval: false\n    from htmltools import head_content\n    from shiny import ui\n\n    ui.page_fluid(\n        ui.head_content(ui.include_css(\"custom.css\")),\n\n        # You can also inline css by passing a dictionary with a `style` element.\n        ui.div(\n            {\"style\": \"font-weight: bold;\"},\n            ui.p(\"Some text!\"),\n        )\n    )\n    ```\n\n    See Also\n    --------\n    ~ui.tags.style\n    ~ui.tags.link\n    ~include_js\n    \"\"\"\n    ...\n\ndef check_path(path: Path | str) -> Path:\n    ...\n\ndef create_include_dependency(name: str, path: str, include_files: bool) -> tuple[HTMLDependency, str]:\n    ...\n\ndef maybe_copy_files(path: Path | str, include_files: bool) -> tuple[str, str]:\n    ...\n\ndef get_hash(path: Path | str, include_files: bool) -> str:\n    ...\n\ndef get_file_key(path: Path | str) -> str:\n    ...\n\ndef hash_deterministic(s: str) -> str:\n    \"\"\"\n    Returns a deterministic hash of the given string.\n    \"\"\"\n    ...\n\ndef read_utf8(path: Path | str) -> str:\n    ...\n\nDEFAULT_VERSION = ...\n",
  "/src/typings/shiny/ui/_input_action_button.pyi": "from typing import Optional\nfrom htmltools import Tag, TagAttrValue, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_action_button\", \"input_action_link\")\n@add_example()\ndef input_action_button(id: str, label: TagChild, *, icon: TagChild = ..., width: Optional[str] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates an action button whose value is initially zero, and increments by one each\n    time it is pressed.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    kwargs\n        Attributes to be applied to the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    An integer representing the number of clicks.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_action_link\n    ~shiny.reactive.event\n    \"\"\"\n    ...\n\n@add_example()\ndef input_action_link(id: str, label: TagChild, *, icon: TagChild = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates a link whose value is initially zero, and increments by one each time it is\n    pressed.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    kwargs\n        Attributes to be applied to the link.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    An integer representing the number of clicks.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_action_button\n    ~shiny.reactive.event\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_check_radio.pyi": "from typing import Mapping, Optional, Union\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_checkbox\", \"input_checkbox_group\", \"input_radio_buttons\")\n_Choices = Mapping[str, TagChild]\nChoicesArg = Union[\"list[str]\", \"tuple[str, ...]\", _Choices,]\n@add_example()\ndef input_checkbox(id: str, label: TagChild, value: bool = ..., *, width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a checkbox that can be used to specify logical values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    ``True`` if checked, ``False`` otherwise.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_switch\n    ~shiny.ui.update_checkbox\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n    ...\n\n@add_example()\ndef input_switch(id: str, label: TagChild, value: bool = ..., *, width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a switch that can be used to specify logical values. Similar to\n    ~shiny.ui.input_checkbox, but implies to the user that the change will take effect\n    immediately.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    ``True`` if checked, ``False`` otherwise.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox\n    ~shiny.ui.update_switch\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n    ...\n\n@add_example()\ndef input_checkbox_group(id: str, label: TagChild, choices: ChoicesArg, *, selected: Optional[str | list[str]] = ..., inline: bool = ..., width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a group of checkboxes that can be used to toggle multiple choices\n    independently.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If `True`, the result is displayed inline\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A tuple of string(s) with the selected value(s) (if any).\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_checkbox_group\n    ~shiny.ui.input_checkbox\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n    ...\n\n@add_example()\ndef input_radio_buttons(id: str, label: TagChild, choices: ChoicesArg, *, selected: Optional[str] = ..., inline: bool = ..., width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a set of radio buttons used to select an item from a list.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True``, the result is displayed inline\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string with the selected value.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_radio_buttons\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_checkbox\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_date.pyi": "from datetime import date\nfrom typing import Optional\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_date\", \"input_date_range\")\n@add_example()\ndef input_date(id: str, label: TagChild, *, value: Optional[date | str] = ..., min: Optional[date | str] = ..., max: Optional[date | str] = ..., format: str = ..., startview: str = ..., weekstart: int = ..., language: str = ..., width: Optional[str] = ..., autoclose: bool = ..., datesdisabled: Optional[list[str]] = ..., daysofweekdisabled: Optional[list[int]] = ...) -> Tag:\n    \"\"\"\n    Creates a text input which, when clicked on, brings up a calendar that the user can\n    click on to select dates.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        The starting date. Either a :class:`~datetime.date` object, or a string in\n        `yyyy-mm-dd` format. If None (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    max\n        The maximum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    format\n        The format of the date to display in the browser. Defaults to `\"yyyy-mm-dd\"`.\n    startview\n        The date range shown when the input object is first clicked. Can be \"month\" (the\n        default), \"year\", or \"decade\".\n    weekstart\n        Which day is the start of the week. Should be an integer from 0 (Sunday) to 6\n        (Saturday).\n    language\n        The language used for month and day names. Default is \"en\". Other valid values\n        include \"ar\", \"az\", \"bg\", \"bs\", \"ca\", \"cs\", \"cy\", \"da\", \"de\", \"el\", \"en-AU\",\n        \"en-GB\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"fi\", \"fo\", \"fr-CH\", \"fr\", \"gl\", \"he\",\n        \"hr\", \"hu\", \"hy\", \"id\", \"is\", \"it-CH\", \"it\", \"ja\", \"ka\", \"kh\", \"kk\", \"ko\", \"kr\",\n        \"lt\", \"lv\", \"me\", \"mk\", \"mn\", \"ms\", \"nb\", \"nl-BE\", \"nl\", \"no\", \"pl\", \"pt-BR\",\n        \"pt\", \"ro\", \"rs-latin\", \"rs\", \"ru\", \"sk\", \"sl\", \"sq\", \"sr-latin\", \"sr\", \"sv\",\n        \"sw\", \"th\", \"tr\", \"uk\", \"vi\", \"zh-CN\", and \"zh-TW\".\n    width\n        The CSS width, e.g. '400px', or '100%'\n    autoclose\n        Whether or not to close the datepicker immediately when a date is selected.\n    datesdisabled\n        Which dates should be disabled (in `yyyy-mm-dd` format).\n    daysofweekdisabled\n        Days of the week that should be disabled. Should be a integer vector with values\n        from 0 (Sunday) to 6 (Saturday).\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    The date ``format`` string specifies how the date will be displayed in the browser.\n    It allows the following values:\n\n    - ``yy``: Year without century (12)\n    - ``yyyy``: Year with century (2012)\n    - ``mm``: Month number, with leading zero (01-12)\n    - ``m``: Month number, without leading zero (1-12)\n    - ``M``: Abbreviated month name\n    - ``MM``: Full month name\n    - ``dd``: Day of month with leading zero\n    - ``d``: Day of month without leading zero\n    - ``D``: Abbreviated weekday name\n    - ``DD``: Full weekday name\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A :class:`~datetime.date` object.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_date\n    ~shiny.ui.input_date_range\n    \"\"\"\n    ...\n\n@add_example()\ndef input_date_range(id: str, label: TagChild, *, start: Optional[date | str] = ..., end: Optional[date | str] = ..., min: Optional[date | str] = ..., max: Optional[date | str] = ..., format: str = ..., startview: str = ..., weekstart: int = ..., language: str = ..., separator: str = ..., width: Optional[str] = ..., autoclose: bool = ...) -> Tag:\n    \"\"\"\n    Creates a pair of text inputs which, when clicked on, bring up calendars that the\n    user can click on to select dates.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    start\n        The initial start date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    end\n        The initial end date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    max\n        The maximum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    format\n        The format of the date to display in the browser.\n    startview\n        The date range shown when the input object is first clicked. Can be \"month\" (the\n        default), \"year\", or \"decade\".\n    weekstart\n        Which day is the start of the week. Should be an integer from 0 (Sunday) to 6\n        (Saturday).\n    language\n        The language used for month and day names. Default is \"en\". Other valid values\n        include \"ar\", \"az\", \"bg\", \"bs\", \"ca\", \"cs\", \"cy\", \"da\", \"de\", \"el\", \"en-AU\",\n        \"en-GB\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"fi\", \"fo\", \"fr-CH\", \"fr\", \"gl\", \"he\",\n        \"hr\", \"hu\", \"hy\", \"id\", \"is\", \"it-CH\", \"it\", \"ja\", \"ka\", \"kh\", \"kk\", \"ko\", \"kr\",\n        \"lt\", \"lv\", \"me\", \"mk\", \"mn\", \"ms\", \"nb\", \"nl-BE\", \"nl\", \"no\", \"pl\", \"pt-BR\",\n        \"pt\", \"ro\", \"rs-latin\", \"rs\", \"ru\", \"sk\", \"sl\", \"sq\", \"sr-latin\", \"sr\", \"sv\",\n        \"sw\", \"th\", \"tr\", \"uk\", \"vi\", \"zh-CN\", and \"zh-TW\".\n    separator\n        String to display between the start and end input boxes.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    autoclose\n        Whether or not to close the datepicker immediately when a date is selected.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    The date ``format`` string specifies how the date will be displayed in the browser.\n    It allows the following values:\n\n    - ``yy``: Year without century (12)\n    - ``yyyy``: Year with century (2012)\n    - ``mm``: Month number, with leading zero (01-12)\n    - ``m``: Month number, without leading zero (1-12)\n    - ``M``: Abbreviated month name\n    - ``MM``: Full month name\n    - ``dd``: Day of month with leading zero\n    - ``d``: Day of month without leading zero\n    - ``D``: Abbreviated weekday name\n    - ``DD``: Full weekday name\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A tuple of :class:`~datetime.date` objects.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_date_range\n    ~shiny.ui.input_date\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_file.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_file\", )\n@add_example()\ndef input_file(id: str, label: TagChild, *, multiple: bool = ..., accept: Optional[str | list[str]] = ..., width: Optional[str] = ..., button_label: str = ..., placeholder: str = ..., capture: Optional[Literal[\"environment\", \"user\"]] = ...) -> Tag:\n    \"\"\"\n    Create a file upload control that can be used to upload one or more files.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    multiple\n        Whether the user should be allowed to select and upload multiple files at once.\n    accept\n        Unique file type specifier(s) which give the browser a hint as to the type of\n        file the server expects. Many browsers use this to prevent the user from\n        selecting an invalid file. Examples of valid values include a case insensitive\n        extension (e.g. ``.csv`` or ``.rds``), a valid MIME type (e.g. ``text/plain`` or\n        ``application/pdf``) or one of ``audio/*``, ``video/*``, or ``image/*`` meaning\n        any audio, video, or image type, respectively.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    button_label\n        The label used on the button.\n    placeholder\n        The text to show on the input before a file has been uploaded.\n    capture\n        On mobile devices, this can be used to open the device's camera for input. If\n        \"environment\", it will open the rear-facing camera. If \"user\", it will open the\n        front-facing camera. By default, it will accept either still photos or video. To\n        accept only still photos, use ``accept=\"image/*\"``; to accept only video, use\n        ``accept=\"video/*\"``.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    -----\n\n    ::: {.callout-note title=\"Server value\"}\n    A list of dictionaries (one for each file upload) with the following keys:\n\n    * name: The filename provided by the web browser. This is *not* the path to read\n        to get at the actual data that was uploaded (see 'datapath').\n    * size: The size of the uploaded data, in bytes.\n    * type: The MIME type reported by the browser (for example, 'text/plain'), or\n        empty string if the browser didn't know.\n    * datapath: The path to a temp file that contains the data that was uploaded.\n        This file may be deleted if the user performs another upload operation.\n    :::\n\n    See Also\n    --------\n    ~shiny.ui.download_button\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_numeric.pyi": "from typing import Optional\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_numeric\", )\n@add_example()\ndef input_numeric(id: str, label: TagChild, value: float, *, min: Optional[float] = ..., max: Optional[float] = ..., step: Optional[float] = ..., width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create an input control for entry of numeric values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Interval to use when stepping between min and max.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A numeric value.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_numeric\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_password.pyi": "from typing import Optional\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_password\", )\n@add_example()\ndef input_password(id: str, label: TagChild, value: str = ..., *, width: Optional[str] = ..., placeholder: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create an password control for entry of passwords.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    placeholder\n        The placeholder of the input.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string of the password input. The default value is unless value is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_text\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_select.pyi": "from typing import Mapping, Optional, Union\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_select\", \"input_selectize\")\n_Choices = Mapping[str, TagChild]\n_OptGrpChoices = Mapping[str, _Choices]\n_SelectChoices = Union[_Choices, _OptGrpChoices]\nSelectChoicesArg = Union[\"list[str]\", \"tuple[str, ...]\", _Choices, _OptGrpChoices,]\n_topics = ...\n@add_example()\ndef input_selectize(id: str, label: TagChild, choices: SelectChoicesArg, *, selected: Optional[str | list[str]] = ..., multiple: bool = ..., width: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a select list that can be used to choose a single or multiple items from a\n    list of values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    multiple\n        Is selection of multiple items allowed?\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A list of strings, usually of length 1, with the value of the selected items. When\n    ``multiple=True`` and nothing is selected, this value will be ``None``.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_select ~shiny.ui.input_radio_buttons ~shiny.ui.input_checkbox_group\n    \"\"\"\n    ...\n\n@add_example()\ndef input_select(id: str, label: TagChild, choices: SelectChoicesArg, *, selected: Optional[str | list[str]] = ..., multiple: bool = ..., selectize: bool = ..., width: Optional[str] = ..., size: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a select list that can be used to choose a single or multiple items from a\n    list of values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    multiple\n        Is selection of multiple items allowed?\n    selectize\n        Whether to use selectize.js or not.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    size\n        Number of items to show in the selection box; a larger number will result in a\n        taller box. Normally, when ``multiple=False``, a select input will be a\n        drop-down list, but when size is set, it will be a box instead.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A list of strings, usually of length 1, with the value of the selected items. When\n    ``multiple=True`` and nothing is selected, this value will be ``None``.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_selectize\n    ~shiny.ui.update_select\n    ~shiny.ui.input_radio_buttons\n    ~shiny.ui.input_checkbox_group\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_slider.pyi": "from datetime import date, datetime, timedelta\nfrom typing import Iterable, Optional, TypeVar, Union\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\nfrom .._typing_extensions import NotRequired, TypedDict\n\n__all__ = (\"input_slider\", \"SliderValueArg\", \"SliderStepArg\", \"AnimationOptions\")\nSliderValueArg = TypeVar(\"SliderValueArg\", float, datetime, date)\nSliderStepArg = Union[float, timedelta]\nclass AnimationOptions(TypedDict):\n    \"\"\"\n    Options for the animation of a :func:`input_slider`.\n\n    Parameters\n    ----------\n    interval\n        The interval, in milliseconds, between each animation step.\n    loop\n        ``True`` to automatically restart the animation when it reaches the end.\n    play_button\n        Play button text or HTML.\n    pause_button\n        Pause button text or HTML.\n\n    Returns\n    -------\n    :\n        A TypedDict.\n\n    See Also\n    --------\n    ~shiny.ui.input_slider\n    \"\"\"\n    interval: NotRequired[int]\n    loop: NotRequired[bool]\n    play_button: NotRequired[TagChild]\n    pause_button: NotRequired[TagChild]\n    ...\n\n\n@add_example()\ndef input_slider(id: str, label: TagChild, min: SliderValueArg, max: SliderValueArg, value: SliderValueArg | Iterable[SliderValueArg], *, step: Optional[SliderStepArg] = ..., ticks: bool = ..., animate: bool | AnimationOptions = ..., width: Optional[str] = ..., sep: str = ..., pre: Optional[str] = ..., post: Optional[str] = ..., time_format: Optional[str] = ..., timezone: Optional[str] = ..., drag_range: bool = ...) -> Tag:\n    \"\"\"\n    Constructs a slider widget to select a number, date, or date-time from a range.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    value\n        Initial value.\n    step\n        Interval to use when stepping between min and max.\n    ticks\n        ``False`` to hide tick marks, ``True`` to show them according to some simple\n        heuristics.\n    animate\n        ``True`` to show simple animation controls with default settings; ``False`` not\n        to; or a custom settings list, such as those created using\n        :class:`AnimationOptions()`.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    sep\n        Separator between thousands places in numbers.\n    pre\n        A prefix string to put in front of the value.\n    post\n        A suffix string to put after the value.\n    time_format\n        Only used if the slider values are :class:`~datetime.date` or\n        :class:`~datetime.datetime` objects. A time format string, to be passed to the\n        Javascript strftime library. See https://github.com/samsonjs/strftime for more\n        details. For Dates, the default is \"%F\" (like \"2015-07-01\"), and for Datetimes,\n        the default is \"%F %T\" (like \"2015-07-01 15:32:10\").\n    timezone\n        Only used if the values are :class:`~datetime.datetime` objects. A string\n        specifying the time zone offset for the displayed times, in the format \"+HHMM\"\n        or \"-HHMM\". If ``None`` (the default), times will be displayed in the browser's\n        time zone. The value \"+0000\" will result in UTC time.\n    drag_range\n        This option is used only if it is a range slider (with two values). If ``True``\n        (the default), the range can be dragged. In other words, the min and max can be\n        dragged together. If ``False``, the range cannot be dragged.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A number, date, or date-time (depending on the class of value), or in the case of\n    slider range, a list of two numbers/dates/date-times.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_slider\n    \"\"\"\n    ...\n\nplay_icon = ...\npause_icon = ...\n",
  "/src/typings/shiny/ui/_input_text.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagChild\nfrom .._docstring import add_example\n\n__all__ = (\"input_text\", \"input_text_area\")\n@add_example()\ndef input_text(id: str, label: TagChild, value: str = ..., *, width: Optional[str] = ..., placeholder: Optional[str] = ..., autocomplete: Optional[str] = ..., spellcheck: Optional[Literal[\"true\", \"false\"]] = ...) -> Tag:\n    \"\"\"\n    Create an input control for entry of text values\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    placeholder\n        A hint as to what can be entered into the control.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is None).\n        If None, then it will use the browser's default behavior. Other possible values\n        include \"on\", \"off\", \"name\", \"username\", and \"email\". See\n        https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete for\n        more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_text_area\n    \"\"\"\n    ...\n\n@add_example()\ndef input_text_area(id: str, label: TagChild, value: str = ..., *, width: Optional[str] = ..., height: Optional[str] = ..., cols: Optional[int] = ..., rows: Optional[int] = ..., placeholder: Optional[str] = ..., resize: Optional[Literal[\"none\", \"both\", \"horizontal\", \"vertical\"]] = ..., autocomplete: Optional[str] = ..., spellcheck: Optional[Literal[\"true\", \"false\"]] = ...) -> Tag:\n    \"\"\"\n    Create a textarea input control for entry of unstructured text values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    height\n        The CSS height, e.g. '400px', or '100%'\n    cols\n        Value of the visible character columns of the input, e.g. 80. This argument will\n        only take effect if there is not a CSS width rule defined for this element; such\n        a rule could come from the width argument of this function or from a containing\n        page layout such as :func:`~shiny.ui.page_fluid`.\n    rows\n        The value of the visible character rows of the input, e.g. 6. If the height\n        argument is specified, height will take precedence in the browser's rendering.\n    placeholder\n        A hint as to what can be entered into the control.\n    resize\n        Which directions the textarea box can be resized. Can be one of \"both\", \"none\",\n        \"vertical\", and \"horizontal\". The default, ``None``, will use the client\n        browser's default setting for resizing textareas.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is \"off\").\n        If None, then it will use the browser's default behavior. Other possible values\n        include \"on\", \"name\", \"username\", and \"email\". See\n        https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete for\n        more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_text\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_input_update.pyi": "from datetime import date\nfrom typing import Optional\nfrom htmltools import TagChild\nfrom .._docstring import add_example, doc_format\nfrom .._typing_extensions import NotRequired, TypedDict\nfrom ..session import Session\nfrom ._input_check_radio import ChoicesArg\nfrom ._input_select import SelectChoicesArg\nfrom ._input_slider import SliderStepArg, SliderValueArg\n\n__all__ = (\"update_action_button\", \"update_action_link\", \"update_checkbox\", \"update_switch\", \"update_checkbox_group\", \"update_radio_buttons\", \"update_date\", \"update_date_range\", \"update_numeric\", \"update_select\", \"update_selectize\", \"update_slider\", \"update_text\", \"update_text_area\", \"update_navs\")\n_note = ...\n@add_example()\n@doc_format(note=_note)\ndef update_action_button(id: str, *, label: Optional[str] = ..., icon: TagChild = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the label and/or icon of an action button on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n       :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    :func:`~shiny.input_action_button`\n    \"\"\"\n    ...\n\nupdate_action_link = ...\n@add_example()\n@doc_format(note=_note)\ndef update_checkbox(id: str, *, label: Optional[str] = ..., value: Optional[bool] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a checkbox input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox\n    \"\"\"\n    ...\n\n@doc_format(note=_note)\ndef update_switch(id: str, *, label: Optional[str] = ..., value: Optional[bool] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a switch input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_switch\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_checkbox_group(id: str, *, label: Optional[str] = ..., choices: Optional[ChoicesArg] = ..., selected: Optional[str | list[str] | tuple[str, ...]] = ..., inline: bool = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a checkbox group input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True``, the result is displayed inline\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox_group\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_radio_buttons(id: str, *, label: Optional[str] = ..., choices: Optional[ChoicesArg] = ..., selected: Optional[str] = ..., inline: bool = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a radio input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True```, the result is displayed inline\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_date(id: str, *, label: Optional[str] = ..., value: Optional[date | str] = ..., min: Optional[date | str] = ..., max: Optional[date | str] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a date input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        The starting date. Either a `date()` object, or a string in yyyy-mm-dd format.\n        If ``None`` (the default), will use the current date in the client's time zone.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_date\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_date_range(id: str, *, label: Optional[str] = ..., start: Optional[date | str] = ..., end: Optional[date | str] = ..., min: Optional[date | str] = ..., max: Optional[date | str] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the start and end values of a date range input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    start\n        The initial start date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    end\n        The initial end date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_date_range\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_numeric(id: str, *, label: Optional[str] = ..., value: Optional[float] = ..., min: Optional[float] = ..., max: Optional[float] = ..., step: Optional[float] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a number input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Interval to use when stepping between min and max.\n    session\n        The :class:`~shiny.Session` object passed to the server function of a :func:`~shiny.App`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_numeric\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_select(id: str, *, label: Optional[str] = ..., choices: Optional[SelectChoicesArg] = ..., selected: Optional[str | list[str]] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a select input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_select\n    ~shiny.ui.update_selectize\n    \"\"\"\n    ...\n\nclass FlatSelectChoice(TypedDict):\n    label: str\n    value: str\n    optgroup: NotRequired[str]\n    ...\n\n\n@add_example()\n@doc_format(note=_note)\ndef update_selectize(id: str, *, label: Optional[str] = ..., choices: Optional[SelectChoicesArg] = ..., selected: Optional[str | list[str]] = ..., server: bool = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a selectize.js powered input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    server\n        Whether to store choices on the server side, and load the select options\n        dynamically on searching, instead of writing all choices into the page at once\n        (i.e., only use the client-side version of selectize.js)\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_selectize\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_slider(id: str, *, label: Optional[str] = ..., value: Optional[SliderValueArg | tuple[SliderValueArg, SliderValueArg]] = ..., min: Optional[SliderValueArg] = ..., max: Optional[SliderValueArg] = ..., step: Optional[SliderStepArg] = ..., time_format: Optional[str] = ..., timezone: Optional[str] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a slider input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Specifies the interval between each selectable value on the slider. Either\n        ``None`` (the default), which uses a heuristic to determine the step size or a\n        single number. If the values are dates, step is in days; if the values are\n        date-times, step is in seconds.\n    time_format\n        Only used if the slider values are :class:`~datetime.date` or\n        :class:`~datetime.datetime` objects. A time format string, to be passed to the\n        Javascript strftime library. See https://github.com/samsonjs/strftime for more\n        details. For Dates, the default is \"%F\" (like \"2015-07-01\"), and for Datetimes,\n        the default is \"%F %T\" (like \"2015-07-01 15:32:10\").\n    timezone\n        Only used if the values are :class:`~datetime.datetime` objects. A string\n        specifying the time zone offset for the displayed times, in the format \"+HHMM\"\n        or \"-HHMM\". If ``None`` (the default), times will be displayed in the browser's\n        time zone. The value \"+0000\" will result in UTC time.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_slider\n    \"\"\"\n    ...\n\n@add_example()\n@doc_format(note=_note)\ndef update_text(id: str, *, label: Optional[str] = ..., value: Optional[str] = ..., placeholder: Optional[str] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a text input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    placeholder\n        A hint as to what can be entered into the control.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_text\n    \"\"\"\n    ...\n\nupdate_text_area = ...\n@add_example()\n@doc_format(note=_note)\ndef update_navs(id: str, selected: Optional[str] = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Change the value of a navs container on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    selected\n        The values that should be initially selected, if any.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.page_navbar\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_insert.pyi": "from typing import Literal, Optional\nfrom htmltools import TagChild\nfrom .._docstring import add_example\nfrom ..session import Session\n\n__all__ = (\"insert_ui\", \"remove_ui\")\n@add_example()\ndef insert_ui(ui: TagChild, selector: str, where: Literal[\"beforeBegin\", \"afterBegin\", \"beforeEnd\", \"afterEnd\"] = ..., multiple: bool = ..., immediate: bool = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Insert UI objects\n\n    Parameters\n    ----------\n    ui\n        The UI object you want to insert. This can be anything that you usually put\n        inside your apps's ui function. If you're inserting multiple elements in one\n        call, make sure to wrap them in either a :func:`~shiny.ui.TagList` or a\n        :func:`~shiny.ui.tags.div` (the latter option has the advantage that you can\n        give it an id to make it easier to reference or remove it later on). If you want\n        to insert raw html, use :func:`~shiny.ui.HTML`.\n    selector\n        A string that is accepted by jQuery's selector (i.e. the string ``s`` to be\n        placed in a ``$(s)`` jQuery call) which determines the element(s) relative to\n        which you want to insert your UI object.\n    where\n        Where your UI object should go relative to the selector:\n\n        - beforeBegin: Before the selector element itself\n        - afterBegin: Just inside the selector element, before its first child\n        - beforeEnd: Just inside the selector element, after its last child (default)\n        - afterEnd: After the selector element itself\n\n        Adapted from\n        https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML.\n    multiple\n        In case your selector matches more than one element, multiple determines whether\n        Shiny should insert the UI object relative to all matched elements or just\n        relative to the first matched element (default).\n    immediate\n        Whether the UI object should be immediately inserted or removed, or whether\n        Shiny should wait until all outputs have been updated and all effects have been\n        run (default).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    This function allows you to dynamically add arbitrary UI into your app, whenever you\n    want, as many times as you want. Unlike :func:`~shiny.render.ui`, the UI generated\n    with `insert_ui` is persistent: once it's created, it stays there until removed by\n    :func:`remove_ui`. Each new call to `insert_ui` creates more UI objects, in addition\n    to the ones already there (all independent from one another). To update a part of\n    the UI (ex: an input object), you must use the appropriate render function or a\n    customized reactive function.\n\n    See Also\n    --------\n    ~shiny.ui.remove_ui\n    ~shiny.render.ui\n    \"\"\"\n    ...\n\n@add_example()\ndef remove_ui(selector: str, multiple: bool = ..., immediate: bool = ..., session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Remove UI objects\n\n    Parameters\n    ----------\n    selector\n        A string that is accepted by jQuery's selector (i.e. the string ``x`` to be\n        placed in a ``$(x)`` jQuery call) which determines the element(s) to remove. If\n        you want to remove a Shiny input or output, note that many of these are wrapped\n        in ``<div>``s, so you may need to use a somewhat complex selector \u2014 see the\n        Examples below. (Alternatively, you could also wrap the inputs/outputs that you\n        want to be able to remove easily in a ``<div>`` with an id.)\n    multiple\n        In case your selector matches more than one element, multiple determines whether\n        Shiny should insert the UI object relative to all matched elements or just\n        relative to the first matched element (default).\n    immediate\n        Whether the UI object should be immediately inserted or removed, or whether\n        Shiny should wait until all outputs have been updated and all effects have been\n        run (default).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.insert_ui\n    ~shiny.render.ui\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_markdown.pyi": "from typing import Callable, Literal, Optional\nfrom htmltools import HTML\nfrom .._docstring import add_example\n\n__all__ = (\"markdown\", )\n@add_example()\ndef markdown(text: str, *, render_func: Optional[Callable[[str], str]] = ..., **kwargs: object) -> HTML:\n    \"\"\"\n    Convert a string of markdown to :func:`ui.HTML`.\n\n    Parameters\n    ----------\n    text\n        A string of text containing markdown.\n    render_func\n        A function (with at least 1 argument) which accepts a string of markdown and\n        returns a string of HTML. By default, a customized instance of the\n        :class:`MarkdownIt` class (which supports Github-flavored markdown) from the\n        ``markdown-it`` package is used.\n    **kwargs\n        Additional keyword arguments passed to the ``render_func``.\n\n    Returns\n    -------\n    :\n        An :func:`ui.HTML` string of the rendered markdown.\n\n    Note\n    ----\n    Use :func:`ui.include_markdown` instead if you want to include local images (or\n    other files) in the markdown.\n\n    See Also\n    --------\n    :func:`ui.include_markdown`\n    \"\"\"\n    ...\n\ndef default_md_renderer(preset: Literal[\"commonmark\", \"gfm\"] = ...) -> Callable[[str], str]:\n    ...\n\n",
  "/src/typings/shiny/ui/_modal.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild\nfrom .._docstring import add_example\nfrom ..session import Session\nfrom ..types import MISSING_TYPE\n\n__all__ = (\"modal_button\", \"modal\", \"modal_show\", \"modal_remove\")\ndef modal_button(label: TagChild, icon: TagChild = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates a button that will dismiss a :func:`modal` (useful when customising the\n    ``footer`` of :func:`modal`).\n\n    Parameters\n    ----------\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    kwargs\n        Attributes to be applied to the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.ui.modal\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal_remove\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    ...\n\n@add_example()\ndef modal(*args: TagChild | TagAttrs, title: Optional[str] = ..., footer: TagChild | MISSING_TYPE = ..., size: Literal[\"m\", \"s\", \"l\", \"xl\"] = ..., easy_close: bool = ..., fade: bool = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates the UI for a modal dialog, using Bootstrap's modal class. Modals are\n    typically used for showing important messages, or for presenting UI that requires\n    input from the user, such as a user name and/or password input.\n\n    Parameters\n    ----------\n    args\n        UI elements for the body of the modal.\n    title\n        An optional title for the modal dialog.\n    footer\n        UI for footer. Use ``None`` for no footer.\n    size\n        One of \"s\" for small, \"m\" (the default) for medium, or \"l\" for large.\n    easy_close\n        If ``True``, the modal dialog can be dismissed by clicking outside the dialog\n        box, or be pressing the Escape key. If ``False`` (the default), the modal dialog\n        can't be dismissed in those ways; instead it must be dismissed by clicking on a\n        ``modal_button()``, or from a call to ``modal_remove()`` on the server.\n    fade\n        If ``False``, the modal dialog will have no fade-in animation (it will simply\n        appear rather than fade in to view).\n    kwargs\n        Attributes to be applied to the modal's body tag.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal_remove\n    ~shiny.ui.modal_button\n    \"\"\"\n    ...\n\ndef modal_show(modal: Tag, session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Show a modal dialog.\n\n    Parameters\n    ----------\n    modal\n        Typically a :func:`modal` instance.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.modal_remove\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    ...\n\ndef modal_remove(session: Optional[Session] = ...) -> None:\n    \"\"\"\n    Remove a modal dialog.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_navs.pyi": "from typing import Any, Literal, Optional, Sequence\nfrom htmltools import MetadataNode, Tag, TagChild, TagList\nfrom .._docstring import add_example\nfrom ..types import NavSetArg\n\n__all__ = (\"nav\", \"nav_menu\", \"nav_control\", \"nav_spacer\", \"navset_tab\", \"navset_tab_card\", \"navset_pill\", \"navset_pill_card\", \"navset_pill_list\", \"navset_hidden\", \"navset_bar\")\nclass Nav:\n    nav: Tag\n    content: Optional[Tag]\n    def __init__(self, nav: Tag, content: Optional[Tag] = ...) -> None:\n        ...\n    \n    def resolve(self, selected: Optional[str], context: dict[str, Any]) -> tuple[TagChild, TagChild]:\n        ...\n    \n    def get_value(self) -> Optional[str]:\n        ...\n    \n    def tagify(self) -> None:\n        ...\n    \n\n\n@add_example()\ndef nav(title: TagChild, *args: TagChild, value: Optional[str] = ..., icon: TagChild = ...) -> Nav:\n    \"\"\"\n    Create a nav item pointing to some internal content.\n\n    Parameters\n    ----------\n    title\n        A title to display. Can be a character string or UI elements (i.e., tags).\n    *args\n        UI elements to display when the item is active.\n    value\n        The value of the item. This is used to determine whether the item is active\n        (when an ``id`` is provided to the nav container), programmatically select the\n        item (e.g., :func:`~shiny.ui.update_navs`), and/or be provided to the\n        ``selected`` argument of the navigation container (e.g.,\n        :func:`~shiny.ui.navset_tab`).\n    icon\n        An icon to appear inline with the button/link.\n\n    See Also\n    -------\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n    \"\"\"\n    ...\n\ndef nav_control(*args: TagChild) -> Nav:\n    \"\"\"\n    Place a control in the navigation container.\n\n    Parameters\n    ----------\n    *args\n        UI elements to display as the nav item.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\ndef nav_spacer() -> Nav:\n    \"\"\"\n    Create space between nav items.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\nclass NavMenu:\n    nav_controls: list[NavSetArg]\n    title: TagChild\n    value: str\n    align: Literal[\"left\", \"right\"]\n    def __init__(self, *args: NavSetArg | str, title: TagChild, value: str, align: Literal[\"left\", \"right\"] = ...) -> None:\n        ...\n    \n    def resolve(self, selected: Optional[str], context: dict[str, Any]) -> tuple[TagChild, TagChild]:\n        ...\n    \n    def get_value(self) -> Optional[str]:\n        ...\n    \n    def tagify(self) -> None:\n        ...\n    \n\n\ndef menu_string_as_nav(x: str | NavSetArg) -> NavSetArg:\n    ...\n\ndef nav_menu(title: TagChild, *args: Nav | str, value: Optional[str] = ..., icon: TagChild = ..., align: Literal[\"left\", \"right\"] = ...) -> NavMenu:\n    \"\"\"\n    Create a menu of nav items.\n\n    Parameters\n    ----------\n    title\n        A title to display. Can be a character string or UI elements (i.e., tags).\n    *args\n        A collection of nav items (e.g., :func:`~shiny.ui.nav`) and/or strings.\n        Strings will be rendered as a section header unless the string is a set\n        of two or more hyphens (e.g., ``---``), in which case it will be rendered\n        as a divider.\n    value\n        The value of the item. This is used to determine whether the item is active\n        (when an ``id`` is provided to the nav container), programmatically select the\n        item (e.g., :func:`~shiny.ui.update_navs`), and/or be provided to the\n        ``selected`` argument of the navigation container (e.g.,\n        :func:`~shiny.ui.navset_tab`).\n    icon\n        An icon to appear inline with the button/link.\n    align\n        Horizontal alignment of the dropdown menu relative to dropdown toggle.\n\n    Returns\n    -------\n    :\n        A UI element representing both the navigation menu.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\nclass NavSet:\n    args: tuple[NavSetArg | MetadataNode]\n    ul_class: str\n    id: Optional[str]\n    selected: Optional[str]\n    header: TagChild\n    footer: TagChild\n    def __init__(self, *args: NavSetArg | MetadataNode, ul_class: str, id: Optional[str], selected: Optional[str], header: TagChild = ..., footer: TagChild = ...) -> None:\n        ...\n    \n    def tagify(self) -> TagList | Tag:\n        ...\n    \n    def layout(self, nav: TagChild, content: TagChild) -> TagList | Tag:\n        ...\n    \n\n\ndef navset_tab(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ...) -> NavSet:\n    \"\"\"\n    Render nav items as a tabset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\ndef navset_pill(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ...) -> NavSet:\n    \"\"\"\n    Render nav items as a pillset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\n@add_example()\ndef navset_hidden(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ...) -> NavSet:\n    \"\"\"\n    Render nav contents without the nav items.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    --------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_pill_list\n    ~shiny.ui.navset_bar\n    \"\"\"\n    ...\n\nclass NavSetCard(NavSet):\n    placement: Literal[\"above\", \"below\"]\n    def __init__(self, *args: NavSetArg, ul_class: str, id: Optional[str], selected: Optional[str], header: TagChild = ..., footer: TagChild = ..., placement: Literal[\"above\", \"below\"] = ...) -> None:\n        ...\n    \n    def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        ...\n    \n\n\ndef navset_tab_card(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ...) -> NavSetCard:\n    \"\"\"\n    Render nav items as a tabset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\ndef navset_pill_card(*args: NavSetArg, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ..., placement: Literal[\"above\", \"below\"] = ...) -> NavSetCard:\n    \"\"\"\n    Render nav items as a pillset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    placement\n        Placement of the nav items relative to the content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\nclass NavSetPillList(NavSet):\n    well: bool\n    widths: tuple[int, int]\n    def __init__(self, *args: NavSetArg | MetadataNode, ul_class: str, id: Optional[str], selected: Optional[str], header: TagChild = ..., footer: TagChild = ..., well: bool = ..., widths: tuple[int, int] = ...) -> None:\n        ...\n    \n    def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        ...\n    \n\n\ndef navset_pill_list(*args: NavSetArg | MetadataNode, id: Optional[str] = ..., selected: Optional[str] = ..., header: TagChild = ..., footer: TagChild = ..., well: bool = ..., widths: tuple[int, int] = ...) -> NavSet:\n    \"\"\"\n    Render nav items as a vertical pillset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    well\n        ``True`` to place a well (gray rounded rectangle) around the navigation list.\n    widths\n        Column widths of the navigation list and tabset content areas respectively.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    ...\n\nclass NavSetBar(NavSet):\n    title: TagChild\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"]\n    bg: Optional[str]\n    inverse: bool\n    collapsible: bool\n    fluid: bool\n    def __init__(self, *args: NavSetArg | MetadataNode, ul_class: str, title: TagChild, id: Optional[str], selected: Optional[str], position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"] = ..., header: TagChild = ..., footer: TagChild = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ...) -> None:\n        ...\n    \n    def layout(self, nav: TagChild, content: TagChild) -> TagList:\n        ...\n    \n\n\ndef navset_bar(*args: NavSetArg | MetadataNode | Sequence[MetadataNode], title: TagChild, id: Optional[str] = ..., selected: Optional[str] = ..., position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"] = ..., header: TagChild = ..., footer: TagChild = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ...) -> NavSetBar:\n    \"\"\"\n    Render nav items as a navbar.\n\n    Parameters\n    ----------\n    args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    title\n        Title to display in the navbar.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n\n    See Also\n    -------\n    ~shiny.ui.page_navbar\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_tab_card\n    ~shiny.ui.navset_pill_card\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n    ...\n\ndef render_navset(*items: NavSetArg | MetadataNode, ul_class: str, id: Optional[str], selected: Optional[str], context: dict[str, Any]) -> tuple[Tag, Tag]:\n    ...\n\ndef card(*args: TagChild, header: TagChild = ..., footer: TagChild = ...) -> Tag:\n    ...\n\n",
  "/src/typings/shiny/ui/_notification.pyi": "from typing import Literal, Optional\nfrom htmltools import TagChild\nfrom .._docstring import add_example\nfrom ..session import Session\n\n__all__ = (\"notification_show\", \"notification_remove\")\n@add_example()\ndef notification_show(ui: TagChild, *, action: Optional[TagChild] = ..., duration: Optional[int | float] = ..., close_button: bool = ..., id: Optional[str] = ..., type: Literal[\"default\", \"message\", \"warning\", \"error\"] = ..., session: Optional[Session] = ...) -> str:\n    \"\"\"\n    Show a notification to the user.\n\n    Parameters\n    ----------\n    ui\n        Content of message.\n    action\n        Message content that represents an action. For example, this could be a link\n        that the user can click on. This is separate from ui so customized layouts can\n        handle the main notification content separately from action content.\n    duration\n        Number of seconds to display the message before it disappears. Use ``None`` to\n        make the message not automatically disappear.\n    close_button\n        If ``True``, display a button which will make the notification disappear when\n        clicked. If ``False`` do not display.\n    id\n        An optional unique identifier for the notification. If supplied, any existing\n        notification with the same ``id`` will be replaced with this one (otherwise, a\n        new notification is created).\n    type\n        A string which controls the color of the notification. One of \"default\" (gray),\n        \"message\" (blue), \"warning\" (yellow), or \"error\" (red).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The notification's ``id``.\n\n    See Also\n    -------\n    ~shiny.ui.notification_remove\n    ~shiny.ui.modal\n    \"\"\"\n    ...\n\ndef notification_remove(id: str, *, session: Optional[Session] = ...) -> str:\n    \"\"\"\n    Remove a notification.\n\n    Parameters\n    ----------\n    id\n        A notification ``id``.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The notification's ``id``.\n\n    See Also\n    -------\n    ~shiny.ui.notification_show\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`notification_show`.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_output.pyi": "from typing import Optional\nfrom htmltools import Tag, TagAttrValue, TagFunction\nfrom .._docstring import add_example\nfrom ._plot_output_opts import BrushOpts, ClickOpts, DblClickOpts, HoverOpts\n\n__all__ = (\"output_plot\", \"output_image\", \"output_text\", \"output_text_verbatim\", \"output_table\", \"output_ui\")\n@add_example()\ndef output_plot(id: str, width: str = ..., height: str = ..., *, inline: bool = ..., click: bool | ClickOpts = ..., dblclick: bool | DblClickOpts = ..., hover: bool | HoverOpts = ..., brush: bool | BrushOpts = ...) -> Tag:\n    \"\"\"\n    Create a output container for a static plot.\n\n    Place a :func:`~shiny.render.plot` result in the user interface. See\n    :func:`~shiny.render.plot` for more details on what types of plots are supported.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.plot ~shiny.ui.output_image\n    \"\"\"\n    ...\n\n@add_example()\ndef output_image(id: str, width: str = ..., height: str = ..., *, inline: bool = ..., click: bool | ClickOpts = ..., dblclick: bool | DblClickOpts = ..., hover: bool | HoverOpts = ..., brush: bool | BrushOpts = ...) -> Tag:\n    \"\"\"\n    Create a output container for a static image.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.image\n    ~shiny.ui.output_plot\n    \"\"\"\n    ...\n\n@add_example()\ndef output_text(id: str, inline: bool = ..., container: Optional[TagFunction] = ...) -> Tag:\n    \"\"\"\n    Create a output container for some text.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Note\n    ----\n    Text is HTML-escaped prior to rendering.\n\n    See Also\n    -------\n    ~shiny.render.text\n    ~shiny.ui.output_text_verbatim\n    \"\"\"\n    ...\n\ndef output_text_verbatim(id: str, placeholder: bool = ...) -> Tag:\n    \"\"\"\n    Create a output container for some text.\n\n    Place a :func:`~shiny.render.text` result in the user interface.\n    Differs from :func:`~shiny.ui.output_text` in that it wraps the text in a\n    fixed-width container with a gray-ish background color and border.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    placeholder\n        If the output is empty or ``None``, should an empty rectangle be displayed to\n        serve as a placeholder? (does not affect behavior when the output is nonempty)\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.text\n    ~shiny.ui.output_text\n\n    Example\n    -------\n    See :func:`~shiny.ui.output_text`\n    \"\"\"\n    ...\n\n@add_example()\ndef output_table(id: str, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a output container for a table.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    **kwargs\n        Additional attributes to add to the container.\n\n    Returns\n    -------\n    :\n\n    See Also\n    -------\n    ~shiny.render.table\n    \"\"\"\n    ...\n\n@add_example()\ndef output_ui(id: str, inline: bool = ..., container: Optional[TagFunction] = ..., **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a output container for a UI (i.e., HTML) element.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n    kwargs\n        Attributes to be applied to the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_text\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_page.pyi": "from typing import Literal, Optional, Sequence\nfrom htmltools import MetadataNode, Tag, TagAttrs, TagChild, TagList\nfrom .._docstring import add_example\nfrom ..types import MISSING_TYPE, NavSetArg\n\n__all__ = (\"page_navbar\", \"page_fluid\", \"page_fixed\", \"page_bootstrap\")\ndef page_navbar(*args: NavSetArg | MetadataNode | Sequence[MetadataNode], title: Optional[str | Tag | TagList] = ..., id: Optional[str] = ..., selected: Optional[str] = ..., position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\"] = ..., header: Optional[TagChild] = ..., footer: Optional[TagChild] = ..., bg: Optional[str] = ..., inverse: bool = ..., collapsible: bool = ..., fluid: bool = ..., window_title: str | MISSING_TYPE = ..., lang: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a page with a navbar and a title.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.nav`\n    :func:`~shiny.ui.nav_menu`\n    :func:`~shiny.ui.navset_bar`\n    :func:`~shiny.ui.page_fluid`\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n    ...\n\n@add_example()\ndef page_fluid(*args: TagChild | TagAttrs, title: Optional[str] = ..., lang: Optional[str] = ..., **kwargs: str) -> Tag:\n    \"\"\"\n    Create a fluid page.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Attributes on the page level container.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fixed`\n    :func:`~shiny.ui.page_bootstrap`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n    ...\n\n@add_example()\ndef page_fixed(*args: TagChild | TagAttrs, title: Optional[str] = ..., lang: Optional[str] = ..., **kwargs: str) -> Tag:\n    \"\"\"\n    Create a fixed page.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Attributes on the page level container.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fluid`\n    :func:`~shiny.ui.page_bootstrap`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n    ...\n\ndef page_bootstrap(*args: TagChild | TagAttrs, title: Optional[str] = ..., lang: Optional[str] = ...) -> Tag:\n    \"\"\"\n    Create a Bootstrap UI page container.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fluid`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shiny/ui/_plot_output_opts.pyi": "from typing import Literal\nfrom .._typing_extensions import NotRequired, TypedDict\n\nclass ClickOpts(TypedDict):\n    id: NotRequired[str]\n    clip: bool\n    ...\n\n\nclass DblClickOpts(TypedDict):\n    id: NotRequired[str]\n    clip: bool\n    delay: int\n    ...\n\n\nclass HoverOpts(TypedDict):\n    id: NotRequired[str]\n    delay: int\n    delayType: Literal[\"debounce\", \"throttle\"]\n    clip: bool\n    nullOutside: bool\n    ...\n\n\nclass BrushOpts(TypedDict):\n    id: NotRequired[str]\n    fill: str\n    stroke: str\n    opacity: float\n    delay: int\n    delayType: Literal[\"debounce\", \"throttle\"]\n    clip: bool\n    direction: str\n    resetOnNew: bool\n    ...\n\n\ndef format_opt_names(opts: ClickOpts | DblClickOpts | HoverOpts | BrushOpts, prefix: str) -> dict[str, str]:\n    ...\n\ndef click_opts(*, clip: bool = ...) -> ClickOpts:\n    ...\n\ndef dblclick_opts(*, delay: int = ..., clip: bool = ...) -> DblClickOpts:\n    ...\n\ndef hover_opts(*, delay: int = ..., delay_type: Literal[\"debounce\", \"throttle\"] = ..., clip: bool = ..., null_outside: bool = ...) -> HoverOpts:\n    ...\n\ndef brush_opts(*, fill: str = ..., stroke: str = ..., opacity: float = ..., delay: int = ..., delay_type: Literal[\"debounce\", \"throttle\"] = ..., clip: bool = ..., direction: str = ..., reset_on_new: bool = ...) -> BrushOpts:\n    ...\n\n",
  "/src/typings/shiny/ui/_progress.pyi": "from types import TracebackType\nfrom typing import Optional, Type\nfrom .._docstring import add_example\nfrom ..session import Session\n\n__all__ = (\"Progress\", )\n@add_example()\nclass Progress:\n    \"\"\"\n    Initialize a progress bar.\n\n    Parameters\n    ----------\n    min\n        The value that represents the starting point of the progress bar. Must be less\n        than ``max``.\n    max\n        The value that represents the end of the progress bar. Must be greater than\n        ``min``.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n    \"\"\"\n    _style = ...\n    min: int\n    max: int\n    value: float | None\n    def __init__(self, min: int = ..., max: int = ..., session: Optional[Session] = ...) -> None:\n        ...\n    \n    def __enter__(self) -> Progress:\n        ...\n    \n    def __exit__(self, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]) -> None:\n        ...\n    \n    def set(self, value: Optional[float] = ..., message: Optional[str] = ..., detail: Optional[str] = ...) -> None:\n        \"\"\"\n        Updates the progress panel. When called the first time, the progress panel is\n        displayed.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        value\n            The value at which to set the progress bar, relative to ``min`` and ``max``.\n            ``None`` hides the progress bar, if it is currently visible.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the\n            current detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n        ...\n    \n    def inc(self, amount: float = ..., message: Optional[str] = ..., detail: Optional[str] = ...) -> None:\n        \"\"\"\n        Increment the progress bar.\n\n        Like ``set``, this updates the progress panel. The difference is that ``inc``\n        increases the progress bar by amount, instead of setting it to a specific value.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        amount\n            The amount to increment in progress.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the current\n            detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n        ...\n    \n    def close(self) -> None:\n        \"\"\"\n        Close the progress bar. You can also use the Progress object as a context\n        manager, which will cause the progress bar to close on exit.\n\n        Parameters\n        ----------\n        self\n            The object instance\n\n        Note\n        ----\n        Removes the progress panel. Future calls to set and close will be ignored.\n        \"\"\"\n        ...\n    \n\n\n",
  "/src/typings/shiny/ui/_utils.pyi": "from typing import Optional, overload\nfrom htmltools import HTMLDependency, Tag, TagChild, TagList\nfrom ..types import MISSING_TYPE\n\ndef shiny_input_label(id: str, label: TagChild = ...) -> Tag:\n    ...\n\n@overload\ndef get_window_title(title: None, window_title: MISSING_TYPE) -> None:\n    ...\n\n@overload\ndef get_window_title(title: None, window_title: str) -> HTMLDependency:\n    ...\n\n@overload\ndef get_window_title(title: str | Tag | TagList, window_title: str | MISSING_TYPE) -> HTMLDependency:\n    ...\n\ndef get_window_title(title: Optional[str | Tag | TagList], window_title: str | MISSING_TYPE = ...) -> Optional[HTMLDependency]:\n    ...\n\n",
  "/src/typings/shiny/ui/_x/_css_unit.pyi": "from typing import Union, overload\n\n__all__ = (\"CssUnit\", \"as_css_unit\", \"as_css_padding\")\nCssUnit = Union[int, float, str,]\n@overload\ndef as_css_unit(value: None) -> None:\n    ...\n\n@overload\ndef as_css_unit(value: CssUnit) -> str:\n    ...\n\ndef as_css_unit(value: None | CssUnit) -> None | str:\n    ...\n\n@overload\ndef as_css_padding(padding: CssUnit | list[CssUnit]) -> str:\n    ...\n\n@overload\ndef as_css_padding(padding: None) -> None:\n    ...\n\ndef as_css_padding(padding: CssUnit | list[CssUnit] | None) -> str | None:\n    ...\n\ndef to_width_unit(x: str | float | int) -> str:\n    ...\n\n",
  "/src/typings/shiny/ui/_x/_fill.pyi": "from typing import TypeVar\n\n__all__ = (\"as_fillable_container\", \"as_fill_item\")\nTagT = TypeVar(\"TagT\", bound=\"Tag\")\nFILL_ITEM_CLASS = ...\nFILL_CONTAINER_CLASS = ...\ndef as_fillable_container(tag: TagT) -> TagT:\n    ...\n\ndef as_fill_item(tag: TagT) -> TagT:\n    ...\n\n",
  "/src/typings/shiny/ui/_x/_htmldeps.pyi": "from htmltools import HTMLDependency\n\n_x_www = ...\n_x_sidebar_path = ...\n_x_nav_spacer_path = ...\n_x_fill_path = ...\ndef fill_dependency() -> HTMLDependency:\n    ...\n\ndef sidebar_dependency() -> HTMLDependency:\n    ...\n\ndef nav_spacer_dependency() -> HTMLDependency:\n    ...\n\n",
  "/src/typings/shiny/ui/_x/_sidebar.pyi": "from typing import Literal, Optional\nfrom htmltools import Tag, TagAttrValue, TagAttrs, TagChild, TagList\nfrom ._css_unit import CssUnit\n\nclass Sidebar:\n    def __init__(self, tag: Tag, collapse_tag: Optional[Tag], position: Literal[\"left\", \"right\"], open: Literal[\"desktop\", \"open\", \"closed\", \"always\"], width: CssUnit, max_height_mobile: Optional[str | float], color_fg: Optional[str], color_bg: Optional[str]) -> None:\n        ...\n    \n\n\ndef sidebar(*args: TagChild | TagAttrs, width: CssUnit = ..., position: Literal[\"left\", \"right\"] = ..., open: Literal[\"desktop\", \"open\", \"closed\", \"always\"] = ..., id: Optional[str] = ..., title: TagChild | str = ..., bg: Optional[str] = ..., fg: Optional[str] = ..., class_: Optional[str] = ..., max_height_mobile: Optional[str | float] = ...) -> Sidebar:\n    ...\n\ndef layout_sidebar(sidebar: Sidebar, content: PanelMain, fillable: bool = ..., fill: bool = ..., bg: Optional[str] = ..., fg: Optional[str] = ..., border: Optional[bool] = ..., border_radius: Optional[bool] = ..., border_color: Optional[str] = ..., gap: Optional[CssUnit] = ..., padding: Optional[CssUnit | list[CssUnit]] = ..., height: Optional[CssUnit] = ..., **kwargs: TagAttrValue) -> Tag:\n    ...\n\nclass PanelSidebar:\n    def __init__(self, *args: TagChild | TagAttrs, width: int = ..., **kwargs: TagAttrValue) -> None:\n        ...\n    \n    def get_sidebar(self, position: Literal[\"left\", \"right\"] = ...) -> Sidebar:\n        ...\n    \n    def tagify(self) -> Tag:\n        ...\n    \n\n\nclass PanelMain:\n    attrs: TagAttrs\n    children: list[TagChild]\n    def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        ...\n    \n    def tagify(self) -> TagList:\n        ...\n    \n\n\n",
  "/src/typings/shiny/ui/_x/_tag.pyi": "from typing import TypeVar\n\nTagT = TypeVar(\"TagT\", bound=\"Tag\")\ndef tag_prepend_class(tag: TagT, *class_: str | None) -> TagT:\n    ...\n\n",
  "/src/typings/shiny/ui/_x/_utils.pyi": "import typing\nfrom typing import overload\nfrom htmltools import TagAttrValue, TagAttrs, TagChild\n\nTagChildT = typing.TypeVar(\"TagChildT\", bound=TagChild)\n@overload\ndef consolidate_attrs(*args: TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChild]]:\n    ...\n\n@overload\ndef consolidate_attrs(*args: TagChildT | TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChildT]]:\n    ...\n\ndef consolidate_attrs(*args: TagChildT | TagAttrs, **kwargs: TagAttrValue) -> tuple[TagAttrs, list[TagChildT]]:\n    ...\n\n@overload\ndef trinary(x: None) -> None:\n    ...\n\n@overload\ndef trinary(x: bool | str) -> str:\n    ...\n\ndef trinary(x: bool | str | None) -> None | str:\n    ...\n\n",
  "/src/typings/shiny/ui/dataframe/__init__.pyi": "from ._dataframe import output_data_frame\n\n__all__ = (\"output_data_frame\", )\n",
  "/src/typings/shiny/ui/dataframe/_dataframe.pyi": "from htmltools import HTMLDependency, Tag\n\n__all__ = (\"output_data_frame\", )\ndef data_frame_deps() -> HTMLDependency:\n    ...\n\ndef output_data_frame(id: str) -> Tag:\n    \"\"\"\n    Create a output container for a data frame.\n\n    Parameters\n    ----------\n    id\n        An input id.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    --------\n    :func:`~shiny.render.data_frame`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shinywidgets/__init__.pyi": "from ._dependencies import bokeh_dependency\nfrom ._shinywidgets import as_widget, output_widget, reactive_read, register_widget, render_widget\n\n\"\"\"Top-level package for shinywidgets.\"\"\"\n__author__ = ...\n__email__ = ...\n__version__ = ...\n__all__ = (\"output_widget\", \"register_widget\", \"render_widget\", \"reactive_read\", \"bokeh_dependency\", \"as_widget\")\n",
  "/src/typings/shinywidgets/_as_widget.pyi": "from typing import Optional\nfrom ipywidgets.widgets.widget import Widget\n\n__all__ = (\"as_widget\", )\ndef as_widget(x: object) -> Widget:\n    ...\n\ndef as_widget_altair(x: object) -> Optional[Widget]:\n    ...\n\ndef as_widget_bokeh(x: object) -> Optional[Widget]:\n    ...\n\ndef as_widget_plotly(x: object) -> Optional[Widget]:\n    ...\n\ndef as_widget_pydeck(x: object) -> Optional[Widget]:\n    ...\n\nAS_WIDGET_MAP = ...\n",
  "/src/typings/shinywidgets/_comm.pyi": "from typing import Callable, Dict, List, Optional\n\nclass ShinyCommManager:\n    comms: Dict[str, ShinyComm] = ...\n    def register_comm(self, comm: ShinyComm) -> str:\n        ...\n    \n    def unregister_comm(self, comm: ShinyComm) -> ShinyComm:\n        ...\n    \n\n\nMsgCallback = Callable[[Dict[str, object]], None]\nDataType = Optional[Dict[str, object]]\nMetadataType = Optional[Dict[str, object]]\nBufferType = Optional[List[bytes]]\nclass ShinyComm:\n    kernel = ...\n    _msg_callback: MsgCallback\n    _close_callback: MsgCallback\n    _closed: bool = ...\n    _closed_data: Dict[str, object] = ...\n    def __init__(self, comm_id: str, comm_manager: ShinyCommManager, target_name: str, data: DataType = ..., metadata: MetadataType = ..., buffers: BufferType = ..., **keys: object) -> None:\n        ...\n    \n    def open(self, data: DataType = ..., metadata: MetadataType = ..., buffers: BufferType = ..., **keys: object) -> None:\n        ...\n    \n    def send(self, data: DataType = ..., metadata: MetadataType = ..., buffers: BufferType = ...) -> None:\n        ...\n    \n    def close(self, data: DataType = ..., metadata: MetadataType = ..., buffers: BufferType = ..., deleting: bool = ...) -> None:\n        ...\n    \n    def __del__(self): # -> None:\n        ...\n    \n    def on_msg(self, callback: MsgCallback) -> None:\n        ...\n    \n    def on_close(self, callback: MsgCallback) -> None:\n        ...\n    \n    def handle_msg(self, msg: Dict[str, object]) -> None:\n        ...\n    \n    def handle_close(self, msg: Dict[str, object]) -> None:\n        ...\n    \n\n\n",
  "/src/typings/shinywidgets/_dependencies.pyi": "from typing import List, Optional\nfrom htmltools import HTMLDependency\nfrom ipywidgets.widgets.widget import Widget\nfrom shiny import Session\n\ndef libembed_dependency() -> List[HTMLDependency]:\n    ...\n\ndef output_binding_dependency() -> HTMLDependency:\n    ...\n\ndef require_dependency(w: Widget, session: Session, warn_if_missing: bool = ...) -> Optional[HTMLDependency]:\n    \"\"\"\n    Obtain an HTMLDependency for a 3rd party ipywidget that points\n    require('widget-npm-package') requests in the browser to the correct local path.\n    \"\"\"\n    ...\n\ndef bokeh_dependency() -> HTMLDependency:\n    ...\n\ndef jupyter_extension_path(module_name: str) -> Optional[str]:\n    ...\n\ndef jupyter_extension_destination(w: Widget) -> str:\n    ...\n\ndef widget_pkg(w: object) -> str:\n    ...\n\ndef parse_version(v: str) -> str:\n    ...\n\ndef parse_version_safely(v: str) -> str:\n    ...\n\n",
  "/src/typings/shinywidgets/_serialization.pyi": "def json_packer(obj: object) -> str:\n    ...\n\ndef json_default(obj: object) -> object:\n    ...\n\n",
  "/src/typings/shinywidgets/_shinywidgets.pyi": "from typing import Any, Awaitable, Callable, Optional, Sequence, Union, overload\nfrom htmltools import Tag\nfrom ipywidgets.widgets.widget import Widget\nfrom shiny import Session\nfrom shiny.render import RenderFunction, RenderFunctionAsync\n\n__all__ = (\"output_widget\", \"register_widget\", \"render_widget\", \"reactive_read\", \"as_widget\")\nSHINYWIDGETS_CDN = ...\nSHINYWIDGETS_CDN_ONLY = ...\nSHINYWIDGETS_EXTENSION_WARNING = ...\ndef output_widget(id: str, *, width: Optional[str] = ..., height: Optional[str] = ...) -> Tag:\n    ...\n\ndef init_shiny_widget(w: Widget): # -> None:\n    ...\n\nSESSIONS = ...\nCOMM_MANAGER = ...\nIPyWidgetRenderFunc = Callable[[], Widget]\nIPyWidgetRenderFuncAsync = Callable[[], Awaitable[Widget]]\nclass IPyWidget(RenderFunction[Widget, object]):\n    def __init__(self, fn: IPyWidgetRenderFunc) -> None:\n        ...\n    \n    def __call__(self) -> object:\n        ...\n    \n    async def run(self) -> object:\n        ...\n    \n\n\nclass IPyWidgetAsync(IPyWidget, RenderFunctionAsync[Widget, object]):\n    def __init__(self, fn: IPyWidgetRenderFuncAsync) -> None:\n        ...\n    \n    async def __call__(self) -> object:\n        ...\n    \n\n\n@overload\ndef render_widget(fn: Union[IPyWidgetRenderFunc, IPyWidgetRenderFuncAsync]) -> IPyWidget:\n    ...\n\n@overload\ndef render_widget() -> Callable[[Union[IPyWidgetRenderFunc, IPyWidgetRenderFuncAsync]], IPyWidget]:\n    ...\n\ndef render_widget(fn: Optional[Union[IPyWidgetRenderFunc, IPyWidgetRenderFuncAsync]] = ...) -> Union[IPyWidget, Callable[[Union[IPyWidgetRenderFunc, IPyWidgetRenderFuncAsync]], IPyWidget],]:\n    ...\n\ndef reactive_read(widget: Widget, names: Union[str, Sequence[str]]) -> Any:\n    ...\n\ndef reactive_depend(widget: Widget, names: Union[str, Sequence[str]], type: str = ...) -> None:\n    \"\"\"\n    Reactively read a Widget's trait(s)\n    \"\"\"\n    ...\n\ndef register_widget(id: str, widget: Widget, session: Optional[Session] = ...) -> Widget:\n    ...\n\ndef package_dir(package: str) -> str:\n    ...\n\ndef is_instance_of_class(x: object, class_name: str, module_name: Optional[str] = ...) -> bool:\n    ...\n\n",
  "/src/typings/shinyswatch/__init__.pyi": "from . import theme\nfrom ._get_theme import get_theme\nfrom ._theme_picker import theme_picker_server, theme_picker_ui\n\n\"\"\"Bootswatch + Bootstrap 5 themes for Shiny\"\"\"\n__version__ = ...\n__all__ = (\"theme\", \"get_theme\", \"theme_picker_ui\", \"theme_picker_server\")\n",
  "/src/typings/shinyswatch/_assert.pyi": "newline_and_star = ...\ndef assert_theme(*, name: str) -> None:\n    ...\n\n",
  "/src/typings/shinyswatch/_bsw5.pyi": "from ._typing_extensions import Literal\n\nbsw5_version = ...\nbsw5_themes = ...\nBSW5_THEME_NAME = Literal[\"cerulean\", \"cosmo\", \"cyborg\", \"darkly\", \"flatly\", \"journal\", \"litera\", \"lumen\", \"lux\", \"materia\", \"minty\", \"morph\", \"pulse\", \"quartz\", \"sandstone\", \"simplex\", \"sketchy\", \"slate\", \"solar\", \"spacelab\", \"superhero\", \"united\", \"vapor\", \"yeti\", \"zephyr\",]\n",
  "/src/typings/shinyswatch/_get_theme.pyi": "from htmltools import HTMLDependency\nfrom ._bsw5 import BSW5_THEME_NAME\n\ndef get_theme(name: BSW5_THEME_NAME) -> list[HTMLDependency]:\n    \"\"\"\n    Create a Bootswatch and Bootstrap 5 theme for Shiny.\n\n    Parameters\n    ----------\n    name\n        A Bootswatch theme name.\n\n    Returns\n    -------\n    :\n        A list of HTML dependencies.\n    \"\"\"\n    ...\n\n",
  "/src/typings/shinyswatch/_shiny.pyi": "bs5_path = ...\nbase_dep_version = ...\nbs_dep_no_files = ...\nshiny_deps = ...\nif bs_dep_no_files is None:\n    ...\n",
  "/src/typings/shinyswatch/_theme_picker.pyi": "from shiny import reactive, ui\nfrom ._bsw5 import BSW5_THEME_NAME\n\ndefault_theme_name = ...\ntheme_name: reactive.Value[BSW5_THEME_NAME] = ...\ncounter: reactive.Value[int] = ...\ndef theme_picker_ui() -> ui.TagChild:\n    \"\"\"\n    Theme picker - UI\n\n    Add this to your UI to enable the theme picker. This function requires :func:`~shinyswatch.theme_picker_server` to be included in your `server` function.\n\n    Notes\n    -----\n    * All simultaneous theme picker users on the same Shiny server will see the same theme. This only is an issue when you are sharing the same Shiny server.\n    * Do not include more than one theme picker in your app.\n    * Do not call the theme picker UI / server inside a module.\n\n    Returns\n    -------\n    :\n        A UI elements creating the theme picker.\n\n    See Also\n    --------\n    * :func:`shinyswatch.theme_picker_server`\n    \"\"\"\n    ...\n\ndef theme_picker_server() -> None:\n    \"\"\"\n    Theme picker - Server\n\n    This function adds the necessary hooks for the theme picker UI to properly update. This function requires :func:`~shinyswatch.theme_picker_ui` to be included in your UI definition.\n\n    Note: All simultaneous theme picker users on the same Shiny server will see the same theme. This only is an issue when you are sharing the same Shiny server.\n\n    See Also\n    --------\n    * :func:`~shinyswatch.theme_picker_ui`\n    \"\"\"\n    ...\n\n",
  "/src/typings/shinyswatch/_typing_extensions.pyi": "import sys\n\nif sys.version_info >= (3, 8):\n    ...\nelse:\n    ...\n",
  "/src/typings/shinyswatch/theme.pyi": "from htmltools import HTMLDependency\n\n\"\"\"\nTargeted theme methods for all Bootswatch themes.\n\"\"\"\ndef cerulean() -> list[HTMLDependency]:\n    \"\"\"\n    `cerulean` Bootswatch theme\n\n    Visit [https://bootswatch.com/cerulean/](https://bootswatch.com/cerulean/) to see a Bootswatch's demo of the `cerulean` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (cerulean) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef cosmo() -> list[HTMLDependency]:\n    \"\"\"\n    `cosmo` Bootswatch theme\n\n    Visit [https://bootswatch.com/cosmo/](https://bootswatch.com/cosmo/) to see a Bootswatch's demo of the `cosmo` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (cosmo) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef cyborg() -> list[HTMLDependency]:\n    \"\"\"\n    `cyborg` Bootswatch theme\n\n    Visit [https://bootswatch.com/cyborg/](https://bootswatch.com/cyborg/) to see a Bootswatch's demo of the `cyborg` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (cyborg) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef darkly() -> list[HTMLDependency]:\n    \"\"\"\n    `darkly` Bootswatch theme\n\n    Visit [https://bootswatch.com/darkly/](https://bootswatch.com/darkly/) to see a Bootswatch's demo of the `darkly` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (darkly) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef flatly() -> list[HTMLDependency]:\n    \"\"\"\n    `flatly` Bootswatch theme\n\n    Visit [https://bootswatch.com/flatly/](https://bootswatch.com/flatly/) to see a Bootswatch's demo of the `flatly` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (flatly) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef journal() -> list[HTMLDependency]:\n    \"\"\"\n    `journal` Bootswatch theme\n\n    Visit [https://bootswatch.com/journal/](https://bootswatch.com/journal/) to see a Bootswatch's demo of the `journal` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (journal) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef litera() -> list[HTMLDependency]:\n    \"\"\"\n    `litera` Bootswatch theme\n\n    Visit [https://bootswatch.com/litera/](https://bootswatch.com/litera/) to see a Bootswatch's demo of the `litera` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (litera) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef lumen() -> list[HTMLDependency]:\n    \"\"\"\n    `lumen` Bootswatch theme\n\n    Visit [https://bootswatch.com/lumen/](https://bootswatch.com/lumen/) to see a Bootswatch's demo of the `lumen` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (lumen) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef lux() -> list[HTMLDependency]:\n    \"\"\"\n    `lux` Bootswatch theme\n\n    Visit [https://bootswatch.com/lux/](https://bootswatch.com/lux/) to see a Bootswatch's demo of the `lux` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (lux) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef materia() -> list[HTMLDependency]:\n    \"\"\"\n    `materia` Bootswatch theme\n\n    Visit [https://bootswatch.com/materia/](https://bootswatch.com/materia/) to see a Bootswatch's demo of the `materia` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (materia) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef minty() -> list[HTMLDependency]:\n    \"\"\"\n    `minty` Bootswatch theme\n\n    Visit [https://bootswatch.com/minty/](https://bootswatch.com/minty/) to see a Bootswatch's demo of the `minty` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (minty) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef morph() -> list[HTMLDependency]:\n    \"\"\"\n    `morph` Bootswatch theme\n\n    Visit [https://bootswatch.com/morph/](https://bootswatch.com/morph/) to see a Bootswatch's demo of the `morph` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (morph) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef pulse() -> list[HTMLDependency]:\n    \"\"\"\n    `pulse` Bootswatch theme\n\n    Visit [https://bootswatch.com/pulse/](https://bootswatch.com/pulse/) to see a Bootswatch's demo of the `pulse` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (pulse) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef quartz() -> list[HTMLDependency]:\n    \"\"\"\n    `quartz` Bootswatch theme\n\n    Visit [https://bootswatch.com/quartz/](https://bootswatch.com/quartz/) to see a Bootswatch's demo of the `quartz` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (quartz) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef sandstone() -> list[HTMLDependency]:\n    \"\"\"\n    `sandstone` Bootswatch theme\n\n    Visit [https://bootswatch.com/sandstone/](https://bootswatch.com/sandstone/) to see a Bootswatch's demo of the `sandstone` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (sandstone) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef simplex() -> list[HTMLDependency]:\n    \"\"\"\n    `simplex` Bootswatch theme\n\n    Visit [https://bootswatch.com/simplex/](https://bootswatch.com/simplex/) to see a Bootswatch's demo of the `simplex` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (simplex) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef sketchy() -> list[HTMLDependency]:\n    \"\"\"\n    `sketchy` Bootswatch theme\n\n    Visit [https://bootswatch.com/sketchy/](https://bootswatch.com/sketchy/) to see a Bootswatch's demo of the `sketchy` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (sketchy) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef slate() -> list[HTMLDependency]:\n    \"\"\"\n    `slate` Bootswatch theme\n\n    Visit [https://bootswatch.com/slate/](https://bootswatch.com/slate/) to see a Bootswatch's demo of the `slate` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (slate) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef solar() -> list[HTMLDependency]:\n    \"\"\"\n    `solar` Bootswatch theme\n\n    Visit [https://bootswatch.com/solar/](https://bootswatch.com/solar/) to see a Bootswatch's demo of the `solar` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (solar) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef spacelab() -> list[HTMLDependency]:\n    \"\"\"\n    `spacelab` Bootswatch theme\n\n    Visit [https://bootswatch.com/spacelab/](https://bootswatch.com/spacelab/) to see a Bootswatch's demo of the `spacelab` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (spacelab) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef superhero() -> list[HTMLDependency]:\n    \"\"\"\n    `superhero` Bootswatch theme\n\n    Visit [https://bootswatch.com/superhero/](https://bootswatch.com/superhero/) to see a Bootswatch's demo of the `superhero` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (superhero) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef united() -> list[HTMLDependency]:\n    \"\"\"\n    `united` Bootswatch theme\n\n    Visit [https://bootswatch.com/united/](https://bootswatch.com/united/) to see a Bootswatch's demo of the `united` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (united) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef vapor() -> list[HTMLDependency]:\n    \"\"\"\n    `vapor` Bootswatch theme\n\n    Visit [https://bootswatch.com/vapor/](https://bootswatch.com/vapor/) to see a Bootswatch's demo of the `vapor` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (vapor) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef yeti() -> list[HTMLDependency]:\n    \"\"\"\n    `yeti` Bootswatch theme\n\n    Visit [https://bootswatch.com/yeti/](https://bootswatch.com/yeti/) to see a Bootswatch's demo of the `yeti` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (yeti) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\ndef zephyr() -> list[HTMLDependency]:\n    \"\"\"\n    `zephyr` Bootswatch theme\n\n    Visit [https://bootswatch.com/zephyr/](https://bootswatch.com/zephyr/) to see a Bootswatch's demo of the `zephyr` theme.\n\n    Returns\n    -------\n    list[htmltools.HTMLDependency]\n        List of HTMLDependency objects that create a Bootswatch (zephyr) and Bootstrap 5 theme.\n    \"\"\"\n    ...\n\n"
}